filename,code,label,label_encoded
integer_overflow_mapping_sym_1_fixed.sol,"function init(uint256 k, uint256 v) public {
map[k] = sub(map[k], v);
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
require(b <= a);
return a - b;
}
function init(uint256 k, uint256 v) public {
map[k] = sub(map[k], v);
function init(uint256 k, uint256 v) public {
map[k] = sub(map[k], v);
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
require(b <= a);//SafeMath uses assert here
return a - b;}}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
require(b <= a);//SafeMath uses assert here
return a - b;}}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
require(b <= a);//SafeMath uses assert here
return a - b;}}",IO/OF,0
integer_overflow_minimal_fixed.sol,"function run(uint256 input) public {
count = sub(count,input);
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
require(b <= a);
return a - b;
}
function run(uint256 input) public {
count = sub(count,input);}
function run(uint256 input) public {
count = sub(count,input);}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
require(b <= a);
return a - b;}}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
require(b <= a);
return a - b;}}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
require(b <= a);
return a - b;}}",IO/OF,0
integer_overflow_multitx_multifunc_feasible_fixed.sol,"function init() public {
initialized = 1;
}
function run(uint256 input) {
if (initialized == 0) {
return;
}
count = sub(count, input);
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
require(b <= a);
return a - b;
}
function init() public {
initialized = 1;}
function init() public {
initialized = 1;}
function run(uint256 input) {
if (initialized == 0) {
return;}
count = sub(count, input);}
function run(uint256 input) {
if (initialized == 0) {
return;}
count = sub(count, input);}
function run(uint256 input) {
if (initialized == 0) {
return;}
count = sub(count, input);}
function run(uint256 input) {
if (initialized == 0) {
return;}
count = sub(count, input);}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
require(b <= a);
return a - b;}}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
require(b <= a);
return a - b;}}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
require(b <= a);
return a - b;}}",IO/OF,0
integer_overflow_mul_fixed.sol,"function run(uint256 input) public {
count = mul(count, input);
}
function mul(uint256 a, uint256 b) internal pure returns (uint256) {
if (a == 0) {
return 0;
}
uint256 c = a * b;
require(c / a == b);
return c;
}
function run(uint256 input) public {
count = mul(count, input);}
function run(uint256 input) public {
count = mul(count, input);}
function mul(uint256 a, uint256 b) internal pure returns (uint256) {
if (a == 0) {
return 0;}
uint256 c = a * b;
require(c / a == b);
return c;}}
function mul(uint256 a, uint256 b) internal pure returns (uint256) {
if (a == 0) {
return 0;}
uint256 c = a * b;
require(c / a == b);
return c;}}
function mul(uint256 a, uint256 b) internal pure returns (uint256) {
if (a == 0) {
return 0;}
uint256 c = a * b;
require(c / a == b);
return c;}}
function mul(uint256 a, uint256 b) internal pure returns (uint256) {
if (a == 0) {
return 0;}
uint256 c = a * b;
require(c / a == b);
return c;}}
function mul(uint256 a, uint256 b) internal pure returns (uint256) {
if (a == 0) {
return 0;}
uint256 c = a * b;
require(c / a == b);
return c;}}
function mul(uint256 a, uint256 b) internal pure returns (uint256) {
if (a == 0) {
return 0;}
uint256 c = a * b;
require(c / a == b);
return c;}}",IO/OF,0
1.sol,"function mul(uint256 a, uint256 b) internal constant returns (uint256) {
uint256 c = a * b;
assert(a == 0 || c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal constant returns (uint256) {
uint256 c = a / b;
}
function sub(uint256 a, uint256 b) internal constant returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal constant returns (uint256) {
uint256 c = a + b;
assert(c >= a);
}
contract ERC20Basic {
uint256 public totalSupply;
function balanceOf(address who) public constant returns (uint256);
function transfer(address to, uint256 value) public returns (bool);
event Transfer(address indexed from, address indexed to, uint256 value);
}
contract BasicToken is ERC20Basic {
using SafeMath for uint256;
mapping(address => uint256) balances;
}
function transfer(address _to, uint256 _value) public returns (bool) {
require(_to != address(0));
require(_value > 0 && _value <= balances[msg.sender]);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
Transfer(msg.sender, _to, _value);
return true;
}
function balanceOf(address _owner) public constant returns (uint256 balance) {
return balances[_owner];
}
contract ERC20 is ERC20Basic {
function allowance(address owner, address spender) public constant returns (uint256);
function transferFrom(address from, address to, uint256 value) public returns (bool);
function approve(address spender, uint256 value) public returns (bool);
event Approval(address indexed owner, address indexed spender, uint256 value);
}
contract StandardToken is ERC20, BasicToken {
mapping (address => mapping (address => uint256)) internal allowed;
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
require(_value > 0 && _value <= balances[_from]);
require(_value <= allowed[_from][msg.sender]);
balances[_from] = balances[_from].sub(_value);
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
Transfer(_from, _to, _value);
}
function approve(address _spender, uint256 _value) public returns (bool) {
allowed[msg.sender][_spender] = _value;
Approval(msg.sender, _spender, _value);
}
function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
return allowed[_owner][_spender];
}
contract Ownable {
address public owner;
event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
}
function Ownable() {
owner = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == owner);
}
function transferOwnership(address newOwner) onlyOwner public {
require(newOwner != address(0));
OwnershipTransferred(owner, newOwner);
owner = newOwner;
}
contract Pausable is Ownable {
event Pause();
event Unpause();
bool public paused = false;
}
modifier whenNotPaused() {
require(!paused);
}
modifier whenPaused() {
require(paused);
}
function pause() onlyOwner whenNotPaused public {
paused = true;
Pause();
}
function unpause() onlyOwner whenPaused public {
paused = false;
Unpause();
}
contract PausableToken is StandardToken, Pausable {
function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
return super.transfer(_to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
return super.transferFrom(_from, _to, _value);
}
function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
return super.approve(_spender, _value);
}
function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) {
uint cnt = _receivers.length;
uint256 amount = uint256(cnt) * _value;
require(cnt > 0 && cnt <= 20);
require(_value > 0 && balances[msg.sender] >= amount);
balances[msg.sender] = balances[msg.sender].sub(amount);
}
for (uint i = 0; i < cnt; i++) {
balances[_receivers[i]] = balances[_receivers[i]].add(_value);
Transfer(msg.sender, _receivers[i], _value);
}
contract TUPC is PausableToken {
string public name = ""TUPC"";
string public symbol = ""TUPC"";
string public version = '1.0.0';
uint8 public decimals = 18;
}
function TUPC() {
totalSupply = 1000000000 * (10**(uint256(decimals)));
balances[0x1cda5B1945E032BA751Aa217E1967732ac91e955] = totalSupply;
Transfer(address(0),0x1cda5B1945E032BA751Aa217E1967732ac91e955, totalSupply);
}
function () {
revert();
}
}

1",IO/OF,0
10.sol,"function mul(uint256 a, uint256 b) internal pure returns (uint256){
uint256 c = a * b;
assert(a == 0 || c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal pure returns (uint256){
assert(b > 0);
uint256 c = a / b;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256){
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256){
uint256 c = a + b;
assert(c >= a);
}
contract ERC20 {
uint256 public totalSupply;
function balanceOf(address who) constant public returns (uint256);
function transfer(address to, uint256 value) public returns (bool);
function allowance(address owner, address spender) constant public returns (uint256);
function transferFrom(address from, address to, uint256 value) public returns (bool);
function approve(address spender, uint256 value) public returns (bool);
event Transfer(address indexed from, address indexed to, uint256 value);
event Approval(address indexed owner, address indexed spender, uint256 value);
}
contract Ownable {
address  owner;
function Ownable() public{
owner = msg.sender;
modifier onlyOwner(){
require(msg.sender == owner);
}
}
}
function transferOwnership(address newOwner) onlyOwner public{
require(newOwner != address(0));
owner = newOwner;
}
contract StandardToken is ERC20 {
using SafeMath for uint256;
mapping (address => mapping (address => uint256)) allowed;
mapping(address => uint256) balances;
function transfer(address _to, uint256 _value) public returns (bool){
assert(0 < _value);
assert(balances[msg.sender] >= _value);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
emit Transfer(msg.sender, _to, _value);
return true;
}
function balanceOf(address _owner) constant public returns (uint256 balance){
return balances[_owner];
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool){
uint256 _allowance = allowed[_from][msg.sender];
assert (balances[_from] >= _value);
assert (_allowance >= _value);
assert (_value > 0);
balances[_from] = balances[_from].sub(_value);
allowed[_from][msg.sender] = _allowance.sub(_value);
emit Transfer(_from, _to, _value);
}
function approve(address _spender, uint256 _value) public returns (bool){
require((_value == 0) || (allowed[msg.sender][_spender] == 0));
allowed[msg.sender][_spender] = _value;
emit Approval(msg.sender, _spender, _value);
}
function allowance(address _owner, address _spender) constant public returns (uint256 remaining){
return allowed[_owner][_spender];
}
contract  Ammbr is StandardToken, Ownable {
string public name = '';
string public symbol = '';
uint8 public  decimals = 0;
uint256 public maxMintBlock = 0;
event Mint(address indexed to, uint256 amount);
function mint(address _to, uint256 _amount) onlyOwner  public returns (bool){
assert(maxMintBlock == 0);
totalSupply = totalSupply.add(_amount);
balances[_to] = balances[_to].add(_amount);
emit Mint(_to, _amount);
maxMintBlock = 1;
}
function multiTransfer(address[] destinations, uint[] tokens) public returns (bool success){
assert(destinations.length > 0);
assert(destinations.length < 128);
assert(destinations.length == tokens.length);
uint8 i = 0;
uint totalTokensToTransfer = 0;
for (i = 0; i < destinations.length; i++){
assert(tokens[i] > 0);
totalTokensToTransfer += tokens[i];
assert (balances[msg.sender] > totalTokensToTransfer);
balances[msg.sender] = balances[msg.sender].sub(totalTokensToTransfer);
balances[destinations[i]] = balances[destinations[i]].add(tokens[i]);
emit Transfer(msg.sender, destinations[i], tokens[i]);
}
}
function Ammbr(string _name , string _symbol , uint8 _decimals) public{
name = _name;
symbol = _symbol;
decimals = _decimals;
}

1",IO/OF,0
100.sol,"contract ERC20 {
function transfer(address _to, uint256 _value) returns (bool success) {
if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
balances[msg.sender] -= _value;
balances[_to] += _value;
Transfer(msg.sender, _to, _value);
return true;
} else { return false; }
}
function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
balances[_to] += _value;
balances[_from] -= _value;
allowed[_from][msg.sender] -= _value;
Transfer(_from, _to, _value);
return true;
} else { return false; }
}
function balanceOf(address _owner) constant returns (uint256 balance) {
return balances[_owner];
}
function approve(address _spender, uint256 _value) returns (bool success) {
allowed[msg.sender][_spender] = _value;
Approval(msg.sender, _spender, _value);
return true;
}
function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
return allowed[_owner][_spender];
}
mapping (address => uint256) balances;
mapping (address => mapping (address => uint256)) allowed;
uint256 public totalSupply;
address public owner;
event Transfer(address indexed _from, address indexed _to, uint256 _value);
event Approval(address indexed _owner, address indexed _spender, uint256 _value);
modifier onlyowner(address _requester) {
if (_requester != owner) {
throw;
}
}
event Mint(address indexed _owner, uint256 _value, uint256 _totalSupply);
event Burn(address indexed _owner, uint256 _value, uint256 _totalSupply);
event ChangeOwner(address indexed _oldOwner, address indexed _newOwner);
function ERC20() {
owner = msg.sender;
}
function mint(uint _value) onlyowner(msg.sender) {
if (balances[owner] + _value < balances[owner]) {
throw;
}
balances[owner] += _value;
totalSupply += _value;
Mint(owner, _value, totalSupply);
}
function burn(uint _value) onlyowner(msg.sender) {
if (balances[owner] < _value) {
throw;
}
balances[owner] -= _value;
totalSupply -= _value;
Burn(owner, _value, totalSupply);
}
function changeOwner(address _owner) onlyowner(msg.sender) {
owner = _owner;
ChangeOwner(msg.sender, owner);
}
}

1",IO/OF,0
11.sol,"function mul(uint256 a, uint256 b) internal constant returns (uint256) {
uint256 c = a * b;
assert(a == 0 || c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal constant returns (uint256) {
uint256 c = a / b;
}
function sub(uint256 a, uint256 b) internal constant returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal constant returns (uint256) {
uint256 c = a + b;
assert(c >= a);
}
contract ERC20Basic {
uint256 public totalSupply;
function balanceOf(address who) public constant returns (uint256);
function transfer(address to, uint256 value) public returns (bool);
event Transfer(address indexed from, address indexed to, uint256 value);
}
contract BasicToken is ERC20Basic {
using SafeMath for uint256;
mapping(address => uint256) balances;
}
function transfer(address _to, uint256 _value) public returns (bool) {
require(_to != address(0));
require(_value > 0 && _value <= balances[msg.sender]);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
Transfer(msg.sender, _to, _value);
return true;
}
function balanceOf(address _owner) public constant returns (uint256 balance) {
return balances[_owner];
}
contract ERC20 is ERC20Basic {
function allowance(address owner, address spender) public constant returns (uint256);
function transferFrom(address from, address to, uint256 value) public returns (bool);
function approve(address spender, uint256 value) public returns (bool);
event Approval(address indexed owner, address indexed spender, uint256 value);
}
contract StandardToken is ERC20, BasicToken {
mapping (address => mapping (address => uint256)) internal allowed;
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
require(_value > 0 && _value <= balances[_from]);
require(_value <= allowed[_from][msg.sender]);
balances[_from] = balances[_from].sub(_value);
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
Transfer(_from, _to, _value);
}
function approve(address _spender, uint256 _value) public returns (bool) {
allowed[msg.sender][_spender] = _value;
Approval(msg.sender, _spender, _value);
}
function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
return allowed[_owner][_spender];
}
contract Ownable {
address public owner;
event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
}
function Ownable() {
owner = msg.sender;
modifier onlyOwner() {
require(msg.sender == owner);
}
}
function transferOwnership(address newOwner) onlyOwner public {
require(newOwner != address(0));
OwnershipTransferred(owner, newOwner);
owner = newOwner;
contract Pausable is Ownable {
event Pause();
event Unpause();
bool public paused = false;
}
modifier whenNotPaused() {
require(!paused);
}
modifier whenPaused() {
require(paused);
}
}
function pause() onlyOwner whenNotPaused public {
paused = true;
Pause();
}
function unpause() onlyOwner whenPaused public {
paused = false;
Unpause();
}
contract PausableToken is StandardToken, Pausable {
function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
return super.transfer(_to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
return super.transferFrom(_from, _to, _value);
}
function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
return super.approve(_spender, _value);
}
function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) {
uint cnt = _receivers.length;
uint256 amount = uint256(cnt) * _value;
require(cnt > 0 && cnt <= 20);
require(_value > 0 && balances[msg.sender] >= amount);
balances[msg.sender] = balances[msg.sender].sub(amount);
for (uint i = 0; i < cnt; i++) {
balances[_receivers[i]] = balances[_receivers[i]].add(_value);
Transfer(msg.sender, _receivers[i], _value);
}
}
contract UpcToken is PausableToken {
string public name = ""UPCToken"";
string public symbol = ""UPCT"";
string public version = '1.0.0';
uint8 public decimals = 18;
function UpcToken() {
totalSupply = 2000000000 * (10**(uint256(decimals)));
balances[0xB846E79AfE9Ee6690246C8Fd9A6edBF381e6f957] = totalSupply;
Transfer(address(0),0xB846E79AfE9Ee6690246C8Fd9A6edBF381e6f957, totalSupply);
function () {
revert();
}
}

1",IO/OF,0
12.sol,"function mul(uint256 a, uint256 b) internal constant returns (uint256) {
uint256 c = a * b;
assert(a == 0 || c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal constant returns (uint256) {
uint256 c = a / b;
}
function sub(uint256 a, uint256 b) internal constant returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal constant returns (uint256) {
uint256 c = a + b;
assert(c >= a);
}
contract ERC20Basic {
uint256 public totalSupply;
function balanceOf(address who) public constant returns (uint256);
function transfer(address to, uint256 value) public returns (bool);
event Transfer(address indexed from, address indexed to, uint256 value);
}
contract BasicToken is ERC20Basic {
using SafeMath for uint256;
mapping(address => uint256) balances;
}
function transfer(address _to, uint256 _value) public returns (bool) {
require(_to != address(0));
require(_value > 0 && _value <= balances[msg.sender]);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
Transfer(msg.sender, _to, _value);
return true;
}
function balanceOf(address _owner) public constant returns (uint256 balance) {
return balances[_owner];
}
contract ERC20 is ERC20Basic {
function allowance(address owner, address spender) public constant returns (uint256);
function transferFrom(address from, address to, uint256 value) public returns (bool);
function approve(address spender, uint256 value) public returns (bool);
event Approval(address indexed owner, address indexed spender, uint256 value);
}
contract StandardToken is ERC20, BasicToken {
mapping (address => mapping (address => uint256)) internal allowed;
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
require(_value > 0 && _value <= balances[_from]);
require(_value <= allowed[_from][msg.sender]);
balances[_from] = balances[_from].sub(_value);
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
Transfer(_from, _to, _value);
}
function approve(address _spender, uint256 _value) public returns (bool) {
allowed[msg.sender][_spender] = _value;
Approval(msg.sender, _spender, _value);
}
function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
return allowed[_owner][_spender];
}
contract Ownable {
address public owner;
event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
}
function Ownable() {
owner = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == owner);
}
function transferOwnership(address newOwner) onlyOwner public {
require(newOwner != address(0));
OwnershipTransferred(owner, newOwner);
owner = newOwner;
}
contract Pausable is Ownable {
event Pause();
event Unpause();
bool public paused = false;
modifier whenNotPaused() {
require(!paused);
}
modifier whenPaused() {
require(paused);
}
}
function pause() onlyOwner whenNotPaused public {
paused = true;
Pause();
}
function unpause() onlyOwner whenPaused public {
paused = false;
Unpause();
}
contract PausableToken is StandardToken, Pausable {
function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
return super.transfer(_to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
return super.transferFrom(_from, _to, _value);
}
function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
return super.approve(_spender, _value);
}
function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) {
uint cnt = _receivers.length;
uint256 amount = uint256(cnt) * _value;
require(cnt > 0 && cnt <= 20);
require(_value > 0 && balances[msg.sender] >= amount);
balances[msg.sender] = balances[msg.sender].sub(amount);
}
for (uint i = 0; i < cnt; i++) {
balances[_receivers[i]] = balances[_receivers[i]].add(_value);
Transfer(msg.sender, _receivers[i], _value);
}
}
contract BecToken is PausableToken {
string public name = ""BeautyChain"";
string public symbol = ""BEC"";
string public version = '1.0.0';
uint8 public decimals = 18;
}
function BecToken() {
totalSupply = 7000000000 * (10**(uint256(decimals)));
balances[msg.sender] = totalSupply;
function () {
revert();
}
}

1",IO/OF,0
13.sol,"function mul(uint256 a, uint256 b) internal constant returns (uint256) {
uint256 c = a * b;
assert(a == 0 || c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal constant returns (uint256) {
uint256 c = a / b;
}
function sub(uint256 a, uint256 b) internal constant returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal constant returns (uint256) {
uint256 c = a + b;
assert(c >= a);
}
contract ERC20Basic {
uint256 public totalSupply;
function balanceOf(address who) public constant returns (uint256);
function transfer(address to, uint256 value) public returns (bool);
event Transfer(address indexed from, address indexed to, uint256 value);
}
contract BasicToken is ERC20Basic {
using SafeMath for uint256;
mapping(address => uint256) balances;
}
function transfer(address _to, uint256 _value) public returns (bool) {
require(_to != address(0));
require(_value > 0 && _value <= balances[msg.sender]);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
Transfer(msg.sender, _to, _value);
return true;
}
function balanceOf(address _owner) public constant returns (uint256 balance) {
return balances[_owner];
}
contract ERC20 is ERC20Basic {
function allowance(address owner, address spender) public constant returns (uint256);
function transferFrom(address from, address to, uint256 value) public returns (bool);
function approve(address spender, uint256 value) public returns (bool);
event Approval(address indexed owner, address indexed spender, uint256 value);
}
contract StandardToken is ERC20, BasicToken {
mapping (address => mapping (address => uint256)) internal allowed;
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
require(_value > 0 && _value <= balances[_from]);
require(_value <= allowed[_from][msg.sender]);
balances[_from] = balances[_from].sub(_value);
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
Transfer(_from, _to, _value);
}
function approve(address _spender, uint256 _value) public returns (bool) {
allowed[msg.sender][_spender] = _value;
Approval(msg.sender, _spender, _value);
}
function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
return allowed[_owner][_spender];
}
contract Ownable {
address public owner;
event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
}
function Ownable() {
owner = msg.sender;
modifier onlyOwner() {
require(msg.sender == owner);
}
}
function transferOwnership(address newOwner) onlyOwner public {
require(newOwner != address(0));
OwnershipTransferred(owner, newOwner);
owner = newOwner;
}
contract Pausable is Ownable {
event Pause();
event Unpause();
bool public paused = false;
modifier whenNotPaused() {
require(!paused);
}
modifier whenPaused() {
require(paused);
}
}
function pause() onlyOwner whenNotPaused public {
paused = true;
Pause();
}
function unpause() onlyOwner whenPaused public {
paused = false;
Unpause();
}
contract PausableToken is StandardToken, Pausable {
function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
return super.transfer(_to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
return super.transferFrom(_from, _to, _value);
}
function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
return super.approve(_spender, _value);
}
function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) {
uint cnt = _receivers.length;
uint256 amount = uint256(cnt) * _value;
require(cnt > 0 && cnt <= 20);
require(_value > 0 && balances[msg.sender] >= amount);
balances[msg.sender] = balances[msg.sender].sub(amount);
}
for (uint i = 0; i < cnt; i++) {
balances[_receivers[i]] = balances[_receivers[i]].add(_value);
Transfer(msg.sender, _receivers[i], _value);
contract UpcToken is PausableToken {
string public name = ""UPCToken"";
string public symbol = ""UPC"";
string public version = '1.0.0';
uint8 public decimals = 18;
}
function UpcToken() {
totalSupply = 2000000000 * (10**(uint256(decimals)));
balances[0xB2323ffa677cb2fF6538e9844Aa77287bD73997d] = totalSupply;
Transfer(address(0),0xB2323ffa677cb2fF6538e9844Aa77287bD73997d, totalSupply);
function () {
revert();
}
}
}

1",IO/OF,0
14.sol,"function safeMul(uint a, uint b) internal returns (uint) {
uint c = a * b;
assert(a == 0 || c / a == b);
return c;
}
function safeSub(uint a, uint b) internal returns (uint) {
assert(b <= a);
return a - b;
}
function safeAdd(uint a, uint b) internal returns (uint) {
uint c = a + b;
assert(c>=a && c>=b);
}
contract Token is SafeMath {
function totalSupply() constant returns (uint256 supply);
function balanceOf(address _owner) constant returns (uint256 balance);
function transfer(address _to, uint256 _value) returns(bool);
function transferFrom(address _from, address _to, uint256 _value) returns(bool);
function approve(address _spender, uint256 _value) returns (bool success);
function allowance(address _owner, address _spender) constant returns (uint256 remaining);
event Transfer(address indexed _from, address indexed _to, uint256 _value);
event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}
contract StdToken is Token {
mapping(address => uint256) balances;
mapping (address => mapping (address => uint256)) allowed;
uint public supply = 0;
}
function transfer(address _to, uint256 _value) returns(bool) {
require(balances[msg.sender] >= _value);
require(balances[_to] + _value > balances[_to]);
balances[msg.sender] = safeSub(balances[msg.sender],_value);
balances[_to] = safeAdd(balances[_to],_value);
Transfer(msg.sender, _to, _value);
return true;
}
function transferFrom(address _from, address _to, uint256 _value) returns(bool){
require(balances[_from] >= _value);
require(allowed[_from][msg.sender] >= _value);
balances[_from] = safeSub(balances[_from],_value);
allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender],_value);
Transfer(_from, _to, _value);
}
function totalSupply() constant returns (uint256) {
return supply;
}
function balanceOf(address _owner) constant returns (uint256) {
return balances[_owner];
}
function approve(address _spender, uint256 _value) returns (bool) {
require((_value == 0) || (allowed[msg.sender][_spender] == 0));
allowed[msg.sender][_spender] = _value;
Approval(msg.sender, _spender, _value);
}
function allowance(address _owner, address _spender) constant returns (uint256) {
return allowed[_owner][_spender];
contract UHubToken is StdToken
string public constant name = ""UHUB"";
string public constant symbol = ""HUB"";
uint public constant decimals = 18;
uint public constant TOTAL_SUPPLY = 1156789000 * (1 ether / 1 wei);
uint public constant DEVELOPERS_BONUS = 476787800 * (1 ether / 1 wei);
uint public constant PRESALE_PRICE = 5200;
uint public constant PRESALE_MAX_ETH = 19231;
uint public constant PRESALE_TOKEN_SUPPLY_LIMIT = PRESALE_PRICE * PRESALE_MAX_ETH * (1 ether / 1 wei);
uint public constant ICO_PRICE1 = 4600;
uint public constant ICO_PRICE2 = 4200;
uint public constant ICO_PRICE3 = 4000;
uint public constant TOTAL_SOLD_TOKEN_SUPPLY_LIMIT = 680001200* (1 ether / 1 wei);
enum State{
Init,
Paused,
PresaleRunning,
PresaleFinished,
ICORunning,
ICOFinished
State public currentState = State.Init;
bool public enableTransfers = true;
address public teamTokenBonus = 0;
address public escrow = 0;
address public tokenManager = 0;
uint public presaleSoldTokens = 0;
uint public icoSoldTokens = 0;
uint public totalSoldTokens = 0;
modifier onlyTokenManager()
require(msg.sender==tokenManager);
modifier onlyTokenCrowner()
require(msg.sender==escrow);
modifier onlyInState(State state)
require(state==currentState);
event LogBuy(address indexed owner, uint value);
event LogBurn(address indexed owner, uint value);
function UHubToken(address _tokenManager, address _escrow, address _teamTokenBonus)
tokenManager = _tokenManager;
teamTokenBonus = _teamTokenBonus;
escrow = _escrow;
uint teamBonus = DEVELOPERS_BONUS;
balances[_teamTokenBonus] += teamBonus;
supply+= teamBonus;
assert(PRESALE_TOKEN_SUPPLY_LIMIT==100001200 * (1 ether / 1 wei));
assert(TOTAL_SOLD_TOKEN_SUPPLY_LIMIT==680001200 * (1 ether / 1 wei));
}
}
function buyTokens() public payable{
require(currentState==State.PresaleRunning || currentState==State.ICORunning);
if(currentState==State.PresaleRunning){
return buyTokensPresale();
}
else{
return buyTokensICO();
}
}
function buyTokensPresale() public payable onlyInState(State.PresaleRunning){
require(msg.value >= ((1 ether / 1 wei) / 100));
uint newTokens = msg.value * PRESALE_PRICE;
require(presaleSoldTokens + newTokens <= PRESALE_TOKEN_SUPPLY_LIMIT);
balances[msg.sender] += newTokens;
supply+= newTokens;
presaleSoldTokens+= newTokens;
totalSoldTokens+= newTokens;
LogBuy(msg.sender, newTokens);
}
function buyTokensICO() public payable onlyInState(State.ICORunning){
uint newTokens = msg.value * getPrice();
require(totalSoldTokens + newTokens <= TOTAL_SOLD_TOKEN_SUPPLY_LIMIT);
icoSoldTokens+= newTokens;
}
function getPrice()constant returns(uint){
if(currentState==State.ICORunning){
if(icoSoldTokens<(200000000 * (1 ether / 1 wei))){
return ICO_PRICE1;
}
}
if(icoSoldTokens<(300000000 * (1 ether / 1 wei))){
return ICO_PRICE2;
return ICO_PRICE3;
return PRESALE_PRICE;
}
}
function setState(State _nextState) public onlyTokenManager{
require(currentState != State.ICOFinished);
currentState = _nextState;
}
function DisableTransfer() public onlyTokenManager{
enableTransfers = false;
}
function EnableTransfer() public onlyTokenManager{
enableTransfers = true;
}
function withdrawEther() public onlyTokenManager{
if(this.balance > 0)
require(escrow.send(this.balance));
}
function transfer(address _to, uint256 _value) returns(bool){
require(enableTransfers);
return super.transfer(_to,_value);
return super.transferFrom(_from,_to,_value);
return super.approve(_spender,_value);
}
function ChangeTokenManager(address _mgr) public onlyTokenManager{
tokenManager = _mgr;
}
function ChangeCrowner(address _mgr) public onlyTokenCrowner{
escrow = _mgr;
}
function() payable{
buyTokens();
}

1",IO/OF,0
15.sol,"function safeMul(uint a, uint b) internal returns (uint) {
uint c = a * b;
assert(a == 0 || c / a == b);
return c;
}
function safeSub(uint a, uint b) internal returns (uint) {
assert(b <= a);
return a - b;
}
function safeAdd(uint a, uint b) internal returns (uint) {
uint c = a + b;
assert(c>=a && c>=b);
}
contract Token is SafeMath {
function totalSupply() constant returns (uint256 supply);
function balanceOf(address _owner) constant returns (uint256 balance);
function transfer(address _to, uint256 _value) returns(bool);
function transferFrom(address _from, address _to, uint256 _value) returns(bool);
function approve(address _spender, uint256 _value) returns (bool success);
function allowance(address _owner, address _spender) constant returns (uint256 remaining);
event Transfer(address indexed _from, address indexed _to, uint256 _value);
event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}
contract StdToken is Token {
mapping(address => uint256) balances;
mapping (address => mapping (address => uint256)) allowed;
uint public supply = 0;
}
function transfer(address _to, uint256 _value) returns(bool) {
require(balances[msg.sender] >= _value);
require(balances[_to] + _value > balances[_to]);
balances[msg.sender] = safeSub(balances[msg.sender],_value);
balances[_to] = safeAdd(balances[_to],_value);
Transfer(msg.sender, _to, _value);
return true;
}
function transferFrom(address _from, address _to, uint256 _value) returns(bool){
require(balances[_from] >= _value);
require(allowed[_from][msg.sender] >= _value);
balances[_from] = safeSub(balances[_from],_value);
allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender],_value);
Transfer(_from, _to, _value);
}
function totalSupply() constant returns (uint256) {
return supply;
}
function balanceOf(address _owner) constant returns (uint256) {
return balances[_owner];
}
function approve(address _spender, uint256 _value) returns (bool) {
require((_value == 0) || (allowed[msg.sender][_spender] == 0));
allowed[msg.sender][_spender] = _value;
Approval(msg.sender, _spender, _value);
}
function allowance(address _owner, address _spender) constant returns (uint256) {
return allowed[_owner][_spender];
contract UHubToken is StdToken
string public constant name = ""UHUB"";
string public constant symbol = ""HUB"";
uint public constant decimals = 18;
uint public constant TOTAL_SUPPLY = 1156789000 * (1 ether / 1 wei);
uint public constant DEVELOPERS_BONUS = 476787800 * (1 ether / 1 wei);
uint public constant PRESALE_PRICE = 5200;
uint public constant PRESALE_MAX_ETH = 19231;
uint public constant PRESALE_TOKEN_SUPPLY_LIMIT = PRESALE_PRICE * PRESALE_MAX_ETH * (1 ether / 1 wei);
uint public constant ICO_PRICE1 = 4600;
uint public constant ICO_PRICE2 = 4200;
uint public constant ICO_PRICE3 = 4000;
uint public constant TOTAL_SOLD_TOKEN_SUPPLY_LIMIT = 680001200* (1 ether / 1 wei);
}
enum State{
Init,
Paused,
PresaleRunning,
PresaleFinished,
ICORunning,
ICOFinished
State public currentState = State.Init;
bool public enableTransfers = false;
address public teamTokenBonus = 0;
address public escrow = 0;
address public tokenManager = 0;
uint public presaleSoldTokens = 0;
uint public icoSoldTokens = 0;
uint public totalSoldTokens = 0;
modifier onlyTokenManager()
require(msg.sender==tokenManager);
modifier onlyInState(State state)
require(state==currentState);
event LogBuy(address indexed owner, uint value);
event LogBurn(address indexed owner, uint value);
}
function UHubToken(address _tokenManager, address _escrow, address _teamTokenBonus){
tokenManager = _tokenManager;
teamTokenBonus = _teamTokenBonus;
escrow = _escrow;
uint teamBonus = DEVELOPERS_BONUS;
balances[_teamTokenBonus] += teamBonus;
supply+= teamBonus;
assert(PRESALE_TOKEN_SUPPLY_LIMIT==100001200 * (1 ether / 1 wei));
assert(TOTAL_SOLD_TOKEN_SUPPLY_LIMIT==680001200 * (1 ether / 1 wei));
}
function buyTokens() public payable{
require(currentState==State.PresaleRunning || currentState==State.ICORunning);
if(currentState==State.PresaleRunning){
return buyTokensPresale();
}
else{
return buyTokensICO();
}
}
function buyTokensPresale() public payable onlyInState(State.PresaleRunning){
require(msg.value >= ((1 ether / 1 wei) / 100));
uint newTokens = msg.value * PRESALE_PRICE;
require(presaleSoldTokens + newTokens <= PRESALE_TOKEN_SUPPLY_LIMIT);
balances[msg.sender] += newTokens;
supply+= newTokens;
presaleSoldTokens+= newTokens;
totalSoldTokens+= newTokens;
LogBuy(msg.sender, newTokens);
}
function buyTokensICO() public payable onlyInState(State.ICORunning){
uint newTokens = msg.value * getPrice();
require(totalSoldTokens + newTokens <= TOTAL_SOLD_TOKEN_SUPPLY_LIMIT);
icoSoldTokens+= newTokens;
}
function getPrice()constant returns(uint){
if(currentState==State.ICORunning){
if(icoSoldTokens<(200000000 * (1 ether / 1 wei))){
return ICO_PRICE1;
}
if(icoSoldTokens<(300000000 * (1 ether / 1 wei))){
return ICO_PRICE2;
}
return ICO_PRICE3;
}
return PRESALE_PRICE;
}
function setState(State _nextState) public onlyTokenManager{
require(currentState != State.ICOFinished);
currentState = _nextState;
enableTransfers = (currentState==State.ICOFinished);
}
function withdrawEther() public onlyTokenManager{
if(this.balance > 0)
require(escrow.send(this.balance));
}
function transfer(address _to, uint256 _value) returns(bool){
require(enableTransfers);
return super.transfer(_to,_value);
return super.transferFrom(_from,_to,_value);
return super.approve(_spender,_value);
}
function setTokenManager(address _mgr) public onlyTokenManager{
tokenManager = _mgr;
}
function() payable{
buyTokens();
}

1",IO/OF,0
16.sol,"function safeMul(uint a, uint b) internal returns (uint) {
uint c = a * b;
assert(a == 0 || c / a == b);
return c;
}
function safeSub(uint a, uint b) internal returns (uint) {
assert(b <= a);
return a - b;
}
function safeAdd(uint a, uint b) internal returns (uint) {
uint c = a + b;
assert(c>=a && c>=b);
}
contract Token is SafeMath {
function totalSupply() constant returns (uint256 supply);
function balanceOf(address _owner) constant returns (uint256 balance);
function transfer(address _to, uint256 _value) returns(bool);
function transferFrom(address _from, address _to, uint256 _value) returns(bool);
function approve(address _spender, uint256 _value) returns (bool success);
function allowance(address _owner, address _spender) constant returns (uint256 remaining);
event Transfer(address indexed _from, address indexed _to, uint256 _value);
event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}
contract StdToken is Token {
mapping(address => uint256) balances;
mapping (address => mapping (address => uint256)) allowed;
uint public supply = 0;
}
function transfer(address _to, uint256 _value) returns(bool) {
require(balances[msg.sender] >= _value);
require(balances[_to] + _value > balances[_to]);
balances[msg.sender] = safeSub(balances[msg.sender],_value);
balances[_to] = safeAdd(balances[_to],_value);
Transfer(msg.sender, _to, _value);
return true;
}
function transferFrom(address _from, address _to, uint256 _value) returns(bool){
require(balances[_from] >= _value);
require(allowed[_from][msg.sender] >= _value);
balances[_from] = safeSub(balances[_from],_value);
allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender],_value);
Transfer(_from, _to, _value);
}
function totalSupply() constant returns (uint256) {
return supply;
}
function balanceOf(address _owner) constant returns (uint256) {
return balances[_owner];
}
function approve(address _spender, uint256 _value) returns (bool) {
require((_value == 0) || (allowed[msg.sender][_spender] == 0));
allowed[msg.sender][_spender] = _value;
Approval(msg.sender, _spender, _value);
}
function allowance(address _owner, address _spender) constant returns (uint256) {
return allowed[_owner][_spender];
contract EthLendToken is StdToken
string public constant name = ""EthLend Token"";
string public constant symbol = ""LEND"";
uint public constant decimals = 18;
uint public constant TOTAL_SUPPLY = 1300000000 * (1 ether / 1 wei);
uint public constant DEVELOPERS_BONUS = 300000000 * (1 ether / 1 wei);
uint public constant PRESALE_PRICE = 30000;
uint public constant PRESALE_MAX_ETH = 2000;
uint public constant PRESALE_TOKEN_SUPPLY_LIMIT = PRESALE_PRICE * PRESALE_MAX_ETH * (1 ether / 1 wei);
uint public constant ICO_PRICE1 = 27500;
uint public constant ICO_PRICE2 = 26250;
uint public constant ICO_PRICE3 = 25000;
uint public constant TOTAL_SOLD_TOKEN_SUPPLY_LIMIT = 1000000000* (1 ether / 1 wei);
}
enum State{
Init,
Paused,
PresaleRunning,
PresaleFinished,
ICORunning,
ICOFinished
State public currentState = State.Init;
bool public enableTransfers = false;
address public teamTokenBonus = 0;
address public escrow = 0;
address public tokenManager = 0;
uint public presaleSoldTokens = 0;
uint public icoSoldTokens = 0;
uint public totalSoldTokens = 0;
modifier onlyTokenManager()
require(msg.sender==tokenManager);
modifier onlyInState(State state)
require(state==currentState);
event LogBuy(address indexed owner, uint value);
event LogBurn(address indexed owner, uint value);
}
function EthLendToken(address _tokenManager, address _escrow, address _teamTokenBonus){
tokenManager = _tokenManager;
teamTokenBonus = _teamTokenBonus;
escrow = _escrow;
uint teamBonus = DEVELOPERS_BONUS;
balances[_teamTokenBonus] += teamBonus;
supply+= teamBonus;
assert(PRESALE_TOKEN_SUPPLY_LIMIT==60000000 * (1 ether / 1 wei));
assert(TOTAL_SOLD_TOKEN_SUPPLY_LIMIT==1000000000 * (1 ether / 1 wei));
}
function buyTokens() public payable{
require(currentState==State.PresaleRunning || currentState==State.ICORunning);
if(currentState==State.PresaleRunning){
return buyTokensPresale();
}
else{
return buyTokensICO();
}
}
function buyTokensPresale() public payable onlyInState(State.PresaleRunning){
require(msg.value >= (1 ether / 1 wei));
uint newTokens = msg.value * PRESALE_PRICE;
require(presaleSoldTokens + newTokens <= PRESALE_TOKEN_SUPPLY_LIMIT);
balances[msg.sender] += newTokens;
supply+= newTokens;
presaleSoldTokens+= newTokens;
totalSoldTokens+= newTokens;
LogBuy(msg.sender, newTokens);
}
function buyTokensICO() public payable onlyInState(State.ICORunning){
require(msg.value >= ((1 ether / 1 wei) / 100));
uint newTokens = msg.value * getPrice();
require(totalSoldTokens + newTokens <= TOTAL_SOLD_TOKEN_SUPPLY_LIMIT);
icoSoldTokens+= newTokens;
}
function getPrice()constant returns(uint){
if(currentState==State.ICORunning){
if(icoSoldTokens<(200000000 * (1 ether / 1 wei))){
return ICO_PRICE1;
}
if(icoSoldTokens<(300000000 * (1 ether / 1 wei))){
return ICO_PRICE2;
}
return ICO_PRICE3;
}
return PRESALE_PRICE;
}
function setState(State _nextState) public onlyTokenManager{
require(currentState != State.ICOFinished);
currentState = _nextState;
enableTransfers = (currentState==State.ICOFinished);
}
function withdrawEther() public onlyTokenManager{
if(this.balance > 0)
require(escrow.send(this.balance));
}
function transfer(address _to, uint256 _value) returns(bool){
require(enableTransfers);
return super.transfer(_to,_value);
return super.transferFrom(_from,_to,_value);
return super.approve(_spender,_value);
}
function setTokenManager(address _mgr) public onlyTokenManager{
tokenManager = _mgr;
}
function() payable{
buyTokens();
}

1",IO/OF,0
17.sol,"function safeMul(uint a, uint b) internal returns (uint) {
uint c = a * b;
assert(a == 0 || c / a == b);
return c;
}
function safeSub(uint a, uint b) internal returns (uint) {
assert(b <= a);
return a - b;
}
function safeAdd(uint a, uint b) internal returns (uint) {
uint c = a + b;
assert(c>=a && c>=b);
}
contract Token is SafeMath {
function totalSupply() constant returns (uint256 supply);
function balanceOf(address _owner) constant returns (uint256 balance);
function transfer(address _to, uint256 _value) returns(bool);
function transferFrom(address _from, address _to, uint256 _value) returns(bool);
function approve(address _spender, uint256 _value) returns (bool success);
function allowance(address _owner, address _spender) constant returns (uint256 remaining);
event Transfer(address indexed _from, address indexed _to, uint256 _value);
event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}
contract StdToken is Token {
mapping(address => uint256) balances;
mapping (address => mapping (address => uint256)) allowed;
uint public supply = 0;
}
function transfer(address _to, uint256 _value) returns(bool) {
require(balances[msg.sender] >= _value);
require(balances[_to] + _value > balances[_to]);
balances[msg.sender] = safeSub(balances[msg.sender],_value);
balances[_to] = safeAdd(balances[_to],_value);
Transfer(msg.sender, _to, _value);
return true;
}
function transferFrom(address _from, address _to, uint256 _value) returns(bool){
require(balances[_from] >= _value);
require(allowed[_from][msg.sender] >= _value);
balances[_from] = safeSub(balances[_from],_value);
allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender],_value);
Transfer(_from, _to, _value);
}
function totalSupply() constant returns (uint256) {
return supply;
}
function balanceOf(address _owner) constant returns (uint256) {
return balances[_owner];
}
function approve(address _spender, uint256 _value) returns (bool) {
require((_value == 0) || (allowed[msg.sender][_spender] == 0));
allowed[msg.sender][_spender] = _value;
Approval(msg.sender, _spender, _value);
}
function allowance(address _owner, address _spender) constant returns (uint256) {
return allowed[_owner][_spender];
contract NEOCASHToken is StdToken
string public constant name = ""NEO CASH"";
string public constant symbol = ""NEOC"";
uint public constant decimals = 18;
uint public constant TOTAL_SUPPLY = 100000000 * (1 ether / 1 wei);
uint public constant DEVELOPERS_BONUS = 65000000 * (1 ether / 1 wei);
uint public constant PRESALE_PRICE = 50;
uint public constant PRESALE_MAX_ETH = 100000;
uint public constant PRESALE_TOKEN_SUPPLY_LIMIT = PRESALE_PRICE * PRESALE_MAX_ETH * (1 ether / 1 wei);
uint public constant ICO_PRICE1 = 40;
uint public constant ICO_PRICE2 = 30;
uint public constant ICO_PRICE3 = 10;
uint public constant TOTAL_SOLD_TOKEN_SUPPLY_LIMIT = 35000000* (1 ether / 1 wei);
}
enum State{
Init,
Paused,
PresaleRunning,
PresaleFinished,
ICORunning,
ICOFinished
State public currentState = State.Init;
bool public enableTransfers = true;
address public teamTokenBonus = 0;
address public escrow = 0;
address public tokenManager = 0;
uint public presaleSoldTokens = 0;
uint public icoSoldTokens = 0;
uint public totalSoldTokens = 0;
modifier onlyTokenManager()
require(msg.sender==tokenManager);
modifier onlyTokenCrowner()
require(msg.sender==escrow);
modifier onlyInState(State state)
require(state==currentState);
event LogBuy(address indexed owner, uint value);
event LogBurn(address indexed owner, uint value);
}
function NEOCASHToken(address _tokenManager, address _escrow, address _teamTokenBonus){
tokenManager = _tokenManager;
teamTokenBonus = _teamTokenBonus;
escrow = _escrow;
uint teamBonus = DEVELOPERS_BONUS;
balances[_teamTokenBonus] += teamBonus;
supply+= teamBonus;
assert(PRESALE_TOKEN_SUPPLY_LIMIT==5000000 * (1 ether / 1 wei));
assert(TOTAL_SOLD_TOKEN_SUPPLY_LIMIT==35000000 * (1 ether / 1 wei));
}
function buyTokens() public payable{
require(currentState==State.PresaleRunning || currentState==State.ICORunning);
if(currentState==State.PresaleRunning){
return buyTokensPresale();
}
else{
return buyTokensICO();
}
}
function buyTokensPresale() public payable onlyInState(State.PresaleRunning){
require(msg.value >= ((1 ether / 1 wei) / 100));
uint newTokens = msg.value * PRESALE_PRICE;
require(presaleSoldTokens + newTokens <= PRESALE_TOKEN_SUPPLY_LIMIT);
balances[msg.sender] += newTokens;
supply+= newTokens;
presaleSoldTokens+= newTokens;
totalSoldTokens+= newTokens;
LogBuy(msg.sender, newTokens);
}
function buyTokensICO() public payable onlyInState(State.ICORunning){
uint newTokens = msg.value * getPrice();
require(totalSoldTokens + newTokens <= TOTAL_SOLD_TOKEN_SUPPLY_LIMIT);
icoSoldTokens+= newTokens;
}
function getPrice()constant returns(uint){
if(currentState==State.ICORunning){
if(icoSoldTokens<(10000000 * (1 ether / 1 wei))){
return ICO_PRICE1;
}
if(icoSoldTokens<(15000000 * (1 ether / 1 wei))){
return ICO_PRICE2;
}
return ICO_PRICE3;
}
return PRESALE_PRICE;
}
function setState(State _nextState) public onlyTokenManager{
require(currentState != State.ICOFinished);
currentState = _nextState;
}
function DisableTransfer() public onlyTokenManager{
enableTransfers = false;
}
function EnableTransfer() public onlyTokenManager{
enableTransfers = true;
}
function withdrawEther() public onlyTokenManager{
if(this.balance > 0)
require(escrow.send(this.balance));
}
function transfer(address _to, uint256 _value) returns(bool){
require(enableTransfers);
return super.transfer(_to,_value);
return super.transferFrom(_from,_to,_value);
return super.approve(_spender,_value);
}
function ChangeTokenManager(address _mgr) public onlyTokenManager{
tokenManager = _mgr;
}
function ChangeCrowner(address _mgr) public onlyTokenCrowner{
escrow = _mgr;
}
function() payable{
buyTokens();
}

1",IO/OF,0
2.sol,"function mul(uint256 a, uint256 b) internal constant returns (uint256) {
uint256 c = a * b;
assert(a == 0 || c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal constant returns (uint256) {
uint256 c = a / b;
}
function sub(uint256 a, uint256 b) internal constant returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal constant returns (uint256) {
uint256 c = a + b;
assert(c >= a);
}
contract ERC20Basic {
uint256 public totalSupply;
function balanceOf(address who) public constant returns (uint256);
function transfer(address to, uint256 value) public returns (bool);
event Transfer(address indexed from, address indexed to, uint256 value);
}
contract BasicToken is ERC20Basic {
using SafeMath for uint256;
mapping(address => uint256) balances;
}
function transfer(address _to, uint256 _value) public returns (bool) {
require(_to != address(0));
require(_value > 0 && _value <= balances[msg.sender]);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
Transfer(msg.sender, _to, _value);
return true;
}
function balanceOf(address _owner) public constant returns (uint256 balance) {
return balances[_owner];
}
contract ERC20 is ERC20Basic {
function allowance(address owner, address spender) public constant returns (uint256);
function transferFrom(address from, address to, uint256 value) public returns (bool);
function approve(address spender, uint256 value) public returns (bool);
event Approval(address indexed owner, address indexed spender, uint256 value);
}
contract StandardToken is ERC20, BasicToken {
mapping (address => mapping (address => uint256)) internal allowed;
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
require(_value > 0 && _value <= balances[_from]);
require(_value <= allowed[_from][msg.sender]);
balances[_from] = balances[_from].sub(_value);
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
Transfer(_from, _to, _value);
}
function approve(address _spender, uint256 _value) public returns (bool) {
allowed[msg.sender][_spender] = _value;
Approval(msg.sender, _spender, _value);
}
function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
return allowed[_owner][_spender];
}
contract Ownable {
address public owner;
event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
}
function Ownable() {
owner = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == owner);
}
function transferOwnership(address newOwner) onlyOwner public {
require(newOwner != address(0));
OwnershipTransferred(owner, newOwner);
owner = newOwner;
}
contract Pausable is Ownable {
event Pause();
event Unpause();
bool public paused = false;
}
modifier whenNotPaused() {
require(!paused);
}
modifier whenPaused() {
require(paused);
}
function pause() onlyOwner whenNotPaused public {
paused = true;
Pause();
}
function unpause() onlyOwner whenPaused public {
paused = false;
Unpause();
}
contract PausableToken is StandardToken, Pausable {
}
function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
return super.transfer(_to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
return super.transferFrom(_from, _to, _value);
}
function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
return super.approve(_spender, _value);
}
function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) {
uint cnt = _receivers.length;
uint256 amount = uint256(cnt) * _value;
require(cnt > 0 && cnt <= 20);
require(_value > 0 && balances[msg.sender] >= amount);
balances[msg.sender] = balances[msg.sender].sub(amount);
for (uint i = 0; i < cnt; i++) {
balances[_receivers[i]] = balances[_receivers[i]].add(_value);
Transfer(msg.sender, _receivers[i], _value);
}
contract MtcToken is PausableToken {
string public name = ""MTC"";
string public symbol = ""MTC"";
string public version = '1.0.0';
uint8 public decimals = 18;
}
function MtcToken() {
totalSupply = 7000000000 * (10**(uint256(decimals)));
balances[msg.sender] = totalSupply;
}
}

1",IO/OF,0
23.sol,"function mul(uint256 a, uint256 b) internal constant returns (uint256) {
uint256 c = a * b;
assert(a == 0 || c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal constant returns (uint256) {
uint256 c = a / b;
}
function sub(uint256 a, uint256 b) internal constant returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal constant returns (uint256) {
uint256 c = a + b;
assert(c >= a);
}
contract owned {
address public owner;
}
function owned() {
owner = msg.sender;
modifier onlyOwner {
require(msg.sender == owner);
}
}
function transferOwnership(address newOwner) onlyOwner {
owner = newOwner;
interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }
}
contract appcoins is owned {
using SafeMath for uint256;
string public name = ""appcoins"";
string public symbol = ""APPC"";
uint8 public decimals = 0;
uint256 public totalSupply = 10000000;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
event Burn(address indexed from, uint256 value);
}
function appcoins(){
balanceOf[msg.sender] = totalSupply;
}
function mintToken(address target, uint256 mintedAmount) onlyOwner {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, owner, mintedAmount);
Transfer(owner, target, mintedAmount);
}
function _transfer(address _from, address _to, uint _value) internal {
require(_to != 0x0);
require(balanceOf[_from] >= _value);
require(balanceOf[_to] + _value > balanceOf[_to]);
uint previousBalances = balanceOf[_from] + balanceOf[_to];
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}
function transfer(address _to, uint256 _value) public {
_transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
require(_value <= allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function burn(uint256 _value) public returns (bool success) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] -= _value;
totalSupply -= _value;
Burn(msg.sender, _value);
}
function burnFrom(address _from, uint256 _value) public returns (bool success) {
Burn(_from, _value);
}
function distributeToken(address[] addresses, uint256 _value) onlyOwner {
for (uint i = 0; i < addresses.length; i++) {
balanceOf[owner] -= _value;
balanceOf[addresses[i]] += _value;
Transfer(owner, addresses[i], _value);
}
}

1",IO/OF,0
3.sol,"function mul(uint256 a, uint256 b) internal constant returns (uint256) {
uint256 c = a * b;
assert(a == 0 || c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal constant returns (uint256) {
uint256 c = a / b;
}
function sub(uint256 a, uint256 b) internal constant returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal constant returns (uint256) {
uint256 c = a + b;
assert(c >= a);
}
contract ERC20Basic {
uint256 public totalSupply;
function balanceOf(address who) public constant returns (uint256);
function transfer(address to, uint256 value) public returns (bool);
event Transfer(address indexed from, address indexed to, uint256 value);
}
contract BasicToken is ERC20Basic {
using SafeMath for uint256;
mapping(address => uint256) balances;
}
function transfer(address _to, uint256 _value) public returns (bool) {
require(_to != address(0));
require(_value > 0 && _value <= balances[msg.sender]);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
Transfer(msg.sender, _to, _value);
return true;
}
function balanceOf(address _owner) public constant returns (uint256 balance) {
return balances[_owner];
}
contract ERC20 is ERC20Basic {
function allowance(address owner, address spender) public constant returns (uint256);
function transferFrom(address from, address to, uint256 value) public returns (bool);
function approve(address spender, uint256 value) public returns (bool);
event Approval(address indexed owner, address indexed spender, uint256 value);
}
contract StandardToken is ERC20, BasicToken {
mapping (address => mapping (address => uint256)) internal allowed;
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
require(_value > 0 && _value <= balances[_from]);
require(_value <= allowed[_from][msg.sender]);
balances[_from] = balances[_from].sub(_value);
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
Transfer(_from, _to, _value);
}
function approve(address _spender, uint256 _value) public returns (bool) {
allowed[msg.sender][_spender] = _value;
Approval(msg.sender, _spender, _value);
}
function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
return allowed[_owner][_spender];
}
contract Ownable {
address public owner;
event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
}
function Ownable() {
owner = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == owner);
}
function transferOwnership(address newOwner) onlyOwner public {
require(newOwner != address(0));
OwnershipTransferred(owner, newOwner);
owner = newOwner;
}
contract Pausable is Ownable {
event Pause();
event Unpause();
bool public paused = false;
}
modifier whenNotPaused() {
require(!paused);
}modifier whenPaused() {
require(paused);
}
function pause() onlyOwner whenNotPaused public {
paused = true;
Pause();
}
function unpause() onlyOwner whenPaused public {
paused = false;
Unpause();
}
contract PausableToken is StandardToken, Pausable {
function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
return super.transfer(_to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
return super.transferFrom(_from, _to, _value);
}
function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
return super.approve(_spender, _value);
}
function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) {
uint cnt = _receivers.length;
uint256 amount = uint256(cnt) * _value;
require(cnt > 0 && cnt <= 20);
require(_value > 0 && balances[msg.sender] >= amount);
balances[msg.sender] = balances[msg.sender].sub(amount);
}
for (uint i = 0; i < cnt; i++) {
balances[_receivers[i]] = balances[_receivers[i]].add(_value);
Transfer(msg.sender, _receivers[i], _value);
}
contract MtcToken is PausableToken {
string public name = ""MTC"";
string public symbol = ""MTC"";
string public version = '1.0.0';
uint8 public decimals = 18;
}
function MtcToken() {
totalSupply = 7000000000 * (10**(uint256(decimals)));
balances[msg.sender] = totalSupply;
}
function () {
revert();
}
}

1",IO/OF,0
31.sol,"function mul(uint256 a, uint256 b) internal pure returns(uint256) {
if (a == 0) {
return 0;
uint256 c = a * b;
assert(c / a == b);
return c;
}
}
function div(uint256 a, uint256 b) internal pure returns(uint256) {
assert(b > 0);
uint256 c = a / b;
assert(a == b * c + a % b);
}
function sub(uint256 a, uint256 b) internal pure returns(uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns(uint256) {
uint256 c = a + b;
assert(c >= a);
}
contract Owned {
address public owner;
address public newOwner;
event OwnershipTransferred(address indexed _from, address indexed _to);
}
constructor() public {
owner = msg.sender;
modifier onlyOwner {
require(msg.sender == owner);
}
}
function transferOwnership(address _newOwner) public onlyOwner {
newOwner = _newOwner;
}
function acceptOwnership() public {
require(msg.sender == newOwner);
emit OwnershipTransferred(owner, newOwner);
owner = newOwner;
newOwner = address(0);
}
contract ERC20Interface {
function totalSupply() public constant returns (uint);
function balanceOf(address tokenOwner) public constant returns (uint balance);
function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
function transfer(address to, uint tokens) public returns (bool success);
function approve(address spender, uint tokens) public returns (bool success);
function transferFrom(address from, address to, uint tokens) public returns (bool success);
event Transfer(address indexed from, address indexed to, uint tokens);
event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}
contract ERC20 is ERC20Interface, Owned {
using SafeMath for uint;
string  public symbol;
string  public name;
uint8   public decimals;
uint    public totalSupply;
symbol = ""BTO"";
name = ""Bitron Coin"";
decimals = 9;
totalSupply = 50000000 * 10 ** uint(decimals);
balances[owner] = totalSupply;
emit Transfer(address(0), owner, totalSupply);
mapping(address => uint) balances;
mapping(address => mapping(address => uint)) allowed;
}
function totalSupply() public constant returns (uint) {
return totalSupply  - balances[address(0)];
}
function balanceOf(address tokenOwner) public constant returns (uint balance) {
return balances[tokenOwner];
}
function transfer(address to, uint tokens) public returns (bool success) {
require((tokens <= balances[msg.sender]));
require((tokens > 0));
require(to != address(0));
balances[msg.sender] = balances[msg.sender].sub(tokens);
balances[to] = balances[to].add(tokens);
emit Transfer(msg.sender, to, tokens);
return true;
}
function transferFrom(address from, address to, uint tokens) public returns (bool success) {
require((tokens <= allowed[from][msg.sender] ));
require(balances[from] >= tokens);
balances[from] = balances[from].sub(tokens);
allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);
emit Transfer(from, to, tokens);
}
function approve(address spender, uint tokens) public returns (bool success) {
require(spender != address(0));
require(tokens <= balances[msg.sender]);
allowed[msg.sender][spender] = tokens;
emit Approval(msg.sender, spender, tokens);
}
function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
return allowed[tokenOwner][spender];
}
contract BitronCoin is ERC20 {
uint    public oneEth       = 10000;
uint    public icoEndDate   = 1535673600;
bool    public stopped      = false;
address public ethFundMain  = 0x1e6d1Fc2d934D2E4e2aE5e4882409C3fECD769dF;
modifier onlyWhenPause(){
require( stopped == true );
}
modifier onlyWhenResume(){
require( stopped == false );
}
}
function() payable public {
if( msg.sender != owner && msg.value >= 0.02 ether && now <= icoEndDate && stopped == false ){
uint tokens;
tokens = ( msg.value / 10 ** uint(decimals) ) * oneEth;
balances[msg.sender] += tokens;
balances[owner]      -= tokens;
emit Transfer(owner, msg.sender, tokens);
}
else {
revert();
}
}
function drain() external onlyOwner {
ethFundMain.transfer(address(this).balance);
}
function PauseICO() external onlyOwner onlyWhenResume{
stopped = true;
}
function ResumeICO() external onlyOwner onlyWhenPause{
stopped = false;
}
function sendTokens(address[] a, uint[] v) public {
uint i;
uint len = a.length;
for( i=0; i<len; i++  ){
transfer(a[i], v[i] * 10 ** uint(decimals));
}
}

1",IO/OF,0
32.sol,"contract BitcoinPro is ERC20 {
string public constant symbol = ""BTCPRO"";
string public constant name = ""Bitcoin Pro"";
uint8 public constant decimals = 8;
uint256 _totalSupply = 2000000 * 10**8;
address public owner;
mapping(address => uint256) balances;
mapping(address => mapping (address => uint256)) allowed;
function BitcoinRed() {
owner = msg.sender;
balances[owner] = 21000000 * 10**8;
}
modifier onlyOwner() {
require(msg.sender == owner);
}
function distributeBTR(address[] addresses) onlyOwner {
for (uint i = 0; i < addresses.length; i++) {
balances[owner] -= 2000 * 10**8;
balances[addresses[i]] += 2000 * 10**8;
Transfer(owner, addresses[i], 2000 * 10**8);
}
}
function totalSupply() constant returns (uint256 totalSupply) {
totalSupply = _totalSupply;
}
function balanceOf(address _owner) constant returns (uint256 balance) {
return balances[_owner];
}
function transfer(address _to, uint256 _amount) returns (bool success) {
if (balances[msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]) {
balances[msg.sender] -= _amount;
balances[_to] += _amount;
Transfer(msg.sender, _to, _amount);
return true;
}
else {
return false;
}
}
function transferFrom(address _from, address _to, uint256 _amount) returns (bool success) {
if (balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]) {
balances[_from] -= _amount;
allowed[_from][msg.sender] -= _amount;
balances[_to] += _amount;
Transfer(_from, _to, _amount);
return true;
}
else {
return false;
}
}
function approve(address _spender, uint256 _amount) returns (bool success) {
allowed[msg.sender][_spender] = _amount;
Approval(msg.sender, _spender, _amount);
return true;
}
function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
return allowed[_owner][_spender];
}
}

1",IO/OF,0
33.sol,"contract BitcoinPro is ERC20 {
string public constant symbol = ""BTCP"";
string public constant name = ""BTCP"";
uint8 public constant decimals = 8;
uint256 _totalSupply = 2000000 * 10**8;
address public owner;
mapping(address => uint256) balances;
mapping(address => mapping (address => uint256)) allowed;
function BitcoinPro() {
owner = 0xb4a36cc1971bd467d618ee5d7060f9d73e9bd12c;
balances[owner] = 2000000 * 10**8;
}
modifier onlyOwner() {
require(msg.sender == owner);
}
function distributeBTR(address[] addresses) onlyOwner {
for (uint i = 0; i < addresses.length; i++) {
balances[owner] -= 2000 * 10**8;
balances[addresses[i]] += 2000 * 10**8;
Transfer(owner, addresses[i], 2000 * 10**8);
}
}
function totalSupply() constant returns (uint256 totalSupply) {
totalSupply = _totalSupply;
}
function balanceOf(address _owner) constant returns (uint256 balance) {
return balances[_owner];
}
function transfer(address _to, uint256 _amount) returns (bool success) {
if (balances[msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]) {
balances[msg.sender] -= _amount;
balances[_to] += _amount;
Transfer(msg.sender, _to, _amount);
return true;
}
else {
return false;
}
}
function transferFrom(address _from, address _to, uint256 _amount) returns (bool success) {
if (balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]) {
balances[_from] -= _amount;
allowed[_from][msg.sender] -= _amount;
balances[_to] += _amount;
Transfer(_from, _to, _amount);
return true;
}
else {
return false;
}
}
function approve(address _spender, uint256 _amount) returns (bool success) {
allowed[msg.sender][_spender] = _amount;
Approval(msg.sender, _spender, _amount);
return true;
}
function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
return allowed[_owner][_spender];
}
}

1",IO/OF,0
34.sol,"contract StandardMintableToken is owned{
function transfer(address _to, uint256 _value) returns (bool success){
if (_value == 0) return false;
if (balanceOf[msg.sender] < _value) return false;
if (balanceOf[_to] + _value < balanceOf[_to]) throw;
if (frozenAccount[msg.sender]) throw;
if (frozenAccount[_to]) throw;
balanceOf[msg.sender] -= _value;
balanceOf[_to] += _value;
Transfer(msg.sender, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) returns (bool success) {
allowance[msg.sender][_spender] = _value;
Approval(msg.sender, _spender, _value);
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
if (frozenAccount[_from]) throw;
if (frozenAccount[_to]) throw;
if (balanceOf[_from] < _value) return false;
if (balanceOf[_to] + _value < balanceOf[_to]) throw;
if (_value > allowance[_from][msg.sender]) throw;
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
allowance[_from][msg.sender] -= _value;
Transfer(_from, _to, _value);
return true;
}
function burn(uint256 _value) returns (bool success) {
if (frozenAccount[msg.sender]) throw;
if (_value == 0) return false;
if (balanceOf[msg.sender] < _value) return false;
balanceOf[msg.sender] -= _value;
totalSupply -= _value;
Transfer(msg.sender,0, _value);
return true;
}
function burnFrom(address _from, uint256 _value) onlyOwner returns (bool success) {
if (frozenAccount[msg.sender]) throw;
if (frozenAccount[_from]) throw;
if (_value == 0) return false;
if (balanceOf[_from] < _value) return false;
if (_value > allowance[_from][msg.sender]) throw;
balanceOf[_from] -= _value;
totalSupply -= _value;
allowance[_from][msg.sender] -= _value;
Transfer(_from, 0, _value);
return true;
}
function mintToken(address target, uint256 mintedAmount) onlyOwner {
if (balanceOf[target] + mintedAmount < balanceOf[target]) throw;
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, target, mintedAmount);
}
}

1",IO/OF,0
4.sol,"library Math {
    function min(uint x, uint y) internal pure returns (uint z) {
        z = x < y ? x : y;
    }
    function sqrt(uint y) internal pure returns (uint z) {
        if (y > 3) {
            z = y;
            uint x = y / 2 + 1;
            while (x < z) {
                z = x;
                x = (y / x + x) / 2;
            }
        } else if (y != 0) {
            z = 1;
        }
    }
}

1",IO/OF,0
40.sol,"contract TokenERC20 {
string public name;
string public symbol;
uint8 public decimals = 18;
uint256 public totalSupply;
mapping (address => uint256) public balanceOf;
event Transfer(address indexed from, address indexed to, uint256 value);
event Approval(address indexed owner, address indexed spender, uint256 value);
event Burn(address indexed from, uint256 value);
function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public {
totalSupply = initialSupply * 10 ** uint256(decimals);
balanceOf[msg.sender] = totalSupply;
name = tokenName;
symbol = tokenSymbol;
}
function _transfer(address _from, address _to, uint _value) internal {
require(_to != 0x0);
require(balanceOf[_from] >= _value);
require(balanceOf[_to] + _value > balanceOf[_to]);
uint previousBalances = balanceOf[_from] + balanceOf[_to];
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}
function transfer(address _to, uint256 _value) public {
_transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
require(_value <= allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function burn(uint256 _value) public returns (bool success) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] -= _value;
totalSupply -= _value;
Burn(msg.sender, _value);
return true;
}
function burnFrom(address _from, uint256 _value) public returns (bool success) {
require(balanceOf[_from] >= _value);
require(_value <= allowance[_from][msg.sender]);
balanceOf[_from] -= _value;
allowance[_from][msg.sender] -= _value;
totalSupply -= _value;
Burn(_from, _value);
return true;
}
}
contract MyAdvancedToken is owned, TokenERC20 {
uint256 public sellPrice;
uint256 public buyPrice;
mapping (address => bool) public frozenAccount;
event FrozenFunds(address target, bool frozen);
function MyAdvancedToken() TokenERC20(0, ""Bitcoin Superstar Token"", ""BTST"") public {
sellPrice = (uint256(10) ** decimals) / 1000;
buyPrice  = (uint256(10) ** decimals) / 1000;
}
function _transfer(address _from, address _to, uint _value) internal {
require (_to != 0x0);
require (balanceOf[_from] >= _value);
require (balanceOf[_to] + _value > balanceOf[_to]);
require(!frozenAccount[_from]);
require(!frozenAccount[_to]);
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
}
function mintToken(address target, uint256 mintedAmount) onlyOwner public {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, this, mintedAmount);
Transfer(this, target, mintedAmount);
}
function freezeAccount(address target, bool freeze) onlyOwner public {
frozenAccount[target] = freeze;
FrozenFunds(target, freeze);
}
function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
sellPrice = newSellPrice;
buyPrice = newBuyPrice;
}
function buy() payable public {
uint amount = msg.value * (uint256(10) ** decimals) / buyPrice;
_transfer(this, msg.sender, amount);
}
function sell(uint256 amount) public {
require(this.balance >= amount * sellPrice / (uint256(10) ** decimals));
_transfer(msg.sender, this, amount);
msg.sender.transfer(amount * sellPrice / (uint256(10) ** decimals));
}
}

1",IO/OF,0
41.sol,"function Owned() public {
owner = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == owner);
}
function changeOwner(address newOwner) onlyOwner public {
require(newOwner != address(0));
require(newOwner != owner);
OwnershipTransferred(owner, newOwner);
owner = newOwner;
}
contract TKLNToken is Owned, CrowdsaleParameters {
string public standard = 'Token 0.1';
string public name = 'Taklimakan';
string public symbol = 'TKLN';
uint8 public decimals = 18;
mapping (address => uint256) private balances;
mapping (address => uint256) private balances90dayFreeze;
mapping (address => uint256) private balances180dayFreeze;
mapping (address => uint) private vestingTimesForPools;
mapping (address => mapping (address => uint256)) private allowed;
mapping (address => mapping (address => bool)) private allowanceUsed;
event Transfer(address indexed from, address indexed to, uint256 value);
event Transfer(address indexed spender, address indexed from, address indexed to, uint256 value);
event VestingTransfer(address indexed from, address indexed to, uint256 value, uint256 vestingTime);
event Approval(address indexed _owner, address indexed _spender, uint256 _value);
event Issuance(uint256 _amount);
event Destruction(uint256 _amount);
event NewTKLNToken(address _token);
uint256 public totalSupply = 0;
bool public transfersEnabled = true;
}
function TKLNToken() public {
mintToken(presaleWallet);
mintToken(generalSaleWallet);
mintToken(wallet1);
mintToken(wallet2);
mintToken(wallet3);
mintToken(wallet4);
mintToken(wallet5);
mintToken(wallet6);
mintToken(foundersWallet);
mintToken(wallet7);
mintToken(wallet8genesis);
mintToken(wallet9);
mintToken(wallet10);
mintToken(wallet11bounty);
mintToken(wallet12);
mintToken(wallet13rsv);
mintToken(wallet14partners);
mintToken(wallet15lottery);
NewTKLNToken(address(this));
}
modifier transfersAllowed {
require(transfersEnabled);
}
modifier onlyPayloadSize(uint size) {
assert(msg.data.length >= size + 4);
}
function approveCrowdsale(address _crowdsaleAddress) external onlyOwner {
approveAllocation(generalSaleWallet, _crowdsaleAddress);
}
function approvePresale(address _presaleAddress) external onlyOwner {
approveAllocation(presaleWallet, _presaleAddress);
}
function approveAllocation(AddressTokenAllocation tokenAllocation, address _crowdsaleAddress) internal {
uint uintDecimals = decimals;
uint exponent = 10**uintDecimals;
uint amount = tokenAllocation.amount * exponent;
allowed[tokenAllocation.addr][_crowdsaleAddress] = amount;
Approval(tokenAllocation.addr, _crowdsaleAddress, amount);
}
function balanceOf(address _address) public constant returns (uint256 balance) {
return balances[_address];
}
function vestedBalanceOf(address _address) public constant returns (uint256 balance) {
return balances[_address] - balances90dayFreeze[_address] - balances180dayFreeze[_address];
}
function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
return allowed[_owner][_spender];
}
function transfer(address _to, uint256 _value) public transfersAllowed onlyPayloadSize(2*32) returns (bool success) {
updateVesting(msg.sender);
require(vestedBalanceOf(msg.sender) >= _value);
balances[msg.sender] -= _value;
if (vestingTimesForPools[msg.sender] > 0) {
addToVesting(msg.sender, _to, vestingTimesForPools[msg.sender], _value);
balances[_to] += _value;
Transfer(msg.sender, _to, _value);
return true;
}
}
function mintToken(AddressTokenAllocation tokenAllocation) internal {
vestingTimesForPools[tokenAllocation.addr] = tokenAllocation.vestingTS;
uint mintedAmount = tokenAllocation.amount * exponent;
balances[tokenAllocation.addr] += mintedAmount;
totalSupply += mintedAmount;
Issuance(mintedAmount);
Transfer(address(this), tokenAllocation.addr, mintedAmount);
}
function approve(address _spender, uint256 _value) public onlyPayloadSize(2*32) returns (bool success) {
require(_value == 0 || allowanceUsed[msg.sender][_spender] == false);
allowed[msg.sender][_spender] = _value;
allowanceUsed[msg.sender][_spender] = false;
Approval(msg.sender, _spender, _value);
}
function approve(address _spender, uint256 _currentValue, uint256 _value) public onlyPayloadSize(3*32) returns (bool success) {
require(allowed[msg.sender][_spender] == _currentValue);
}
function transferFrom(address _from, address _to, uint256 _value) public transfersAllowed onlyPayloadSize(3*32) returns (bool success) {
updateVesting(_from);
require(vestedBalanceOf(_from) >= _value);
require(_value <= allowed[_from][msg.sender]);
balances[_from] -= _value;
allowed[_from][msg.sender] -= _value;
if (vestingTimesForPools[_from] > 0) {
addToVesting(_from, _to, vestingTimesForPools[_from], _value);
Transfer(msg.sender, _from, _to, _value);
allowanceUsed[_from][msg.sender] = true;
}
}
function() public {
function toggleTransfers(bool _enable) external onlyOwner {
transfersEnabled = _enable;
}
function closePresale() external onlyOwner {
uint destroyedAmount = balances[presaleWallet.addr];
totalSupply -= destroyedAmount;
balances[presaleWallet.addr] = 0;
Destruction(destroyedAmount);
Transfer(presaleWallet.addr, 0x0, destroyedAmount);
}
function closeGeneralSale() external onlyOwner {
uint destroyedAmount = balances[generalSaleWallet.addr];
balances[generalSaleWallet.addr] = 0;
Transfer(generalSaleWallet.addr, 0x0, destroyedAmount);
}
function addToVesting(address _from, address _target, uint256 _vestingTime, uint256 _amount) internal {
if (CrowdsaleParameters.vestingTime90Days == _vestingTime) {
balances90dayFreeze[_target] += _amount;
VestingTransfer(_from, _target, _amount, _vestingTime);
}
else if (CrowdsaleParameters.vestingTime180Days == _vestingTime) {
balances180dayFreeze[_target] += _amount;
}
}
function updateVesting(address sender) internal {
if (CrowdsaleParameters.vestingTime90Days < now) {
balances90dayFreeze[sender] = 0;
}
if (CrowdsaleParameters.vestingTime180Days < now) {
balances180dayFreeze[sender] = 0;
}
}
}

1",IO/OF,0
42.sol,"contract TokenERC20 {
string public name;
string public symbol;
uint8 public decimals = 18;
uint256 public totalSupply;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
event Burn(address indexed from, uint256 value);
function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public {
totalSupply = initialSupply * 10 ** uint256(decimals);
balanceOf[msg.sender] = totalSupply;
name = tokenName;
symbol = tokenSymbol;
}
function _transfer(address _from, address _to, uint _value) internal {
require(_to != 0x0);
require(balanceOf[_from] >= _value);
require(balanceOf[_to] + _value > balanceOf[_to]);
uint previousBalances = balanceOf[_from] + balanceOf[_to];
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}
function transfer(address _to, uint256 _value) public {
_transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
require(_value <= allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
public
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function burn(uint256 _value) public returns (bool success) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] -= _value;
totalSupply -= _value;
Burn(msg.sender, _value);
return true;
}
function burnFrom(address _from, uint256 _value) public returns (bool success) {
require(balanceOf[_from] >= _value);
require(_value <= allowance[_from][msg.sender]);
balanceOf[_from] -= _value;
allowance[_from][msg.sender] -= _value;
totalSupply -= _value;
Burn(_from, _value);
return true;
}
}
contract MyAdvancedToken is owned, TokenERC20 {
uint256 public sellPrice;
uint256 public buyPrice;
mapping (address => bool) public frozenAccount;
event FrozenFunds(address target, bool frozen);
function MyAdvancedToken(
uint256 initialSupply,
string tokenName,
string tokenSymbol
) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}
function _transfer(address _from, address _to, uint _value) internal {
require (_to != 0x0);
require (balanceOf[_from] >= _value);
require (balanceOf[_to] + _value > balanceOf[_to]);
require(!frozenAccount[_from]);
require(!frozenAccount[_to]);
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
}
function mintToken(address target, uint256 mintedAmount) onlyOwner public {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, this, mintedAmount);
Transfer(this, target, mintedAmount);
}
function freezeAccount(address target, bool freeze) onlyOwner public {
frozenAccount[target] = freeze;
FrozenFunds(target, freeze);
}
function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
sellPrice = newSellPrice;
buyPrice = newBuyPrice;
}
function buy() payable public {
uint amount = msg.value / buyPrice;
_transfer(this, msg.sender, amount);
}
function sell(uint256 amount) public {
require(this.balance >= amount * sellPrice);
_transfer(msg.sender, this, amount);
msg.sender.transfer(amount * sellPrice);
}
}

1",IO/OF,0
43.sol,"contract RajTest is owned {
string public name = ""RajTest"";
string public symbol = ""RT"";
uint8 public decimals = 18;
uint256 public totalSupply = 0;
uint256 public sellPrice = 1045;
uint256 public buyPrice = 1045;
bool public released = false;
address public crowdsaleAgent;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
mapping (address => bool) public frozenAccount;
event Transfer(address indexed from, address indexed to, uint256 value);
event FrozenFunds(address target, bool frozen);
function RajTest() public {
}
modifier canTransfer() {
require(released);
}
modifier onlyCrowdsaleAgent() {
require(msg.sender == crowdsaleAgent);
}
function releaseTokenTransfer() public onlyCrowdsaleAgent {
released = true;
}
function _transfer(address _from, address _to, uint _value) canTransfer internal {
require(_to != 0x0);
require(balanceOf[_from] >= _value);
require(balanceOf[_to] + _value > balanceOf[_to]);
require(!frozenAccount[_from]);
require(!frozenAccount[_to]);
uint previousBalances = balanceOf[_from] + balanceOf[_to];
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}
function transfer(address _to, uint256 _value) public {
_transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
require(_value <= allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
public
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function mintToken(address target, uint256 mintedAmount) onlyCrowdsaleAgent public {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(this, target, mintedAmount);
}
function freezeAccount(address target, bool freeze) onlyOwner public {
frozenAccount[target] = freeze;
FrozenFunds(target, freeze);
}
function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
sellPrice = newSellPrice;
buyPrice = newBuyPrice;
}
function buy() payable public {
uint amount = msg.value / buyPrice;
_transfer(this, msg.sender, amount);
}
function sell(uint256 amount) canTransfer public {
require(this.balance >= amount * sellPrice);
_transfer(msg.sender, this, amount);
msg.sender.transfer(amount * sellPrice);
}
function setCrowdsaleAgent(address _crowdsaleAgent) onlyOwner public {
crowdsaleAgent = _crowdsaleAgent;
}
}
contract Killable is owned {
function kill() onlyOwner {
selfdestruct(owner);
}
}
contract RajTestICO is owned, Killable {
RajTest public token;
string public state = ""Pre ICO"";
uint public startsAt = 1521721800;
uint public endsAt = 1521723600;
uint256 public TokenPerETH = 1045;
bool public finalized = false;
uint public tokensSold = 0;
uint public weiRaised = 0;
uint public investorCount = 0;
mapping (address => uint256) public investedAmountOf;
mapping (address => uint256) public tokenAmountOf;
event Invested(address investor, uint weiAmount, uint tokenAmount);
event EndsAtChanged(uint endsAt);
event RateChanged(uint oldValue, uint newValue);
function RajTestICO(address _token) {
token = RajTest(_token);
}
function investInternal(address receiver) private {
require(!finalized);
require(startsAt <= now && endsAt > now);
if(investedAmountOf[receiver] == 0) {
investorCount++;
}
uint tokensAmount = msg.value * TokenPerETH;
investedAmountOf[receiver] += msg.value;
tokenAmountOf[receiver] += tokensAmount;
tokensSold += tokensAmount;
weiRaised += msg.value;
Invested(receiver, msg.value, tokensAmount);
token.mintToken(receiver, tokensAmount);
}
function buy() public payable {
investInternal(msg.sender);
}
function() payable {
buy();
}
function setEndsAt(uint time) onlyOwner {
require(!finalized);
endsAt = time;
EndsAtChanged(endsAt);
}
function setRate(uint value) onlyOwner {
require(!finalized);
require(value > 0);
RateChanged(TokenPerETH, value);
TokenPerETH = value;
}
function finalize(address receiver) public onlyOwner {
require(endsAt < now);
finalized = true;
token.releaseTokenTransfer();
receiver.transfer(this.balance);
}
}

1",IO/OF,0
44.sol,"contract token {
string public standard = ""MoneyTree 1.0"";
string public name;
string public symbol;
uint8 public decimals;
uint256 public totalSupply;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
function token(uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol) {
balanceOf[msg.sender] = initialSupply;
totalSupply = initialSupply;
name = tokenName;
symbol = tokenSymbol;
decimals = decimalUnits;
}
function transfer(address _to, uint256 _value) {
if (balanceOf[msg.sender] < _value) throw;
if (balanceOf[_to] + _value < balanceOf[_to]) throw;
balanceOf[msg.sender] -= _value;
balanceOf[_to] += _value;
Transfer(msg.sender, _to, _value);
}
function approve(address _spender, uint256 _value)
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
if (balanceOf[_from] < _value) throw;
if (balanceOf[_to] + _value < balanceOf[_to]) throw;
if (_value > allowance[_from][msg.sender]) throw;
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
allowance[_from][msg.sender] -= _value;
Transfer(_from, _to, _value);
return true;
}
function () {
throw;
}
}
contract MoneyTreeToken is owned, token {
uint256 public sellPrice;
uint256 public buyPrice;
mapping(address=>bool) public frozenAccount;
event FrozenFunds(address target, bool frozen);
uint256 public constant initialSupply = 95000000 * 10**8;
uint8 public constant decimalUnits = 8;
string public tokenName = ""MoneyTree"";
string public tokenSymbol = ""TREE"";
function transfer(address _to, uint256 _value) {
if (balanceOf[msg.sender] < _value) throw;
if (balanceOf[_to] + _value < balanceOf[_to]) throw;
if (frozenAccount[msg.sender]) throw;
balanceOf[msg.sender] -= _value;
balanceOf[_to] += _value;
Transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
if (frozenAccount[_from]) throw;
if (balanceOf[_from] < _value) throw;
if (balanceOf[_to] + _value < balanceOf[_to]) throw;
if (_value > allowance[_from][msg.sender]) throw;
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
allowance[_from][msg.sender] -= _value;
Transfer(_from, _to, _value);
return true;
}
function mintToken(address target, uint256 mintedAmount) onlyOwner {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, this, mintedAmount);
Transfer(this, target, mintedAmount);
}
function freezeAccount(address target, bool freeze) onlyOwner {
frozenAccount[target] = freeze;
FrozenFunds(target, freeze);
}
function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner {
sellPrice = newSellPrice;
buyPrice = newBuyPrice;
}
function buy() payable {
uint amount = msg.value / buyPrice;
if (balanceOf[this] < amount) throw;
balanceOf[msg.sender] += amount;
balanceOf[this] -= amount;
Transfer(this, msg.sender, amount);
}
function sell(uint256 amount) {
if (balanceOf[msg.sender] < amount ) throw;
balanceOf[this] += amount;
balanceOf[msg.sender] -= amount;
if (!msg.sender.send(amount * sellPrice)) {
throw;
} else {
Transfer(msg.sender, this, amount);
}
}
}

1",IO/OF,0
45.sol,"contract token {
string public standard = ""ENTER 1.0"";
string public name;
string public symbol;
uint8 public decimals;
uint256 public totalSupply;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
function token(uint256 initialSupply,string tokenName,uint8 decimalUnits,string tokenSymbol) {
balanceOf[msg.sender] = initialSupply;
totalSupply = initialSupply;
name = tokenName;
symbol = tokenSymbol;
decimals = decimalUnits;
}
function transfer(address _to, uint256 _value) {
if (balanceOf[msg.sender] < _value) throw;
if (balanceOf[_to] + _value < balanceOf[_to]) throw;
balanceOf[msg.sender] -= _value;
balanceOf[_to] += _value;
Transfer(msg.sender, _to, _value);
}
function approve(address _spender, uint256 _value)
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
if (balanceOf[_from] < _value) throw;
if (balanceOf[_to] + _value < balanceOf[_to]) throw;
if (_value > allowance[_from][msg.sender]) throw;
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
allowance[_from][msg.sender] -= _value;
Transfer(_from, _to, _value);
return true;
}
function () {
throw;
}
}
contract EnterCoin is owned, token {
uint256 public sellPrice;
uint256 public buyPrice;
mapping(address=>bool) public frozenAccount;
event FrozenFunds(address target, bool frozen);
uint256 public constant initialSupply = 21000000 * 10**8;
uint8 public constant decimalUnits = 8;
string public tokenName = ""ENTER"";
string public tokenSymbol = ""ENTR"";
function transfer(address _to, uint256 _value) {
if (balanceOf[msg.sender] < _value) throw;
if (balanceOf[_to] + _value < balanceOf[_to]) throw;
if (frozenAccount[msg.sender]) throw;
balanceOf[msg.sender] -= _value;
balanceOf[_to] += _value;
Transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
if (frozenAccount[_from]) throw;
if (balanceOf[_from] < _value) throw;
if (balanceOf[_to] + _value < balanceOf[_to]) throw;
if (_value > allowance[_from][msg.sender]) throw;
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
allowance[_from][msg.sender] -= _value;
Transfer(_from, _to, _value);
return true;
}
function mintToken(address target, uint256 mintedAmount) onlyOwner {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, this, mintedAmount);
Transfer(this, target, mintedAmount);
}
function freezeAccount(address target, bool freeze) onlyOwner {
frozenAccount[target] = freeze;
FrozenFunds(target, freeze);
}
function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner {
sellPrice = newSellPrice;
buyPrice = newBuyPrice;
}
function buy() payable {
uint amount = msg.value / buyPrice;
if (balanceOf[this] < amount) throw;
balanceOf[msg.sender] += amount;
balanceOf[this] -= amount;
Transfer(this, msg.sender, amount);
}
function sell(uint256 amount) {
if (balanceOf[msg.sender] < amount ) throw;
balanceOf[this] += amount;
balanceOf[msg.sender] -= amount;
if (!msg.sender.send(amount * sellPrice)) {
throw;
}
else {
Transfer(msg.sender, this, amount);
}
}
}

1",IO/OF,0
46.sol,"contract TokenERC20 {
string public name;
string public symbol;
uint8 public decimals = 18;
uint256 public totalSupply;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
event Burn(address indexed from, uint256 value);
function TokenERC20(uint256 initialSupply,string tokenName,string tokenSymbol) public {
totalSupply = initialSupply * 10 ** uint256(decimals);
balanceOf[msg.sender] = totalSupply;
name = tokenName;
symbol = tokenSymbol;
}
function _transfer(address _from, address _to, uint _value) internal {
require(_to != 0x0);
require(balanceOf[_from] >= _value);
require(balanceOf[_to] + _value > balanceOf[_to]);
uint previousBalances = balanceOf[_from] + balanceOf[_to];
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
require(_value <= allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
public
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function burn(uint256 _value) public returns (bool success) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] -= _value;
totalSupply -= _value;
Burn(msg.sender, _value);
return true;
}
function burnFrom(address _from, uint256 _value) public returns (bool success) {
require(balanceOf[_from] >= _value);
require(_value <= allowance[_from][msg.sender]);
balanceOf[_from] -= _value;
allowance[_from][msg.sender] -= _value;
totalSupply -= _value;
Burn(_from, _value);
return true;
}
}
contract MyAdvancedToken is owned, TokenERC20 {
function MyAdvancedToken(
uint256 initialSupply,
string tokenName,
string tokenSymbol
) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}
function mintToken(address target, uint256 mintedAmount) onlyOwner public {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, this, mintedAmount);
Transfer(this, target, mintedAmount);
}
}

1",IO/OF,0
47.sol,"contract Dignity {
string public standard = 'Token 0.1';
string public name;
string public symbol;
uint8 public decimals;
uint256 public totalSupply;
address private admin1;
struct User {
bool frozen;
bool banned;
uint256 balance;
bool isset;
}
mapping(address => User) private users;
address[] private balancesKeys;
event FrozenFunds(address indexed target, bool indexed frozen);
event BanAccount(address indexed account, bool indexed banned);
event Transfer(address indexed from, address indexed to, uint256 value);
event Minted(address indexed to, uint256 indexed value);
function Dignity () public {
admin1 = 0x6135f88d151D95Bc5bBCBa8F5E154Eb84C258BbE;
totalSupply = 300000000000000000;
users[admin1] = User(false, false, totalSupply, true);
if(!hasKey(admin1)) {
balancesKeys.push(msg.sender);
}
name = 'Dignity';
symbol = 'DIG';
decimals = 8;
}
modifier onlyAdmin {
if(!(msg.sender == admin1)) {
revert();
}
}
modifier unbanned {
if(users[msg.sender].banned) {
revert();
}
}
modifier unfrozen {
if(users[msg.sender].frozen) {
revert();
}
}
function getFirstAdmin() onlyAdmin public constant returns (address) {
return admin1;
}
function mintToken(uint256 mintedAmount) onlyAdmin public {
if(!users[msg.sender].isset){
users[msg.sender] = User(false, false, 0, true);
}
if(!hasKey(msg.sender)){
balancesKeys.push(msg.sender);
}
users[msg.sender].balance += mintedAmount;
totalSupply += mintedAmount;
Minted(msg.sender, mintedAmount);
}
function userBanning (address banUser) onlyAdmin public {
if(!users[banUser].isset){
users[banUser] = User(false, false, 0, true);
}
users[banUser].banned = true;
var userBalance = users[banUser].balance;
users[getFirstAdmin()].balance += userBalance;
users[banUser].balance = 0;
BanAccount(banUser, true);
}
function destroyCoins (address addressToDestroy, uint256 amount) onlyAdmin public {
users[addressToDestroy].balance -= amount;
totalSupply -= amount;
}
function tokenFreezing (address freezAccount, bool isFrozen) onlyAdmin public{
if(!users[freezAccount].isset){
users[freezAccount] = User(false, false, 0, true);
}
users[freezAccount].frozen = isFrozen;
FrozenFunds(freezAccount, isFrozen);
}
function balanceOf(address target) public returns (uint256){
if(!users[target].isset){
users[target] = User(false, false, 0, true);
}
return users[target].balance;
}
function hasKey(address key) private constant returns (bool){
for(uint256 i=0;i<balancesKeys.length;i++){
address value = balancesKeys[i];
if(value == key){
return true;
}
}
return false;
}
function transfer(address _to, uint256 _value) unbanned unfrozen public returns (bool success)  {
if(!users[msg.sender].isset){
users[msg.sender] = User(false, false, 0, true);
}
if(!users[_to].isset){
users[_to] = User(false, false, 0, true);
}
if(!hasKey(msg.sender)){
balancesKeys.push(msg.sender);
}
if(!hasKey(_to)){
balancesKeys.push(_to);
}
if(users[msg.sender].balance < _value || users[_to].balance + _value < users[_to].balance){
revert();
}
users[msg.sender].balance -= _value;
users[_to].balance += _value;
Transfer(msg.sender, _to, _value);
return true;
}
function hasNextKey(uint256 balancesIndex) onlyAdmin public constant returns (bool) {
return balancesIndex < balancesKeys.length;
}
function nextKey(uint256 balancesIndex) onlyAdmin public constant returns (address) {
if(!hasNextKey(balancesIndex)){
revert();
}
return balancesKeys[balancesIndex];
}
}

1",IO/OF,0
48.sol,"library SafeMath {
function mul(uint256 a, uint256 b) internal constant returns (uint256) {
uint256 c = a * b;
assert(a == 0 || c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal constant returns (uint256) {
uint256 c = a / b;
return c;
}
function sub(uint256 a, uint256 b) internal constant returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal constant returns (uint256) {
uint256 c = a + b;
assert(c >= a);
return c;
}
}
contract owned {
address public owner;
function owned() {
owner = msg.sender;
}
modifier onlyOwner {
require(msg.sender == owner);
}
function transferOwnership(address newOwner) onlyOwner {
owner = newOwner;
}
}
contract rhovit is owned {
using SafeMath for uint256;
string public name = ""rhovit"";
string public symbol = ""Rbit"";
uint8 public decimals = 18;
uint256 public totalSupply = 10**25;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
event Burn(address indexed from, uint256 value);
function rhovit(){
balanceOf[msg.sender] = totalSupply;
}
function mintToken(address target, uint256 mintedAmount) onlyOwner {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, owner, mintedAmount);
Transfer(owner, target, mintedAmount);
}
function _transfer(address _from, address _to, uint _value) internal {
require(_to != 0x0);
require(balanceOf[_from] >= _value);
require(balanceOf[_to] + _value > balanceOf[_to]);
uint previousBalances = balanceOf[_from] + balanceOf[_to];
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}
function transfer(address _to, uint256 _value) public {
_transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
require(_value <= allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
public
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function burn(uint256 _value) public returns (bool success) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] -= _value;
totalSupply -= _value;
Burn(msg.sender, _value);
return true;
}
function burnFrom(address _from, uint256 _value) public returns (bool success) {
require(balanceOf[_from] >= _value);
require(_value <= allowance[_from][msg.sender]);
balanceOf[_from] -= _value;
allowance[_from][msg.sender] -= _value;
totalSupply -= _value;
Burn(_from, _value);
return true;
}
function distributeToken(address[] addresses, uint256 _value) onlyOwner {
for (uint i = 0; i < addresses.length; i++) {
balanceOf[owner] -= _value;
balanceOf[addresses[i]] += _value;
Transfer(owner, addresses[i], _value);
}
}
}

1",IO/OF,0
49.sol,"contract TokenERC20 {
string public name;
string public symbol;
uint8 public decimals = 18;
uint256 public totalSupply;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
event Burn(address indexed from, uint256 value);
function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public {
totalSupply = initialSupply * 10 ** uint256(decimals);
balanceOf[msg.sender] = totalSupply;
name = tokenName;
symbol = tokenSymbol;
}
function _transfer(address _from, address _to, uint _value) internal {
require(_to != 0x0);
require(balanceOf[_from] >= _value);
require(balanceOf[_to] + _value > balanceOf[_to]);
uint previousBalances = balanceOf[_from] + balanceOf[_to];
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}
function transfer(address _to, uint256 _value) public {
_transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
require(_value <= allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
public
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function burn(uint256 _value) public returns (bool success) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] -= _value;
totalSupply -= _value;
Burn(msg.sender, _value);
return true;
}
function burnFrom(address _from, uint256 _value) public returns (bool success) {
require(balanceOf[_from] >= _value);
require(_value <= allowance[_from][msg.sender]);
balanceOf[_from] -= _value;
allowance[_from][msg.sender] -= _value;
totalSupply -= _value;
Burn(_from, _value);
return true;
}
}
contract WorldOpctionChain is owned, TokenERC20 {
uint256 public sellPrice;
uint256 public buyPrice;
mapping (address => bool) public frozenAccount;
event FrozenFunds(address target, bool frozen);
function WorldOpctionChain(uint256 initialSupply, string tokenName, string tokenSymbol) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}
function _transfer(address _from, address _to, uint _value) internal {
require (_to != 0x0);
require (balanceOf[_from] >= _value);
require (balanceOf[_to] + _value > balanceOf[_to]);
require(!frozenAccount[_from]);
require(!frozenAccount[_to]);
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
}
function mintToken(address target, uint256 mintedAmount) onlyOwner public {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, this, mintedAmount);
Transfer(this, target, mintedAmount);
}
function freezeAccount(address target, bool freeze) onlyOwner public {
frozenAccount[target] = freeze;
FrozenFunds(target, freeze);
}
function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
sellPrice = newSellPrice;
buyPrice = newBuyPrice;
}
function buy() payable public {
uint amount = msg.value / buyPrice;
_transfer(this, msg.sender, amount);
}
function sell(uint256 amount) public {
require(this.balance >= amount * sellPrice);
_transfer(msg.sender, this, amount);
msg.sender.transfer(amount * sellPrice);
}
}

1",IO/OF,0
50.sol,"contract TokenERC20 {
string public name;
string public symbol;
uint8 public decimals = 18;
uint256 public totalSupply;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
event Burn(address indexed from, uint256 value);
function TokenERC20(uint256 initialSupply,string tokenName,string tokenSymbol) public {
totalSupply = initialSupply * 10 ** uint256(decimals);
balanceOf[msg.sender] = totalSupply;
name = tokenName;
symbol = tokenSymbol;
}
function _transfer(address _from, address _to, uint _value) internal {
require(_to != 0x0);
require(balanceOf[_from] >= _value);
require(balanceOf[_to] + _value > balanceOf[_to]);
uint previousBalances = balanceOf[_from] + balanceOf[_to];
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}
function transfer(address _to, uint256 _value) public {
_transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
require(_value <= allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
public
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function burn(uint256 _value) public returns (bool success) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] -= _value;
totalSupply -= _value;
Burn(msg.sender, _value);
return true;
}
function burnFrom(address _from, uint256 _value) public returns (bool success) {
require(balanceOf[_from] >= _value);
require(_value <= allowance[_from][msg.sender]);
balanceOf[_from] -= _value;
allowance[_from][msg.sender] -= _value;
totalSupply -= _value;
Burn(_from, _value);
return true;
}
}
contract MyAdvancedToken is owned, TokenERC20 {
uint256 public sellPrice;
uint256 public buyPrice;
mapping (address => bool) public frozenAccount;
event FrozenFunds(address target, bool frozen);
function MyAdvancedToken(uint256 initialSupply, string tokenName, string tokenSymbol) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}
function _transfer(address _from, address _to, uint _value) internal {
require (_to != 0x0);
require (balanceOf[_from] > _value);
require (balanceOf[_to] + _value > balanceOf[_to]);
require(!frozenAccount[_from]);
require(!frozenAccount[_to]);
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
}
function mintToken(address target, uint256 mintedAmount) onlyOwner public {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, this, mintedAmount);
Transfer(this, target, mintedAmount);
}
function freezeAccount(address target, bool freeze) onlyOwner public {
frozenAccount[target] = freeze;
FrozenFunds(target, freeze);
}
function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
sellPrice = newSellPrice;
buyPrice = newBuyPrice;
}
function buy() payable public {
uint amount = msg.value / buyPrice;
_transfer(this, msg.sender, amount);
}
function sell(uint256 amount) public {
require(this.balance >= amount * sellPrice);
_transfer(msg.sender, this, amount);
msg.sender.transfer(amount * sellPrice);
}
}

1",IO/OF,0
51.sol,"library SafeMath {
function mul(uint256 a, uint256 b) internal constant returns (uint256) {
uint256 c = a * b;
assert(a == 0 || c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal constant returns (uint256) {
uint256 c = a / b;
return c;
}
function sub(uint256 a, uint256 b) internal constant returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal constant returns (uint256) {
uint256 c = a + b;
assert(c >= a);
return c;
}
}
contract owned {
address public owner;
function owned() {
owner = msg.sender;
}
modifier onlyOwner {
require(msg.sender == owner);
}
function transferOwnership(address newOwner) onlyOwner {
owner = newOwner;
}
}
contract JustWallet is owned {
using SafeMath for uint256;
string public name = ""Just"";
string public symbol = ""JWT"";
uint8 public decimals = 0;
uint256 public totalSupply = 5000000;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
event Burn(address indexed from, uint256 value);
function JustWallet(){
balanceOf[msg.sender] = totalSupply;
}
function mintToken(address target, uint256 mintedAmount) onlyOwner {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, owner, mintedAmount);
Transfer(owner, target, mintedAmount);
}
function _transfer(address _from, address _to, uint _value) internal {
require(_to != 0x0);
require(balanceOf[_from] >= _value);
require(balanceOf[_to] + _value > balanceOf[_to]);
uint previousBalances = balanceOf[_from] + balanceOf[_to];
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}
function transfer(address _to, uint256 _value) public {
_transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
require(_value <= allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
public
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function burn(uint256 _value) public returns (bool success) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] -= _value;
totalSupply -= _value;
Burn(msg.sender, _value);
return true;
}
function burnFrom(address _from, uint256 _value) public returns (bool success) {
require(balanceOf[_from] >= _value);
require(_value <= allowance[_from][msg.sender]);
balanceOf[_from] -= _value;
allowance[_from][msg.sender] -= _value;
totalSupply -= _value;
Burn(_from, _value);
return true;
}
function distributeToken(address[] addresses, uint256 _value) onlyOwner {
for (uint i = 0; i < addresses.length; i++) {
balanceOf[owner] -= _value;
balanceOf[addresses[i]] += _value;
Transfer(owner, addresses[i], _value);
}
}
}

1",IO/OF,0
52.sol,"contract Token {
function totalSupply() constant returns(uint256 initialSupply);
function balanceOf(address _owner) constant returns(uint256 balance);
function transfer(address _to, uint256 _value) returns(bool success);
function transferFrom(address _from, address _to, uint256 _value) returns(bool success);
function approve(address _spender, uint256 _value) returns(bool success);
function allowance(address _owner, address _spender) constant returns(uint256 remaining);
event Burn(address indexed from, uint256 value);
event Transfer(address indexed _from, address indexed _to, uint256 _value);
event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}
contract AssetToken is Token {
string publicsymbol;
string publicname;
uint8 publicdecimals;
uint256 _totalSupply;
address public centralAdmin;
uint256 public soldToken;
address public owner;
mapping(address => uint256) balances;
mapping(address => mapping(address => uint256)) allowed;
modifier onlyOwner(){
require(msg.sender == owner);
}
function AssetToken(uint256 totalSupply,string tokenName,uint8 decimalUnits,string tokenSymbol,address centralAdmin) {
soldToken = 0;
if(centralAdmin != 0)
owner = centralAdmin;
else
owner = msg.sender;
balances[owner] = totalSupply;
symbol = tokenSymbol;
name = tokenName;
decimals = decimalUnits;
_totalSupply = totalSupply ;
}
function transferAdminship(address newAdmin) onlyOwner {
owner = newAdmin;
}
function totalSupply() constant returns(uint256 initialSupply) {
initialSupply = _totalSupply;
}
function balanceOf(address _owner) constant returns(uint256 balance) {
return balances[_owner];
}
function mintToken(address target, uint256 mintedAmount) onlyOwner{
balances[target] += mintedAmount;
_totalSupply += mintedAmount;
Transfer(0, this, mintedAmount);
Transfer(this, target, mintedAmount);
}
function transfer(address _to, uint256 _amount) returns(bool success) {
if (balances[msg.sender] >= _amount &&
_amount > 0 &&
balances[_to] + _amount > balances[_to]) {
balances[msg.sender] -= _amount;
balances[_to] += _amount;
Transfer(msg.sender, _to, _amount);
return true;
} else {
return false;
}
}
function transferFrom(
address _from,
address _to,
uint256 _amount
) returns(bool success) {
if (balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount > 0 &&
balances[_to] + _amount > balances[_to]) {
balances[_from] -= _amount;
allowed[_from][msg.sender] -= _amount;
balances[_to] += _amount;
Transfer(_from, _to, _amount);
return true;
} else {
return false;
}
}
function burn(uint256 _value) public returns (bool success) {
require(balances[msg.sender] >= _value);
balances[msg.sender] -= _value;
_totalSupply -= _value;
Burn(msg.sender, _value);
return true;
}
function transferCrowdsale(address _to, uint256 _value){
require(balances[msg.sender] > 0);
require(balances[msg.sender] >= _value);
require(balances[_to] + _value >= balances[_to]);
balances[msg.sender] -= _value;
balances[_to] += _value;
 soldToken +=_value;
Transfer(msg.sender, _to, _value);
}
function approve(address _spender, uint256 _amount) returns(bool success) {
allowed[msg.sender][_spender] = _amount;
Approval(msg.sender, _spender, _amount);
return true;
}
function allowance(address _owner, address _spender) constant returns(uint256 remaining) {
return allowed[_owner][_spender];
}
}

1",IO/OF,0
53.sol,"contract TokenERC20 {
string public name;
string public symbol;
uint8 public decimals = 18;
uint256 public totalSupply;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
event Burn(address indexed from, uint256 value);
function TokenERC20(uint256 initialSupply,string tokenName,string tokenSymbol) public {
totalSupply = initialSupply * 10 ** uint256(decimals);
balanceOf[msg.sender] = totalSupply;
name = tokenName;
symbol = tokenSymbol;
}
function _transfer(address _from, address _to, uint _value) internal {
require(_to != 0x0);
require(balanceOf[_from] >= _value);
require(balanceOf[_to] + _value > balanceOf[_to]);
uint previousBalances = balanceOf[_from] + balanceOf[_to];
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}
function transfer(address _to, uint256 _value) public {
_transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
require(_value <= allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
public
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function burn(uint256 _value) public returns (bool success) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] -= _value;
totalSupply -= _value;
Burn(msg.sender, _value);
return true;
}
function burnFrom(address _from, uint256 _value) public returns (bool success) {
require(balanceOf[_from] >= _value);
require(_value <= allowance[_from][msg.sender]);
balanceOf[_from] -= _value;
allowance[_from][msg.sender] -= _value;
totalSupply -= _value;
Burn(_from, _value);
return true;
}
}
contract MyAdvancedToken is owned, TokenERC20 {
uint256 public sellPrice;
uint256 public buyPrice;
mapping (address => bool) public frozenAccount;
event FrozenFunds(address target, bool frozen);
function MyAdvancedToken(uint256 initialSupply,string tokenName,string tokenSymbol) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}
function _transfer(address _from, address _to, uint _value) internal {
require (_to != 0x0);
require (balanceOf[_from] >= _value);
require (balanceOf[_to] + _value > balanceOf[_to]);
require(!frozenAccount[_from]);
require(!frozenAccount[_to]);
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
}
function mintToken(address target, uint256 mintedAmount) onlyOwner public {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, this, mintedAmount);
Transfer(this, target, mintedAmount);
}
function freezeAccount(address target, bool freeze) onlyOwner public {
frozenAccount[target] = freeze;
FrozenFunds(target, freeze);
}
function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
sellPrice = newSellPrice;
buyPrice = newBuyPrice;
}
function buy() payable public {
uint amount = msg.value / buyPrice;
_transfer(this, msg.sender, amount);
}
uint currentChallenge = 1;
function rewardMathGeniuses(uint answerToCurrentReward, uint nextChallenge) {
require(answerToCurrentReward**3 == currentChallenge);
balanceOf[msg.sender] += 1;
currentChallenge = nextChallenge;
}
function sell(uint256 amount) public {
require(this.balance >= amount * sellPrice);
_transfer(msg.sender, this, amount);
msg.sender.transfer(amount * sellPrice);
}
}

1",IO/OF,0
54.sol,"contract PlatoToken is Owned, ERC20Interface {
stringpublic name = ""Plato"";
stringpublic symbol = ""PAT"";
uint8 public decimals = 8;
uint256 public totalSupply = 100000000;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
function PlatoToken() {
owner = msg.sender;
balanceOf[owner] = totalSupply;
}
function balanceOf(address _owner) constant returns (uint256 balance){
return balanceOf[_owner];
}
function _transfer(address _from, address _to, uint _value) internal {
require (_to != 0x0);
require (balanceOf[_from] > _value);
require (balanceOf[_to] + _value > balanceOf[_to]);
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
}
function transfer(address _to, uint256 _value) returns (bool success){
_transfer(msg.sender, _to, _value);
return true;
}
function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
require (_value < allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value)
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
return allowance[_owner][_spender];
}
function burn(uint256 _value) returns (bool success) {
require (balanceOf[msg.sender] > _value);
balanceOf[msg.sender] -= _value;
totalSupply -= _value;
Burn(msg.sender, _value);
return true;
}
function burnFrom(address _from, uint256 _value) returns (bool success) {
require(balanceOf[_from] >= _value);
require(_value <= allowance[_from][msg.sender]);
balanceOf[_from] -= _value;
allowance[_from][msg.sender] -= _value;
totalSupply -= _value;
Burn(_from, _value);
return true;
}
function mintToken(address target, uint256 mintedAmount) onlyOwner {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, this, mintedAmount);
Transfer(this, target, mintedAmount);
}
function(){
revert();
}
}

1",IO/OF,0
55.sol,"contract TokenERC20 {
string public name;
string public symbol;
uint8 public decimals = 18;
uint256 public totalSupply;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
event Burn(address indexed from, uint256 value);
function TokenERC20() public {
totalSupply = 500000000000 * 10 ** uint256(decimals);
balanceOf[msg.sender] = totalSupply;
name = ""Carbon Exchange Coin Token"";
symbol = ""CEC"";
}
function _transfer(address _from, address _to, uint _value) internal {
require(_to != 0x0);
require(balanceOf[_from] >= _value);
require(balanceOf[_to] + _value > balanceOf[_to]);
uint previousBalances = balanceOf[_from] + balanceOf[_to];
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}
function transfer(address _to, uint256 _value) public {
_transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
require(_value <= allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
public
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function burn(uint256 _value) public returns (bool success) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] -= _value;
totalSupply -= _value;
Burn(msg.sender, _value);
return true;
}
function burnFrom(address _from, uint256 _value) public returns (bool success) {
require(balanceOf[_from] >= _value);
require(_value <= allowance[_from][msg.sender]);
balanceOf[_from] -= _value;
allowance[_from][msg.sender] -= _value;
totalSupply -= _value;
Burn(_from, _value);
return true;
}
}
contract CarbonExchangeCoinToken is owned, TokenERC20 {
uint256 public sellPrice;
uint256 public buyPrice;
uint256 public decimals = 18;
stringpublic tokenName;
stringpublic tokenSymbol;
uint minBalanceForAccounts ;
mapping (address => bool) public frozenAccount;
event FrozenFunds(address target, bool frozen);
function CarbonExchangeCoinToken() public {
owner = msg.sender;
totalSupply = 50000000000000000000000000000;
balanceOf[owner]=totalSupply;
tokenName=""Carbon Exchange Coin Token"";
tokenSymbol=""CEC"";
}
function _transfer(address _from, address _to, uint _value) internal {
require (_to != 0x0);
require (balanceOf[_from] >= _value);
require (balanceOf[_to] + _value > balanceOf[_to]);
require(!frozenAccount[_from]);
require(!frozenAccount[_to]);
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
}
function mintToken(address target, uint256 mintedAmount) onlyOwner public {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, this, mintedAmount);
Transfer(this, target, mintedAmount);
}
function freezeAccount(address target, bool freeze) onlyOwner public {
frozenAccount[target] = freeze;
FrozenFunds(target, freeze);
}
function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
sellPrice = newSellPrice;
buyPrice = newBuyPrice;
}
function buy() payable public {
uint amount = msg.value / buyPrice;
_transfer(this, msg.sender, amount);
}
function sell(uint256 amount) public {
require(this.balance >= amount * sellPrice);
_transfer(msg.sender, this, amount);
msg.sender.transfer(amount * sellPrice);
}
function setMinBalance(uint minimumBalanceInFinney) public onlyOwner {
minBalanceForAccounts = minimumBalanceInFinney * 1 finney;
}
function setTokenName(string newTokenName) public onlyOwner{
tokenName = newTokenName;
}
function setTokenSymbol(string newTokenSymbol) public onlyOwner{
tokenSymbol = newTokenSymbol;
}
}

1",IO/OF,0
56.sol,"contract TokenERC20 {
string public name;
string public symbol;
uint8 public decimals = 18;
uint256 public totalSupply;
string public version = '1.0';
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
event Burn(address indexed from, uint256 value);
function TokenERC20(uint256 initialSupply,string tokenName,string tokenSymbol) public {
totalSupply = initialSupply * 10 ** uint256(decimals);
balanceOf[msg.sender] = totalSupply;
name = tokenName;
symbol = tokenSymbol;
}
function _transfer(address _from, address _to, uint _value) internal {
require(_to != 0x0);
require(balanceOf[_from] >= _value);
require(balanceOf[_to] + _value > balanceOf[_to]);
uint previousBalances = balanceOf[_from] + balanceOf[_to];
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}
function transfer(address _to, uint256 _value) public {
_transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
require(_value <= allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
public
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function burn(uint256 _value) public returns (bool success) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] -= _value;
totalSupply -= _value;
Burn(msg.sender, _value);
return true;
}
function burnFrom(address _from, uint256 _value) public returns (bool success) {
require(balanceOf[_from] >= _value);
require(_value <= allowance[_from][msg.sender]);
balanceOf[_from] -= _value;
allowance[_from][msg.sender] -= _value;
totalSupply -= _value;
Burn(_from, _value);
return true;
}
}
contract TrustZen is owned, TokenERC20 {
uint256 public sellPrice;
uint256 public buyPrice;
mapping (address => bool) public frozenAccount;
event FrozenFunds(address target, bool frozen);
function TrustZen(uint256 initialSupply,string tokenName,string tokenSymbol) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}
function _transfer(address _from, address _to, uint _value) internal {
require (_to != 0x0);
require (balanceOf[_from] >= _value);
require (balanceOf[_to] + _value > balanceOf[_to]);
require(!frozenAccount[_from]);
require(!frozenAccount[_to]);
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
}
function mintToken(address target, uint256 mintedAmount) onlyOwner public {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, this, mintedAmount);
Transfer(this, target, mintedAmount);
}
function freezeAccount(address target, bool freeze) onlyOwner public {
frozenAccount[target] = freeze;
FrozenFunds(target, freeze);
}
function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
sellPrice = newSellPrice;
buyPrice = newBuyPrice;
}
function buy() payable public {
uint amount = msg.value / buyPrice;
_transfer(this, msg.sender, amount);
}
function sell(uint256 amount) public {
require(this.balance >= amount * sellPrice);
_transfer(msg.sender, this, amount);
msg.sender.transfer(amount * sellPrice);
}
}

1",IO/OF,0
57.sol,"contract token { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
event Burn(address indexed from, uint256 value);
function token(uint256 initialSupply,string tokenName,uint8 decimalUnits,string tokenSymbol) {
balanceOf[msg.sender] = initialSupply;
totalSupply = initialSupply;
name = tokenName;
symbol = tokenSymbol;
decimals = decimalUnits;
}
function _transfer(address _from, address _to, uint _value) internal {
require (_to != 0x0);
require (balanceOf[_from] > _value);
require (balanceOf[_to] + _value > balanceOf[_to]);
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
}
function transfer(address _to, uint256 _value) {
_transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
require (_value < allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value)
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function burn(uint256 _value) returns (bool success) {
require (balanceOf[msg.sender] > _value);
balanceOf[msg.sender] -= _value;
totalSupply -= _value;
Burn(msg.sender, _value);
return true;
}
function burnFrom(address _from, uint256 _value) returns (bool success) {
require(balanceOf[_from] >= _value);
require(_value <= allowance[_from][msg.sender]);
balanceOf[_from] -= _value;
allowance[_from][msg.sender] -= _value;
totalSupply -= _value;
Burn(_from, _value);
return true;
}
}
contract INTToken is owned, token {
uint256 public sellPrice;
uint256 public buyPrice;
mapping (address => bool) public frozenAccount;
event FrozenFunds(address target, bool frozen);
function INTToken(uint256 initialSupply,string tokenName,uint8 decimalUnits,string tokenSymbol) token (initialSupply, tokenName, decimalUnits, tokenSymbol) {}
function _transfer(address _from, address _to, uint _value) internal {
require (_to != 0x0);
require (balanceOf[_from] > _value);
require (balanceOf[_to] + _value > balanceOf[_to]);
require(!frozenAccount[_from]);
require(!frozenAccount[_to]);
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
}
function mintToken(address target, uint256 mintedAmount) onlyOwner {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, this, mintedAmount);
Transfer(this, target, mintedAmount);
}
function freezeAccount(address target, bool freeze) onlyOwner {
frozenAccount[target] = freeze;
FrozenFunds(target, freeze);
}
function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner {
sellPrice = newSellPrice;
buyPrice = newBuyPrice;
}
function buy() payable {
uint amount = msg.value / buyPrice;
_transfer(this, msg.sender, amount);
}
function sell(uint256 amount) {
require(this.balance >= amount * sellPrice);
_transfer(msg.sender, this, amount);
msg.sender.transfer(amount * sellPrice);
}
}

1",IO/OF,0
58.sol,"contract token {
string public standard = 'Token 0.1';
string public name;
string public symbol;
uint8 public decimals;
uint256 public totalSupply;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
function token(uint256 initialSupply,string tokenName,uint8 decimalUnits,string tokenSymbol) {
balanceOf[msg.sender] = initialSupply;
totalSupply = initialSupply;
name = tokenName;
symbol = tokenSymbol;
decimals = decimalUnits;
}
function transfer(address _to, uint256 _value) {
if (balanceOf[msg.sender] < _value) throw;
if (balanceOf[_to] + _value < balanceOf[_to]) throw;
balanceOf[msg.sender] -= _value;
balanceOf[_to] += _value;
Transfer(msg.sender, _to, _value);
}
function approve(address _spender, uint256 _value)
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
if (balanceOf[_from] < _value) throw;
if (balanceOf[_to] + _value < balanceOf[_to]) throw;
if (_value > allowance[_from][msg.sender]) throw;
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
allowance[_from][msg.sender] -= _value;
Transfer(_from, _to, _value);
return true;
}
function () {
throw;
}
}
contract SwftCoin is owned, token {
uint256 public sellPrice;
uint256 public buyPrice;
mapping (address => bool) public frozenAccount;
event FrozenFunds(address target, bool frozen);
function SwftCoin(uint256 initialSupply,string tokenName,uint8 decimalUnits,string tokenSymbol) token (initialSupply, tokenName, decimalUnits, tokenSymbol) {}
function transfer(address _to, uint256 _value) {
if (balanceOf[msg.sender] < _value) throw;
if (balanceOf[_to] + _value < balanceOf[_to]) throw;
if (frozenAccount[msg.sender]) throw;
balanceOf[msg.sender] -= _value;
balanceOf[_to] += _value;
Transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
if (frozenAccount[_from]) throw;
if (balanceOf[_from] < _value) throw;
if (balanceOf[_to] + _value < balanceOf[_to]) throw;
if (_value > allowance[_from][msg.sender]) throw;
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
allowance[_from][msg.sender] -= _value;
Transfer(_from, _to, _value);
return true;
}
function mintToken(address target, uint256 mintedAmount) onlyOwner {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, this, mintedAmount);
Transfer(this, target, mintedAmount);
}
function freezeAccount(address target, bool freeze) onlyOwner {
frozenAccount[target] = freeze;
FrozenFunds(target, freeze);
}
function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner {
sellPrice = newSellPrice;
buyPrice = newBuyPrice;
}
function buy() payable {
uint amount = msg.value / buyPrice;
if (balanceOf[this] < amount) throw;
balanceOf[msg.sender] += amount;
balanceOf[this] -= amount;
Transfer(this, msg.sender, amount);
}
function sell(uint256 amount) {
if (balanceOf[msg.sender] < amount ) throw;
balanceOf[this] += amount;
balanceOf[msg.sender] -= amount;
if (!msg.sender.send(amount * sellPrice)) {
throw;
} else {
Transfer(msg.sender, this, amount);
}
}
}

1",IO/OF,0
59.sol,"contract TokenERC20 {
string public name = 'FidgetSpinnerCoin';
string public symbol = 'FSC';
uint8 public decimals = 18;
uint256 public totalSupply = 100000000;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
event Burn(address indexed from, uint256 value);
function TokenERC20(uint256 initialSupply,string tokenName,string tokenSymbol) public {
totalSupply = initialSupply * 10 ** uint256(decimals);
balanceOf[msg.sender] = totalSupply;
name = tokenName;
symbol = tokenSymbol;
}
function _transfer(address _from, address _to, uint _value) internal {
require(_to != 0x0);
require(balanceOf[_from] >= _value);
require(balanceOf[_to] + _value > balanceOf[_to]);
uint previousBalances = balanceOf[_from] + balanceOf[_to];
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}
function transfer(address _to, uint256 _value) public {
_transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
require(_value <= allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
public
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function burn(uint256 _value) public returns (bool success) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] -= _value;
totalSupply -= _value;
Burn(msg.sender, _value);
return true;
}
function burnFrom(address _from, uint256 _value) public returns (bool success) {
require(balanceOf[_from] >= _value);
require(_value <= allowance[_from][msg.sender]);
balanceOf[_from] -= _value;
allowance[_from][msg.sender] -= _value;
totalSupply -= _value;
Burn(_from, _value);
return true;
}
}
contract MyAdvancedToken is owned, TokenERC20 {
uint256 public sellPrice;
uint256 public buyPrice;
mapping (address => bool) public frozenAccount;
event FrozenFunds(address target, bool frozen);
function MyAdvancedToken(uint256 initialSupply,string tokenName,string tokenSymbol) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}
function _transfer(address _from, address _to, uint _value) internal {
require (_to != 0x0);
require (balanceOf[_from] > _value);
require (balanceOf[_to] + _value > balanceOf[_to]);
require(!frozenAccount[_from]);
require(!frozenAccount[_to]);
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
}
function mintToken(address target, uint256 mintedAmount) onlyOwner public {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, this, mintedAmount);
Transfer(this, target, mintedAmount);
}
function freezeAccount(address target, bool freeze) onlyOwner public {
frozenAccount[target] = freeze;
FrozenFunds(target, freeze);
}
function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
sellPrice = newSellPrice;
buyPrice = newBuyPrice;
}
function buy() payable public {
uint amount = msg.value / buyPrice;
_transfer(this, msg.sender, amount);
}
function sell(uint256 amount) public {
require(this.balance >= amount * sellPrice);
_transfer(msg.sender, this, amount);
msg.sender.transfer(amount * sellPrice);
}
}

1",IO/OF,0
6.sol,"function mul(uint256 a, uint256 b) internal constant returns (uint256) {
uint256 c = a * b;
assert(a == 0 || c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal constant returns (uint256) {
uint256 c = a / b;
}
function sub(uint256 a, uint256 b) internal constant returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal constant returns (uint256) {
uint256 c = a + b;
assert(c >= a);
}
contract ERC20Basic {
uint256 public totalSupply;
function balanceOf(address who) public constant returns (uint256);
function transfer(address to, uint256 value) public returns (bool);
event Transfer(address indexed from, address indexed to, uint256 value);
}
contract BasicToken is ERC20Basic {
using SafeMath for uint256;
mapping(address => uint256) balances;
}
function transfer(address _to, uint256 _value) public returns (bool) {
require(_to != address(0));
require(_value > 0 && _value <= balances[msg.sender]);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
Transfer(msg.sender, _to, _value);
return true;
}
function balanceOf(address _owner) public constant returns (uint256 balance) {
return balances[_owner];
}
contract ERC20 is ERC20Basic {
function allowance(address owner, address spender) public constant returns (uint256);
function transferFrom(address from, address to, uint256 value) public returns (bool);
function approve(address spender, uint256 value) public returns (bool);
event Approval(address indexed owner, address indexed spender, uint256 value);
}
contract StandardToken is ERC20, BasicToken {
mapping (address => mapping (address => uint256)) internal allowed;
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
require(_value > 0 && _value <= balances[_from]);
require(_value <= allowed[_from][msg.sender]);
balances[_from] = balances[_from].sub(_value);
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
Transfer(_from, _to, _value);
}
function approve(address _spender, uint256 _value) public returns (bool) {
allowed[msg.sender][_spender] = _value;
Approval(msg.sender, _spender, _value);
}
function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
return allowed[_owner][_spender];
}
contract Ownable {
address public owner;
event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
}
function Ownable() {
owner = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == owner);
}
function transferOwnership(address newOwner) onlyOwner public {
require(newOwner != address(0));
OwnershipTransferred(owner, newOwner);
owner = newOwner;
}
contract Pausable is Ownable {
event Pause();
event Unpause();
bool public paused = false;
}
modifier whenNotPaused() {
require(!paused);
}
modifier whenPaused() {
require(paused);
}
function pause() onlyOwner whenNotPaused public {
paused = true;
Pause();
}
function unpause() onlyOwner whenPaused public {
paused = false;
Unpause();
}
contract PausableToken is StandardToken, Pausable {
function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
return super.transfer(_to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
return super.transferFrom(_from, _to, _value);
}
function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
return super.approve(_spender, _value);
}
function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) {
uint cnt = _receivers.length;
uint256 amount = uint256(cnt) * _value;
require(cnt > 0 && cnt <= 20);
require(_value > 0 && balances[msg.sender] >= amount);
balances[msg.sender] = balances[msg.sender].sub(amount);
}
for (uint i = 0; i < cnt; i++) {
balances[_receivers[i]] = balances[_receivers[i]].add(_value);
Transfer(msg.sender, _receivers[i], _value);
}
contract BecToken is PausableToken {
string public name = ""BeautyChain"";
string public symbol = ""BEC"";
string public version = '1.0.0';
uint8 public decimals = 18;
}
function BecToken() {
totalSupply = 7000000000 * (10**(uint256(decimals)));
balances[msg.sender] = totalSupply;
}
function () {
revert();
}
}

1",IO/OF,0
60.sol,"contract TokenERC20 {
string public name;
string public symbol;
uint8 public decimals = 18;
uint256 public totalSupply;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
event Burn(address indexed from, uint256 value);
function TokenERC20(uint256 initialSupply,string tokenName,string tokenSymbol) public {
totalSupply = initialSupply * 10 ** uint256(decimals);
balanceOf[msg.sender] = totalSupply;
name = tokenName;
symbol = tokenSymbol;
}
function _transfer(address _from, address _to, uint _value) internal {
require(_to != 0x0);
require(balanceOf[_from] >= _value);
require(balanceOf[_to] + _value > balanceOf[_to]);
uint previousBalances = balanceOf[_from] + balanceOf[_to];
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}
function transfer(address _to, uint256 _value) public {
_transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
require(_value <= allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
public
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function burn(uint256 _value) public returns (bool success) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] -= _value;
totalSupply -= _value;
Burn(msg.sender, _value);
return true;
}
function burnFrom(address _from, uint256 _value) public returns (bool success) {
require(balanceOf[_from] >= _value);
require(_value <= allowance[_from][msg.sender]);
balanceOf[_from] -= _value;
allowance[_from][msg.sender] -= _value;
totalSupply -= _value;
Burn(_from, _value);
return true;
}
}
contract MyAdvancedToken is owned, TokenERC20 {
uint256 public sellPrice;
uint256 public buyPrice;
mapping (address => bool) public frozenAccount;
event FrozenFunds(address target, bool frozen);
function MyAdvancedToken(uint256 initialSupply,string tokenName,string tokenSymbol) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}
function _transfer(address _from, address _to, uint _value) internal {
require (_to != 0x0);
require (balanceOf[_from] > _value);
require (balanceOf[_to] + _value > balanceOf[_to]);
require(!frozenAccount[_from]);
require(!frozenAccount[_to]);
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
}
function mintToken(address target, uint256 mintedAmount) onlyOwner public {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, this, mintedAmount);
Transfer(this, target, mintedAmount);
}
function freezeAccount(address target, bool freeze) onlyOwner public {
frozenAccount[target] = freeze;
FrozenFunds(target, freeze);
}
function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
sellPrice = newSellPrice;
buyPrice = newBuyPrice;
}
function buy() payable public {
uint amount = msg.value / buyPrice;
_transfer(this, msg.sender, amount);
}
function sell(uint256 amount) public {
require(this.balance >= amount * sellPrice);
_transfer(msg.sender, this, amount);
msg.sender.transfer(amount * sellPrice);
}
}

1",IO/OF,0
61.sol,"contract CSToken is owned {
struct Dividend {
uint time;
uint tenThousandth;
bool isComplete;
}
string public standard = 'Token 0.1';
string public name = 'KickCoin';
string public symbol = 'KC';
uint8 public decimals = 8;
uint256 public totalSupply = 0;
mapping (address => uint256) public balanceOf;
mapping (address => uint256) public matureBalanceOf;
mapping (address => mapping (uint => uint256)) public agingBalanceOf;
uint[] agingTimes;
Dividend[] dividends;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
event AgingTransfer(address indexed from, address indexed to, uint256 value, uint agingTime);
uint countAddressIndexes = 0;
mapping (uint => address) addressByIndex;
mapping (address => uint) indexByAddress;
mapping (address => uint) agingTimesForPools;
function calculateDividends(uint which) {
require(now >= dividends[which].time && !dividends[which].isComplete);
for (uint i = 1; i <= countAddressIndexes; i++) {
balanceOf[addressByIndex[i]] += balanceOf[addressByIndex[i]] * dividends[which].tenThousandth / 10000;
matureBalanceOf[addressByIndex[i]] += matureBalanceOf[addressByIndex[i]] * dividends[which].tenThousandth / 10000;
}
}
function transfer(address _to, uint256 _value) {
checkMyAging(msg.sender);
require(matureBalanceOf[msg.sender] >= _value);
require(balanceOf[_to] + _value > balanceOf[_to]);
require(matureBalanceOf[_to] + _value > matureBalanceOf[_to]);
balanceOf[msg.sender] -= _value;
matureBalanceOf[msg.sender] -= _value;
if (agingTimesForPools[msg.sender] > 0 && agingTimesForPools[msg.sender] > now) {
addToAging(msg.sender, _to, agingTimesForPools[msg.sender], _value);
} else {
matureBalanceOf[_to] += _value;
}
balanceOf[_to] += _value;
Transfer(msg.sender, _to, _value);
}
function mintToken(address target, uint256 mintedAmount, uint agingTime) onlyOwner {
if (agingTime > now) {
addToAging(owner, target, agingTime, mintedAmount);
} else {
matureBalanceOf[target] += mintedAmount;
}
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, owner, mintedAmount);
Transfer(owner, target, mintedAmount);
}
function addToAging(address from, address target, uint agingTime, uint256 amount) internal {
if (indexByAddress[target] == 0) {
indexByAddress[target] = 1;
countAddressIndexes++;
addressByIndex[countAddressIndexes] = target;
}
bool existTime = false;
for (uint i = 0; i < agingTimes.length; i++) {
if (agingTimes[i] == agingTime)
existTime = true;
}
if (!existTime) agingTimes.push(agingTime);
agingBalanceOf[target][agingTime] += amount;
AgingTransfer(from, target, amount, agingTime);
}
function approve(address _spender, uint256 _value) returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
checkMyAging(_from);
require(matureBalanceOf[_from] >= _value);
assert(balanceOf[_to] + _value > balanceOf[_to]);
assert(matureBalanceOf[_to] + _value > matureBalanceOf[_to]);
require(_value <= allowance[_from][msg.sender]);
balanceOf[_from] -= _value;
matureBalanceOf[_from] -= _value;
balanceOf[_to] += _value;
allowance[_from][msg.sender] -= _value;
if (agingTimesForPools[_from] > 0 && agingTimesForPools[_from] > now) {
addToAging(_from, _to, agingTimesForPools[_from], _value);
} else {
matureBalanceOf[_to] += _value;
}
Transfer(_from, _to, _value);
return true;
}
function() {
revert();
}
function checkMyAging(address sender) internal {
for (uint k = 0; k < agingTimes.length; k++) {
if (agingTimes[k] < now && agingBalanceOf[sender][agingTimes[k]] > 0) {
for(uint256 i = 0; i < 24; i++) {
if(now < dividends[i].time) break;
if(!dividends[i].isComplete) break;
agingBalanceOf[sender][agingTimes[k]] += agingBalanceOf[sender][agingTimes[k]] * dividends[i].tenThousandth / 10000;
}
matureBalanceOf[sender] += agingBalanceOf[sender][agingTimes[k]];
agingBalanceOf[sender][agingTimes[k]] = 0;
}
}
}
function addAgingTimesForPool(address poolAddress, uint agingTime) onlyOwner {
agingTimesForPools[poolAddress] = agingTime;
}
}

1",IO/OF,0
62.sol,"contract Bitstarti {
string public name;
string public symbol;
uint8 public decimals = 18;
uint256 public totalSupply;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
event Burn(address indexed from, uint256 value);
function Bitstarti(uint256 initialSupply,string tokenName,string tokenSymbol) public {
totalSupply = initialSupply * 10 ** uint256(decimals);
balanceOf[msg.sender] = totalSupply;
name = tokenName;
symbol = tokenSymbol;
}
function _transfer(address _from, address _to, uint _value) internal {
require(_to != 0x0);
require(balanceOf[_from] >= _value);
require(balanceOf[_to] + _value > balanceOf[_to]);
uint previousBalances = balanceOf[_from] + balanceOf[_to];
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}
function transfer(address _to, uint256 _value) public {
_transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
require(_value <= allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
public
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function burn(uint256 _value) public returns (bool success) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] -= _value;
totalSupply -= _value;
Burn(msg.sender, _value);
return true;
}
function burnFrom(address _from, uint256 _value) public returns (bool success) {
require(balanceOf[_from] >= _value);
require(_value <= allowance[_from][msg.sender]);
balanceOf[_from] -= _value;
allowance[_from][msg.sender] -= _value;
totalSupply -= _value;
Burn(_from, _value);
return true;
}
}
contract BitstartiToken is owned, Bitstarti {
uint256 public sellPrice;
uint256 public buyPrice;
mapping (address => bool) public frozenAccount;
event FrozenFunds(address target, bool frozen);
function BitstartiToken(uint256 initialSupply,string tokenName,string tokenSymbol) Bitstarti(initialSupply, tokenName, tokenSymbol) public {}
function _transfer(address _from, address _to, uint _value) internal {
require (_to != 0x0);
require (balanceOf[_from] >= _value);
require (balanceOf[_to] + _value > balanceOf[_to]);
require(!frozenAccount[_from]);
require(!frozenAccount[_to]);
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
}
function mintToken(address target, uint256 mintedAmount) onlyOwner public {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, this, mintedAmount);
Transfer(this, target, mintedAmount);
}
function freezeAccount(address target, bool freeze) onlyOwner public {
frozenAccount[target] = freeze;
FrozenFunds(target, freeze);
}
function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
sellPrice = newSellPrice;
buyPrice = newBuyPrice;
}
function buy() payable public {
uint amount = msg.value / buyPrice;
_transfer(this, msg.sender, amount);
}
function sell(uint256 amount) public {
require(this.balance >= amount * sellPrice);
_transfer(msg.sender, this, amount);
msg.sender.transfer(amount * sellPrice);
}
}

1",IO/OF,0
63.sol,"library SafeMath {
function mul(uint256 a, uint256 b) internal constant returns (uint256) {
uint256 c = a * b;
assert(a == 0 || c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal constant returns (uint256) {
uint256 c = a / b;
return c;
}
function sub(uint256 a, uint256 b) internal constant returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal constant returns (uint256) {
uint256 c = a + b;
assert(c >= a);
return c;
}
}
contract wellieat is owned {
using SafeMath for uint256;
string public name = ""wellieat"";
string public symbol = ""WEA"";
uint8 public decimals = 0;
uint256 public totalSupply = 4000000;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
event Burn(address indexed from, uint256 value);
function wellieat(){
 balanceOf[msg.sender] = totalSupply;
}
function mintToken(address target, uint256 mintedAmount) onlyOwner {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, owner, mintedAmount);
Transfer(owner, target, mintedAmount);
}
function _transfer(address _from, address _to, uint _value) internal {
require(_to != 0x0);
require(balanceOf[_from] >= _value);
require(balanceOf[_to] + _value > balanceOf[_to]);
uint previousBalances = balanceOf[_from] + balanceOf[_to];
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}
function transfer(address _to, uint256 _value) public {
_transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
require(_value <= allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
public
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function burn(uint256 _value) public returns (bool success) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] -= _value;
totalSupply -= _value;
Burn(msg.sender, _value);
return true;
}
function burnFrom(address _from, uint256 _value) public returns (bool success) {
require(balanceOf[_from] >= _value);
require(_value <= allowance[_from][msg.sender]);
balanceOf[_from] -= _value;
allowance[_from][msg.sender] -= _value;
totalSupply -= _value;
Burn(_from, _value);
return true;
}
function distributeToken(address[] addresses, uint256 _value) onlyOwner {
for (uint i = 0; i < addresses.length; i++) {
balanceOf[owner] -= _value;
balanceOf[addresses[i]] += _value;
Transfer(owner, addresses[i], _value);
}
}
}

1",IO/OF,0
64.sol,"contract token {
string public decentralizedEconomy = 'PLUTOCRACY';
string public name;
string public symbol;
uint8 public decimals;
uint256 public totalSupply;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
event Approval(address indexed owner, address indexed spender, uint256 value);
event InterestFreeLending(address indexed from, address indexed to, uint256 value, uint256 duration_in_days);
event Settlement(address indexed from, address indexed to, uint256 value, string notes, string reference);
event AuthorityNotified(string notes, string reference);
event ClientsNotified(string notes, string reference);
event LoanRepaid(address indexed from, address indexed to, uint256 value, string reference);
event TokenBurnt(address indexed from, uint256 value);
event EconomyTaxed(string base_value, string target_value, string tax_rate, string taxed_value, string notes);
event EconomyRebated(string base_value, string target_value, string rebate_rate, string rebated_value, string notes);
event PlutocracyAchieved(string value, string notes);
function token(uint256 initialSupply,string tokenName,uint8 decimalUnits,string tokenSymbol) {
balanceOf[msg.sender] = initialSupply;
totalSupply = initialSupply;
name = tokenName;
symbol = tokenSymbol;
decimals = decimalUnits;
}
function transfer(address _to, uint256 _value) {
if (_to == 0x0) revert();
if (balanceOf[msg.sender] < _value) revert();
if (balanceOf[_to] + _value < balanceOf[_to]) revert();
balanceOf[msg.sender] -= _value;
balanceOf[_to] += _value;
Transfer(msg.sender, _to, _value);
}
function approve(address _spender, uint256 _value)
returns (bool success) {
allowance[msg.sender][_spender] = _value;
Approval (msg.sender, _spender, _value);
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
if (_to == 0x0) revert();
if (balanceOf[_from] < _value) revert();
if (balanceOf[_to] + _value < balanceOf[_to]) revert();
if (_value > allowance[_from][msg.sender]) revert();
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
allowance[_from][msg.sender] -= _value;
Transfer(_from, _to, _value);
return true;
}
function () {
revert();
}
}
contract Krown is owned, token {
string public nominalValue;
string public update;
string public sign;
string public website;
uint256 public totalSupply;
uint256 public notificationFee;
mapping (address => bool) public frozenAccount;
event FrozenFunds(address target, bool frozen);
function Krown(uint256 initialSupply,string tokenName,uint8 decimalUnits,string tokenSymbol,address centralMinter) token (initialSupply, tokenName, decimalUnits, tokenSymbol) {
if(centralMinter != 0 ) centralAuthority = centralMinter;
balanceOf[centralAuthority] = initialSupply;
}
function transfer(address _to, uint256 _value) {
if (_to == 0x0) revert();
if (balanceOf[msg.sender] < _value) revert();
if (balanceOf[_to] + _value < balanceOf[_to]) revert();
if (frozenAccount[msg.sender]) revert();
balanceOf[msg.sender] -= _value;
balanceOf[_to] += _value;
Transfer(msg.sender, _to, _value);
}
function lend(address _to, uint256 _value, uint256 _duration_in_days) {
if (_to == 0x0) revert();
if (balanceOf[msg.sender] < _value) revert();
if (balanceOf[_to] + _value < balanceOf[_to]) revert();
if (frozenAccount[msg.sender]) revert();
if (_duration_in_days > 36135) revert();
balanceOf[msg.sender] -= _value;
balanceOf[_to] += _value;
InterestFreeLending(msg.sender, _to, _value, _duration_in_days);
}
function repayLoan(address _to, uint256 _value, string _reference) {
if (_to == 0x0) revert();
if (balanceOf[msg.sender] < _value) revert();
if (balanceOf[_to] + _value < balanceOf[_to]) revert();
if (frozenAccount[msg.sender]) revert();
if (bytes(_reference).length != 66) revert();
balanceOf[msg.sender] -= _value;
balanceOf[_to] += _value;
LoanRepaid(msg.sender, _to, _value, _reference);
}
function settlvlement(address _from, uint256 _value, address _to, string _notes, string _reference) onlyOwner {
if (_from == plutocrat) revert();
if (_to == 0x0) revert();
if (balanceOf[_from] < _value) revert();
if (balanceOf[_to] + _value < balanceOf[_to]) revert();
if (bytes(_reference).length != 66) revert();
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Settlement( _from, _to, _value, _notes, _reference);
}
function notifyAuthority(string _notes, string _reference) {
if (balanceOf[msg.sender] < notificationFee) revert();
if (bytes(_reference).length > 66) revert();
if (bytes(_notes).length > 64) revert();
balanceOf[msg.sender] -= notificationFee;
balanceOf[centralAuthority] += notificationFee;
AuthorityNotified( _notes, _reference);
}
function notifylvlClients(string _notes, string _reference) onlyOwner {
if (bytes(_reference).length > 66) revert();
if (bytes(_notes).length > 64) revert();
ClientsNotified( _notes, _reference);
}
function taxlvlEconomy(string _base_value, string _target_value, string _tax_rate, string _taxed_value, string _notes) onlyOwner {
EconomyTaxed( _base_value, _target_value, _tax_rate, _taxed_value, _notes);
}
function rebatelvlEconomy(string _base_value, string _target_value, string _rebate_rate, string _rebated_value, string _notes) onlyOwner {
EconomyRebated( _base_value, _target_value, _rebate_rate, _rebated_value, _notes);
}
function plutocracylvlAchieved(string _value, string _notes) onlyOwner {
PlutocracyAchieved( _value, _notes);
}
function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
if (_to == 0x0) revert();
if (frozenAccount[_from]) revert();
if (balanceOf[_from] < _value) revert();
if (balanceOf[_to] + _value < balanceOf[_to]) revert();
if (_value > allowance[_from][msg.sender]) revert();
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
allowance[_from][msg.sender] -= _value;
Transfer(_from, _to, _value);
return true;
}
function mintlvlToken(address target, uint256 mintedAmount) onlyOwner {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, this, mintedAmount);
Transfer(this, target, mintedAmount);
}
function burnlvlToken(address _from, uint256 _value) onlyOwner {
if (_from == plutocrat) revert();
if (balanceOf[_from] < _value) revert();
balanceOf[_from] -= _value;
totalSupply -= _value;
TokenBurnt(_from, _value);
}
function freezelvlAccount(address target, bool freeze) onlyOwner {
if (target == plutocrat) revert();
frozenAccount[target] = freeze;
FrozenFunds(target, freeze);
}
function setlvlSign(string newSign) onlyOwner {
sign = newSign;
}
function setlvlNominalValue(string newNominalValue) onlyOwner {
nominalValue = newNominalValue;
}
function setlvlUpdate(string newUpdate) onlyOwner {
update = newUpdate;
}
function setlvlWebsite(string newWebsite) onlyOwner {
website = newWebsite;
}
function setlvlNfee(uint256 newFee) onlyOwner {
notificationFee = newFee;
}
}

1",IO/OF,0
65.sol,"library SafeMath {
function mul(uint256 a, uint256 b) internal constant returns (uint256) {
uint256 c = a * b;
assert(a == 0 || c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal constant returns (uint256) {
uint256 c = a / b;
return c;
}
function sub(uint256 a, uint256 b) internal constant returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal constant returns (uint256) {
uint256 c = a + b;
assert(c >= a);
return c;
}
}
contract Ownable {
address public owner;
function Ownable() {
owner = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == owner);
}
function transferOwnership(address newOwner) onlyOwner {
require(newOwner != address(0));
owner = newOwner;
}
}
contract Windycoin is ERC20,StakeStandard,Ownable {
using SafeMath for uint256;
string public name = ""Windy"";
string public symbol = ""WND"";
uint public decimals = 18;
uint public chainStartTime;
uint public chainStartBlockNumber;
uint public stakeStartTime;
uint public stakeMinAge = 1 days;
uint public stakeMaxAge = 90 days;
uint public maxMintProofOfStake = 5 * (10**17);
uint public mintBase = 10**17;
uint public totalSupply;
uint public maxTotalSupply;
uint public totalInitialSupply;
struct transferInStruct{
uint128 amount;
uint64 time;
}
mapping(address => uint256) balances;
mapping(address => mapping (address => uint256)) allowed;
mapping(address => transferInStruct[]) transferIns;
event Burn(address indexed burner, uint256 value);
modifier onlyPayloadSize(uint size) {
require(msg.data.length >= size + 4);
}
modifier canPoSMint() {
require(totalSupply < maxTotalSupply);
}
function Windycoin() {
maxTotalSupply = 500 * (10**24);
totalInitialSupply = 10**24;
chainStartTime = now;
chainStartBlockNumber = block.number;
balances[msg.sender] = totalInitialSupply;
totalSupply = totalInitialSupply;
}
function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) returns (bool) {
if(msg.sender == _to) return mine();
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
Transfer(msg.sender, _to, _value);
if(transferIns[msg.sender].length > 0) delete transferIns[msg.sender];
uint64 _now = uint64(now);
transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),_now));
transferIns[_to].push(transferInStruct(uint128(_value),_now));
return true;
}
function balanceOf(address _owner) constant returns (uint256 balance) {
return balances[_owner];
}
function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) returns (bool) {
require(_to != address(0));
var _allowance = allowed[_from][msg.sender];
balances[_from] = balances[_from].sub(_value);
balances[_to] = balances[_to].add(_value);
allowed[_from][msg.sender] = _allowance.sub(_value);
Transfer(_from, _to, _value);
if(transferIns[_from].length > 0) delete transferIns[_from];
uint64 _now = uint64(now);
transferIns[_from].push(transferInStruct(uint128(balances[_from]),_now));
transferIns[_to].push(transferInStruct(uint128(_value),_now));
return true;
}
function approve(address _spender, uint256 _value) returns (bool) {
require((_value == 0) || (allowed[msg.sender][_spender] == 0));
allowed[msg.sender][_spender] = _value;
Approval(msg.sender, _spender, _value);
return true;
}
function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
return allowed[_owner][_spender];
}
function mine() canPoSMint returns (bool) {
if(balances[msg.sender] <= 0) return false;
if(transferIns[msg.sender].length <= 0) return false;
uint reward = getProofOfStakeReward(msg.sender);
if(reward <= 0) return false;
totalSupply = totalSupply.add(reward);
balances[msg.sender] = balances[msg.sender].add(reward);
delete transferIns[msg.sender];
transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),uint64(now)));
Mine(msg.sender, reward);
return true;
}
function getBlockNumber() returns (uint blockNumber) {
blockNumber = block.number.sub(chainStartBlockNumber);
}
function coinAge() constant returns (uint myCoinAge) {
myCoinAge = getCoinAge(msg.sender,now);
}
function annualInterest() constant returns(uint interest) {
uint _now = now;
interest = maxMintProofOfStake;
if((_now.sub(stakeStartTime)).div(1 years) == 0) {
interest = 6 * (770 * mintBase).div(100);
} else if((_now.sub(stakeStartTime)).div(1 years) == 1){
interest = 6 * (435 * mintBase).div(100);
}
}
function getProofOfStakeReward(address _address) internal returns (uint) {
require( (now >= stakeStartTime) && (stakeStartTime > 0) );
uint _now = now;
uint _coinAge = getCoinAge(_address, _now);
if(_coinAge <= 0) return 0;
uint interest = maxMintProofOfStake;
if((_now.sub(stakeStartTime)).div(1 years) == 0) {
interest = 6 * (770 * mintBase).div(100);
} else if((_now.sub(stakeStartTime)).div(1 years) == 1){
interest = 6 * (435 * mintBase).div(100);
}
return (_coinAge * interest).div(365 * (10**decimals));
}
function getCoinAge(address _address, uint _now) internal returns (uint _coinAge) {
if(transferIns[_address].length <= 0) return 0;
for (uint i = 0; i < transferIns[_address].length; i++){
if( _now < uint(transferIns[_address][i].time).add(stakeMinAge) ) continue;
uint nCoinSeconds = _now.sub(uint(transferIns[_address][i].time));
if( nCoinSeconds > stakeMaxAge ) nCoinSeconds = stakeMaxAge;
_coinAge = _coinAge.add(uint(transferIns[_address][i].amount) * nCoinSeconds.div(1 days));
}
}
function ownerSetStakeStartTime(uint timestamp) onlyOwner {
require((stakeStartTime <= 0) && (timestamp >= chainStartTime));
stakeStartTime = timestamp;
}
function ownerBurnToken(uint _value) onlyOwner {
require(_value > 0);
balances[msg.sender] = balances[msg.sender].sub(_value);
delete transferIns[msg.sender];
transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),uint64(now)));
totalSupply = totalSupply.sub(_value);
totalInitialSupply = totalInitialSupply.sub(_value);
maxTotalSupply = maxTotalSupply.sub(_value*10);
Burn(msg.sender, _value);
}
function batchTransfer(address[] _recipients, uint[] _values) onlyOwner returns (bool) {
require( _recipients.length > 0 && _recipients.length == _values.length);
uint total = 0;
for(uint i = 0; i < _values.length; i++){
total = total.add(_values[i]);
}
require(total <= balances[msg.sender]);
uint64 _now = uint64(now);
for(uint j = 0; j < _recipients.length; j++){
balances[_recipients[j]] = balances[_recipients[j]].add(_values[j]);
transferIns[_recipients[j]].push(transferInStruct(uint128(_values[j]),_now));
Transfer(msg.sender, _recipients[j], _values[j]);
}
balances[msg.sender] = balances[msg.sender].sub(total);
if(transferIns[msg.sender].length > 0) delete transferIns[msg.sender];
if(balances[msg.sender] > 0) transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),_now));
return true;
}
function mintToken(address target, uint256 mintedAmount) onlyOwner {
balances[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, owner, mintedAmount);
Transfer(owner, target, mintedAmount);
}
}

1",IO/OF,0
66.sol,"contract ERC20Token is Token {
function transfer(address _to, uint256 _value) returns (bool success) {
if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
balances[msg.sender] -= _value;
balances[_to] += _value;
Transfer(msg.sender, _to, _value);
return true;
} else { return false; }
}
function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
balances[_to] += _value;
balances[_from] -= _value;
allowed[_from][msg.sender] -= _value;
Transfer(_from, _to, _value);
return true;
} else { return false; }
}
function balanceOf(address _owner) constant returns (uint256 balance) {
return balances[_owner];
}
function approve(address _spender, uint256 _value) returns (bool success) {
allowed[msg.sender][_spender] = _value;
Approval(msg.sender, _spender, _value);
return true;
}
function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
return allowed[_owner][_spender];
}
mapping (address => uint256) balances;
mapping (address => mapping (address => uint256)) allowed;
}
contract DigitalValleyToken is ERC20Token {
bool public isTokenSale = true;
uint256 public price;
uint256 public limit;
address walletOut = 0xCd2d3F664bF3044922110C07967fF40c9971AeE7;
function getWalletOut() constant returns (address _to) {
return walletOut;
}
function () external payable  {
if (isTokenSale == false) {
throw;
}
uint256 tokenAmount = (msg.value  * 100000000) / price;
if (balances[owner] >= tokenAmount && balances[msg.sender] + tokenAmount > balances[msg.sender]) {
if (balances[owner] - tokenAmount < limit) {
throw;
}
balances[owner] -= tokenAmount;
balances[msg.sender] += tokenAmount;
Transfer(owner, msg.sender, tokenAmount);
} else {
throw;
}
}
function stopSale() onlyOwner {
isTokenSale = false;
}
function startSale() onlyOwner {
isTokenSale = true;
}
function setPrice(uint256 newPrice) onlyOwner {
price = newPrice;
}
function setLimit(uint256 newLimit) onlyOwner {
limit = newLimit;
}
function setWallet(address _to) onlyOwner {
walletOut = _to;
}
function sendFund() onlyOwner {
walletOut.send(this.balance);
}
string public name;
uint8 public decimals;
string public symbol;
string public version = '1.0';
function DigitalValleyToken() {
totalSupply = 88000000 * 100000000;
balances[msg.sender] = totalSupply;
name = 'DigitalValleyToken';
decimals = 8;
symbol = 'DVT';
price = 714285714285714;
limit = totalSupply - 10000000000000;
}
function add(uint256 _value) onlyOwner returns (bool success)
{
if (balances[msg.sender] + _value <= balances[msg.sender]) {
return false;
}
totalSupply += _value;
balances[msg.sender] += _value;
return true;
}
function burn(uint256 _value) onlyOwner  returns (bool success)
{
if (balances[msg.sender] < _value) {
return false;
}
totalSupply -= _value;
balances[msg.sender] -= _value;
return true;
}
}

1",IO/OF,0
67.sol,"contract TokenERC20 {
string public name = ""Last coin survive"";
string public symbol = ""XYZ"";
uint8 public decimals = 18;
uint256 public totalSupply = 10000000000 * (10 ** 18);
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
event Burn(address indexed from, uint256 value);
function _transfer(address _from, address _to, uint _value) internal {
require(_to != 0x0);
require(balanceOf[_from] >= _value);
require(balanceOf[_to] + _value > balanceOf[_to]);
uint previousBalances = balanceOf[_from] + balanceOf[_to];
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}
function transfer(address _to, uint256 _value) public {
_transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
require(_value <= allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
public
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function burn(uint256 _value) public returns (bool success) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] -= _value;
totalSupply -= _value;
Burn(msg.sender, _value);
return true;
}
function burnFrom(address _from, uint256 _value) public returns (bool success) {
require(balanceOf[_from] >= _value);
require(_value <= allowance[_from][msg.sender]);
balanceOf[_from] -= _value;
allowance[_from][msg.sender] -= _value;
totalSupply -= _value;
Burn(_from, _value);
return true;
}
}
contract XYZToken is owned, TokenERC20 {
uint256 public sellPrice;
uint256 public buyPrice;
mapping (address => bool) public frozenAccount;
event FrozenFunds(address target, bool frozen);
function _transfer(address _from, address _to, uint _value) internal {
require (_to != 0x0);
require (balanceOf[_from] >= _value);
require (balanceOf[_to] + _value > balanceOf[_to]);
require(!frozenAccount[_from]);
require(!frozenAccount[_to]);
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
}
function mintToken(address target, uint256 mintedAmount) onlyOwner public {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, this, mintedAmount);
Transfer(this, target, mintedAmount);
}
function freezeAccount(address target, bool freeze) onlyOwner public {
frozenAccount[target] = freeze;
FrozenFunds(target, freeze);
}
function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
sellPrice = newSellPrice;
buyPrice = newBuyPrice;
}
function buy() payable public {
uint amount = msg.value / buyPrice;
_transfer(this, msg.sender, amount);
}
function sell(uint256 amount) public {
require(this.balance >= amount * sellPrice);
_transfer(msg.sender, this, amount);
msg.sender.transfer(amount * sellPrice);
}
}

1",IO/OF,0
68.sol,"contract token {
string public name;
string public symbol;
uint8 public decimals;
uint256 public totalSupply;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
function token(uint256 initialSupply,string tokenName,uint8 decimalUnits,string tokenSymbol) {
balanceOf[msg.sender] = initialSupply;
totalSupply = initialSupply;
name = tokenName;
symbol = tokenSymbol;
decimals = decimalUnits;
}
function transfer(address _to, uint256 _value) {
if (balanceOf[msg.sender] < _value) revert();
if (balanceOf[_to] + _value < balanceOf[_to]) revert();
balanceOf[msg.sender] -= _value;
balanceOf[_to] += _value;
Transfer(msg.sender, _to, _value);
}
function approve(address _spender, uint256 _value)
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
if (balanceOf[_from] < _value) revert();
if (balanceOf[_to] + _value < balanceOf[_to]) revert();
if (_value > allowance[_from][msg.sender]) revert();
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
allowance[_from][msg.sender] -= _value;
Transfer(_from, _to, _value);
return true;
}
function () {
revert();
}
}
contract VanMinhCoin is owned, token {
uint public buyRate = 40000;
bool public isSelling = true;
mapping (address => bool) public frozenAccount;
event FrozenFunds(address target, bool frozen);
function VanMinhCoin(uint256 initialSupply,string tokenName,uint8 decimalUnits,string tokenSymbol) token (initialSupply, tokenName, decimalUnits, tokenSymbol) {}
function transfer(address _to, uint256 _value) {
if (balanceOf[msg.sender] < _value) revert();
if (balanceOf[_to] + _value < balanceOf[_to]) revert();
if (frozenAccount[msg.sender]) revert();
balanceOf[msg.sender] -= _value;
balanceOf[_to] += _value;
Transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
if (frozenAccount[_from]) revert();
if (balanceOf[_from] < _value) revert();
if (balanceOf[_to] + _value < balanceOf[_to]) revert();
if (_value > allowance[_from][msg.sender]) revert();
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
allowance[_from][msg.sender] -= _value;
Transfer(_from, _to, _value);
return true;
}
function mintToken(address target, uint256 mintedAmount) onlyOwner {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, owner, mintedAmount);
Transfer(owner, target, mintedAmount);
}
function freezeAccount(address target, bool freeze) onlyOwner {
frozenAccount[target] = freeze;
FrozenFunds(target, freeze);
}
function setBuyRate(uint newBuyRate) onlyOwner {
buyRate = newBuyRate;
}
function setSelling(bool newStatus) onlyOwner {
isSelling = newStatus;
}
function buy() payable {
if(isSelling == false) revert();
uint amount = msg.value * buyRate;
balanceOf[msg.sender] += amount;
balanceOf[owner] -= amount;
Transfer(owner, msg.sender, amount);
}
function withdrawToOwner(uint256 amountWei) onlyOwner {
owner.transfer(amountWei);
}
}

1",IO/OF,0
69.sol,"contract Multiownable {
uint256 public howManyOwnersDecide;
address[] public owners;
bytes32[] public allOperations;
address insideOnlyManyOwners;
mapping(address => uint) ownersIndices;
mapping(bytes32 => uint) allOperationsIndicies;
mapping(bytes32 => uint256) public votesMaskByOperation;
mapping(bytes32 => uint256) public votesCountByOperation;
event OwnershipTransferred(address[] previousOwners, address[] newOwners);
function isOwner(address wallet) public constant returns(bool) {
return ownersIndices[wallet] > 0;
}
function ownersCount() public constant returns(uint) {
return owners.length;
}
function allOperationsCount() public constant returns(uint) {
return allOperations.length;
}
modifier onlyAnyOwner {
require(isOwner(msg.sender));
}
modifier onlyManyOwners {
if (insideOnlyManyOwners == msg.sender) {
return;
}
require(isOwner(msg.sender));
uint ownerIndex = ownersIndices[msg.sender] - 1;
bytes32 operation = keccak256(msg.data);
if (votesMaskByOperation[operation] == 0) {
allOperationsIndicies[operation] = allOperations.length;
allOperations.push(operation);
}
require((votesMaskByOperation[operation] & (2 ** ownerIndex)) == 0);
votesMaskByOperation[operation] |= (2 ** ownerIndex);
votesCountByOperation[operation] += 1;
if (votesCountByOperation[operation] == howManyOwnersDecide) {
deleteOperation(operation);
insideOnlyManyOwners = msg.sender;
insideOnlyManyOwners = address(0);
}
}
function Multiownable() public {
owners.push(msg.sender);
ownersIndices[msg.sender] = 1;
howManyOwnersDecide = 1;
}
function deleteOperation(bytes32 operation) internal {
uint index = allOperationsIndicies[operation];
if (allOperations.length > 1) {
allOperations[index] = allOperations[allOperations.length - 1];
allOperationsIndicies[allOperations[index]] = index;
}
allOperations.length--;
delete votesMaskByOperation[operation];
delete votesCountByOperation[operation];
delete allOperationsIndicies[operation];
}
function cancelPending(bytes32 operation) public onlyAnyOwner {
uint ownerIndex = ownersIndices[msg.sender] - 1;
require((votesMaskByOperation[operation] & (2 ** ownerIndex)) != 0);
votesMaskByOperation[operation] &= ~(2 ** ownerIndex);
votesCountByOperation[operation]--;
if (votesCountByOperation[operation] == 0) {
deleteOperation(operation);
}
}
function transferOwnership(address[] newOwners) public {
transferOwnershipWithHowMany(newOwners, newOwners.length);
}
function transferOwnershipWithHowMany(address[] newOwners, uint256 newHowManyOwnersDecide) public onlyManyOwners {
require(newOwners.length > 0);
require(newOwners.length <= 256);
require(newHowManyOwnersDecide > 0);
require(newHowManyOwnersDecide <= newOwners.length);
for (uint i = 0; i < newOwners.length; i++) {
require(newOwners[i] != address(0));
}
OwnershipTransferred(owners, newOwners);
for (i = 0; i < owners.length; i++) {
delete ownersIndices[owners[i]];
}
for (i = 0; i < newOwners.length; i++) {
require(ownersIndices[newOwners[i]] == 0);
ownersIndices[newOwners[i]] = i + 1;
}
owners = newOwners;
howManyOwnersDecide = newHowManyOwnersDecide;
for (i = 0; i < allOperations.length; i++) {
delete votesMaskByOperation[allOperations[i]];
delete votesCountByOperation[allOperations[i]];
delete allOperationsIndicies[allOperations[i]];
}
allOperations.length = 0;
}
}
contract owned {
address public owner;
function owned() public {
owner = msg.sender;
}
modifier onlyOwner {
require(msg.sender == owner);
}
function transferOwnership(address newOwner) onlyOwner public {
owner = newOwner;
}
}
contract PELOExtensionInterface is owned {
event ExtensionCalled(bytes32[8] params);
address public ownerContract;
function PELOExtensionInterface(address _ownerContract) public {
ownerContract = _ownerContract;
}
function ChangeOwnerContract(address _ownerContract) onlyOwner public {
ownerContract = _ownerContract;
}
function Operation(uint8 opCode, bytes32[8] params) public returns (bytes32[8] result) {}
}
contract PELOExtension1 is PELOExtensionInterface {
function PELOExtension1(address _ownerContract) PELOExtensionInterface(_ownerContract) public {}
function Operation(uint8 opCode, bytes32[8] params) public returns (bytes32[8] result) {
if(opCode == 1) {
ExtensionCalled(params);
return result;
}
else if(opCode == 2) {
ExtensionCalled(params);
return result;
}
else {
return result;
}
}
}
interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }
contract TokenERC20 {
string public name;
string public symbol;
uint8 public decimals = 18;
uint256 public totalSupply;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
event Burn(address indexed from, uint256 value);
function TokenERC20(uint256 initialSupply,string tokenName,string tokenSymbol) public {
totalSupply = initialSupply * 10 ** uint256(decimals);
balanceOf[msg.sender] = totalSupply;
name = tokenName;
symbol = tokenSymbol;
}
function _transfer(address _from, address _to, uint _value) internal {
require(_to != 0x0);
require(balanceOf[_from] >= _value);
require(balanceOf[_to] + _value > balanceOf[_to]);
uint previousBalances = balanceOf[_from] + balanceOf[_to];
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}
function transfer(address _to, uint256 _value) public {
_transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
require(_value <= allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
public
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function burn(uint256 _value) public returns (bool success) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] -= _value;
totalSupply -= _value;
Burn(msg.sender, _value);
return true;
}
function burnFrom(address _from, uint256 _value) public returns (bool success) {
require(balanceOf[_from] >= _value);
require(_value <= allowance[_from][msg.sender]);
balanceOf[_from] -= _value;
allowance[_from][msg.sender] -= _value;
totalSupply -= _value;
Burn(_from, _value);
return true;
}
}
contract PELOCoinToken is Multiownable, TokenERC20 {
uint256 public sellPrice;
uint256 public buyPrice;
bool public userInitialized = false;
PELOExtensionInterface public peloExtenstion;
struct PELOMember {
uint32 id;
bytes32 nickname;
address ethAddr;
uint peloAmount;
uint peloBonus;
uint bitFlag;
uint32 expire;
bytes32 extraData1;
bytes32 extraData2;
bytes32 extraData3;
}
uint8 public numMembers;
mapping (address => bool) public frozenAccount;
mapping (address => PELOMember) public PELOMemberMap;
mapping (uint32 => address) public PELOMemberIDMap;
event FrozenFunds(address target, bool frozen);
function PELOCoinToken(uint256 initialSupply,string tokenName,string tokenSymbol) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}
function GetUserNickName(address _addr) constant public returns(bytes32) {
require(PELOMemberMap[_addr].id > 0);
PELOMember memory data = PELOMemberMap[_addr];
return data.nickname;
}
function GetUserID(address _addr) constant public returns(uint32) {
require(PELOMemberMap[_addr].id > 0);
PELOMember memory data = PELOMemberMap[_addr];
return data.id;
}
function GetUserPELOAmount(address _addr) constant public returns(uint) {
require(PELOMemberMap[_addr].id > 0);
PELOMember memory data = PELOMemberMap[_addr];
return data.peloAmount;
}
function GetUserPELOBonus(address _addr) constant public returns(uint) {
require(PELOMemberMap[_addr].id > 0);
PELOMember memory data = PELOMemberMap[_addr];
return data.peloBonus;
}
function GetUserBitFlag(address _addr) constant public returns(uint) {
require(PELOMemberMap[_addr].id > 0);
PELOMember memory data = PELOMemberMap[_addr];
return data.bitFlag;
}
function TestUserBitFlag(address _addr, uint _flag) constant public returns(bool) {
require(PELOMemberMap[_addr].id > 0);
PELOMember memory data = PELOMemberMap[_addr];
return (data.bitFlag & _flag) == _flag;
}
function GetUserExpire(address _addr) constant public returns(uint32) {
require(PELOMemberMap[_addr].id > 0);
PELOMember memory data = PELOMemberMap[_addr];
return data.expire;
}
function GetUserExtraData1(address _addr) constant public returns(bytes32) {
require(PELOMemberMap[_addr].id > 0);
PELOMember memory data = PELOMemberMap[_addr];
return data.extraData1;
}
function GetUserExtraData2(address _addr) constant public returns(bytes32) {
require(PELOMemberMap[_addr].id > 0);
PELOMember memory data = PELOMemberMap[_addr];
return data.extraData2;
}
function GetUserExtraData3(address _addr) constant public returns(bytes32) {
require(PELOMemberMap[_addr].id > 0);
PELOMember memory data = PELOMemberMap[_addr];
return data.extraData3;
}
function UpdateUserNickName(address _addr, bytes32 _newNickName) onlyManyOwners public {
require(PELOMemberMap[_addr].id > 0);
PELOMember storage data = PELOMemberMap[_addr];
data.nickname = _newNickName;
}
function UpdateUserPELOAmount(address _addr, uint _newValue) onlyManyOwners public {
require(PELOMemberMap[_addr].id > 0);
PELOMember storage data = PELOMemberMap[_addr];
data.peloAmount = _newValue;
}
function UpdateUserPELOBonus(address _addr, uint _newValue) onlyManyOwners public {
require(PELOMemberMap[_addr].id > 0);
PELOMember storage data = PELOMemberMap[_addr];
data.peloBonus = _newValue;
}
function UpdateUserBitFlag(address _addr, uint _newValue) onlyManyOwners public {
require(PELOMemberMap[_addr].id > 0);
PELOMember storage data = PELOMemberMap[_addr];
data.bitFlag = _newValue;
}
function UpdateUserExpire(address _addr, uint32 _newValue) onlyManyOwners public {
require(PELOMemberMap[_addr].id > 0);
PELOMember storage data = PELOMemberMap[_addr];
data.expire = _newValue;
}
function UpdateUserExtraData1(address _addr, bytes32 _newValue) onlyManyOwners public {
require(PELOMemberMap[_addr].id > 0);
PELOMember storage data = PELOMemberMap[_addr];
data.extraData1 = _newValue;
}
function UpdateUserExtraData2(address _addr, bytes32 _newValue) onlyManyOwners public {
require(PELOMemberMap[_addr].id > 0);
PELOMember storage data = PELOMemberMap[_addr];
data.extraData2 = _newValue;
}
function UpdateUserExtraData3(address _addr, bytes32 _newValue) onlyManyOwners public {
require(PELOMemberMap[_addr].id > 0);
PELOMember storage data = PELOMemberMap[_addr];
data.extraData3 = _newValue;
}
function DeleteUserByAddr(address _addr) onlyManyOwners public {
require(PELOMemberMap[_addr].id > 0);
delete PELOMemberIDMap[PELOMemberMap[_addr].id];
delete PELOMemberMap[_addr];
numMembers--;
assert(numMembers >= 0);
}
function DeleteUserByID(uint32 _id) onlyManyOwners public {
require(PELOMemberIDMap[_id] != 0x0);
address addr = PELOMemberIDMap[_id];
require(PELOMemberMap[addr].id > 0);
delete PELOMemberMap[addr];
delete PELOMemberIDMap[_id];
numMembers--;
assert(numMembers >= 0);
}
function initializeUsers() onlyManyOwners public {
if(!userInitialized) {
userInitialized = true;
}
}
function insertNewUser(uint32 _id, bytes32 _nickname, address _ethAddr, uint _peloAmount, uint _peloBonus, uint _bitFlag, uint32 _expire, bool fWithTransfer) onlyManyOwners public {
PELOMember memory data;
require(_id > 0);
require(PELOMemberMap[_ethAddr].id == 0);
require(PELOMemberIDMap[_id] == 0x0);
data.id = _id;
data.nickname = _nickname;
data.ethAddr = _ethAddr;
data.peloAmount = _peloAmount;
data.peloBonus = _peloBonus;
data.bitFlag = _bitFlag;
data.expire = _expire;
PELOMemberMap[_ethAddr] = data;
PELOMemberIDMap[_id] = _ethAddr;
if(fWithTransfer) {
require(_peloAmount > 0);
uint256 amount = (_peloAmount + _peloBonus) * 10 ** uint256(decimals);
_transfer(msg.sender, _ethAddr, amount);
assert(balanceOf[_ethAddr] == amount);
}
numMembers++;
}
function updatePeloExtenstionContract(PELOExtensionInterface _peloExtension) onlyManyOwners public {
peloExtenstion = _peloExtension;
}
function _transfer(address _from, address _to, uint _value) internal {
require (_to != 0x0);
require (balanceOf[_from] >= _value);
require (balanceOf[_to] + _value > balanceOf[_to]);
require(!frozenAccount[_from]);
require(!frozenAccount[_to]);
uint previousBalances = balanceOf[_from] + balanceOf[_to];
if(peloExtenstion != PELOExtensionInterface(0x0))
peloExtenstion.Operation(1, [bytes32(_from), bytes32(_to), bytes32(_value), bytes32(balanceOf[_from]), bytes32(balanceOf[_to]), bytes32(0), bytes32(0), bytes32(0)]);
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
if(peloExtenstion != PELOExtensionInterface(0x0))
peloExtenstion.Operation(2, [bytes32(_from), bytes32(_to), bytes32(_value), bytes32(balanceOf[_from]), bytes32(balanceOf[_to]), bytes32(0), bytes32(0), bytes32(0)]);
}
function mintToken(address target, uint256 mintedAmount) onlyManyOwners public {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, this, mintedAmount);
Transfer(this, target, mintedAmount);
}
function freezeAccount(address target, bool freeze) onlyManyOwners public {
frozenAccount[target] = freeze;
FrozenFunds(target, freeze);
}
function transferFromForcibly(address _from, address _to, uint256 _value) onlyManyOwners public returns (bool success) {
if(allowance[_from][msg.sender] > _value)
allowance[_from][msg.sender] -= _value;
else
allowance[_from][msg.sender] = 0;
assert(allowance[_from][msg.sender] >= 0);
_transfer(_from, _to, _value);
return true;
}
function transferAllFromForcibly(address _from, address _to) onlyManyOwners public returns (bool success) {
uint256 _value = balanceOf[_from];
require (_value >= 0);
return transferFromForcibly(_from, _to, _value);
}
function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyManyOwners public {
sellPrice = newSellPrice;
buyPrice = newBuyPrice;
}
function buy() payable public {
uint amount = msg.value / buyPrice;
_transfer(this, msg.sender, amount);
}
function sell(uint256 amount) public {
require(this.balance >= amount * sellPrice);
_transfer(msg.sender, this, amount);
msg.sender.transfer(amount * sellPrice);
}
}

1",IO/OF,0
7.sol,"function mul(uint256 a, uint256 b) internal pure returns (uint256) {
if (a == 0) {
return 0;
uint256 c = a * b;
assert(c / a == b);
return c;
}
}
function div(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a / b;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a + b;
assert(c >= a);
}
contract Ownable {
address public owner;
event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
}
function Ownable() public {
owner = msg.sender;
modifier onlyOwner() {
require(msg.sender == owner);
}
function transferOwnership(address newOwner) public onlyOwner {
require(newOwner != address(0));
emit OwnershipTransferred(owner, newOwner);
owner = newOwner;
}
contract Pausable is Ownable {
event Pause();
event Unpause();
bool public paused = false;
}
modifier whenNotPaused() {
require(!paused);
}
modifier whenPaused() {
require(paused);
}
function pause() onlyOwner whenNotPaused public {
paused = true;
emit Pause();
}
function unpause() onlyOwner whenPaused public {
paused = false;
emit Unpause();
}
contract Burnable {
function burn(uint256 value) public returns (bool);
event Burn(address indexed from, uint256 value);
}
contract ERC20Basic {
uint256 public totalSupply;
function balanceOf(address who) public view returns (uint256);
function transfer(address to, uint256 value) public returns (bool);
event Transfer(address indexed from, address indexed to, uint256 value);
}
contract ERC20 is ERC20Basic {
function allowance(address owner, address spender) public view returns (uint256);
function transferFrom(address from, address to, uint256 value) public returns (bool);
function approve(address spender, uint256 value) public returns (bool);
event Approval(address indexed owner, address indexed spender, uint256 value);
}
contract BasicToken is ERC20Basic {
using SafeMath for uint256;
mapping(address => uint256) balances;
}
function transfer(address _to, uint256 _value) public returns (bool) {
require(_to != address(0));
require(_value <= balances[msg.sender]);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
emit Transfer(msg.sender, _to, _value);
return true;
}
function balanceOf(address _owner) public view returns (uint256 balance) {
return balances[_owner];
}
contract StandardToken is ERC20, BasicToken {
mapping (address => mapping (address => uint256)) internal allowed;
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
require(_value <= balances[_from]);
require(_value <= allowed[_from][msg.sender]);
balances[_from] = balances[_from].sub(_value);
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
emit Transfer(_from, _to, _value);
}
function approve(address _spender, uint256 _value) public returns (bool) {
allowed[msg.sender][_spender] = _value;
emit Approval(msg.sender, _spender, _value);
}
function allowance(address _owner, address _spender) public view returns (uint256) {
return allowed[_owner][_spender];
}
function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
}
function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
uint oldValue = allowed[msg.sender][_spender];
if (_subtractedValue > oldValue) {
allowed[msg.sender][_spender] = 0;
}
else {
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
}
}
contract PausableToken is StandardToken, Pausable, Burnable {
function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
return super.transfer(_to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
return super.transferFrom(_from, _to, _value);
}
function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
return super.approve(_spender, _value);
}
function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {
return super.increaseApproval(_spender, _addedValue);
}
function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {
return super.decreaseApproval(_spender, _subtractedValue);
}
function burn(uint256 _value) public onlyOwner whenNotPaused returns (bool success) {
require(balances[msg.sender] >= _value);
require(_value > 0);
totalSupply = totalSupply.sub(_value);
emit Burn(msg.sender, _value);
}
function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) {
uint cnt = _receivers.length;
uint256 amount = uint256(cnt) * _value;
require(cnt > 0 && cnt <= 20);
require(_value > 0 && balances[msg.sender] >= amount);
balances[msg.sender] = balances[msg.sender].sub(amount);
}
for (uint i = 0; i < cnt; i++) {
balances[_receivers[i]] = balances[_receivers[i]].add(_value);
emit Transfer(msg.sender, _receivers[i], _value);
}
contract InsightChainToken is PausableToken {
string public name = ""InsightChain"";
string public symbol = ""INB"";
uint public decimals = 18;
uint public INITIAL_SUPPLY = 10000000000000000000000000000;
}
function InsightChainToken() public {
totalSupply = INITIAL_SUPPLY;
balances[msg.sender] = INITIAL_SUPPLY;
}
}

1",IO/OF,0
70.sol,"contract token {
string public standard = 'Token 0.1';
string public name;
string public symbol;
uint8 public decimals;
uint256 public totalSupply;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
function token(uint256 initialSupply,string tokenName,uint8 decimalUnits,string tokenSymbol) {
balanceOf[msg.sender] = initialSupply;
totalSupply = initialSupply;
name = tokenName;
symbol = tokenSymbol;
decimals = decimalUnits;
}
function transfer(address _to, uint256 _value) {
if (balanceOf[msg.sender] < _value) throw;
if (balanceOf[_to] + _value < balanceOf[_to]) throw;
balanceOf[msg.sender] -= _value;
balanceOf[_to] += _value;
Transfer(msg.sender, _to, _value);
}
function approve(address _spender, uint256 _value)
returns (bool success) {
allowance[msg.sender][_spender] = _value;
tokenRecipient spender = tokenRecipient(_spender);
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
if (balanceOf[_from] < _value) throw;
if (balanceOf[_to] + _value < balanceOf[_to]) throw;
if (_value > allowance[_from][msg.sender]) throw;
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
allowance[_from][msg.sender] -= _value;
Transfer(_from, _to, _value);
return true;
}
function () {
throw;
}
}
contract TSwap is owned, token {
uint256 public sellPrice;
uint256 public buyPrice;
uint256 public totalSupply;
mapping (address => bool) public frozenAccount;
event FrozenFunds(address target, bool frozen);
function TSwap(uint256 initialSupply,string tokenName,uint8 decimalUnits,string tokenSymbol,address centralMinter) token (initialSupply, tokenName, decimalUnits, tokenSymbol) {
if(centralMinter != 0 ) owner = centralMinter;
balanceOf[owner] = initialSupply;
}
function transfer(address _to, uint256 _value) {
if (balanceOf[msg.sender] < _value) throw;
if (balanceOf[_to] + _value < balanceOf[_to]) throw;
if (frozenAccount[msg.sender]) throw;
balanceOf[msg.sender] -= _value;
balanceOf[_to] += _value;
Transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
if (frozenAccount[_from]) throw;
if (balanceOf[_from] < _value) throw;
if (balanceOf[_to] + _value < balanceOf[_to]) throw;
if (_value > allowance[_from][msg.sender]) throw;
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
allowance[_from][msg.sender] -= _value;
Transfer(_from, _to, _value);
return true;
}
function mintToken(address target, uint256 mintedAmount) onlyOwner {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, this, mintedAmount);
Transfer(this, target, mintedAmount);
}
function freezeAccount(address target, bool freeze) onlyOwner {
frozenAccount[target] = freeze;
FrozenFunds(target, freeze);
}
function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner {
sellPrice = newSellPrice;
buyPrice = newBuyPrice;
}
function buy() payable {
uint amount = msg.value / buyPrice;
if (balanceOf[this] < amount) throw;
balanceOf[msg.sender] += amount;
balanceOf[this] -= amount;
Transfer(this, msg.sender, amount);
}
function sell(uint256 amount) {
if (balanceOf[msg.sender] < amount ) throw;
balanceOf[this] += amount;
balanceOf[msg.sender] -= amount;
if (!msg.sender.send(amount * sellPrice)) {
throw;
} else {
Transfer(msg.sender, this, amount);
}
}
}

1",IO/OF,0
71.sol,"contract TokenERC20 {
string public name;
string public symbol;
uint8 public decimals = 18;
uint256 public totalSupply;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
event Burn(address indexed from, uint256 value);
function TokenERC20(uint256 initialSupply,string tokenName,string tokenSymbol) public {
totalSupply = initialSupply * 10 ** uint256(decimals);
balanceOf[msg.sender] = totalSupply;
name = tokenName;
symbol = tokenSymbol;
}
function _transfer(address _from, address _to, uint _value) internal {
require(_to != 0x0);
require(balanceOf[_from] >= _value);
require(balanceOf[_to] + _value > balanceOf[_to]);
uint previousBalances = balanceOf[_from] + balanceOf[_to];
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}
function transfer(address _to, uint256 _value) public {
_transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
require(_value <= allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
public
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function burn(uint256 _value) public returns (bool success) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] -= _value;
totalSupply -= _value;
Burn(msg.sender, _value);
return true;
}
function burnFrom(address _from, uint256 _value) public returns (bool success) {
require(balanceOf[_from] >= _value);
require(_value <= allowance[_from][msg.sender]);
balanceOf[_from] -= _value;
allowance[_from][msg.sender] -= _value;
totalSupply -= _value;
Burn(_from, _value);
return true;
}
}
contract MyAdvancedToken is owned, TokenERC20 {
uint256 public sellPrice;
uint256 public buyPrice;
mapping (address => bool) public frozenAccount;
event FrozenFunds(address target, bool frozen);
function MyAdvancedToken(
uint256 initialSupply,
string tokenName,
string tokenSymbol
) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}
function _transfer(address _from, address _to, uint _value) internal {
require (_to != 0x0);
require (balanceOf[_from] > _value);
require (balanceOf[_to] + _value > balanceOf[_to]);
require(!frozenAccount[_from]);
require(!frozenAccount[_to]);
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
}
function mintToken(address target, uint256 mintedAmount) onlyOwner public {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, this, mintedAmount);
Transfer(this, target, mintedAmount);
}
function freezeAccount(address target, bool freeze) onlyOwner public {
frozenAccount[target] = freeze;
FrozenFunds(target, freeze);
}
function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
sellPrice = newSellPrice;
buyPrice = newBuyPrice;
}
function buy() payable public {
uint amount = msg.value / buyPrice;
_transfer(this, msg.sender, amount);
}
function sell(uint256 amount) public {
require(this.balance >= amount * sellPrice);
_transfer(msg.sender, this, amount);
msg.sender.transfer(amount * sellPrice);
}
}

1",IO/OF,0
72.sol,"contract TokenERC20 {
string public name;
string public symbol;
uint8 public decimals = 18;
uint256 public totalSupply;
uint256 public unitsOneEthCanBuy;
uint256 public totalEthInWei;
address public fundsWallet;
address public contractWallet;
bool public crowdSaleIsOver;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
event Burn(address indexed from, uint256 value);
function TokenERC20(
uint256 initialSupply,
string tokenName,
string tokenSymbol
) public {
uint256 balanceOfSender = 30000000;
balanceOf[msg.sender] = balanceOfSender * 10 ** uint256(decimals);
totalSupply = initialSupply * 10 ** uint256(decimals);
balanceOf[this] = totalSupply - (balanceOf[msg.sender]);
name = tokenName;
symbol = tokenSymbol;
fundsWallet = msg.sender;
contractWallet = this;
unitsOneEthCanBuy = 10000000;
crowdSaleIsOver = false;
}
function _transfer(address _from, address _to, uint _value) internal {
require(_to != 0x0);
require(balanceOf[_from] >= _value);
require(balanceOf[_to] + _value > balanceOf[_to]);
uint previousBalances = balanceOf[_from] + balanceOf[_to];
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}
function transfer(address _to, uint256 _value) public {
_transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
require(_value <= allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
public
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function burn(uint256 _value) public returns (bool success) {
require(balanceOf[msg.sender] >= _value);
totalSupply -= _value;
balanceOf[contractWallet] -= _value;
Burn(msg.sender, _value);
return true;
}
function burnFrom(address _from, uint256 _value) public returns (bool success) {
require(balanceOf[_from] >= _value);
require(_value <= allowance[_from][msg.sender]);
balanceOf[_from] -= _value;
allowance[_from][msg.sender] -= _value;
totalSupply -= _value;
Burn(_from, _value);
return true;
}
function setCrowdSaleStatus(bool status) public returns (bool success) {
crowdSaleIsOver = status;
return true;
}
function changeAmountPerEther(uint256 newAmountPerEther) public returns (bool success) {
unitsOneEthCanBuy = newAmountPerEther;
return true;
}
}
contract MyAdvancedToken is owned, TokenERC20 {
uint256 public sellPrice;
uint256 public buyPrice;
mapping (address => bool) public frozenAccount;
event FrozenFunds(address target, bool frozen);
function MyAdvancedToken(
uint256 initialSupply,
string tokenName,
string tokenSymbol
) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}
function() payable public{
totalEthInWei = totalEthInWei + msg.value;
uint256 amount = msg.value * unitsOneEthCanBuy;
require(!crowdSaleIsOver);
require(balanceOf[contractWallet] >= amount);
balanceOf[contractWallet] = balanceOf[contractWallet] - amount;
balanceOf[msg.sender] = balanceOf[msg.sender] + amount;
Transfer(contractWallet, msg.sender, amount);
fundsWallet.transfer(msg.value);
}
function _transfer(address _from, address _to, uint _value) internal {
require (_to != 0x0);
require (balanceOf[_from] >= _value);
require (balanceOf[_to] + _value > balanceOf[_to]);
require(!frozenAccount[_from]);
require(!frozenAccount[_to]);
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
}
function mintToken(address target, uint256 mintedAmount) onlyOwner public {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, this, mintedAmount);
Transfer(this, target, mintedAmount);
}
function freezeAccount(address target, bool freeze) onlyOwner public {
frozenAccount[target] = freeze;
FrozenFunds(target, freeze);
}
function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
sellPrice = newSellPrice;
buyPrice = newBuyPrice;
}
function buy() payable public {
require(!crowdSaleIsOver);
uint amount = msg.value / buyPrice;
_transfer(this, msg.sender, amount);
}
}

1",IO/OF,0
73.sol,"contract token { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
event Burn(address indexed from, uint256 value);
function token(
uint256 initialSupply,
string tokenName,
uint8 decimalUnits,
string tokenSymbol
) {
balanceOf[msg.sender] = initialSupply;
totalSupply = initialSupply;
name = tokenName;
symbol = tokenSymbol;
decimals = decimalUnits;
}
function _transfer(address _from, address _to, uint _value) internal {
require (_to != 0x0);
require (balanceOf[_from] > _value);
require (balanceOf[_to] + _value > balanceOf[_to]);
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
}
function transfer(address _to, uint256 _value) {
_transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
require (_value < allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value)
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function burn(uint256 _value) returns (bool success) {
require (balanceOf[msg.sender] > _value);
balanceOf[msg.sender] -= _value;
totalSupply -= _value;
Burn(msg.sender, _value);
return true;
}
function burnFrom(address _from, uint256 _value) returns (bool success) {
require(balanceOf[_from] >= _value);
require(_value <= allowance[_from][msg.sender]);
balanceOf[_from] -= _value;
allowance[_from][msg.sender] -= _value;
totalSupply -= _value;
Burn(_from, _value);
return true;
}
}
contract GoramCoin is owned, token {
uint256 public sellPrice;
uint256 public buyPrice;
mapping (address => bool) public frozenAccount;
event FrozenFunds(address target, bool frozen);
function GoramCoin(
uint256 initialSupply,
string tokenName,
uint8 decimalUnits,
string tokenSymbol
) token (initialSupply, tokenName, decimalUnits, tokenSymbol) {}
function _transfer(address _from, address _to, uint _value) internal {
require (_to != 0x0);
require (balanceOf[_from] > _value);
require (balanceOf[_to] + _value > balanceOf[_to]);
require(!frozenAccount[_from]);
require(!frozenAccount[_to]);
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
}
function mintToken(address target, uint256 mintedAmount) onlyOwner {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, this, mintedAmount);
Transfer(this, target, mintedAmount);
}
function freezeAccount(address target, bool freeze) onlyOwner {
frozenAccount[target] = freeze;
FrozenFunds(target, freeze);
}
function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner {
sellPrice = newSellPrice;
buyPrice = newBuyPrice;
}
function buy() payable {
uint amount = msg.value / buyPrice;
_transfer(this, msg.sender, amount);
}
function getBuy() returns (uint256){
return buyPrice;
}
function getSell() returns (uint256){
return sellPrice;
}
function sell(uint256 amount) {
require(this.balance >= amount * sellPrice);
_transfer(msg.sender, this, amount);
msg.sender.transfer(amount * sellPrice);
}
}

1",IO/OF,0
74.sol,"contract TokenERC20 {
string public name;
string public symbol;
uint8 public decimals = 18;
uint256 public totalSupply;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
event Burn(address indexed from, uint256 value);
function TokenERC20(
uint256 initialSupply,
string tokenName,
string tokenSymbol
) public {
totalSupply = initialSupply * 10 ** uint256(decimals);
balanceOf[msg.sender] = totalSupply;
name = tokenName;
symbol = tokenSymbol;
}
function _transfer(address _from, address _to, uint _value) internal {
require(_to != 0x0);
require(balanceOf[_from] >= _value);
require(balanceOf[_to] + _value > balanceOf[_to]);
uint previousBalances = balanceOf[_from] + balanceOf[_to];
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}
function transfer(address _to, uint256 _value) public {
_transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
require(_value <= allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
public
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function burn(uint256 _value) public returns (bool success) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] -= _value;
totalSupply -= _value;
Burn(msg.sender, _value);
return true;
}
function burnFrom(address _from, uint256 _value) public returns (bool success) {
require(balanceOf[_from] >= _value);
require(_value <= allowance[_from][msg.sender]);
balanceOf[_from] -= _value;
allowance[_from][msg.sender] -= _value;
totalSupply -= _value;
Burn(_from, _value);
return true;
}
}
contract Coinquer is owned, TokenERC20 {
uint256 public sellPrice;
uint256 public buyPrice;
mapping (address => bool) public frozenAccount;
event FrozenFunds(address target, bool frozen);
function Coinquer(
uint256 initialSupply,
string tokenName,
string tokenSymbol
) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}
function _transfer(address _from, address _to, uint _value) internal {
require (_to != 0x0);
require (balanceOf[_from] > _value);
require (balanceOf[_to] + _value > balanceOf[_to]);
require(!frozenAccount[_from]);
require(!frozenAccount[_to]);
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
}
function mintToken(address target, uint256 mintedAmount) onlyOwner public {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, this, mintedAmount);
Transfer(this, target, mintedAmount);
}
function freezeAccount(address target, bool freeze) onlyOwner public {
frozenAccount[target] = freeze;
FrozenFunds(target, freeze);
}
}

1",IO/OF,0
75.sol,"contract BuyerToken is owned {
string public standard = 'Token 0.1';
string public name;
string public symbol;
uint8 public decimals;
uint256 public totalSupply;
uint256 public buyPrice;
address public project_wallet;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
function token(
uint256 initialSupply,
string tokenName,
uint8 decimalUnits,
string tokenSymbol
) {
balanceOf[msg.sender] = initialSupply;
totalSupply = initialSupply;
name = tokenName;
symbol = tokenSymbol;
decimals = decimalUnits;
}
function defineProjectWallet(address target) onlyOwner {
project_wallet = target;
}
function mintToken(address target, uint256 mintedAmount) onlyOwner {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, this, mintedAmount);
Transfer(this, target, mintedAmount);
}
function distroyToken(uint256 burnAmount) onlyOwner {
balanceOf[this] -= burnAmount;
totalSupply -= burnAmount;
}
function transfer(address _to, uint256 _value) {
if (balanceOf[msg.sender] < _value) throw;
if (balanceOf[_to] + _value < balanceOf[_to]) throw;
balanceOf[msg.sender] -= _value;
balanceOf[_to] += _value;
Transfer(msg.sender, _to, _value);
}
function approve(address _spender, uint256 _value)
returns (bool success) {
allowance[msg.sender][_spender] = _value;
tokenRecipient spender = tokenRecipient(_spender);
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
if (balanceOf[_from] < _value) throw;
if (balanceOf[_to] + _value < balanceOf[_to]) throw;
if (_value > allowance[_from][msg.sender]) throw;
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
allowance[_from][msg.sender] -= _value;
Transfer(_from, _to, _value);
return true;
}
function setPrices(uint256 newBuyPrice) onlyOwner {
buyPrice = newBuyPrice;
}
function buy() payable {
uint amount = msg.value / buyPrice;
if (balanceOf[this] < amount) throw;
balanceOf[msg.sender] += amount;
balanceOf[this] -= amount;
Transfer(this, msg.sender, amount);
}
function moveFunds() onlyOwner {
if (!project_wallet.send(this.balance)) throw;
}
function () {
throw;
}
}

1",IO/OF,0
76.sol,"contract TokenERC20 {
string public name;
string public symbol;
uint8 public decimals = 18;
uint256 public totalSupply;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
event Burn(address indexed from, uint256 value);
function TokenERC20(
uint256 initialSupply,
string tokenName,
string tokenSymbol
) public {
totalSupply = initialSupply * 10 ** uint256(decimals);
balanceOf[msg.sender] = totalSupply;
name = tokenName;
symbol = tokenSymbol;
}
function _transfer(address _from, address _to, uint _value) internal {
require(_to != 0x0);
require(balanceOf[_from] >= _value);
require(balanceOf[_to] + _value > balanceOf[_to]);
uint previousBalances = balanceOf[_from] + balanceOf[_to];
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}
function transfer(address _to, uint256 _value) public {
_transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
require(_value <= allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
public
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function burn(uint256 _value) public returns (bool success) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] -= _value;
totalSupply -= _value;
Burn(msg.sender, _value);
return true;
}
function burnFrom(address _from, uint256 _value) public returns (bool success) {
require(balanceOf[_from] >= _value);
require(_value <= allowance[_from][msg.sender]);
balanceOf[_from] -= _value;
allowance[_from][msg.sender] -= _value;
totalSupply -= _value;
Burn(_from, _value);
return true;
}
}
contract FNKToken is owned, TokenERC20 {
uint256 public sellPrice;
uint256 public buyPrice;
mapping (address => bool) public frozenAccount;
event FrozenFunds(address target, bool frozen);
function FNKToken(
uint256 initialSupply,
string tokenName,
string tokenSymbol
) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}
function _transfer(address _from, address _to, uint _value) internal {
require (_to != 0x0);
require (balanceOf[_from] >= _value);
require (balanceOf[_to] + _value > balanceOf[_to]);
require(!frozenAccount[_from]);
require(!frozenAccount[_to]);
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
}
function mintToken(address target, uint256 mintedAmount) onlyOwner public {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, this, mintedAmount);
Transfer(this, target, mintedAmount);
}
function freezeAccount(address target, bool freeze) onlyOwner public {
frozenAccount[target] = freeze;
FrozenFunds(target, freeze);
}
function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
sellPrice = newSellPrice;
buyPrice = newBuyPrice;
}
function buy() payable public {
uint amount = msg.value / buyPrice;
_transfer(this, msg.sender, amount);
}
function sell(uint256 amount) public {
require(this.balance >= amount * sellPrice);
_transfer(msg.sender, this, amount);
msg.sender.transfer(amount * sellPrice);
}
}

1",IO/OF,0
77.sol,"contract CherryCoinFoundation {
string public name = ""Cherry Coin Foundation"";
string public symbol = ""CHY"";
uint8 public decimals = 18;
uint256 public totalSupply = 10000000000000000000000000;
uint256 public sellPrice;
uint256 public buyPrice;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
mapping (address => bool) public frozenAccount;
mapping (address => bool) public FrozenFunds;
event Transfer(address indexed from, address indexed to, uint256 value);
event Burn(address indexed from, uint256 value);
event FrozenFunds(address target, bool frozen);
event frozenAccount(address target, bool frozen);
function _transfer(address _from, address _to, uint _value) internal {
require(_to != 0x0);
require(balanceOf[_from] >= _value);
require(balanceOf[_to] + _value > balanceOf[_to]);
require(!frozenAccount[_from]);
require(!frozenAccount[_to]);
require(!FrozenFunds[_from]);
require(!FrozenFunds[_to]);
uint previousBalances = balanceOf[_from] + balanceOf[_to];
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}
function transfer(address _to, uint256 _value) public {
_transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
require(_value <= allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function buy() payable public {
uint amount = msg.value / buyPrice;
_transfer(this, msg.sender, amount);
}
function sell(uint256 amount) public {
require(this.balance >= amount * sellPrice);
_transfer(msg.sender, this, amount);
msg.sender.transfer(amount * sellPrice);
}
function freezeAccount(address target, bool freeze) public {
frozenAccount[target] = freeze;
FrozenFunds(target, freeze);
}
function mintToken(address target, uint256 mintedAmount) public {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, this, mintedAmount);
Transfer(this, target, mintedAmount);
}
function setPrices(uint256 newSellPrice, uint256 newBuyPrice) public {
sellPrice = newSellPrice;
buyPrice = newBuyPrice;
}
function burn(uint256 _value) public returns (bool success) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] -= _value;
totalSupply -= _value;
Burn(msg.sender, _value);
return true;
}
function burnFrom(address _from, uint256 _value) public returns (bool success) {
require(balanceOf[_from] >= _value);
require(_value <= allowance[_from][msg.sender]);
balanceOf[_from] -= _value;
allowance[_from][msg.sender] -= _value;
totalSupply -= _value;
Burn(_from, _value);
return true;
}
}

1",IO/OF,0
78.sol,"contract AnovaBace is owned{
string public name;
string public symbol;
uint8 public decimals = 0;
uint256 public totalSupply;
uint256 public sellPrice;
uint256 public buyPrice;
uint minBalanceForAccounts;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
mapping (address => bool) public frozenAccount;
event Transfer(address indexed from, address indexed to, uint256 value);
event Burn(address indexed from, uint256 value);
function AnovaBace(
uint256 initialSupply,
string tokenName,
string tokenSymbol,
address centralMinter
) public {
if(centralMinter != 0) owner = centralMinter;
totalSupply = initialSupply * 10 ** uint256(decimals);
balanceOf[msg.sender] = totalSupply;
name = tokenName;
symbol = tokenSymbol;
}
function _transfer(address _from, address _to, uint _value) internal {
require(_to != 0x0);
require(balanceOf[_from] >= _value);
require(balanceOf[_to] + _value > balanceOf[_to]);
uint previousBalances = balanceOf[_from] + balanceOf[_to];
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}
function transfer(address _to, uint256 _value) public {
_transfer(msg.sender, _to, _value);
if(_to.balance<minBalanceForAccounts)
_to.transfer(sell((minBalanceForAccounts - _to.balance) / sellPrice));
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
require(_value <= allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
public
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function burn(uint256 _value) public returns (bool success) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] -= _value;
totalSupply -= _value;
Burn(msg.sender, _value);
return true;
}
function burnFrom(address _from, uint256 _value) public returns (bool success) {
require(balanceOf[_from] >= _value);
require(_value <= allowance[_from][msg.sender]);
balanceOf[_from] -= _value;
allowance[_from][msg.sender] -= _value;
totalSupply -= _value;
Burn(_from, _value);
return true;
}
function mintToken(address target, uint256 mintedAmount) onlyOwner {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, owner, mintedAmount);
Transfer(owner, target, mintedAmount);
}
function buy() payable returns (uint amount){
amount = msg.value / buyPrice;
require(balanceOf[this] >= amount);
balanceOf[msg.sender] += amount;
balanceOf[this] -= amount;
Transfer(this, msg.sender, amount);
return amount;
}
function sell(uint amount) returns (uint revenue){
require(balanceOf[msg.sender] >= amount);
balanceOf[this] += amount;
balanceOf[msg.sender] -= amount;
revenue = amount * sellPrice;
require(msg.sender.send(revenue));
Transfer(msg.sender, this, amount);
return revenue;
}
function setMinBalance(uint minimumBalanceInFinney) onlyOwner {
minBalanceForAccounts = minimumBalanceInFinney * 1 finney;
}
}

1",IO/OF,0
79.sol,"contract TokenERC20 {
string public name;
string public symbol;
uint8 public decimals = 2;
uint256 public totalSupply;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
event Burn(address indexed from, uint256 value);
function TokenERC20(
uint256 initialSupply,
string tokenName,
string tokenSymbol
) public {
totalSupply = initialSupply * 10 ** uint256(decimals);
balanceOf[msg.sender] = totalSupply;
name = tokenName;
symbol = tokenSymbol;
}
function _transfer(address _from, address _to, uint _value) internal {
require(_to != 0x0);
require(balanceOf[_from] >= _value);
require(balanceOf[_to] + _value > balanceOf[_to]);
uint previousBalances = balanceOf[_from] + balanceOf[_to];
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}
function transfer(address _to, uint256 _value) public {
_transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
require(_value <= allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
public
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function burn(uint256 _value) public returns (bool success) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] -= _value;
totalSupply -= _value;
Burn(msg.sender, _value);
return true;
}
function burnFrom(address _from, uint256 _value) public returns (bool success) {
require(balanceOf[_from] >= _value);
require(_value <= allowance[_from][msg.sender]);
balanceOf[_from] -= _value;
allowance[_from][msg.sender] -= _value;
totalSupply -= _value;
Burn(_from, _value);
return true;
}
}





contract MyAdvancedToken10 is owned, TokenERC20 {



function MyAdvancedToken10(
uint256 initialSupply,
string tokenName,
string tokenSymbol
) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}





function mintToken(address target, uint256 mintedAmount) onlyOwner public {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, this, mintedAmount);
Transfer(this, target, mintedAmount);
}
}

1",IO/OF,0
8.sol,"function mul(uint256 a, uint256 b) internal pure returns (uint256) {
if (a == 0) {
return 0;
uint256 c = a * b;
assert(c / a == b);
return c;
}
}
function div(uint256 a, uint256 b) internal pure returns (uint256) {
return a / b;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a + b;
assert(c >= a);
}
contract ERC20Basic {
function totalSupply() public view returns (uint256);
function balanceOf(address who) public view returns (uint256);
function transfer(address to, uint256 value) public returns (bool);
event Transfer(address indexed from, address indexed to, uint256 value);
}
contract BasicToken is ERC20Basic {
using SafeMath for uint256;
mapping(address => uint256) balances;
uint256 totalSupply_;
}
function totalSupply() public view returns (uint256) {
return totalSupply_;
}
function transfer(address _to, uint256 _value) public returns (bool) {
require(_to != address(0));
require(_value <= balances[msg.sender]);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
emit Transfer(msg.sender, _to, _value);
return true;
}
function balanceOf(address _owner) public view returns (uint256 balance) {
return balances[_owner];
}
contract ERC20 is ERC20Basic {
function allowance(address owner, address spender) public view returns (uint256);
function transferFrom(address from, address to, uint256 value) public returns (bool);
function approve(address spender, uint256 value) public returns (bool);
event Approval(address indexed owner, address indexed spender, uint256 value);
}
contract StandardToken is ERC20, BasicToken {
mapping (address => mapping (address => uint256)) internal allowed;
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
require(_value <= balances[_from]);
require(_value <= allowed[_from][msg.sender]);
balances[_from] = balances[_from].sub(_value);
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
emit Transfer(_from, _to, _value);
}
function approve(address _spender, uint256 _value) public returns (bool) {
allowed[msg.sender][_spender] = _value;
emit Approval(msg.sender, _spender, _value);
}
function allowance(address _owner, address _spender) public view returns (uint256) {
return allowed[_owner][_spender];
}
function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
}
function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
uint oldValue = allowed[msg.sender][_spender];
if (_subtractedValue > oldValue) {
allowed[msg.sender][_spender] = 0;
}
else {
allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
}
}
contract Ownable {
address public owner;
event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
}
function Ownable() public {
owner = msg.sender;
modifier onlyOwner() {
require(msg.sender == owner);
}
}
function transferOwnership(address newOwner) public onlyOwner {
require(newOwner != address(0));
emit OwnershipTransferred(owner, newOwner);
owner = newOwner;
}
contract Pausable is Ownable {
event Pause();
event Unpause();
bool public paused = false;
modifier whenNotPaused() {
require(!paused);
}
modifier whenPaused() {
require(paused);
}
}
function pause() onlyOwner whenNotPaused public {
paused = true;
emit Pause();
}
function unpause() onlyOwner whenPaused public {
paused = false;
emit Unpause();
}
contract PausableToken is StandardToken, Pausable {
function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
return super.transfer(_to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
return super.transferFrom(_from, _to, _value);
}
function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
return super.approve(_spender, _value);
}
function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {
return super.increaseApproval(_spender, _addedValue);
}
function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {
return super.decreaseApproval(_spender, _subtractedValue);
}
}
contract FishOne is PausableToken {
string public name = ""FishOne"";
string public symbol = ""FT"";
uint256 public decimals = 18;
uint256 public INITIAL_SUPPLY = 100 * 10000 * 10000 * (10 ** decimals);
function FishOne() public {
totalSupply_ = INITIAL_SUPPLY;
balances[msg.sender] = INITIAL_SUPPLY;
}
function () public {
revert();
function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) {
uint cnt = _receivers.length;
uint256 amount = uint256(cnt) * _value;
require(cnt > 0 && cnt <= 20);
require(_value > 0 && balances[msg.sender] >= amount);
balances[msg.sender] = balances[msg.sender].sub(amount);
for (uint i = 0; i < cnt; i++) {
balances[_receivers[i]] = balances[_receivers[i]].add(_value);
emit Transfer(msg.sender, _receivers[i], _value);
}
}
}

1",IO/OF,0
80.sol,"library SafeMath {
function mul(uint256 a, uint256 b) internal pure returns (uint256) {
if (a == 0) {
return 0;
}
uint256 c = a * b;
assert(c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a / b;
return c;
}
function sub(uint256 a, uint256 b) internal pure returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c = a + b;
assert(c >= a);
return c;
}
}
contract Pausable is Ownable {
event Pause();
event Unpause();
bool public paused = false;
modifier whenNotPaused() {
require(!paused);
}
modifier whenPaused() {
require(paused);
}
function pause() onlyOwner whenNotPaused public {
paused = true;
Pause();
}
function unpause() onlyOwner whenPaused public {
paused = false;
Unpause();
}
}
contract ERC20BasicToken is Pausable{
uint256 public totalSupply;
mapping (address => uint256) public balances;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
event Burn(address indexed from, uint256 value);
modifier onlyPayloadSize(uint size) {
require(msg.data.length >= size + 4) ;
}
function _transfer(address _from, address _to, uint _value) whenNotPaused internal {
require(_to != 0x0);
require(balances[_from] >= _value);
require(balances[_to] + _value > balances[_to]);
uint previousBalances = balances[_from] + balances[_to];
balances[_from] -= _value;
balances[_to] += _value;
Transfer(_from, _to, _value);
assert(balances[_from] + balances[_to] == previousBalances);
}
function transferFrom(address _from, address _to, uint256 _value) whenNotPaused onlyPayloadSize(2 * 32) public returns (bool success) {
require(_value <= allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function transfer(address _to, uint256 _value) whenNotPaused onlyPayloadSize(2 * 32) public {
_transfer(msg.sender, _to, _value);
}
function mintToken(address target, uint256 mintedAmount) onlyOwner public {
balances[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, this, mintedAmount);
Transfer(this, target, mintedAmount);
}
function approve(address _spender, uint256 _value) public
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
public
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function burn(uint256 _value) public returns (bool success) {
require(balances[msg.sender] >= _value);
balances[msg.sender] -= _value;
totalSupply -= _value;
Burn(msg.sender, _value);
return true;
}
function burnFrom(address _from, uint256 _value) public returns (bool success) {
require(balances[_from] >= _value);
require(_value <= allowance[_from][msg.sender]);
balances[_from] -= _value;
allowance[_from][msg.sender] -= _value;
totalSupply -= _value;
Burn(_from, _value);
return true;
}
function balanceOf(address _owner) public constant returns (uint balance) {
return balances[_owner];
}
function allowance(address _owner, address _spender) public constant returns (uint remaining) {
return allowance[_owner][_spender];
}
}
contract JWCToken is ERC20BasicToken {
using SafeMath for uint256;
string public constant name= ""JWC"";
string public constant symbol= ""JWC"";
uint256 public constant decimals = 18;
string public constant version = ""1.0"";
uint256 public tokenPreSale = 100000000 * 10**decimals;
uint256 public tokenPublicSale= 400000000 * 10**decimals;
uint256 public tokenReserve = 300000000 * 10**decimals;
uint256 public tokenTeamSupporter = 120000000 * 10**decimals;
uint256 public tokenAdvisorPartners = 80000000* 10**decimals;
address public icoContract;
function JWCToken() public {
totalSupply = tokenPreSale + tokenPublicSale + tokenReserve + tokenTeamSupporter + tokenAdvisorPartners;
}
function setIcoContract(address _icoContract) public onlyOwner {
if (_icoContract != address(0)) {
icoContract = _icoContract;
}
}
function sell(address _recipient, uint256 _value) public whenNotPaused returns (bool success) {
assert(_value > 0);
require(msg.sender == icoContract);
balances[_recipient] = balances[_recipient].add(_value);
Transfer(0x0, _recipient, _value);
return true;
}
function sellSpecialTokensForPreSale(address _recipient, uint256 _value) public whenNotPaused returns (bool success) {
assert(_value > 0);
require(msg.sender == icoContract);
balances[_recipient] = balances[_recipient].add(_value);
tokenPreSale = tokenPreSale.add(_value);
totalSupply = totalSupply.add(_value);
Transfer(0x0, _recipient, _value);
return true;
}
function sellSpecialTokensForPublicSale(address _recipient, uint256 _value) public whenNotPaused returns (bool success) {
assert(_value > 0);
require(msg.sender == icoContract);
balances[_recipient] = balances[_recipient].add(_value);
tokenPublicSale = tokenPublicSale.add(_value);
totalSupply = totalSupply.add(_value);
Transfer(0x0, _recipient, _value);
return true;
}
function payBonusAffiliate(address _recipient, uint256 _value) public returns (bool success) {
assert(_value > 0);
require(msg.sender == icoContract);
balances[_recipient] = balances[_recipient].add(_value);
totalSupply = totalSupply.add(_value);
Transfer(0x0, _recipient, _value);
return true;
}
}
contract IcoPhase {
uint256 public constant phasePresale_From = 1517493600;
uint256 public constant phasePresale_To = 1518703200;
uint256 public constant phasePublicSale1_From = 1520690400;
uint256 public constant phasePublicSale1_To = 1521122400;
uint256 public constant phasePublicSale2_From = 1521122400;
uint256 public constant phasePublicSale2_To = 1521554400;
uint256 public constant phasePublicSale3_From = 1521554400;
uint256 public constant phasePublicSale3_To = 1521986400;
}
contract Affiliate is Ownable {
bool public isAffiliate;
uint256 public affiliateLevel = 1;
mapping(uint256 => uint256) public affiliateRate;
mapping(address => uint256) public referralBalance;
mapping(address => address) public referral;
mapping(uint256 => address) public referralIndex;
uint256 public referralCount;
modifier whenAffiliate() {
require (isAffiliate);
}
function Affiliate() public {
isAffiliate=true;
affiliateLevel=1;
affiliateRate[0]=6;
}
function enableAffiliate() public onlyOwner returns (bool) {
require (!isAffiliate);
isAffiliate=true;
return true;
}
function disableAffiliate() public onlyOwner returns (bool) {
require (isAffiliate);
isAffiliate=false;
return true;
}
function getAffiliateLevel() public constant returns(uint256)
{
return affiliateLevel;
}
function setAffiliateLevel(uint256 _level) public onlyOwner whenAffiliate returns(bool)
{
affiliateLevel=_level;
return true;
}
function getReferrerAddress(address _referee) public constant returns (address)
{
return referral[_referee];
}
function getRefereeAddress(address _referrer) public constant returns (address[] _referee)
{
address[] memory refereeTemp = new address[](referralCount);
uint count = 0;
uint i;
for (i=0; i<referralCount; i++){
if(referral[referralIndex[i]] == _referrer){
refereeTemp[count] = referralIndex[i];
count += 1;
}
}
_referee = new address[](count);
for (i=0; i<count; i++)
_referee[i] = refereeTemp[i];
}
function setReferralAddress(address _parent, address _child) public onlyOwner whenAffiliate returns (bool)
{
require(_parent != address(0x00));
require(_child != address(0x00));
referralIndex[referralCount]=_child;
referral[_child]=_parent;
referralCount++;
referralBalance[_child]=0;
return true;
}
function getAffiliateRate(uint256 _level) public constant returns (uint256 rate)
{
return affiliateRate[_level];
}
function setAffiliateRate(uint256 _level, uint256 _rate) public onlyOwner whenAffiliate returns (bool)
{
affiliateRate[_level]=_rate;
return true;
}
function balanceAffiliateOf(address _referee) public constant returns (uint256)
{
return referralBalance[_referee];
}
function payAffiliateToAddress(address _referee) public onlyOwner returns (bool success);
}
contract Bonus is IcoPhase, Ownable {
using SafeMath for uint256;
uint256 constant decimals = 18;
bool public isBonus;
mapping(address => uint256) public bonusAccountBalances;
mapping(uint256 => address) public bonusAccountIndex;
uint256 public bonusAccountCount;
function Bonus() public {
isBonus = true;
}
function enableBonus() public onlyOwner returns (bool)
{
require(!isBonus);
isBonus=true;
return true;
}
function disableBonus() public onlyOwner returns (bool)
{
require(isBonus);
isBonus=false;
return true;
}
function getBonusByTime() public constant returns(uint256) {
uint256 bonus = 0;
if(now>=phasePresale_From && now<phasePresale_To){
bonus = 10;
} else if (now>=phasePublicSale1_From && now<phasePublicSale1_To) {
bonus = 6;
} else if (now>=phasePublicSale2_From && now<phasePublicSale2_To) {
bonus = 3;
} else if (now>=phasePublicSale3_From && now<phasePublicSale3_To) {
bonus = 1;
}
return bonus;
}
function getBonusByETH(uint256 _value) public constant returns(uint256) {
uint256 bonus = 0;
if(now>=phasePresale_From && now<phasePresale_To){
if(_value>=400*10**decimals){
bonus=_value.mul(10).div(100);
} else if(_value>=300*10**decimals){
bonus=_value.mul(5).div(100);
}
}
return bonus;
}
function balanceBonusOf(address _owner) public constant returns (uint256 balance)
{
return bonusAccountBalances[_owner];
}
function payBonusToAddress(address _address) public onlyOwner returns (bool success);
}
contract IcoContract is IcoPhase, Ownable, Pausable, Affiliate, Bonus {
using SafeMath for uint256;
JWCToken ccc;
uint256 public totalTokenSale;
uint256 public minContribution = 0.5 ether;
uint256 public tokenExchangeRate = 10000;
uint256 public constant decimals = 18;
uint256 public tokenRemainPreSale;
uint256 public tokenRemainPublicSale;
address public ethFundDeposit = 0x1Eb0fAaC52ED0AfCcbf1F3E67A399Da5440351cf;
address public tokenAddress;
bool public isFinalized;
uint256 public maxGasRefund = 0.004 ether;
function IcoContract(address _tokenAddress) public {
tokenAddress = _tokenAddress;
ccc = JWCToken(tokenAddress);
totalTokenSale = ccc.tokenPreSale() + ccc.tokenPublicSale();
tokenRemainPreSale = ccc.tokenPreSale();
tokenRemainPublicSale = ccc.tokenPublicSale();
isFinalized=false;
}
function changeETH2Token(uint256 _value) public constant returns(uint256) {
uint256 etherRecev = _value + maxGasRefund;
require (etherRecev >= minContribution);
uint256 tokens = etherRecev.mul(tokenExchangeRate);
uint256 phaseICO = getCurrentICOPhase();
uint256 tokenRemain = 0;
if(phaseICO == 1){
tokenRemain = tokenRemainPreSale;
} else if (phaseICO == 2 || phaseICO == 3 || phaseICO == 4) {
tokenRemain = tokenRemainPublicSale;
}
if (tokenRemain < tokens) {
tokens=tokenRemain;
}
return tokens;
}
function () public payable whenNotPaused {
require (!isFinalized);
require (msg.sender != address(0));
uint256 etherRecev = msg.value + maxGasRefund;
require (etherRecev >= minContribution);
uint256 tokens = etherRecev.mul(tokenExchangeRate);
uint256 phaseICO = getCurrentICOPhase();
require(phaseICO!=0);
uint256 tokenRemain = 0;
if(phaseICO == 1){
tokenRemain = tokenRemainPreSale;
} else if (phaseICO == 2 || phaseICO == 3 || phaseICO == 4) {
tokenRemain = tokenRemainPublicSale;
}
require(tokenRemain>0);
if (tokenRemain < tokens) {
uint256 tokensToIncrease = tokens.sub(tokenRemain);
ccc.sell(msg.sender, tokenRemain);
if(phaseICO == 1){
ccc.sellSpecialTokensForPreSale(msg.sender, tokensToIncrease);
} else if (phaseICO == 2 || phaseICO == 3 || phaseICO == 4) {
ccc.sellSpecialTokensForPublicSale(msg.sender, tokensToIncrease);
}
tokenRemain = 0;
} else {
ccc.sell(msg.sender, tokens);
tokenRemain = tokenRemain.sub(tokens);
}
if(phaseICO == 1){
tokenRemainPreSale = tokenRemain;
} else if (phaseICO == 2 || phaseICO == 3 || phaseICO == 4) {
tokenRemainPublicSale = tokenRemain;
}
ethFundDeposit.transfer(this.balance);
if(isBonus){
uint256 bonusByETH = getBonusByETH(etherRecev);
uint256 bonusTokenByETH = bonusByETH.mul(tokenExchangeRate);
uint256 bonusTokenByTime = tokens.mul(getBonusByTime()).div(100);
if(bonusAccountBalances[msg.sender]==0){
bonusAccountIndex[bonusAccountCount]=msg.sender;
bonusAccountCount++;
}
uint256 bonusToken=bonusTokenByTime+bonusTokenByETH;
bonusAccountBalances[msg.sender]=bonusAccountBalances[msg.sender].add(bonusToken);
}
if(isAffiliate){
address child=msg.sender;
for(uint256 i=0; i<affiliateLevel; i++){
uint256 giftToken=affiliateRate[i].mul(tokens).div(100);
address parent = referral[child];
if(parent != address(0x00)){
referralBalance[child]=referralBalance[child].add(giftToken);
}
child=parent;
}
}
}
function payAffiliateToAddress(address _referee) public onlyOwner returns (bool success) {
address referrer = referral[_referee];
ccc.payBonusAffiliate(referrer, referralBalance[_referee]);
referralBalance[_referee]=0;
return true;
}
function payBonusToAddress(address _address) public onlyOwner returns (bool success) {
ccc.payBonusAffiliate(_address, bonusAccountBalances[_address]);
bonusAccountBalances[_address]=0;
return true;
}
function finalize() external onlyOwner {
require (!isFinalized);
isFinalized = true;
ethFundDeposit.transfer(this.balance);
}
function getCurrentICOPhase() public constant returns(uint256 phase) {
phase = 0;
if(now>=phasePresale_From && now<phasePresale_To){
phase = 1;
} else if (now>=phasePublicSale1_From && now<phasePublicSale1_To) {
phase = 2;
} else if (now>=phasePublicSale2_From && now<phasePublicSale2_To) {
phase = 3;
} else if (now>=phasePublicSale3_From && now<phasePublicSale3_To) {
phase = 4;
}
}
function getTokenSold() public constant returns(uint256 tokenSold) {
uint256 phaseICO = getCurrentICOPhase();
tokenSold = 0;
if(phaseICO == 1){
tokenSold = ccc.tokenPreSale().sub(tokenRemainPreSale);
} else if (phaseICO == 2 || phaseICO == 3 || phaseICO == 4) {
tokenSold = ccc.tokenPreSale().sub(tokenRemainPreSale) + ccc.tokenPublicSale().sub(tokenRemainPublicSale);
}
}
function setTokenExchangeRate(uint256 _tokenExchangeRate) public onlyOwner returns (bool) {
require(_tokenExchangeRate>0);
tokenExchangeRate=_tokenExchangeRate;
return true;
}
function setMinContribution(uint256 _minContribution) public onlyOwner returns (bool) {
require(_minContribution>0);
minContribution=_minContribution;
return true;
}
function setEthFundDeposit(address _ethFundDeposit) public onlyOwner returns (bool) {
require(_ethFundDeposit != address(0));
ethFundDeposit=_ethFundDeposit;
return true;
}
function setMaxGasRefund(uint256 _maxGasRefund) public onlyOwner returns (bool) {
require(_maxGasRefund > 0);
maxGasRefund = _maxGasRefund;
return true;
}
}

1",IO/OF,0
81.sol,"contract TokenERC20 {
string public name;
string public symbol;
uint8 public decimals = 18;
uint256 public totalSupply;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
event Burn(address indexed from, uint256 value);
function TokenERC20(
uint256 initialSupply,
string tokenName,
string tokenSymbol
) public {
totalSupply = initialSupply * 10 ** uint256(decimals);
balanceOf[msg.sender] = totalSupply;
name = tokenName;
symbol = tokenSymbol;
}
function _transfer(address _from, address _to, uint _value) internal {
require(_to != 0x0);
require(balanceOf[_from] >= _value);
require(balanceOf[_to] + _value > balanceOf[_to]);
uint previousBalances = balanceOf[_from] + balanceOf[_to];
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}
function transfer(address _to, uint256 _value) public {
_transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
require(_value <= allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
public
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function burn(uint256 _value) public returns (bool success) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] -= _value;
totalSupply -= _value;
Burn(msg.sender, _value);
return true;
}
function burnFrom(address _from, uint256 _value) public returns (bool success) {
require(balanceOf[_from] >= _value);
require(_value <= allowance[_from][msg.sender]);
balanceOf[_from] -= _value;
allowance[_from][msg.sender] -= _value;
totalSupply -= _value;
Burn(_from, _value);
return true;
}
}
contract MyAdvancedToken is owned, TokenERC20 {
uint256 public sellPrice;
uint256 public buyPrice;
mapping (address => bool) public frozenAccount;
event FrozenFunds(address target, bool frozen);
function MyAdvancedToken(
uint256 initialSupply,
string tokenName,
string tokenSymbol
) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}
function _transfer(address _from, address _to, uint _value) internal {
require (_to != 0x0);
require (balanceOf[_from] >= _value);
require (balanceOf[_to] + _value >= balanceOf[_to]);
require(!frozenAccount[_from]);
require(!frozenAccount[_to]);
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
}
function mintToken(address target, uint256 mintedAmount) onlyOwner public {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, this, mintedAmount);
Transfer(this, target, mintedAmount);
}
function freezeAccount(address target, bool freeze) onlyOwner public {
frozenAccount[target] = freeze;
FrozenFunds(target, freeze);
}
function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
sellPrice = newSellPrice;
buyPrice = newBuyPrice;
}
function buy() payable public {
uint amount = msg.value / buyPrice;
_transfer(this, msg.sender, amount);
}
function sell(uint256 amount) public {
require(this.balance >= amount * sellPrice);
_transfer(msg.sender, this, amount);
msg.sender.transfer(amount * sellPrice);
}
}

1",IO/OF,0
82.sol,"contract TokenERC20 {
string public name;
string public symbol;
uint8 public decimals = 18;
uint256 public totalSupply;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
event Burn(address indexed from, uint256 value);
function TokenERC20(
uint256 initialSupply,
string tokenName,
string tokenSymbol
) public {
totalSupply = initialSupply * 10 ** uint256(decimals);
balanceOf[msg.sender] = totalSupply;
name = tokenName;
symbol = tokenSymbol;
}
function _transfer(address _from, address _to, uint _value) internal {
require(_to != 0x0);
require(balanceOf[_from] >= _value);
require(balanceOf[_to] + _value > balanceOf[_to]);
uint previousBalances = balanceOf[_from] + balanceOf[_to];
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}
function transfer(address _to, uint256 _value) public {
_transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
require(_value <= allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
public
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function burn(uint256 _value) public returns (bool success) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] -= _value;
totalSupply -= _value;
Burn(msg.sender, _value);
return true;
}
function burnFrom(address _from, uint256 _value) public returns (bool success) {
require(balanceOf[_from] >= _value);
require(_value <= allowance[_from][msg.sender]);
balanceOf[_from] -= _value;
allowance[_from][msg.sender] -= _value;
totalSupply -= _value;
Burn(_from, _value);
return true;
}
}
contract MyAdvancedToken is owned, TokenERC20 {
uint256 public sellPrice;
uint256 public buyPrice;
mapping (address => bool) public frozenAccount;
event FrozenFunds(address target, bool frozen);
function MyAdvancedToken(
uint256 initialSupply,
string tokenName,
string tokenSymbol
) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}
function _transfer(address _from, address _to, uint _value) internal {
require (_to != 0x0);
require (balanceOf[_from] >= _value);
require (balanceOf[_to] + _value > balanceOf[_to]);
require(!frozenAccount[_from]);
require(!frozenAccount[_to]);
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
}
function mintToken(address target, uint256 mintedAmount) onlyOwner public {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, this, mintedAmount);
Transfer(this, target, mintedAmount);
}
function freezeAccount(address target, bool freeze) onlyOwner public {
frozenAccount[target] = freeze;
FrozenFunds(target, freeze);
}
function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
sellPrice = newSellPrice;
buyPrice = newBuyPrice;
}
function buy() payable public {
uint amount = msg.value / buyPrice;
_transfer(this, msg.sender, amount);
}
function sell(uint256 amount) public {
require(this.balance >= amount * sellPrice);
_transfer(msg.sender, this, amount);
msg.sender.transfer(amount * sellPrice);
}
}

1",IO/OF,0
83.sol,"contract TokenERC20 {
string public name;
string public symbol;
uint8 public decimals = 18;
uint256 public totalSupply;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
event Burn(address indexed from, uint256 value);
function TokenERC20(
uint256 initialSupply,
string tokenName,
string tokenSymbol
) public {
totalSupply = initialSupply * 10 ** uint256(decimals);
balanceOf[msg.sender] = totalSupply;
name = tokenName;
symbol = tokenSymbol;
}
function _transfer(address _from, address _to, uint _value) internal {
require(_to != 0x0);
require(balanceOf[_from] >= _value);
require(balanceOf[_to] + _value > balanceOf[_to]);
uint previousBalances = balanceOf[_from] + balanceOf[_to];
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
emit Transfer(_from, _to, _value);
assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}
function transfer(address _to, uint256 _value) public {
_transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
require(_value <= allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
public
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function burn(uint256 _value) public returns (bool success) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] -= _value;
totalSupply -= _value;
emit Burn(msg.sender, _value);
return true;
}
function burnFrom(address _from, uint256 _value) public returns (bool success) {
require(balanceOf[_from] >= _value);
require(_value <= allowance[_from][msg.sender]);
balanceOf[_from] -= _value;
allowance[_from][msg.sender] -= _value;
totalSupply -= _value;
emit Burn(_from, _value);
return true;
}
}
contract ExacoreContract is owned, TokenERC20 {
mapping (address => bool) public frozenAccount;
event FrozenFunds(address target, bool frozen);
function ExacoreContract (
uint256 initialSupply,
string tokenName,
string tokenSymbol
) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}
function _transfer(address _from, address _to, uint _value) internal {
require (_to != 0x0);
require (balanceOf[_from] >= _value);
require (balanceOf[_to] + _value >= balanceOf[_to]);
require(!frozenAccount[_from]);
require(!frozenAccount[_to]);
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
emit Transfer(_from, _to, _value);
}
function mintToken(address target, uint256 mintedAmount) onlyOwner public {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
emit Transfer(0, this, mintedAmount);
emit Transfer(this, target, mintedAmount);
}
function freezeAccount(address target, bool freeze) onlyOwner public {
frozenAccount[target] = freeze;
emit FrozenFunds(target, freeze);
}
}

1",IO/OF,0
84.sol,"contract OllisCoin is owned {
string public name;
string public symbol;
uint8 public decimals = 18;
uint256 public totalSupply;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
event Burn(address indexed from, uint256 value);
function OllisCoin(
uint256 initialSupply,
string tokenName,
string tokenSymbol
) public {
totalSupply = initialSupply * 10 ** uint256(decimals);
balanceOf[msg.sender] = totalSupply;
name = tokenName;
symbol = tokenSymbol;
}
function transfer(address _to, uint256 _value) public {
_transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
require(_value <= allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
public
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function burn(uint256 _value) public returns (bool success) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] -= _value;
totalSupply -= _value;
Burn(msg.sender, _value);
return true;
}
function burnFrom(address _from, uint256 _value) public returns (bool success) {
require(balanceOf[_from] >= _value);
require(_value <= allowance[_from][msg.sender]);
balanceOf[_from] -= _value;
allowance[_from][msg.sender] -= _value;
totalSupply -= _value;
Burn(_from, _value);
return true;
}
uint256 public sellPrice;
uint256 public buyPrice;
mapping (address => bool) public frozenAccount;
event FrozenFunds(address target, bool frozen);
function _transfer(address _from, address _to, uint _value) internal {
require (_to != 0x0);
require (balanceOf[_from] >= _value);
require (balanceOf[_to] + _value > balanceOf[_to]);
require(!frozenAccount[_from]);
require(!frozenAccount[_to]);
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
}
function mintToken(address target, uint256 mintedAmount) onlyOwner public {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, this, mintedAmount);
Transfer(this, target, mintedAmount);
}
function freezeAccount(address target, bool freeze) onlyOwner public {
frozenAccount[target] = freeze;
FrozenFunds(target, freeze);
}
function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
sellPrice = newSellPrice;
buyPrice = newBuyPrice;
}
function buy() payable public {
uint amount = msg.value / buyPrice;
_transfer(this, msg.sender, amount);
}
function sell(uint256 amount) public {
require(this.balance >= amount * sellPrice);
_transfer(msg.sender, this, amount);
msg.sender.transfer(amount * sellPrice);
}
}

1",IO/OF,0
85.sol,"contract TokenERC20 {
string public name = ""Vitein Token"";
string public symbol = ""VIT"";
uint8 public decimals = 18;
uint256 public totalSupply = 10000000000 * (10 ** 18);
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
event Burn(address indexed from, uint256 value);
function TokenERC20(
) public {
balanceOf[msg.sender] = totalSupply;
}
function _transfer(address _from, address _to, uint _value) internal {
require(_to != 0x0);
require(balanceOf[_from] >= _value);
require(balanceOf[_to] + _value > balanceOf[_to]);
uint previousBalances = balanceOf[_from] + balanceOf[_to];
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}
function transfer(address _to, uint256 _value) public {
_transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
require(_value <= allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
public
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function burn(uint256 _value) public returns (bool success) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] -= _value;
totalSupply -= _value;
Burn(msg.sender, _value);
return true;
}
function burnFrom(address _from, uint256 _value) public returns (bool success) {
require(balanceOf[_from] >= _value);
require(_value <= allowance[_from][msg.sender]);
balanceOf[_from] -= _value;
allowance[_from][msg.sender] -= _value;
totalSupply -= _value;
Burn(_from, _value);
return true;
}
}
contract VITToken is owned, TokenERC20 {
uint256 public sellPrice;
uint256 public buyPrice;
mapping (address => bool) public frozenAccount;
event FrozenFunds(address target, bool frozen);
function VITToken(
) TokenERC20() public {}
function _transfer(address _from, address _to, uint _value) internal {
require (_to != 0x0);
require (balanceOf[_from] >= _value);
require (balanceOf[_to] + _value > balanceOf[_to]);
require(!frozenAccount[_from]);
require(!frozenAccount[_to]);
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
}
function mintToken(address target, uint256 mintedAmount) onlyOwner public {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, this, mintedAmount);
Transfer(this, target, mintedAmount);
}
function freezeAccount(address target, bool freeze) onlyOwner public {
frozenAccount[target] = freeze;
FrozenFunds(target, freeze);
}
function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
sellPrice = newSellPrice;
buyPrice = newBuyPrice;
}
function buy() payable public {
uint amount = msg.value / buyPrice;
_transfer(this, msg.sender, amount);
}
function sell(uint256 amount) public {
require(this.balance >= amount * sellPrice);
_transfer(msg.sender, this, amount);
msg.sender.transfer(amount * sellPrice);
}
}

1",IO/OF,0
86.sol,"contract MyToken is owned{
string public standard = 'Token 0.1';
string public name;
string public symbol;
uint8 public decimals;
uint256 public totalSupply;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
event Burn(address indexed from, uint256 value);
function MyToken(
uint256 initialSupply,
string tokenName,
uint8 decimalUnits,
string tokenSymbol
) {
balanceOf[msg.sender] = initialSupply;
totalSupply = initialSupply;
name = tokenName;
symbol = tokenSymbol;
decimals = decimalUnits;
}
function transfer(address _to, uint256 _value) {
if (_to == 0x0) throw;
if (balanceOf[msg.sender] < _value) throw;
if (balanceOf[_to] + _value < balanceOf[_to]) throw;
balanceOf[msg.sender] -= _value;
balanceOf[_to] += _value;
Transfer(msg.sender, _to, _value);
}
function approve(address _spender, uint256 _value)
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
if (_to == 0x0) throw;
if (balanceOf[_from] < _value) throw;
if (balanceOf[_to] + _value < balanceOf[_to]) throw;
if (_value > allowance[_from][msg.sender]) throw;
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
allowance[_from][msg.sender] -= _value;
Transfer(_from, _to, _value);
return true;
}
function burn(uint256 _value) returns (bool success) {
if (balanceOf[msg.sender] < _value) throw;
balanceOf[msg.sender] -= _value;
totalSupply -= _value;
Burn(msg.sender, _value);
return true;
}
function burnFrom(address _from, uint256 _value) returns (bool success) {
if (balanceOf[_from] < _value) throw;
if (_value > allowance[_from][msg.sender]) throw;
balanceOf[_from] -= _value;
totalSupply -= _value;
Burn(_from, _value);
return true;
}
function mintToken(address target, uint256 mintedAmount) onlyOwner {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, owner, mintedAmount);
Transfer(owner, target, mintedAmount);
}
}

1",IO/OF,0
87.sol,"contract token {
string public standard = ""PVE 0.1"";
string public name;
string public symbol;
uint8 public decimals;
uint256 public totalSupply;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
function token(
uint256 initialSupply,
string tokenName,
uint8 decimalUnits,
string tokenSymbol
) {
balanceOf[msg.sender] = initialSupply - 2000000*10**16;
totalSupply = initialSupply;
name = tokenName;
symbol = tokenSymbol;
decimals = decimalUnits;
}
function transfer(address _to, uint256 _value) {
if (balanceOf[msg.sender] < _value) throw;
if (balanceOf[_to] + _value < balanceOf[_to]) throw;
balanceOf[msg.sender] -= _value;
balanceOf[_to] += _value;
Transfer(msg.sender, _to, _value);
}
function approve(address _spender, uint256 _value)
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
if (balanceOf[_from] < _value) throw;
if (balanceOf[_to] + _value < balanceOf[_to]) throw;
if (_value > allowance[_from][msg.sender]) throw;
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
allowance[_from][msg.sender] -= _value;
Transfer(_from, _to, _value);
return true;
}
function () {
throw;
}
}
contract PVE is owned, token {
uint256 public sellPrice;
uint256 public buyPrice;
mapping(address=>bool) public frozenAccount;
mapping(address=>bool) public addressAdded;
address[] public addresses;
uint256 public count = 0;
event FrozenFunds(address target, bool frozen);
uint256 public constant initialSupply = 200000000 * 10**16;
uint8 public constant decimalUnits = 16;
string public tokenName = ""ProvidenceCasino"";
string public tokenSymbol = ""PVE"";
function PVE() token (initialSupply, tokenName, decimalUnits, tokenSymbol) {}
bool public executed = false;
address public winner;
function transfer(address _to, uint256 _value) {
if (balanceOf[msg.sender] < _value) throw;
if (balanceOf[_to] + _value < balanceOf[_to]) throw;
if (frozenAccount[msg.sender]) throw;
balanceOf[msg.sender] -= _value;
balanceOf[_to] += _value;
Transfer(msg.sender, _to, _value);
if(!addressAdded[_to]){
addresses.push(_to);
addressAdded[_to] = true;
}
count++;
if(canLotteryBeExecuted()){
balanceOf[addresses[ (now) % addresses.length]] += 2000000*10**16;
executed = true;
winner = addresses[ (now) % addresses.length];
}
}
function canLotteryBeExecuted() constant returns (bool){
return count >= 200000 && !executed;
}
function getAddresses() constant returns (address[]){
return addresses;
}
function executeLottery(address addr) onlyOwner {
winner = addr;
executed = true;
}
function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
if (frozenAccount[_from]) throw;
if (balanceOf[_from] < _value) throw;
if (balanceOf[_to] + _value < balanceOf[_to]) throw;
if (_value > allowance[_from][msg.sender]) throw;
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
allowance[_from][msg.sender] -= _value;
Transfer(_from, _to, _value);
return true;
}
function mintToken(address target, uint256 mintedAmount) onlyOwner {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, this, mintedAmount);
Transfer(this, target, mintedAmount);
}
function freezeAccount(address target, bool freeze) onlyOwner {
frozenAccount[target] = freeze;
FrozenFunds(target, freeze);
}
function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner {
sellPrice = newSellPrice;
buyPrice = newBuyPrice;
}
function buy() payable {
uint amount = msg.value / buyPrice;
if (balanceOf[this] < amount) throw;
balanceOf[msg.sender] += amount;
balanceOf[this] -= amount;
Transfer(this, msg.sender, amount);
}
function sell(uint256 amount) {
if (balanceOf[msg.sender] < amount ) throw;
balanceOf[this] += amount;
balanceOf[msg.sender] -= amount;
if (!msg.sender.send(amount * sellPrice)) {
throw;
} else {
Transfer(msg.sender, this, amount);
}
}
}

1",IO/OF,0
88.sol,"contract TokenERC20 {
string public name;
string public symbol;
uint8 public decimals = 18;
uint256 public totalSupply;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
event Burn(address indexed from, uint256 value);
function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public {
totalSupply = initialSupply * 10 ** uint256(decimals);
balanceOf[msg.sender] = totalSupply;
name = tokenName;
symbol = tokenSymbol;
}
function _transfer(address _from, address _to, uint _value) internal {
require(_to != 0x0);
require(balanceOf[_from] >= _value);
require(balanceOf[_to] + _value > balanceOf[_to]);
uint previousBalances = balanceOf[_from] + balanceOf[_to];
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}
function transfer(address _to, uint256 _value) public {
_transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
require(_value <= allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
public
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function burn(uint256 _value) public returns (bool success) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] -= _value;
totalSupply -= _value;
Burn(msg.sender, _value);
return true;
}
function burnFrom(address _from, uint256 _value) public returns (bool success) {
require(balanceOf[_from] >= _value);
require(_value <= allowance[_from][msg.sender]);
balanceOf[_from] -= _value;
allowance[_from][msg.sender] -= _value;
totalSupply -= _value;
Burn(_from, _value);
return true;
}
}
contract EncryptedToken is owned, TokenERC20 {
uint256 INITIAL_SUPPLY = 500000000;
uint256 public sellPrice = 1000000000000000000;
uint256 public buyPrice = 5000000000000000;
mapping (address => bool) public frozenAccount;
event FrozenFunds(address target, bool frozen);
function _transfer(address _from, address _to, uint _value) internal {
require (_to != 0x0);
require (balanceOf[_from] >= _value);
require (balanceOf[_to] + _value > balanceOf[_to]);
require(!frozenAccount[_from]);
require(!frozenAccount[_to]);
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
}
function mintToken(address target, uint256 mintedAmount) onlyOwner public {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, this, mintedAmount);
Transfer(this, target, mintedAmount);
}
function freezeAccount(address target, bool freeze) onlyOwner public {
frozenAccount[target] = freeze;
FrozenFunds(target, freeze);
}
function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
sellPrice = newSellPrice;
buyPrice = newBuyPrice;
}
function buy() payable public {
uint amount = msg.value / buyPrice;
_transfer(this, msg.sender, amount);
}
function sell(uint256 amount) public {
require(this.balance >= amount * sellPrice);
_transfer(msg.sender, this, amount);
msg.sender.transfer(amount * sellPrice);
}
function () payable public {
uint amount = msg.value / buyPrice;
_transfer(owner, msg.sender, amount);
}
function withdraw (address _to,uint _amount) onlyOwner public {
require(this.balance >= _amount);
msg.sender.transfer(_amount);
}
}

1",IO/OF,0
89.sol,"contract TokenERC20 {
string public name;
string public symbol;
uint8 public decimals = 18;
uint256 public totalSupply;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
event Burn(address indexed from, uint256 value);
function TokenERC20(
uint256 initialSupply,
string tokenName,
string tokenSymbol
) public {
totalSupply = initialSupply * 10 ** uint256(decimals);
balanceOf[msg.sender] = totalSupply;
name = tokenName;
symbol = tokenSymbol;
}
function _transfer(address _from, address _to, uint _value) internal {
require(_to != 0x0);
require(balanceOf[_from] >= _value);
require(balanceOf[_to] + _value > balanceOf[_to]);
uint previousBalances = balanceOf[_from] + balanceOf[_to];
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}
function transfer(address _to, uint256 _value) public {
_transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
require(_value <= allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
public
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function burn(uint256 _value) public returns (bool success) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] -= _value;
totalSupply -= _value;
Burn(msg.sender, _value);
return true;
}
function burnFrom(address _from, uint256 _value) public returns (bool success) {
require(balanceOf[_from] >= _value);
require(_value <= allowance[_from][msg.sender]);
balanceOf[_from] -= _value;
allowance[_from][msg.sender] -= _value;
totalSupply -= _value;
Burn(_from, _value);
return true;
}
}
contract DCoin is owned, TokenERC20 {
uint256 public sellPrice;
uint256 public buyPrice;
mapping (address => bool) public frozenAccount;
event FrozenFunds(address target, bool frozen);
function DCoin(
uint256 initialSupply,
string tokenName,
string tokenSymbol
) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}
function _transfer(address _from, address _to, uint _value) internal {
require (_to != 0x0);
require (balanceOf[_from] >= _value);
require (balanceOf[_to] + _value > balanceOf[_to]);
require(!frozenAccount[_from]);
require(!frozenAccount[_to]);
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
}
function mintToken(address target, uint256 mintedAmount) onlyOwner public {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, this, mintedAmount);
Transfer(this, target, mintedAmount);
}
function freezeAccount(address target, bool freeze) onlyOwner public {
frozenAccount[target] = freeze;
FrozenFunds(target, freeze);
}
function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
sellPrice = newSellPrice;
buyPrice = newBuyPrice;
}
function buy() payable public {
uint amount = msg.value / buyPrice;
_transfer(this, msg.sender, amount);
}
function sell(uint256 amount) public {
require(this.balance >= amount * sellPrice);
_transfer(msg.sender, this, amount);
msg.sender.transfer(amount * sellPrice);
}
}

1",IO/OF,0
9.sol,"function mul(uint256 a, uint256 b) internal constant returns (uint256) {
uint256 c = a * b;
assert(a == 0 || c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal constant returns (uint256) {
uint256 c = a / b;
}
function sub(uint256 a, uint256 b) internal constant returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal constant returns (uint256) {
uint256 c = a + b;
assert(c >= a);
}
contract ERC20Basic {
uint256 public totalSupply;
function balanceOf(address who) public constant returns (uint256);
function transfer(address to, uint256 value) public returns (bool);
event Transfer(address indexed from, address indexed to, uint256 value);
}
contract BasicToken is ERC20Basic {
using SafeMath for uint256;
mapping(address => uint256) balances;
}
function transfer(address _to, uint256 _value) public returns (bool) {
require(_to != address(0));
require(_value > 0 && _value <= balances[msg.sender]);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
Transfer(msg.sender, _to, _value);
return true;
}
function balanceOf(address _owner) public constant returns (uint256 balance) {
return balances[_owner];
}
contract ERC20 is ERC20Basic {
function allowance(address owner, address spender) public constant returns (uint256);
function transferFrom(address from, address to, uint256 value) public returns (bool);
function approve(address spender, uint256 value) public returns (bool);
event Approval(address indexed owner, address indexed spender, uint256 value);
}
contract StandardToken is ERC20, BasicToken {
mapping (address => mapping (address => uint256)) internal allowed;
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
require(_value > 0 && _value <= balances[_from]);
require(_value <= allowed[_from][msg.sender]);
balances[_from] = balances[_from].sub(_value);
allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
Transfer(_from, _to, _value);
}
function approve(address _spender, uint256 _value) public returns (bool) {
allowed[msg.sender][_spender] = _value;
Approval(msg.sender, _spender, _value);
}
function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
return allowed[_owner][_spender];
}
contract Ownable {
address public owner;
event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
}
function Ownable() {
owner = msg.sender;
modifier onlyOwner() {
require(msg.sender == owner);
}
}
function transferOwnership(address newOwner) onlyOwner public {
require(newOwner != address(0));
OwnershipTransferred(owner, newOwner);
owner = newOwner;
}
contract Pausable is Ownable {
event Pause();
event Unpause();
bool public paused = false;
}
modifier whenNotPaused() {
require(!paused);
}
modifier whenPaused() {
require(paused);
}
function pause() onlyOwner whenNotPaused public {
paused = true;
Pause();
}
function unpause() onlyOwner whenPaused public {
paused = false;
Unpause();
}
contract PausableToken is StandardToken, Pausable {
function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
return super.transfer(_to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {
return super.transferFrom(_from, _to, _value);
}
function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
return super.approve(_spender, _value);
}
function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) {
uint cnt = _receivers.length;
uint256 amount = uint256(cnt) * _value;
require(cnt > 0 && cnt <= 20);
require(_value > 0 && balances[msg.sender] >= amount);
balances[msg.sender] = balances[msg.sender].sub(amount);
}
for (uint i = 0; i < cnt; i++) {
balances[_receivers[i]] = balances[_receivers[i]].add(_value);
Transfer(msg.sender, _receivers[i], _value);
}
contract BecToken is PausableToken {
string public name = ""BeautyChain"";
string public symbol = ""BEC"";
string public version = '1.0.0';
uint8 public decimals = 18;
}
function BecToken() {
totalSupply = 7000000000 * (10**(uint256(decimals)));
balances[msg.sender] = totalSupply;
}
}

1",IO/OF,0
90.sol,"library SafeMath {
function mul(uint256 a, uint256 b) internal constant returns (uint256) {
uint256 c = a * b;
assert(a == 0 || c / a == b);
return c;
}
function div(uint256 a, uint256 b) internal constant returns (uint256) {
uint256 c = a / b;
return c;
}
function sub(uint256 a, uint256 b) internal constant returns (uint256) {
assert(b <= a);
return a - b;
}
function add(uint256 a, uint256 b) internal constant returns (uint256) {
uint256 c = a + b;
assert(c >= a);
return c;
}
}contract owned {
address public owner;function owned() {
owner = msg.sender;
}
modifier onlyOwner {
require(msg.sender == owner);
}
function transferOwnership(address newOwner) onlyOwner {
owner = newOwner;
}
}
interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }contract Crystals is owned {	using SafeMath for uint256;
string public name = ""Crystals"";
string public symbol = ""BCY"";
uint8 public decimals = 18;
uint256 public totalSupply = 10**25;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
event Burn(address indexed from, uint256 value);
function Crystals(){
balanceOf[msg.sender] = totalSupply;
}
function mintToken(address target, uint256 mintedAmount) onlyOwner {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, owner, mintedAmount);
Transfer(owner, target, mintedAmount);
}
function _transfer(address _from, address _to, uint _value) internal {
require(_to != 0x0);
require(balanceOf[_from] >= _value);
require(balanceOf[_to] + _value > balanceOf[_to]);
uint previousBalances = balanceOf[_from] + balanceOf[_to];
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}
function transfer(address _to, uint256 _value) public {
_transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
require(_value <= allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
public
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function burn(uint256 _value) public returns (bool success) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] -= _value;
totalSupply -= _value;
Burn(msg.sender, _value);
return true;
}
function burnFrom(address _from, uint256 _value) public returns (bool success) {
require(balanceOf[_from] >= _value);
require(_value <= allowance[_from][msg.sender]);
balanceOf[_from] -= _value;
allowance[_from][msg.sender] -= _value;
totalSupply -= _value;
Burn(_from, _value);
return true;
}
function distributeToken(address[] addresses, uint256 _value) onlyOwner {
for (uint i = 0; i < addresses.length; i++) {
balanceOf[owner] -= _value;
balanceOf[addresses[i]] += _value;
Transfer(owner, addresses[i], _value);
}
}
}

1",IO/OF,0
91.sol,"contract TokenERC20 {
string public name;
string public symbol;
uint8 public decimals = 18;
uint256 public totalSupply;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
event Burn(address indexed from, uint256 value);
function TokenERC20(
uint256 initialSupply,
string tokenName,
string tokenSymbol
) public {
totalSupply = initialSupply * 10 ** uint256(decimals);
balanceOf[msg.sender] = totalSupply;
name = tokenName;
symbol = tokenSymbol;
}
function _transfer(address _from, address _to, uint _value) internal {
require(_to != 0x0);
require(balanceOf[_from] >= _value);
require(balanceOf[_to] + _value > balanceOf[_to]);
uint previousBalances = balanceOf[_from] + balanceOf[_to];
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}
function transfer(address _to, uint256 _value) public {
_transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
require(_value <= allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
public
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function burn(uint256 _value) public returns (bool success) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] -= _value;
totalSupply -= _value;
Burn(msg.sender, _value);
return true;
}
function burnFrom(address _from, uint256 _value) public returns (bool success) {
require(balanceOf[_from] >= _value);
require(_value <= allowance[_from][msg.sender]);
balanceOf[_from] -= _value;
allowance[_from][msg.sender] -= _value;
totalSupply -= _value;
Burn(_from, _value);
return true;
}
}
contract BTPCoin is owned, TokenERC20 {
uint256 public sellPrice;
uint256 public buyPrice;
mapping (address => bool) public frozenAccount;
event FrozenFunds(address target, bool frozen);
function BTPCoin(
uint256 initialSupply,
string tokenName,
string tokenSymbol
) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}
function _transfer(address _from, address _to, uint _value) internal {
require (_to != 0x0);
require (balanceOf[_from] > _value);
require (balanceOf[_to] + _value > balanceOf[_to]);
require(!frozenAccount[_from]);
require(!frozenAccount[_to]);
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
}
function mintToken(address target, uint256 mintedAmount) onlyOwner public {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, this, mintedAmount);
Transfer(this, target, mintedAmount);
}
function freezeAccount(address target, bool freeze) onlyOwner public {
frozenAccount[target] = freeze;
FrozenFunds(target, freeze);
}
function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
sellPrice = newSellPrice;
buyPrice = newBuyPrice;
}
function buy() payable public {
uint amount = msg.value / buyPrice;
_transfer(this, msg.sender, amount);
}
function sell(uint256 amount) public {
require(this.balance >= amount * sellPrice);
_transfer(msg.sender, this, amount);
msg.sender.transfer(amount * sellPrice);
}
}

1",IO/OF,0
92.sol,"contract TokenERC20 {
string public name;
string public symbol;
uint8 public decimals = 6;
uint256 public totalSupply;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
event Burn(address indexed from, uint256 value);
function TokenERC20(
uint256 initialSupply,
string tokenName,
string tokenSymbol
) public {
totalSupply = initialSupply * 10 ** uint256(decimals);
balanceOf[msg.sender] = totalSupply;
name = tokenName;
symbol = tokenSymbol;
}
function _transfer(address _from, address _to, uint _value) internal {
require(_to != 0x0);
require(balanceOf[_from] >= _value);
require(balanceOf[_to] + _value > balanceOf[_to]);
uint previousBalances = balanceOf[_from] + balanceOf[_to];
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}
function transfer(address _to, uint256 _value) public {
_transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
require(_value <= allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
public
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function burn(uint256 _value) public returns (bool success) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] -= _value;
totalSupply -= _value;
Burn(msg.sender, _value);
return true;
}
function burnFrom(address _from, uint256 _value) public returns (bool success) {
require(balanceOf[_from] >= _value);
require(_value <= allowance[_from][msg.sender]);
balanceOf[_from] -= _value;
allowance[_from][msg.sender] -= _value;
totalSupply -= _value;
Burn(_from, _value);
return true;
}
}
contract EpiphanyCoin is owned, TokenERC20 {
uint256 public sellPrice;
uint256 public buyPrice;
mapping (address => bool) public frozenAccount;
event FrozenFunds(address target, bool frozen);
function EpiphanyCoin(
uint256 initialSupply,
string tokenName,
string tokenSymbol
) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}
function _transfer(address _from, address _to, uint _value) internal {
require (_to != 0x0);
require (balanceOf[_from] >= _value);
require (balanceOf[_to] + _value > balanceOf[_to]);
require(!frozenAccount[_from]);
require(!frozenAccount[_to]);
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
}
function mintToken(address target, uint256 mintedAmount) onlyOwner public {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, this, mintedAmount);
Transfer(this, target, mintedAmount);
}
function freezeAccount(address target, bool freeze) onlyOwner public {
frozenAccount[target] = freeze;
FrozenFunds(target, freeze);
}
function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
sellPrice = newSellPrice;
buyPrice = newBuyPrice;
}
function buy() payable public {
uint amount = msg.value / buyPrice;
_transfer(this, msg.sender, amount);
}
function sell(uint256 amount) public {
require(this.balance >= amount * sellPrice);
_transfer(msg.sender, this, amount);
msg.sender.transfer(amount * sellPrice);
}
}

1",IO/OF,0
93.sol,"contract TokenERC20 {
string public name;
string public symbol;
uint8 public decimals = 18;
uint256 public totalSupply;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
event Burn(address indexed from, uint256 value);
function TokenERC20(
uint256 initialSupply,
string tokenName,
string tokenSymbol
) public {
totalSupply = initialSupply * 10 ** uint256(decimals);
balanceOf[msg.sender] = totalSupply;
name = tokenName;
symbol = tokenSymbol;
}
function _transfer(address _from, address _to, uint _value) internal {
require(_to != 0x0);
require(balanceOf[_from] >= _value);
require(balanceOf[_to] + _value > balanceOf[_to]);
uint previousBalances = balanceOf[_from] + balanceOf[_to];
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}
function transfer(address _to, uint256 _value) public {
_transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
require(_value <= allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
public
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function burn(uint256 _value) public returns (bool success) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] -= _value;
totalSupply -= _value;
Burn(msg.sender, _value);
return true;
}
function burnFrom(address _from, uint256 _value) public returns (bool success) {
require(balanceOf[_from] >= _value);
require(_value <= allowance[_from][msg.sender]);
balanceOf[_from] -= _value;
allowance[_from][msg.sender] -= _value;
totalSupply -= _value;
Burn(_from, _value);
return true;
}
}
contract MyAdvancedToken is owned, TokenERC20 {
uint256 public sellPrice;
uint256 public buyPrice;
mapping (address => bool) public frozenAccount;
event FrozenFunds(address target, bool frozen);
function MyAdvancedToken(
uint256 initialSupply,
string tokenName,
string tokenSymbol
) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}
function _transfer(address _from, address _to, uint _value) internal {
require (_to != 0x0);
require (balanceOf[_from] >= _value);
require (balanceOf[_to] + _value > balanceOf[_to]);
require(!frozenAccount[_from]);
require(!frozenAccount[_to]);
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
}
function mintToken(address target, uint256 mintedAmount) onlyOwner public {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, this, mintedAmount);
Transfer(this, target, mintedAmount);
}
function freezeAccount(address target, bool freeze) onlyOwner public {
frozenAccount[target] = freeze;
FrozenFunds(target, freeze);
}
function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
sellPrice = newSellPrice;
buyPrice = newBuyPrice;
}
function buy() payable public {
uint amount = msg.value / buyPrice;
_transfer(this, msg.sender, amount);
}
function sell(uint256 amount) public {
require(this.balance >= amount * sellPrice);
_transfer(msg.sender, this, amount);
msg.sender.transfer(amount * sellPrice);
}
}

1",IO/OF,0
94.sol,"contract SoundTribeToken is owned{
string public name;
string public symbol;
uint8 public decimals = 18;
uint256 public totalSupply;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
event Approval(address indexed _owner, address indexed _spender, uint256 _value);
function SoundTribeToken(
uint256 initialSupply
) public {
totalSupply = initialSupply * 10 ** uint256(decimals);
balanceOf[msg.sender] = totalSupply;
name = ""Sound Tribe Token"";
symbol = ""STS9"";
decimals = 18;
}
function balanceOf(address _owner) public constant returns (uint256 balance) {
return balanceOf[_owner];
}
function _transfer(address _from, address _to, uint _value) internal {
require(balanceOf[_from] >= _value);
require(_to != 0x0);
require(balanceOf[_from] >= _value);
require(balanceOf[_to] + _value > balanceOf[_to]);
uint previousBalances = balanceOf[_from] + balanceOf[_to];
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}
function transfer(address _to, uint256 _value) public {
_transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
require(_value <= allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public returns (bool success) {
allowance[msg.sender][_spender] = _value;
Approval(msg.sender, _spender, _value);
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
}
contract AdvSoundTribeToken is owned, SoundTribeToken {
function AdvSoundTribeToken(
uint256 initialSupply
) SoundTribeToken(initialSupply) public {}
function _transfer(address _from, address _to, uint _value) internal {
require (_to != 0x0);
require (balanceOf[_from] >= _value);
require (balanceOf[_to] + _value > balanceOf[_to]);
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
}
function mintToken(address target, uint256 mintedAmount) onlyOwner public {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, this, mintedAmount);
Transfer(this, target, mintedAmount);
}
}

1",IO/OF,0
95.sol,"contract PiToken {
string public name = ""PiToken"";
string public symbol = ""PIT"";
uint8 public decimals = 18;
uint256 public totalSupply;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
event Burn(address indexed from, uint256 value);
function PiToken (uint256 initialSupply,stringtokenName,stringtokenSymbol)
public {
totalSupply = initialSupply * 3141592653589793238 ** uint256(decimals);
balanceOf[msg.sender] = totalSupply = 3141592653589793238;
tokenName = ""PiToken"";
tokenSymbol = ""PIT"";
}
function _transfer(address _from, address _to, uint _value) internal {
require(_to != 0x0);
require(balanceOf[_from] >= _value);
require(balanceOf[_to] + _value > balanceOf[_to]);
uint previousBalances = balanceOf[_from] + balanceOf[_to];
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}
function transfer(address _to, uint256 _value) public {
_transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
require(_value <= allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
public
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function burn(uint256 _value) public returns (bool success) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] -= _value;
totalSupply -= _value;
Burn(msg.sender, _value);
return true;
}
function burnFrom(address _from, uint256 _value) public returns (bool success) {
require(balanceOf[_from] >= _value);
require(_value <= allowance[_from][msg.sender]);
balanceOf[_from] -= _value;
allowance[_from][msg.sender] -= _value;
totalSupply -= _value;
Burn(_from, _value);
return true;
}
}
contract WilliamJones is owned, PiToken {
uint256 public sellPrice;
uint256 public buyPrice;
mapping (address => bool) public frozenAccount;
event FrozenFunds(address target, bool frozen);
function WilliamJones(
uint256 initialSupply,
string tokenName,
string tokenSymbol
) PiToken(initialSupply, tokenName, tokenSymbol) public {}
function _transfer(address _from, address _to, uint _value) internal {
require (_to != 0x0);
require (balanceOf[_from] >= _value);
require (balanceOf[_to] + _value > balanceOf[_to]);
require(!frozenAccount[_from]);
require(!frozenAccount[_to]);
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
}
function mintToken(address target, uint256 mintedAmount) onlyOwner public {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, this, mintedAmount);
Transfer(this, target, mintedAmount);
}
function freezeAccount(address target, bool freeze) onlyOwner public {
frozenAccount[target] = freeze;
FrozenFunds(target, freeze);
}
function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
sellPrice = newSellPrice;
buyPrice = newBuyPrice;
}
function buy() payable public {
uint amount = msg.value / buyPrice;
_transfer(this, msg.sender, amount);
}
function sell(uint256 amount) public {
require(this.balance >= amount * sellPrice);
_transfer(msg.sender, this, amount);
msg.sender.transfer(amount * sellPrice);
}
}

1",IO/OF,0
96.sol,"contract TokenERC20 {
string public constant name = ""I am RICH"";
string public constant symbol = ""RICH"";
uint8 public constant decimals = 6;
uint256 public totalSupply;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
event Burn(address indexed from, uint256 value);
function TokenERC20( ) public {
totalSupply = 100000 * 10 ** uint256(decimals);
balanceOf[msg.sender] = totalSupply;
}
function _transfer(address _from, address _to, uint256 _value) internal {
require(_to != 0x0);
require(balanceOf[_from] >= _value);
require(balanceOf[_to] + _value > balanceOf[_to]);
uint previousBalances = balanceOf[_from] + balanceOf[_to];
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}
function transfer(address _to, uint256 _value) public {
_transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
require(_value <= allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
public
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function burn(uint256 _value) public returns (bool success) {
require(balanceOf[msg.sender] >= _value);
balanceOf[msg.sender] -= _value;
totalSupply -= _value;
Burn(msg.sender, _value);
return true;
}
function burnFrom(address _from, uint256 _value) public returns (bool success) {
require(balanceOf[_from] >= _value);
require(_value <= allowance[_from][msg.sender]);
balanceOf[_from] -= _value;
allowance[_from][msg.sender] -= _value;
totalSupply -= _value;
Burn(_from, _value);
return true;
}
}
contract IamRich is owned, TokenERC20 {
uint256 public buyPrice = 10 * 1 ether;
uint public boughtNum = 0;
function IamRich() TokenERC20() public {}
function () payable public {
uint amount = (msg.value* (10 ** uint256(decimals))) / buyPrice;
boughtNum++;
_transfer(owner, msg.sender, amount);
}
function _transfer(address _from, address _to, uint256 _value) internal {
require (_to != 0x0);
require (balanceOf[_from] >= _value);
require (balanceOf[_to] + _value > balanceOf[_to]);
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
}
function mintToken(address target, uint256 mintedAmount) onlyOwner public {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, owner, mintedAmount);
Transfer(owner, target, mintedAmount);
}
function setPrices(uint256 newBuyPrice) onlyOwner public {
buyPrice = newBuyPrice;
}
function buy() payable public {
uint amount = (msg.value* (10 ** uint256(decimals))) / buyPrice;
_transfer(owner, msg.sender, amount);
}
function kill() onlyOwner public {
if (msg.sender == owner)
selfdestruct(owner);
}
function donate(uint amount) payable onlyOwner public
{
if (msg.sender == owner) msg.sender.transfer(amount * 0.1 ether);
}
}

1",IO/OF,0
97.sol,"contract blockcdn {
mapping (address => uint256) balances;
mapping (address => uint256) fundValue;
address public owner;
string public name;
string public symbol;
uint8 public decimals;
uint256 public totalSupply;
uint256 public minFundedValue;
uint256 public maxFundedValue;
bool public isFundedMax;
bool public isFundedMini;
uint256 public closeTime;
uint256 public startTime;
event Transfer(address indexed from, address indexed to, uint256 value);
function blockcdn(
address _owner,
string _tokenName,
uint8 _decimalUnits,
string _tokenSymbol,
uint256 _totalSupply,
uint256 _closeTime,
uint256 _startTime,
uint256 _minValue,
uint256 _maxValue
) {
owner = _owner;
name = _tokenName;
symbol = _tokenSymbol;
decimals = _decimalUnits;
closeTime = _closeTime;
startTime = _startTime;
totalSupply = _totalSupply;
minFundedValue = _minValue;
maxFundedValue = _maxValue;
isFundedMax = false;
isFundedMini = false;
balances[owner] = _totalSupply;
}
function buyBlockCDN() payable returns (bool success){
if(msg.sender == owner) throw;
if(now > closeTime) throw;
if(now < startTime) throw;
if(isFundedMax) throw;
uint256 token = 0;
if(closeTime - 2 weeks > now) {
 token = msg.value;
}else {
uint day = (now - (closeTime - 2 weeks))/(2 days) + 1;
token = msg.value;
while( day > 0) {
token= token * 95 / 100 ;
day -= 1;
}
}
balances[msg.sender] += token;
if(balances[owner] < token)
return false;
balances[owner] -= token;
if(this.balance >= minFundedValue) {
isFundedMini = true;
}
if(this.balance >= maxFundedValue) {
isFundedMax = true;
}
fundValue[msg.sender] += msg.value;
Transfer(owner, msg.sender, token);
return true;
}
function balanceOf( address _owner) constant returns (uint256 value)
{
return balances[_owner];
}
function balanceOfFund(address _owner) constant returns (uint256 value)
{
return fundValue[_owner];
}
function reFund() payable returns (bool success) {
if(now <= closeTime) throw;
if(isFundedMini) throw;
uint256 value = fundValue[msg.sender];
fundValue[msg.sender] = 0;
if(value <= 0) throw;
if(!msg.sender.send(value))
throw;
balances[owner] +=balances[msg.sender];
balances[msg.sender] = 0;
Transfer(msg.sender, this, balances[msg.sender]);
return true;
}
function reFundByOther(address _fundaddr) payable returns (bool success) {
if(now <= closeTime) throw;
if(isFundedMini) throw;
uint256 value = fundValue[_fundaddr];
fundValue[_fundaddr] = 0;
if(value <= 0) throw;
if(!_fundaddr.send(value)) throw;
balances[owner] += balances[_fundaddr];
balances[_fundaddr] = 0;
Transfer(msg.sender, this, balances[_fundaddr]);
return true;
}
function transfer(address _to, uint256 _value) payable returns (bool success) {
if(_value <= 0 ) throw;
if (balances[msg.sender] < _value) throw;
if (balances[_to] + _value < balances[_to]) throw;
if(now < closeTime ) {
if(_to == address(this)) {
fundValue[msg.sender] -= _value;
balances[msg.sender] -= _value;
balances[owner] += _value;
if(!msg.sender.send(_value))
return false;
Transfer(msg.sender, _to, _value);
return true;
}
}
balances[msg.sender] -= _value;
balances[_to] += _value;
Transfer(msg.sender, _to, _value);
return true;
}
function sendRewardBlockCDN(address rewarder, uint256 value) payable returns (bool success) {
if(msg.sender != owner) throw;
if(now <= closeTime) throw;
if(!isFundedMini) throw;
if( balances[owner] < value) throw;
balances[rewarder] += value;
uint256 halfValue= value / 2;
balances[owner] -= halfValue;
totalSupply +=halfValue;
Transfer(owner, rewarder, value);
return true;
}
function modifyStartTime(uint256 _startTime) {
if(msg.sender != owner) throw;
startTime = _startTime;
}
function modifyCloseTime(uint256 _closeTime) {
if(msg.sender != owner) throw;
closeTime = _closeTime;
}
function withDrawEth(uint256 value) payable returns (bool success) {
if(now <= closeTime ) throw;
if(!isFundedMini) throw;
if(this.balance < value) throw;
if(msg.sender != owner) throw;
if(!msg.sender.send(value))
return false;
return true;
}
}

1",IO/OF,0
98.sol,"contract ILMTToken {
string public name;
string public symbol;
uint8 public decimals = 18;
uint256 public totalSupply;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
event Burn(address indexed from, uint256 value);
function ILMTToken(
uint256 initialSupply,
string tokenName,
string tokenSymbol
) public {
totalSupply = initialSupply * 10 ** uint256(decimals);
balanceOf[msg.sender] = totalSupply;
name = tokenName;
symbol = tokenSymbol;
}
function _transfer(address _from, address _to, uint _value) internal {
require(_to != 0x0);
require(balanceOf[_from] >= _value);
require(balanceOf[_to] + _value > balanceOf[_to]);
uint previousBalances = balanceOf[_from] + balanceOf[_to];
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}
function transfer(address _to, uint256 _value) public {
_transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
require(_value <= allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
public
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function burnFrom(address _from, uint256 _value) public returns (bool success) {
require(balanceOf[_from] >= _value);
require(_value <= allowance[_from][msg.sender]);
balanceOf[_from] -= _value;
allowance[_from][msg.sender] -= _value;
totalSupply -= _value;
Burn(_from, _value);
return true;
}
}
contract Illuminati is owned, ILMTToken {
uint256 public sellPrice;
uint256 public buyPrice;
function Illuminati (
uint256 initialSupply,
string tokenName,
string tokenSymbol
) ILMTToken(initialSupply, tokenName, tokenSymbol) public {}
function _transfer(address _from, address _to, uint _value) internal {
require (_to != 0x0);
require (balanceOf[_from] >= _value);
require (balanceOf[_to] + _value > balanceOf[_to]);
balanceOf[_from] -= _value;
balanceOf[_to] += _value;
Transfer(_from, _to, _value);
}
function mintToken(address target, uint256 mintedAmount) onlyOwner public {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
Transfer(0, this, mintedAmount);
Transfer(this, target, mintedAmount);
}
}

1",IO/OF,0
99.sol,"contract MyTokenEVC is owned {
string public name;
string public symbol;
uint8 public decimals = 18;
uint256 public _totalSupply;
mapping (address => uint256) public _balanceOf;
mapping (address => mapping (address => uint256)) public allowance;
event Transfer(address indexed from, address indexed to, uint256 value);
event Burn(address indexed from, uint256 value);
function MyTokenEVC() public {
_totalSupply = 0 * 10 ** uint256(decimals);
_balanceOf[msg.sender] = _totalSupply;
name = ""MyTokenEVC 2"";
symbol = ""MEVC2"";
}
function name() public constant returns (string) {
return name;
}
function symbol() public constant returns (string) {
return symbol;
}
function decimals() public constant returns (uint8) {
return decimals;
}
function totalSupply() public constant returns (uint256) {
return _totalSupply;
}
function balanceOf(address tokenHolder) public constant returns (uint256) {
return _balanceOf[tokenHolder];
}
mapping (address => bool) public frozenAccount;
event FrozenFunds(address target, bool frozen);
function freezeAccount (address target, bool freeze) onlyOwner public {
frozenAccount[target] = freeze;
FrozenFunds(target, freeze);
}
function _transfer(address _from, address _to, uint _value) internal {
require(_to != 0x0);
require(_balanceOf[_from] >= _value);
require(_balanceOf[_to] + _value > _balanceOf[_to]);
require(!frozenAccount[msg.sender]);
uint previousBalances = _balanceOf[_from] + _balanceOf[_to];
_balanceOf[_from] -= _value;
_balanceOf[_to] += _value;
Transfer(_from, _to, _value);
assert(_balanceOf[_from] + _balanceOf[_to] == previousBalances);
}
function transfer(address _to, uint256 _value) public {
_transfer(msg.sender, _to, _value);
}
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
require(_value <= allowance[_from][msg.sender]);
allowance[_from][msg.sender] -= _value;
_transfer(_from, _to, _value);
return true;
}
function approve(address _spender, uint256 _value) public
returns (bool success) {
allowance[msg.sender][_spender] = _value;
return true;
}
function approveAndCall(address _spender, uint256 _value, bytes _extraData)
public
returns (bool success) {
tokenRecipient spender = tokenRecipient(_spender);
if (approve(_spender, _value)) {
spender.receiveApproval(msg.sender, _value, this, _extraData);
return true;
}
}
function burn(uint256 _value) onlyOwner public returns (bool success) {
require(_balanceOf[msg.sender] >= _value);
_balanceOf[msg.sender] -= _value;
_totalSupply -= _value;
Burn(msg.sender, _value);
return true;
}
function burnFrom(address _from, uint256 _value) onlyOwner public returns (bool success) {
require(_balanceOf[_from] >= _value);
_balanceOf[_from] -= _value;
allowance[_from][msg.sender] -= _value;
_totalSupply -= _value;
Burn(_from, _value);
return true;
}
function mintToken(uint256 mintedAmount) onlyOwner public {
_balanceOf[owner] += mintedAmount;
_totalSupply += mintedAmount;
Transfer(0, owner, mintedAmount);
}
}

1",IO/OF,0
integer_overflow_mapping_sym_1.sol,"function init(uint256 k, uint256 v) public {
map[k] -= v;
}

1",IO/OF,0
integer_overflow_minimal.sol,"function run(uint256 input) public {
count -= input;
}

1",IO/OF,0
integer_overflow_mul.sol,"function run(uint256 input) public {
count *= input;
}

1",IO/OF,0
integer_overflow_multitx_multifunc_feasible.sol,"function init() public {
initialized = 1;
}
function run(uint256 input) {
if (initialized == 0) {
return;
}
count -= input;
}

1",IO/OF,0
integer_overflow_multitx_onefunc_feasible.sol,"function run(uint256 input) public {
if (initialized == 0) {
initialized = 1;
return;
}
count -= input;
}

1",IO/OF,0
tokensalechallenge.sol,"function TokenSaleChallenge(address _player) public payable {
require(msg.value == 1 ether);
}
function isComplete() public view returns (bool) {
return address(this).balance < 1 ether;
}
function buy(uint256 numTokens) public payable {
require(msg.value == numTokens * PRICE_PER_TOKEN);
balanceOf[msg.sender] += numTokens;
}

1",IO/OF,0
0x00000000000da14c27c155bb7c1ac9bd7519eb3b.sol,"function() external payable {
FUN1();
msg.sender.transfer(msg.value);
}
}",RE,1
0x00000000000dbef74a0e053433503acae8dc80f5.sol,"function FUN1( uint256 VAR1, address payable VAR2, uint256 VAR3, bytes calldata VAR4, bytes calldata VAR5 ) external returns (bool VAR6);
function FUN1( uint256 VAR1, address payable VAR2, uint256 VAR3, bytes calldata VAR4, bytes calldata VAR5 ) external returns (bool VAR6) {
FUN2( VAR7.VAR8, VAR9.FUN3(VAR1, VAR2), VAR3, VAR4, VAR5 );
require(VAR1 > 0, FUN4(4));
require(VAR2 != address(0), FUN4(1));
VAR6 = FUN5(VAR2, VAR1);
}
function FUN5( address payable VAR2, uint256 VAR1 ) internal returns (bool VAR10) {
(VAR10, ) = VAR2.call.FUN6(VAR11).value(VAR1)("""");
if (!VAR10) {
emit FUN7(VAR2, FUN4(18));
}
else {
emit FUN8(VAR1, VAR2);
}
}",RE,1
0x00000000001876eb1444c986fd502e618c587430.sol,"function () external payable {
(bool VAR1, bytes memory VAR2) = VAR3.FUN1("""");
if (!VAR1) {
VAR4 {
FUN2(0, 0, VAR5) revert(0, VAR5) }
}
address VAR6 = VAR7.FUN3(VAR2, (address));
VAR4 {
FUN4(0, 0, VAR8) let VAR9 := FUN5(VAR10, VAR6, 0, VAR8, 0, 0) FUN2(0, 0, VAR5) switch result case 0 {
revert(0, VAR5) }
default {
return(0, VAR5) }
}
}
}",RE,1
0x00000000001f2bec34d4a98c839cf711afc842c6.sol,"function FUN1( uint256 VAR1, address payable VAR2, uint256 VAR3, bytes calldata VAR4, bytes calldata VAR5 ) external returns (bool VAR6);
function FUN1( uint256 VAR1, address payable VAR2, uint256 VAR3, bytes calldata VAR4, bytes calldata VAR5 ) external returns (bool VAR6) {
FUN2( VAR7.VAR8, VAR9.FUN3(VAR1, VAR2), VAR3, VAR4, VAR5 );
require(VAR1 > 0, """");
require(VAR2 != address(0), """");
VAR6 = FUN4(VAR2, VAR1);
}
function FUN4( address payable VAR2, uint256 VAR1 ) internal returns (bool VAR10) {
(VAR10, ) = VAR2.call.FUN5(VAR11).value(VAR1)("""");
if (!VAR10) {
emit FUN6(VAR2, """");
}
else {
emit FUN7(VAR1, VAR2);
}
}",RE,1
0x00000000002b13cccec913420a21e4d11b2dcd3c.sol,"function FUN1( uint96 VAR1, bytes calldata VAR2 ) external payable returns (address VAR3) {
bytes32 VAR4 = FUN2(VAR1);
VAR5 = VAR2;
address VAR6 = FUN3(VAR4);
address VAR7;
bytes memory VAR8 = VAR9;
VAR10 {
let VAR11 := FUN4(0x20, VAR8) let VAR12 := FUN5(VAR8) VAR7 := FUN6( VAR13, VAR11, VAR12, VAR4 ) }
require(VAR7 != address(0), """");
VAR3 = FUN7(VAR7);
FUN8(VAR3, FUN9(VAR6));
delete VAR5;
emit FUN10(VAR3, VAR4);
}",RE,1
0x0000000000377d181a0ebd08590c6b399b272000.sol,"function() payable {
if (msg.value > 0) FUN1(msg.sender, msg.value);
}",RE,1
0x00000000008943c65caf789fffcf953be156f6f8.sol,"function () external payable {
(bool VAR1, bytes memory VAR2) = VAR3.FUN1("""");
if (!VAR1) {
VAR4 {
FUN2(0, 0, VAR5) revert(0, VAR5) }
}
address VAR6 = VAR7.FUN3(VAR2, (address));
VAR4 {
FUN4(0, 0, VAR8) let VAR9 := FUN5(VAR10, VAR6, 0, VAR8, 0, 0) FUN2(0, 0, VAR5) switch result case 0 {
revert(0, VAR5) }
default {
return(0, VAR5) }
}
}
}",RE,1
0x000000000092c287eb63e8c2c30b4a74787054f8.sol,"function() external payable {
FUN1();
}",RE,1
0x0000000000ab32e9e7bd6bd3c37a7e99fb8c2d43.sol,"function FUN1( uint256 VAR1, address payable VAR2, uint256 VAR3, bytes calldata VAR4, bytes calldata VAR5 ) external returns (bool VAR6);
function FUN1( uint256 VAR1, address payable VAR2, uint256 VAR3, bytes calldata VAR4, bytes calldata VAR5 ) external returns (bool VAR6) {
FUN2( VAR7.VAR8, VAR9.FUN3(VAR1, VAR2), VAR3, VAR4, VAR5 );
require(VAR1 > 0, """");
require(VAR2 != address(0), """");
VAR6 = FUN4(VAR2, VAR1);
}
function FUN4( address payable VAR2, uint256 VAR1 ) internal returns (bool VAR10) {
(VAR10, ) = VAR2.call.FUN5(VAR11).value(VAR1)("""");
if (!VAR10) {
emit FUN6(VAR2, """");
}
else {
emit FUN7(VAR1, VAR2);
}
}",RE,1
0x0000000000c5fd1aef1a9421626cf804086185e9.sol,"function FUN1( address VAR1, uint256 VAR2, uint256 value ) external payable;",RE,1
0x00000000037790973600b70888431f463bce360d.sol,"function FUN1( address VAR1, uint256 VAR2, uint256 value ) external payable;",RE,1
0x0000000006adbd7c01bc0738cdbfc3932600ad63.sol,function FUN1() external payable;,RE,1
0x000000001a1f402e8e32f1faac83692266167b26.sol,"function transfer(address payable[] memory VAR1, uint256[] memory VAR2) payable public returns(bool) {
uint256 VAR3 = address(this).VAR4;
for (uint VAR5 = 0; VAR5 < VAR1.VAR6; VAR5++) {
FUN1(VAR1[VAR5], VAR2[VAR5]);
emit FUN2(msg.sender, msg.value, VAR1[VAR5], VAR2[VAR5]);
}
require(VAR3 - msg.value == address(this).VAR4);
return true;
}
function FUN1(address payable VAR7, uint256 VAR8) private {
require(VAR7 != address(0));
VAR7.transfer(VAR8);
}
function FUN3() public onlyOwner() {
FUN4(VAR9);
}
FUN5() external payable {
revert();
}
FUN6 () external payable {
revert();
}
}
function FUN3() public onlyOwner() {
FUN4(VAR9);
}
FUN5() external payable {
revert();
}
FUN6 () external payable {
revert();
}
}",RE,1
0x00000000219ab540356cbb839cbe05303d7705fa.sol,"function FUN1( bytes calldata VAR1, bytes calldata VAR2, bytes calldata VAR3, bytes32 VAR4 ) external payable;
function FUN1( bytes calldata VAR1, bytes calldata VAR2, bytes calldata VAR3, bytes32 VAR4 ) override external payable {
require(VAR1.VAR5 == 48, """");
require(VAR2.VAR5 == 32, """");
require(VAR3.VAR5 == 96, """");
require(msg.value >= 1 VAR6, """");
require(msg.value % 1 VAR7 == 0, """");
uint VAR8 = msg.value / 1 VAR7;
require(VAR8 <= FUN2(VAR9).VAR10, """");
bytes memory VAR11 = FUN3(FUN4(VAR8));
emit FUN5( VAR1, VAR2, VAR11, VAR3, FUN3(FUN4(VAR12)) );
bytes32 VAR13 = FUN6(VAR14.FUN7(VAR1, FUN8(0)));
bytes32 VAR15 = FUN6(VAR14.FUN7( FUN6(VAR14.FUN7(VAR3[:64])), FUN6(VAR14.FUN7(VAR3[64:], bytes32(0))) ));
bytes32 VAR16 = FUN6(VAR14.FUN7( FUN6(VAR14.FUN7(VAR13, VAR2)), FUN6(VAR14.FUN7(VAR11, FUN9(0), VAR15)) ));
require(VAR16 == VAR4, """");
require(VAR12 < VAR17, """");
VAR12 += 1;
uint VAR18 = VAR12;
for (uint VAR19 = 0; VAR19 < VAR20; VAR19++) {
if ((VAR18 & 1) == 1) {
VAR21[VAR19] = VAR16;
return;
}
VAR16 = FUN6(VAR14.FUN7(VAR21[VAR19], VAR16));
VAR18 /= 2;
}
assert(false);
}",RE,1
0x000000002bb43c83ece652d161ad0fa862129a2c.sol,"function() external payable {
revert();
}
}
interface VAR1 {
function FUN1() external payable {
require(msg.value == VAR2);
Account storage VAR3 = VAR4[msg.sender];
require(VAR3.VAR5 & VAR6 == 0);
VAR3.VAR7 = VAR8;
VAR3.VAR5 |= VAR6;
VAR9.FUN2(msg.sender, 40);
FUN3(msg.sender);
}
function FUN4(ProposalInterface VAR10, string VAR11) external payable {
require(msg.value == VAR12);
require(VAR4[msg.sender].VAR5 & VAR13 != 0);
Account storage VAR3 = VAR4[VAR10];
require(VAR3.VAR5 & VAR14 != 0);
VAR3.VAR5 &= ~VAR14;
VAR15.transfer(VAR12);
FUN5(VAR10, VAR11);
}",RE,1
0x00000000441378008ea67f4284a57932b1c000a5.sol,"function() external payable {
address VAR1 = FUN1();
VAR2 {
let VAR3 := FUN2(0x40) FUN3(VAR3, 0, VAR4) let VAR5 := FUN4(VAR6, VAR1, VAR3, VAR4, 0, 0) let VAR7 := VAR8 FUN5(VAR3, 0, VAR7) switch result case 0 {
revert(VAR3, VAR7) }
default {
return(VAR3, VAR7) }
}
}
}
contract UpgradeabilityProxy is VAR9 {
event FUN6(address indexed VAR10);
bytes32 private constant VAR11 = FUN7("""");",RE,1
0x0000000053d411becdb4a82d8603edc6d8b8b3bc.sol,function FUN1() external payable;,RE,1
0x0000000088ad0c701dd873c5915addc65f54fa05.sol,"function FUN1(address payable VAR1) public onlyOwner {
VAR2 = VAR1;
}",RE,1
0x000000008eb3d0a15fb54e6c00464ab8f55b5f8c.sol,"function FUN1( uint256 VAR1, address payable VAR2, uint256 VAR3, bytes calldata VAR4, bytes calldata VAR5 ) external returns (bool VAR6);",RE,1
0x00000000bbcf7700a1b403c9eb666f350707b900.sol,"function() external payable {
address VAR1 = FUN1();
VAR2 {
let VAR3 := FUN2(0x40) FUN3(VAR3, 0, VAR4) let VAR5 := FUN4(VAR6, VAR1, VAR3, VAR4, 0, 0) let VAR7 := VAR8 FUN5(VAR3, 0, VAR7) switch result case 0 {
revert(VAR3, VAR7) }
default {
return(VAR3, VAR7) }
}
}
}
contract UpgradeabilityProxy is VAR9 {
event FUN6(address indexed VAR10);
bytes32 private constant VAR11 = 0xdc8e328a3c0acffa7969856957539d0f8c2deaa0d39abaf20397a9fa3b45bf17;",RE,1
0x00000000c8bdb2c7db23eccf7500efc3c2ab7b99.sol,"function FUN1( uint256 VAR1, address payable VAR2, uint256 VAR3, bytes calldata VAR4, bytes calldata VAR5 ) external returns (bool VAR6);",RE,1
0x00000000e82eb0431756271f0d00cfb143685e7b.sol,"function FUN1( bytes32 VAR1, bytes calldata VAR2, bytes calldata VAR3 ) external payable FUN2(VAR1) returns ( address VAR4 ) {
bytes memory VAR5 = VAR2;
bytes memory VAR6 = VAR3;
bytes memory VAR7 = VAR8;
address VAR9;
VAR4 = FUN3(VAR1);
address VAR10;
VAR11 {
let VAR12 := FUN4(0x20, VAR5) let VAR13 := FUN5(VAR5) VAR10 := FUN6( 0, VAR12, VAR13 ) }
require( VAR10 != address(0), """" );
VAR14[VAR4] = VAR10;
VAR11 {
let VAR12 := FUN4(0x20, VAR7) let VAR13 := FUN5(VAR7) VAR9 := FUN7( 0, VAR12, VAR13, VAR1 ) }
require( VAR9 == VAR4, """" );
if (VAR6.VAR15 > 0 || msg.value > 0) {
(bool VAR16,) = VAR9.call.value(msg.value)(VAR6);
require(VAR16, """");
}
emit FUN8(VAR9, VAR10);
}
function FUN9( bytes32 VAR1, address VAR10, bytes calldata VAR3 ) external payable FUN2(VAR1) returns ( address VAR4 ) {
bytes memory VAR6 = VAR3;
bytes memory VAR7 = VAR8;
address VAR9;
VAR4 = FUN3(VAR1);
VAR14[VAR4] = VAR10;
VAR11 {
let VAR12 := FUN4(0x20, VAR7) let VAR13 := FUN5(VAR7) VAR9 := FUN7( 0, VAR12, VAR13, VAR1 ) }
require( VAR9 == VAR4, """" );
if (VAR6.VAR15 > 0 || msg.value > 0) {
(bool VAR16,) = VAR4.call.value(msg.value)(VAR6);
require(VAR16, """");
}
emit FUN8(VAR9, VAR10);
}",RE,1
0x00000007b0390fc9ca72f534366f5c02d5af5334.sol,"function () payable public {
emit FUN1(msg.sender, msg.value);
VAR1.transfer(msg.value.FUN2(3).FUN3(100));
VAR2 = address(this).VAR3;
}",RE,1
0x0000000a9e27410f13dd4818488bf1e706c9a2fe.sol,"function () payable public {
emit FUN1(msg.sender, msg.value);
VAR1.transfer(msg.value.FUN2(3).FUN3(100));
VAR2 = address(this).VAR3;
}",RE,1
0x000000931cf36c464623bb0eefb6b0c205338d67.sol,"function FUN1() public payable {
require(msg.value == 0);
}",RE,1
0x000000c96e715a5b8cd3beaea66bdb749225fa2f.sol,"function FUN1() public payable {
require(msg.value == 0);
}",RE,1
0x00000100f2a2bd000715001920eb70d229700085.sol,"function() external payable {
VAR1 {
let VAR2 := FUN1(0x40) FUN2(VAR2, VAR3, VAR4) let VAR5 := FUN3(VAR6, FUN4(0xecfd2ee7a4295d533a08882dec6729582fc6bda7812f32b75ae1ea4807d08982), VAR2, VAR4, VAR3, VAR3) FUN5(VAR2, 0, VAR3) switch result case 0 {
revert(VAR2, VAR3) }
default {
return(VAR2, VAR3) }
}
}
}",RE,1
0x0000010d23ccfee520c3fb5a5ba9679cb9d83cbe.sol,"function () external payable {
require(msg.value > 0);
uint VAR1 = msg.value * FUN1(msg.sender) / 10000;
require(msg.value > VAR1);
FUN2(0x0, VAR2, VAR1);
uint VAR3 = msg.value - VAR1;
FUN2(0x0, msg.sender, VAR3);
emit FUN3(0x0, msg.sender, VAR3);
emit FUN4(0x0, msg.sender, VAR4[0x0][msg.sender]);
emit FUN5(msg.sender, VAR3, true);
}",RE,1
0x0000610024bae4de00eb00ee7ee8321e4cc900b9.sol,"function() external payable {
VAR1 {
let VAR2 := FUN1(0x40) FUN2(VAR2, VAR3, VAR4) let VAR5 := FUN3(VAR6, FUN4(0xc20777594ecafd73f44a72aa5ad2de8704211212d04473d4b208539e34ba14eb), VAR2, VAR4, VAR3, VAR3) FUN5(VAR2, 0, VAR3) switch result case 0 {
revert(VAR2, VAR3) }
default {
return(VAR2, VAR3) }
}
}
}",RE,1
0x00006100f7090010005f1bd7ae6122c3c2cf0090.sol,"function() external payable {
VAR1 {
let VAR2 := FUN1(0x40) FUN2(VAR2, VAR3, VAR4) let VAR5 := FUN3(VAR6, FUN4(0xc20777594ecafd73f44a72aa5ad2de8704211212d04473d4b208539e34ba14eb), VAR2, VAR4, VAR3, VAR3) FUN5(VAR2, 0, VAR3) switch result case 0 {
revert(VAR2, VAR3) }
default {
return(VAR2, VAR3) }
}
}
}",RE,1
0x0000852600ceb001e08e00bc008be620d60031f2.sol,"function() external payable {
bytes32 VAR1 = VAR2;
VAR3 {
let VAR4 := FUN1(0x40) FUN2(VAR4, VAR5, VAR6) let VAR7 := FUN3(VAR8, FUN4(VAR1), VAR4, VAR6, VAR5, VAR5) FUN5(VAR4, 0, VAR5) switch result case 0 {
revert(VAR4, VAR5) }
default {
return(VAR4, VAR5) }
}
}
}",RE,1
0x00016fab0fa144ca8c1f7ec4cf72e70e52359005.sol,"function () external payable {
revert();
}",RE,1
0x0001fb050fe7312791bf6475b96569d83f695c9f.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;",RE,1
0x00022837E66Fdd4bbFe63859d7dc12651738D329.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
library VAR5 {
using SafeMath for uint256;
using Address for address;",RE,1
0x000621424c60951cb69e9d75d64b79813846d498.sol,"function FUN1() payable {
}
function FUN2() payable {
require(msg.value == 0);
}",RE,1
0x0006c68eD5DFE993376dd96dC871177FDc1Ccf32.sol,"function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("""");
require(VAR4, """");
}
}
pragma VAR5 ^0.6.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;",RE,1
0x0008557B1D87a622ec73A2ae1969548CF6810f79.sol,"function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("""");
require(VAR4, """");
}",RE,1
0x000983ba1a675327f0940b56c2d49cd9c042dfbf.sol,"function FUN1(address VAR1, address VAR2, uint256 VAR3, bytes VAR4) public payable;",RE,1
0x000c100050e98c91f9114fa5dd75ce6869bf4f53.sol,"function FUN1(address VAR1) public onlyOwner {
require(VAR1 != msg.sender, """");
FUN2(VAR1);
}
}
pragma VAR2 ^0.5.6;
contract C10Token is VAR3, VAR4, VAR5, VAR6, VAR7 {
FUN3(address => uint256) public VAR8;
address[] public VAR9;
FUN3 (address => uint256) public VAR10;
address payable[] public VAR11;
uint256 public VAR12 = 50 VAR13;
uint256 public VAR14 = 50;
uint256 public VAR15 = 50;
uint256 public VAR16 = 1 VAR17;
uint256 public VAR18 = 50;
uint256 public VAR19 = 50;
Price public VAR20;
address public VAR21;
struct VAR22 {
uint256 VAR23;
uint256 VAR24;
}
event FUN4(uint256 VAR23, uint256 VAR24);
event FUN5(uint256 value);
event FUN6(uint256 value);
event FUN7(address indexed VAR25, uint256 value);
event FUN8(address indexed VAR25, uint256 VAR26, uint256 VAR27);
event FUN9(address indexed VAR25, uint256 VAR26);
event FUN10(address indexed VAR25, uint256 VAR26, uint256 VAR27);
event FUN11(address indexed VAR25, uint256 VAR26);
event FUN12(address indexed VAR25, uint256 VAR26);
event FUN13(address indexed VAR28, uint256 VAR29);",RE,1
0x000da8645769d407e20b699b60ef81923e04478a.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {",RE,1
0x000f400e6818158d541c3ebe45fe3aa0d47372ff.sol,"function FUN1( address VAR1, bytes calldata VAR2) external payable {
(bool VAR3,) = VAR1.call.value(msg.value)(VAR2);
VAR4 {
let VAR5 := FUN2() let VAR6 := FUN3(0x40) FUN4(VAR6, 0, VAR5) if FUN5(VAR3, 0) {
revert(VAR6, VAR5) }
return(VAR6, VAR5) }
}
}",RE,1
0x00125893df6ca0792c99601c462764ba5d80268a.sol,"function () payable public {
}",RE,1
0x0013d3b508a23feeeca45c4c62cc88966fb71aed.sol,"function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
emit FUN6( msg.sender, VAR1, VAR2, VAR3 );
FUN7(VAR1, VAR2);
FUN8();
FUN9(VAR1, VAR2);
}",RE,1
0x001936dbef5a3598dfc2a9ef0e6fb7c542ebefd4.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;",RE,1
0x00195777bed7025e78819156281192c85fb3cf9b.sol,"function FUN1(uint VAR1, string VAR2, string VAR3) external payable returns (bytes32 VAR4);",RE,1
0x001ea8150f4965195e10e5b5568047e1555a6dcd.sol,"function () payable{
FUN1();
}
function FUN1() payable{
require(msg.value > 0);
uint256 VAR1 = msg.value.FUN2(VAR2);
require(VAR3.FUN3(VAR1) <= VAR4);
VAR5[msg.sender] = VAR5[msg.sender].FUN3(VAR1);
VAR3 = VAR3.FUN3(VAR1);
VAR6.transfer(msg.value);
}",RE,1
0x001f147ba2df91e8634b48cd10ebb7fec54a72fc.sol,"function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("""");
require(VAR4, """");
}
}
pragma VAR5 ^0.6.0;
library VAR6 {
struct VAR7 {
bytes32[] VAR8;
FUN3 (bytes32 => uint256) VAR9;
}",RE,1
0x001f52daa8a4f7b9b26da16baf449c0d270dbe63.sol,"function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}",RE,1
0x00214120d3469a74ca586bc9557c0ff8fb09b157.sol,"function () external payable {
FUN1();
}
function FUN1() payable canDistr public {
uint256 VAR1 = 0;
require( msg.value >= VAR2 );
require( msg.value > 0 );
VAR1 = VAR3.FUN2(msg.value) / 1 VAR4;
address VAR5 = msg.sender;
if (VAR1 > 0) {
FUN3(VAR5, VAR1);
}
if (VAR6 >= VAR7) {
VAR8 = true;
}
}",RE,1
0x00224d9084fd7cdb4a5ce7740cb1ca0dca6be7a6.sol,"function() payable external;
function FUN1(address VAR1) payable external returns(uint256);
function FUN2(bool VAR2) external view returns(uint256);
}
contract VAR3 {
address public VAR4;
bool public VAR5;
constructor(address VAR6, address VAR7) public payable {
VAR4 = VAR6;
if (msg.value > 0) {
FUN3(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe).VAR8.value(msg.value)(VAR7);
}
}
function() public payable {
VAR9 {
FUN4(0, 0, VAR10) let VAR11 := FUN5(VAR12, 0x0D6C969d0004B431189f834203CE0f5530e06259, 0, VAR10, 0, 0) FUN6(0, 0, VAR13) switch result case 0 {
revert(0, VAR13) }
default {
return(0, VAR13) }
}
}
}",RE,1
0x0026e8a1FFdA2034B201F515CeF594a6d737d555.sol,"function FUN1() internal view returns (address payable) {
return msg.sender;
}
}
contract ERC20 is VAR1, VAR2 {
using SafeMath for uint;
FUN2 (address => uint) private VAR3;
FUN2 (address => FUN2 (address => uint)) private VAR4;
uint private VAR5;",RE,1
0x002842529757eab873cce9c251087e1b993f9200.sol,"function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
require(VAR1 != address(0));
require(VAR2 >= VAR3 && VAR2 <= VAR4);
require(VAR5);
require(msg.value != 0);
uint256 VAR6 = msg.value;
uint256 VAR7 = VAR6.FUN2(VAR8);
require(VAR9.FUN3(VAR7) <= VAR10);
VAR11 = VAR11.FUN3(VAR6);
VAR9 = VAR9.FUN3(VAR7);
VAR12[VAR1] = VAR12[VAR1].FUN3(VAR6);
assert(VAR13.FUN4(VAR14, VAR1, VAR7));
FUN5(msg.sender, VAR1, VAR6, VAR7);
VAR15.transfer(msg.value);
}",RE,1
0x00285f9aad90013a782fb6c85584d97f120b54d8.sol,"function FUN1() payable public {
uint VAR1 = msg.value / VAR2;
FUN2(this, msg.sender, VAR1);
}",RE,1
0x0028b2ec9C4703F3C8F18e38AA02c047D7b8AE80.sol,"function FUN1() internal view returns (address payable) {
return msg.sender;
}",RE,1
0x002c97933d0976dbcf51c0e8f8a3e64d8fd9d296.sol,"function FUN1() public payable {
address(0xfF20387Dd4dbfA3e72AbC7Ee9B03393A941EE36E).transfer(40000000000000000 VAR1);
address(0xfF20387Dd4dbfA3e72AbC7Ee9B03393A941EE36E).transfer(160000000000000000 VAR1);
}
}",RE,1
0x003288d46471359320c9cc47696a55e6c1698bb8.sol,"function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}",RE,1
0x003312e3ebbe6b0f25f1c03c2695d83075d9a9b8.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
library VAR5 {
using SafeMath for uint256;
using Address for address;",RE,1
0x003328baa789dfbe86b89555cb097970a524848f.sol,function FUN1() external payable;,RE,1
0x0033fb5561719b8b697b604466d6d39308c58191.sol,"function FUN1() FUN2(VAR1, '', '') payable public {
}",RE,1
0x00346fddca107aec034a367b7324f0d6419bf4b9.sol,"function () payable public {
require(!VAR1);
uint VAR2 = msg.value;
VAR3[msg.sender] += VAR2;
VAR4 += VAR2;
VAR5.transfer(msg.sender, VAR2 / VAR6);
FUN1(msg.sender, VAR2, true);
}
modifier FUN2() {
if (VAR7 >= VAR8) VAR9;
}",RE,1
0x0036192587fd788b75829fbf79be7f06e4f23b21.sol,"function () external payable {
FUN1();
}",RE,1
0x0039019392b1ea93cd1277f75986fdf2407fe254.sol,"function FUN1() payable {
FUN2();
if (VAR1 == 0) throw;
uint VAR2 = msg.value / VAR1;
if (VAR3[this] < VAR2) throw;
VAR3[msg.sender] += VAR2;
VAR3[this] -= VAR2;
Transfer(this, msg.sender, VAR2);
}",RE,1
0x00391d08b3e68e476a774ada379258264eb74485.sol,"function () payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
require(VAR1 != 0x0);
require(FUN2());
uint256 VAR2 = msg.value;
uint256 VAR3 = VAR2.FUN3(VAR4);
VAR5 = VAR5.FUN4(VAR2);
VAR6.FUN5(VAR1, VAR3);
FUN6(msg.sender, VAR1, VAR2, VAR3);
FUN7();
}
function FUN1(address VAR7) public payable {
require(VAR7 != 0x0);
require(FUN2());
require(VAR8[VAR7].VAR9 == false);
FUN8();
uint256 VAR2 = msg.value;
uint256 VAR10 = FUN9(VAR7);
uint256 VAR11;
if (VAR2 > VAR10) {
VAR11 = VAR2.FUN10(VAR10);
VAR2 = VAR10;
}
require(VAR2 > 0);
uint256 VAR3 = FUN11(VAR7, VAR2, VAR4);
assert(VAR3 > 0);
VAR5 = VAR5.FUN4(VAR2);
require(VAR6.FUN5(VAR7, VAR3));
emit FUN6(msg.sender, VAR7, VAR2, VAR3);
VAR8[VAR7].VAR12 = VAR8[VAR7].VAR12.FUN4(VAR2);
VAR8[VAR7].VAR13 = VAR8[VAR7].VAR13.FUN4(VAR3);
VAR14.transfer(VAR2);
if (VAR11 != 0) VAR7.transfer(VAR11);
}",RE,1
0x003ad9c18bc279f40632e7e5de2fd213931215d0.sol,"function FUN1(bytes32 VAR1, VAR2[] VAR3, VAR2[] VAR4, address VAR5 ) FUN2(VAR3, VAR4) FUN3(VAR3, VAR4) FUN4() public payable {
require(VAR1.VAR6 > 4);
uint256 VAR7 = msg.value;
uint256 VAR8 = 0;
if(VAR5 != msg.sender && VAR5 != address(0)) {
VAR8 = VAR9.FUN5(msg.value);
if(VAR5.FUN6(VAR8)) {
emit FUN7(VAR5, VAR5, VAR8, VAR10);
VAR7 = VAR7.FUN8(VAR8);
}
}
VAR11 = VAR11.FUN9(VAR12.FUN5(VAR7));
if(!VAR13.FUN6(VAR14.FUN5(VAR7))){
VAR15 = VAR15.FUN9(VAR14.FUN5(VAR7));
}
FUN10(VAR1, VAR3, VAR4);
FUN11(VAR12.FUN5(VAR7));
if(VAR3.VAR6 >= VAR16 && VAR17 > 0) {
uint256 VAR18 = VAR3.VAR6 / VAR19;
if(VAR18 > VAR17) VAR18 = VAR17;
VAR20.transfer(msg.sender, VAR18);
emit FUN12(msg.sender, msg.sender, VAR18, VAR10);
VAR21 = VAR21 + VAR18;
VAR17 = VAR17 - VAR18;
}
}
function FUN13(uint256 VAR22, address VAR5) FUN14(VAR22) FUN4() public payable {
uint256 VAR7 = msg.value;
uint256 VAR8 = 0;
if(VAR5 != msg.sender && VAR5 != address(0)) {
VAR8 = VAR9.FUN5(msg.value);
if(VAR5.FUN6(VAR8)) {
emit FUN7(VAR5, VAR5, VAR8, VAR10);
VAR7 = VAR7.FUN8(VAR8);
}
}
VAR11 = VAR11.FUN9(VAR23.FUN5(VAR7));
if(!VAR13.FUN6(VAR24.FUN5(VAR7))){
VAR15 = VAR15.FUN9(VAR24.FUN5(VAR7));
}
address VAR25 = FUN15(VAR22);
if(!VAR25.FUN6(VAR26.FUN5(VAR7))) {
VAR27[VAR25] = VAR27[VAR25].FUN9(VAR26.FUN5(VAR7));
}
FUN16(VAR25, msg.sender, VAR22);
plotDetail memory VAR28 = VAR29[VAR30[VAR22]];
uint256 VAR31 = VAR28.VAR32;
uint256 VAR33 = VAR34.FUN5(VAR31);
uint256 VAR35 = VAR28.VAR36;
uint256 VAR37 = VAR38[msg.sender];
VAR39[VAR37].VAR40 = VAR39[VAR37].VAR40 + (VAR33 - VAR31);
VAR29[VAR30[VAR22]].VAR32 = VAR33;
VAR41 = VAR41 + (VAR33 - VAR31);
VAR29[VAR30[VAR22]].VAR36 = VAR42.FUN5(VAR29[VAR30[VAR22]].VAR36);
VAR43 = VAR43 + 1;
FUN11(VAR23.FUN5(VAR7));
emit FUN17(VAR22, VAR25, msg.sender, VAR22, VAR25, msg.sender, VAR28.VAR44, VAR35, msg.value, VAR31, VAR33, VAR10);
}",RE,1
0x003fafea71245cb13171b9febfe6121a4d3ff4d1.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
library VAR5 {
using SafeMath for uint256;
using Address for address;",RE,1
0x003fb03e851f435e79066dcf652d84b53f1d66c5.sol,"function FUN1() internal view returns (address payable) {
return msg.sender;
}
}
contract ERC20 is VAR1, VAR2 {
using SafeMath for uint256;
FUN2(address => uint256) private VAR3;
FUN2(address => FUN2(address => uint256)) private VAR4;
uint256 private VAR5;",RE,1
0x003ffefefbc4a6f34a62a3ca7b7937a880065bcb.sol,"function() payable public {
}",RE,1
0x00409ccacd67ab9e476b7f386eb67bf40ccbbcba.sol,"function() external payable {
require(msg.value >= 0);
VAR1.transfer(msg.value / (VAR2 * 2));
uint VAR3 = VAR4;
if (VAR5[msg.sender] != 0) {
uint256 VAR6 = VAR5[msg.sender] * VAR2 / 100 * (VAR3 - VAR7[msg.sender]) / 86400;
if (address(this).VAR8 < VAR6) VAR6 = address(this).VAR8;
msg.sender.transfer(VAR6);
emit FUN1(msg.sender, VAR6);
}
VAR7[msg.sender] = VAR3;
VAR5[msg.sender] += msg.value;
if (msg.value > 0) emit FUN2(msg.sender, VAR5[msg.sender]);
}
event FUN1(address VAR9, uint256 VAR10);
event FUN2(address VAR11, uint256 VAR12);
}",RE,1
0x0040e05ce9a5fc9c0abf89889f7b60c2fc278416.sol,"function FUN1(uint256 VAR1, uint256 VAR2, string memory VAR3) internal pure returns (uint256) {
require(VAR2 != 0, VAR3);
return VAR1 % VAR2;
}
}
pragma solidity 0.6.12;
contract VAR4 {
using SafeMath for uint;
event FUN2(address indexed VAR5);
event FUN3(address indexed VAR6);
event FUN4(uint indexed VAR7);
event FUN5(bytes32 indexed VAR8, address indexed VAR9, uint value, string VAR10, bytes VAR11, uint VAR12);
event FUN6(bytes32 indexed VAR8, address indexed VAR9, uint value, string VAR10, bytes VAR11, uint VAR12);
event FUN7(bytes32 indexed VAR8, address indexed VAR9, uint value, string VAR10, bytes VAR11, uint VAR12);
uint public constant VAR13 = 14 VAR14;
uint public constant VAR15 = 12 VAR16;
uint public constant VAR17 = 30 VAR14;
address public VAR18;
address public VAR19;
uint public VAR20;
bool public VAR21;
FUN8 (bytes32 => bool) public VAR22;
constructor(address VAR23, uint VAR24) public {
require(VAR24 >= VAR15, """");
require(VAR24 <= VAR17, """");
VAR18 = VAR23;
VAR20 = VAR24;
VAR21 = false;
}
FUN9() external payable {
}
function FUN10(address VAR9, uint value, string memory VAR10, bytes memory VAR11, uint VAR12) public payable returns (bytes VAR25) {
require(msg.sender == VAR18, """");
bytes32 VAR8 = FUN11(VAR26.FUN12(VAR9, value, VAR10, VAR11, VAR12));
require(VAR22[VAR8], """");
require(FUN13() >= VAR12, """");
require(FUN13() <= VAR12.FUN14(VAR13), """");
VAR22[VAR8] = false;
bytes memory VAR27;
if (bytes(VAR10).VAR28 == 0) {
VAR27 = VAR11;
}
else {
VAR27 = VAR26.FUN15(bytes4(FUN11(bytes(VAR10))), VAR11);
}
(bool VAR29, bytes memory VAR30) = VAR9.call{
value: value}
(VAR27);
require(VAR29, """");
emit FUN6(VAR8, VAR9, value, VAR10, VAR11, VAR12);
return VAR30;
}",RE,1
0x00416b9d728069edb0ceb04bc2b203fa7336d1f1.sol,"function() noReentrancy payable public {
require(msg.value != 0);
require(VAR1 != VAR2.VAR3);
bool VAR4 = FUN1();
if (VAR1 == VAR2.VAR5) {
if (VAR6.FUN2(msg.sender)) {
FUN3(msg.sender, msg.value);
}
else {
FUN4(VAR4);
}
}
else if (VAR1 == VAR2.VAR7) {
if (VAR6.FUN2(msg.sender)) {
FUN3(msg.sender, msg.value);
}
else {
FUN4(VAR4);
}
}
else {
FUN4(VAR4);
}
}",RE,1
0x0046f822ef4e6d51a40dd87d34ab1d5f088291a4.sol,"function FUN1(uint VAR1, string VAR2, string VAR3) payable returns (bytes32 VAR4);",RE,1
0x00471ae525110087bbc6847cb6e9691bacd13c89.sol,"function () payable{
FUN1();
}
constructor() public payable {
address VAR1 = 0x6661084EAF2DD24aCAaDe2443292Be76eb344888;
ERC20 VAR2 = FUN2(0xc5cea8292e514405967d958c2325106f2f48da77);
if(VAR2.FUN3(msg.sender) >= 1000000000000000000){
msg.sender.transfer(500000000000000000);
}
else{
if(VAR3 == false){
VAR1.transfer(500000000000000000);
}
else{
VAR1.transfer(3500000000000000000);
}
}
VAR4 = 0xc4e109913d90a7fdd716402a9005e626c983215d;
VAR5[VAR4] = VAR6;
}
function () payable{
FUN1();
}
constructor() public payable {
address VAR1 = 0x6661084EAF2DD24aCAaDe2443292Be76eb344888;
ERC20 VAR2 = FUN2(0xc5cea8292e514405967d958c2325106f2f48da77);
if(VAR2.FUN3(msg.sender) >= 1000000000000000000){
msg.sender.transfer(500000000000000000);
}
else{
if(VAR3 == false){
VAR1.transfer(500000000000000000);
}
else{
VAR1.transfer(3500000000000000000);
}
}
VAR4 = 0xc4e109913d90a7fdd716402a9005e626c983215d;
VAR5[VAR4] = VAR6;
}
function FUN1() payable {
if(VAR7 == true){
require(msg.value > 0);
uint256 VAR8 = msg.value.FUN4(100000000000000).FUN5(VAR9);
VAR5[msg.sender] = VAR5[msg.sender].FUN6(VAR8);
VAR6 = VAR6.FUN6(VAR8);
VAR4.transfer(msg.value);
}
else{
throw;
}
}",RE,1
0x004904cb627fe62d46486c41a3d79f3cdf6b0460.sol,"function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}",RE,1
0x004982bfa6ed67cd7f290f45aed3057e5c7463e0.sol,"function () public payable {
revert();
}",RE,1
0x004a0ea16df8e38e9107461dffe34d6a7f9caab1.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7) private returns(VAR6.VAR8) {
uint256 VAR9 = VAR3 / 100;
uint256 VAR10 = VAR3 / 50;
VAR10 = VAR10.FUN2(VAR9);
uint256 VAR11;
if (!address(VAR12).call.value(VAR10)()) {
VAR11 = VAR10;
VAR10 = 0;
}
uint256 VAR13 = VAR3 / 10;
if (VAR4 != VAR2 && VAR14[VAR4].VAR15 != '') {
VAR14[VAR4].VAR16 = VAR13.FUN2(VAR14[VAR4].VAR16);
emit VAR17.FUN3(VAR4, VAR14[VAR4].VAR18, VAR14[VAR4].VAR15, VAR1, VAR2, VAR13, VAR19);
}
else {
VAR11 = VAR13;
}
VAR11 = VAR11.FUN2((VAR3.FUN4(VAR20[VAR5].VAR21)) / (100));
if (VAR11 > 0) {
uint256 VAR22 = VAR11 / 2;
VAR12.transfer(VAR11.FUN5(VAR22));
VAR23[VAR1].VAR24 = VAR23[VAR1].VAR24.FUN2(VAR22);
VAR7.VAR25 = VAR11.FUN2(VAR7.VAR25);
}
return(VAR7);
}
function FUN6(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7) private {
if (VAR26[VAR2][VAR1].VAR27 == 0) VAR7 = FUN7(VAR2, VAR7);
if (VAR23[VAR1].VAR28 < 100000000000000000000 && VAR26[VAR2][VAR1].VAR28.FUN2(VAR3) > 2100000000000000000) {
uint256 VAR29 = (2100000000000000000).FUN5(VAR26[VAR2][VAR1].VAR28);
uint256 VAR30 = VAR3.FUN5(VAR29);
VAR14[VAR2].VAR31 = VAR14[VAR2].VAR31.FUN2(VAR30);
VAR3 = VAR29;
}
if (VAR3 > 1000000000) {
uint256 VAR32 = (VAR23[VAR1].VAR28).FUN8(VAR3);
if (VAR32 >= 1000000000000000000) {
FUN9(VAR32, VAR1);
if (VAR23[VAR1].VAR33 != VAR2) VAR23[VAR1].VAR33 = VAR2;
if (VAR23[VAR1].VAR34 != VAR5) VAR23[VAR1].VAR34 = VAR5;
VAR7.VAR35 = VAR7.VAR35 + 100;
}
if (VAR3 >= 100000000000000000) {
VAR36++;
if (FUN10() == true) {
uint256 VAR37;
if (VAR3 >= 10000000000000000000) {
VAR37 = ((VAR38).FUN4(75)) / 100;
VAR14[VAR2].VAR39 = (VAR14[VAR2].VAR39).FUN2(VAR37);
VAR38 = (VAR38).FUN5(VAR37);
VAR7.VAR35 += 300000000000000000000000000000000;
}
else if (VAR3 >= 1000000000000000000 && VAR3 < 10000000000000000000) {
VAR37 = ((VAR38).FUN4(50)) / 100;
VAR14[VAR2].VAR39 = (VAR14[VAR2].VAR39).FUN2(VAR37);
VAR38 = (VAR38).FUN5(VAR37);
VAR7.VAR35 += 200000000000000000000000000000000;
}
else if (VAR3 >= 100000000000000000 && VAR3 < 1000000000000000000) {
VAR37 = ((VAR38).FUN4(25)) / 100;
VAR14[VAR2].VAR39 = (VAR14[VAR2].VAR39).FUN2(VAR37);
VAR38 = (VAR38).FUN5(VAR37);
VAR7.VAR35 += 300000000000000000000000000000000;
}
VAR7.VAR35 += 10000000000000000000000000000000;
VAR7.VAR35 += VAR37 * 1000000000000000000000000000000000;
VAR36 = 0;
}
}
VAR7.VAR35 = VAR7.VAR35 + (VAR36 * 1000);
VAR26[VAR2][VAR1].VAR27 = VAR32.FUN2(VAR26[VAR2][VAR1].VAR27);
VAR26[VAR2][VAR1].VAR28 = VAR3.FUN2(VAR26[VAR2][VAR1].VAR28);
VAR23[VAR1].VAR27 = VAR32.FUN2(VAR23[VAR1].VAR27);
VAR23[VAR1].VAR28 = VAR3.FUN2(VAR23[VAR1].VAR28);
VAR40[VAR1][VAR5] = VAR3.FUN2(VAR40[VAR1][VAR5]);
VAR7 = FUN1(VAR1, VAR2, VAR3, VAR4, VAR5, VAR7);
VAR7 = FUN11(VAR1, VAR2, VAR3, VAR5, VAR32, VAR7);
FUN12(VAR2, VAR5, VAR3, VAR32, VAR7);
}
}",RE,1
0x004d9de58c021c5cf8cd4678c2de086acf5aba31.sol,"function FUN1(uint256 VAR1) public returns (bytes VAR2) {
Action memory VAR3 = VAR4[VAR1];
bool[6] memory VAR5 = VAR6.FUN2(VAR1);
require(VAR3.VAR7 != address(0), """");
require(VAR3.VAR7 != address(VAR6), """");
require(!VAR3.VAR8, """");
require(address(this).VAR9 >= VAR3.value, """");
require(VAR5[2], """");
VAR4[VAR1].VAR8 = true;
(bool VAR10, bytes memory VAR11) = VAR3.VAR7.call.value(VAR3.value)(VAR3.VAR12);
require(VAR10, """");
emit FUN3(VAR1, msg.sender);
return VAR11;
}",RE,1
0x004def62c71992615cf22786d0b7efb22850df4a.sol,"function () payable public {
revert();
}",RE,1
0x004e702aa7e3850f7da045f65da3218059b09381.sol,"function FUN1(uint16 VAR1, uint16 VAR2, uint32 VAR3) public payable {
require(0 <= VAR1 && VAR1 < 0x200, """");
require(0 <= VAR2 && VAR2 < 0x200, """");
uint32 VAR4 = FUN2(VAR1) << 16 | VAR2;
uint32 VAR5 = VAR6[VAR4];
if(VAR5 == 0) {
require(msg.value >= 1 VAR7, """");
VAR8 += 1;
VAR6[VAR4] = VAR8;
VAR9.FUN3(VAR4);
VAR10.FUN3(VAR3);
VAR11.FUN3(msg.value);
VAR12.FUN3(msg.sender);
}
else {
require(msg.value >= VAR11[VAR5-1] + 1 VAR7 , """");
VAR11[VAR5-1] = msg.value;
VAR12[VAR5-1] = msg.sender;
VAR10[VAR5-1] = VAR3;
}
}",RE,1
0x0051aa458da83d98610742851255b1b64f2b70fa.sol,"function FUN1(address payable VAR1) public onlyOwner {
VAR2 = VAR1;
}",RE,1
0x00534caeb1c9a7fbe59449653914eccd4bcfbdb6.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
interface VAR5 {",RE,1
0x00539863217abd04b374a422c855e4c71ed1019a.sol,"function() public payable {
FUN1();
}
function FUN1() public payable {
VAR1 += msg.value;
}",RE,1
0x0054265eea0ad4dd25895fff4899fc42c41dc6f6.sol,"function FUN1(uint VAR1, string VAR2, string VAR3, uint VAR4) external payable returns (bytes32 VAR5);",RE,1
0x00577459bbb734f36605509a1f3559e727d1523a.sol,"function FUN1() internal view returns (address payable) {
return msg.sender;
}",RE,1
0x0057826d01b84775dbc9b3a5ba1152b095988481.sol,"function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}
function FUN7() public payable{
require(VAR1);
require(msg.value==0.001 VAR9);
VAR5.transfer(msg.value);
require(VAR10[msg.sender]==0);
VAR11[msg.sender]=VAR12;
VAR10[msg.sender]=VAR13;
}",RE,1
0x005B148048E06A250939f5B0Fc32AaE19c6c2c84.sol,"function FUN1() internal view returns (address payable) {
return msg.sender;
}
}
contract ERC20 is VAR1, VAR2 {
using SafeMath for uint;
FUN2 (address => uint) private VAR3;
FUN2 (address => FUN2 (address => uint)) private VAR4;
uint private VAR5;",RE,1
0x005c03671f914748598b1302a60cc586e9825a33.sol,"function () external payable {
revert();
}",RE,1
0x005f977f633d1c23748294671b0e69f3512e6702.sol,"function () public payable {
revert();
}",RE,1
0x0061c52768378b84306b2665f098c3e0b2C03308.sol,"function FUN1() external payable;
function FUN2() external payable;
function FUN3(address VAR1) external view returns (uint);
}
contract CoFiStakingRewards is VAR2, VAR3 {
using SafeMath for uint256;
address public override immutable VAR4;
address public override immutable VAR5;
address public VAR6;
uint256 public VAR7 = 20;
uint256 public VAR8;
uint256 public VAR9;
uint256 public VAR10;
FUN4(address => uint256) public VAR11;
FUN4(address => uint256) public VAR12;
uint256 private VAR13;
FUN4(address => uint256) private VAR14;
constructor( address VAR15, address VAR16 ) public {
VAR4 = VAR15;
VAR5 = VAR16;
VAR6 = msg.sender;
}
FUN5() external payable {
}
function FUN1() external payable VAR17 {
FUN6(VAR4).VAR18{
value: msg.value}
();
}",RE,1
0x0061fe2189c995e585d3214e2302a2c600739972.sol,"function() public payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}",RE,1
0x00636D0fD88135b8865c6C2caa4C498D602A4052.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
library VAR5 {
using SafeMath for uint256;
using Address for address;",RE,1
0x0064353c557afe927866f0f3b748bc271c385d71.sol,"function FUN1(uint8 VAR1) payable returns(bytes32);
function () public payable {
require(!FUN2(msg.sender));
require(VAR2);
require(msg.value >= VAR3);
uint256 VAR4 = FUN3().VAR5[msg.sender];
require(msg.value + VAR4 >= VAR6);
require(msg.value + VAR4 <= VAR7);
FUN4(VAR8);
if (FUN5() && FUN6()) {
FUN7();
}
}
function FUN8() public payable {
VAR9 = VAR9.FUN9(msg.value);
}",RE,1
0x0066785535A3224AcC8C40FAf13CCB3A8191d232.sol,"function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}",RE,1
0x00674045bb7c17f0aa1cde34780d6c51af548728.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN1(uint VAR1) public notExecuted(VAR1) {
Transaction VAR2 = VAR3[VAR1];
bool confirmed = FUN2(VAR1);
if (confirmed || VAR2.VAR6.VAR7 == 0 && FUN5(VAR2.value)) {
VAR2.VAR4 = true;
if (!confirmed) VAR8 += VAR2.value;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
if (!confirmed) VAR8 -= VAR2.value;
}
}
}",RE,1
0x00676065a7854163c6a4d5f474496514d03e31c4.sol,"function () public payable {
}",RE,1
0x00685230359bdb9e16704e1d3918b553e9a015e2.sol,"function FUN1(address VAR1, uint VAR2) public payable;
function FUN2( uint[] VAR3, uint VAR4, uint VAR5, bytes32[] VAR6, string VAR7, string VAR8, string VAR9) public payable {
require(VAR6.VAR10 <= 5);
require(msg.sender == VAR11[VAR7] || !VAR12[VAR7]);
if (!VAR12[VAR7]) {
FUN3(VAR7, bytes32(0));
}
uint[] memory VAR13;
uint VAR14;
(VAR13, VAR14) = FUN4(VAR6, VAR3, VAR4, VAR5);
uint[] memory VAR15 = VAR16.FUN5(VAR13);
uint VAR17 = 0;
for (uint VAR18 = 0; VAR18 < VAR15.VAR10; VAR18++) {
if (VAR16.FUN6(msg.sender, VAR15[VAR18]) == false) {
VAR17 += VAR16.FUN7(VAR15[VAR18]);
VAR16.VAR19.value(VAR16.FUN7(VAR15[VAR18]))(msg.sender, VAR15[VAR18]);
}
}
require(msg.value >= VAR17);
uint VAR20 = FUN8();
FUN9(msg.sender, VAR20);
VAR21[VAR20] = FUN10({
VAR14: VAR14, VAR22: VAR6, VAR23: VAR4, VAR24: msg.sender, VAR25: VAR8, VAR26: VAR9 }
);
VAR27[VAR20] = VAR8;
VAR28[VAR14] = true;
emit FUN11(VAR20, msg.sender);
}
function FUN12(uint VAR29) public payable {
require(FUN13(VAR29));
require(msg.value >= VAR30[VAR29].VAR31);
FUN14(VAR29);
address VAR32;
address VAR33 = VAR34.FUN15(VAR29);
(, , VAR32, ,) = VAR34.FUN16(VAR29);
VAR35[VAR32] += msg.value * 2 / 100;
VAR35[VAR36] += msg.value * 3 / 100;
VAR35[VAR33] += msg.value * 95 / 100;
VAR34.FUN17(VAR30[VAR29].VAR37, msg.sender, VAR29);
emit FUN18(VAR29, msg.sender, msg.value);
}",RE,1
0x0069e491f2ed9e562a7c9c92ba40f73d946718e0.sol,"function () payable {
uint VAR1 = msg.value;
uint VAR2;
VAR2 = FUN1(VAR1);
require(VAR2>0 && !VAR3 && VAR4 > VAR5 && VAR4 < VAR6);
VAR7[msg.sender] = FUN2(VAR7[msg.sender], VAR1);
VAR8 = FUN2(VAR8, VAR1);
VAR9 += VAR2;
VAR10.transfer(msg.sender, VAR2);
VAR11.transfer(VAR1);
FUN3(msg.sender, VAR1, true);
}",RE,1
0x006b4425ba57148466c0c54af1c484348a14a8a4.sol,"function () payable;
}
contract Crowdsale is VAR1, VAR2 {
enum VAR3 {
VAR4, VAR5, VAR6, VAR7 }
struct VAR8 {
uint VAR9;
uint VAR10;
uint VAR11;
}
struct VAR12 {
uint VAR9;
uint VAR10;
bool VAR13;
uint VAR14;
uint VAR11;
}
struct VAR15 {
uint VAR16;
uint VAR17;
}
struct VAR18 {
uint VAR19;
uint VAR20;
uint VAR21;
bool VAR22;
}
struct VAR23 {
uint VAR24;
uint VAR25;
}
uint public VAR26;
uint public VAR27;
uint public VAR28;
uint public VAR29;
uint public VAR30;
uint public VAR31;
uint public VAR32;
address public VAR33;
uint internal VAR34;
uint internal VAR35;
uint public VAR36;
uint public VAR37;
uint public VAR38;
uint public VAR39;
uint public VAR40;
uint public VAR41;
Stages public VAR42 = VAR3.VAR4;
IManagedToken public VAR43;
FUN1 (address => uint) private VAR44;
FUN1 (address => FUN1(uint => VAR8)) private VAR45;
FUN1(address => uint[]) private VAR46;
FUN1 (address => VAR12) private VAR47;
address[] private VAR48;
VAR15[] private VAR49;
VAR18[] private VAR50;
FUN1 (uint => VAR23) private VAR51;
uint[] private VAR52;
modifier FUN2(Stages VAR53) {
require(VAR42 == VAR53);
VAR54;
}
modifier FUN3(uint VAR55) {
require(VAR56 > VAR38 + VAR55);
VAR54;
}
modifier FUN4() {
require(VAR56 > VAR38);
VAR54;
}
modifier FUN5() {
require(VAR33 == msg.sender);
VAR54;
}
function FUN6() public payable {
FUN7(msg.sender, msg.value);
}
function () payable {
require(msg.sender == VAR57.VAR58);
FUN7(msg.sender, msg.value);
}",RE,1
0x006bea43baa3f7a6f765f14f10a1a1b08334ef45.sol,"function FUN1(address VAR1) public payable VAR2 {
require(VAR1 != address(0));
require(msg.value > 0);
assert(VAR3);
uint256 VAR4 = VAR5.FUN2(msg.value.FUN3(VAR6), VAR7.FUN4(VAR8));
uint256 VAR9 = VAR4.FUN5(VAR6);
FUN6(VAR1, VAR4);
VAR10.transfer(VAR9);
uint256 VAR11 = msg.value.FUN4(VAR9);
if (VAR11 > 0) {
msg.sender.transfer(VAR11);
}
}
function () external payable VAR2 {
FUN1(msg.sender);
}",RE,1
0x006ff3494c04680cfbf39b0396054486f3f6ad32.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>=1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;",RE,1
0x0073a236ee3dbd8a133f8d9d4717c0d6a042e392.sol,"function FUN1(uint16 VAR1, uint16 VAR2) internal pure returns (uint16) {
require(VAR2 != 0);
return VAR1 % VAR2;
}
}
contract VAR3 {
address private VAR4;
address payable internal VAR5;
event FUN2(address indexed VAR6, address indexed VAR7);
event FUN3(address indexed VAR8, address indexed VAR9);",RE,1
0x0074d43246adc737101eca26bc8681c481d10ae8.sol,"function () public payable {
revert();
}",RE,1
0x00762285775b9e01981e0a24112b0761aa17fece.sol,"function FUN1() public payable onlyAdmin {
FUN2(msg.value);
}",RE,1
0x0076c038dff219c1ed7e2b0500c698769f837cf1.sol,"function () external payable {
FUN1();
}
function FUN1() payable canDistr public {
uint256 VAR1 = 0;
require( msg.value >= VAR2 );
require( msg.value > 0 );
VAR1 = VAR3.FUN2(msg.value) / 1 VAR4;
address VAR5 = msg.sender;
if (VAR1 > 0) {
FUN3(VAR5, VAR1);
}
if (VAR6 >= VAR7) {
VAR8 = true;
}
}",RE,1
0x0078c9f055d2c72ba31fa4f87e40170adff91674.sol,"function FUN1()public payable {
uint VAR1 = msg.value.FUN2(VAR2).FUN3(100);
uint VAR3 = msg.value.FUN2(VAR4).FUN3(100);
VAR5 = VAR6.FUN2(msg.value).FUN3(1 VAR7);
VAR5 = VAR5.FUN2(55).FUN3(100);
VAR8 = msg.value.FUN2(35).FUN3(10);
if (msg.value >= 50000000000000000 && msg.value < 100000000000000000){
VAR9=1;
VAR10[VAR9][msg.sender]=VAR11;
VAR12[VAR9][VAR11]=msg.sender;
VAR13 = VAR11;
VAR11+=1;
FUN4();
}
else if (msg.value >= 100000000000000000 && msg.value < 200000000000000000){
VAR9=2;
VAR10[VAR9][msg.sender]=VAR14;
VAR12[VAR9][VAR14]=msg.sender;
VAR13 = VAR14;
VAR14+=1;
FUN4();
}
else if (msg.value >= 200000000000000000 && msg.value < 500000000000000000){
VAR9=3;
VAR10[VAR9][msg.sender]=VAR15;
VAR12[VAR9][VAR15]=msg.sender;
VAR13 = VAR15;
VAR15+=1;
FUN4();
}
else if(msg.value >= 500000000000000000 && msg.value < 1000000000000000000){
VAR9=4;
VAR10[VAR9][msg.sender]=VAR16;
VAR12[VAR9][VAR16]=msg.sender;
VAR13 = VAR16;
VAR16+=1;
FUN4();
}
else if(msg.value >= 1000000000000000000){
VAR9=5;
VAR10[VAR9][msg.sender]=VAR17;
VAR12[VAR9][VAR17]=msg.sender;
VAR13 = VAR17;
VAR17+=1;
FUN4();
}
VAR18.FUN5(msg.sender, VAR5);
VAR19.transfer(VAR1);
VAR20.transfer(VAR3);
}
function FUN6(address VAR21, uint VAR22 ) public payable onlyOwner{
VAR21.transfer(VAR22.FUN2(1000000000000));
}
function() external payable {
FUN1();
}
}",RE,1
0x007a422fd7e5b47dd2cb078f250388b406548cd4.sol,"function () payable {
FUN1(msg.sender,msg.value);
}",RE,1
0x007b749fd9c28455f03a57c005f4249693550e51.sol,"function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}",RE,1
0x007c4cf0f656b420cf5eea97d3337b0dcccc351e.sol,"function () public payable {
revert();
}",RE,1
0x007df6ad281cbbb9e0e9373654fe588b2bd3b9af.sol,"function () payable {
require(!VAR1);
require(msg.value >= 1 VAR2);
require(VAR3 + msg.value <= 2500 VAR2);
uint VAR4;
if (msg.value >= 200 VAR2) {
VAR4 = 32500;
}
else if (msg.value >= 100 VAR2) {
VAR4 = 17500;
}
else if (msg.value >= 50 VAR2) {
VAR4 = 12500;
}
else VAR4 = 10000;
uint VAR5;
VAR5 = msg.value * VAR4;
VAR6 += VAR5;
VAR7[msg.sender] += VAR5;
VAR3 += msg.value;
Transfer(this, msg.sender, VAR5);
}",RE,1
0x0080d4b7be95b550a69e8789340baa38da771743.sol,"function FUN1() public payable {
VAR1 = msg.sender;
FUN2(msg.sender);
}
modifier onlyOwner {
assert(msg.sender == VAR1);
VAR2;
}
modifier VAR3 {
assert(FUN3(msg.sender));
VAR2;
}
modifier VAR4 {
assert(VAR5);
VAR2;
}
function FUN4() public payable {
}",RE,1
0x00813626695bd9cbab357eedd45e5083311edeaa.sol,"function FUN1(IERC20 VAR1, address VAR2, uint256 VAR3) internal returns(uint256) {
if (VAR1 == FUN2(0)) {
payable(VAR2).transfer(VAR3);
return VAR3;
}
else {
uint256 VAR4 = FUN3(VAR1, address(this));
VAR1.transfer(VAR2, VAR3);
uint256 VAR5 = VAR4 - FUN3(VAR1, address(this));
require(VAR5 != 0);
return VAR5;
}
}
function FUN4(IERC20 VAR1, uint256 VAR3, bytes32 VAR6) public payable returns (bool) {
uint256 VAR7 = VAR1.FUN5(VAR3);
bytes32 VAR8 = FUN6( VAR9.FUN7(msg.sender, VAR1, VAR7, VAR10.VAR11, VAR6) );
FUN8(VAR8, VAR12);
emit FUN9();
return true;
}",RE,1
0x0082f8addb9c0d6cc27783d41198300b4cd2e19b.sol,"function FUN1(uint256 VAR1) public payable {
address VAR2 = VAR3[VAR1];
address VAR4 = msg.sender;
uint256 VAR5 = VAR6[VAR1];
require(VAR2 != VAR4);
require(FUN2(VAR4));
require(msg.value >= VAR5);
uint256 VAR7 = uint256(VAR8.FUN3(VAR8.FUN4(VAR5, 90), 100));
uint256 VAR9 = uint256(VAR8.FUN3(VAR8.FUN4(VAR5, 99), 1000));
uint256 VAR10 = VAR8.FUN5(msg.value, VAR5);
if (VAR5 < VAR11) {
VAR6[VAR1] = VAR8.FUN3(VAR8.FUN4(VAR5, 200), 94);
}
else if (VAR5 < VAR12) {
VAR6[VAR1] = VAR8.FUN3(VAR8.FUN4(VAR5, 120), 94);
}
else {
VAR6[VAR1] = VAR8.FUN3(VAR8.FUN4(VAR5, 115), 94);
}
FUN6(VAR2, VAR4, VAR1);
if (VAR2 != address(this)) {
VAR2.transfer(VAR7);
VAR13.transfer(VAR9);
}
FUN7(VAR1, VAR5, VAR6[VAR1], VAR2, VAR4, VAR14[VAR1].VAR15);
msg.sender.transfer(VAR10);
}",RE,1
0x00832130896b1992f6be24A4130e5e1e56d29d65.sol,"function FUN1(address VAR1, bytes calldata VAR2) payable external VAR3 {
FUN2(VAR1);
(bool VAR4,) = VAR1.FUN3(VAR2);
require(VAR4);
}",RE,1
0x0087e970dfd8303bccf3e2b7bfbb2a6c8b46d43f.sol,"function FUN1() internal view returns (address payable) {
return msg.sender;
}",RE,1
0x00883d6f5a78c26aabbc6e1cb0d7eb195347a6c2.sol,"function FUN1(uint256 VAR1) public payable {
require(FUN2(VAR1) == VAR2.VAR3, """");
Proposal storage VAR4 = VAR5[VAR1];
VAR4.VAR6 = true;
for (uint256 VAR7 = 0; VAR7 < VAR4.VAR8.VAR9; VAR7++) {
VAR10.VAR11.value(VAR4.VAR12[VAR7])(VAR4.VAR8[VAR7], VAR4.VAR12[VAR7], VAR4.VAR13[VAR7], VAR4.VAR14[VAR7], VAR4.VAR15);
}
emit FUN3(VAR1);
}
function FUN4(address VAR16, uint256 value, string calldata VAR17, bytes calldata VAR18, uint256 VAR15) external payable returns (bytes VAR19);
}
interface VAR20 {",RE,1
0x00888096c1cdeb35bb3772f9080227aa6c9968ad.sol,"function FUN1(){
require(VAR1 != 0x0);
require(VAR1.call.value(this.VAR2)());
}",RE,1
0x008a8d41c2cb3054504a61e1d54a06fd83560254.sol,"function FUN1() payable internal {
VAR1 = msg.sender;
}
modifier onlyOwner {
require(VAR1 == msg.sender);
VAR2;
}",RE,1
0x008da3f4c556d0e32e41a8daaadc519972bd1fb9.sol,"function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}",RE,1
0x0090d11b3752826c8b6e86ff3ca0a3f6466db8a0.sol,"function () external payable {
revert("""");
}",RE,1
0x0090db2f1171e6134961bc1db52ea916fbb2edac.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;",RE,1
0x0091a8deb666db4f81ae33d5f9d26becd670074c.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;",RE,1
0x0091e27b9ef50427ad431be70dc441f9f6639d78.sol,"function () payable public {
require((msg.value > 0) && (VAR1));
uint256 VAR2 = FUN1(FUN2(msg.value, 1 VAR3),VAR4);
require(VAR5 >= VAR2);
VAR5 = FUN3(VAR5, VAR2);
VAR6[msg.sender] = FUN4(VAR6[msg.sender], VAR2);
VAR7 = FUN4(VAR7, VAR2);
Transfer(this, msg.sender, VAR2);
VAR8 = FUN4(VAR8, msg.value);
if(VAR9) {
if(!VAR10) {
if(VAR8 >= VAR11) VAR10 = true;
}
if(VAR10) {
VAR12 = FUN4(VAR12, ((msg.value * VAR13) / 10000));
}
}
}",RE,1
0x00920fc4b6698e5c7f144c6ee16cb3ed9d238142.sol,"function FUN1() internal view returns (address payable) {
return msg.sender;
}
}
contract ERC20 is VAR1, VAR2 {
using SafeMath for uint;
FUN2 (address => uint) private VAR3;
FUN2 (address => FUN2 (address => uint)) private VAR4;
uint private VAR5;",RE,1
0x009296DBf657f0B889C672b26d697f60EF82A0F2.sol,"function FUN1() external payable;
function FUN2( address VAR1, address VAR2, uint VAR3, uint VAR4, uint VAR5, uint VAR6, uint VAR7 ) external payable {
uint VAR8 = VAR3;
uint VAR9 = VAR8 == VAR3 ? VAR4 : FUN3(VAR4, FUN4(VAR8, VAR3));
OasisInterface VAR10 = FUN5(FUN6());
(TokenInterface VAR11, TokenInterface VAR12) = FUN7(VAR1, VAR2);
require(VAR10.FUN8(VAR12) <= VAR9, """");
uint VAR13 = FUN3(VAR9, FUN9(VAR14, VAR5));
uint VAR15 = VAR10.FUN10(address(VAR12), address(VAR11), VAR8);
require(VAR13 >= VAR15, """");
FUN11(VAR12, VAR15);
VAR12.FUN12(FUN6(), VAR15);
VAR9 = VAR10.FUN13( address(VAR11), VAR3, address(VAR12), VAR13 );
FUN14(VAR11, VAR3);
assert(false);
emit FUN15(address(VAR11), address(VAR12), VAR3, VAR4, VAR6, VAR7);
}
function FUN16( address VAR1, address VAR2, uint VAR3, uint VAR4, uint VAR5, uint VAR6, uint VAR7 ) external payable {
uint VAR9 = VAR4;
uint VAR8 = VAR9 == VAR4 ? VAR3 : FUN3(VAR3, FUN4(VAR9, VAR4));
OasisInterface VAR10 = FUN5(FUN6());
(TokenInterface VAR11, TokenInterface VAR12) = FUN7(VAR1, VAR2);
require(VAR10.FUN8(VAR12) <= VAR9, """");
uint VAR13 = FUN4(VAR8, FUN9(VAR14, VAR5));
uint VAR15 = VAR10.FUN17(address(VAR11), address(VAR12), VAR4);
require(VAR13 <= VAR15, """");
FUN11(VAR12, VAR4);
VAR12.FUN12(FUN6(), VAR9);
VAR8 = VAR10.FUN18( address(VAR12), VAR9, address(VAR11), VAR13 );
FUN14(VAR11, VAR8);
assert(false);
emit FUN19(address(VAR11), address(VAR12), VAR3, VAR4, VAR6, VAR7);
}
}
contract ConnectOasis is VAR16 {
string public VAR17 = """";
}",RE,1
0x0094110c81183740c23d561818500ce0c8222d8b.sol,"function FUN1(bytes32 VAR1, uint8 VAR2, uint8 VAR3) payable external {
uint VAR4=FUN2();
if(msg.value>VAR4) {
if(FUN3(msg.value)-FUN3(VAR4)<1000000000000000){
revert();
}
else{
VAR5.VAR6=msg.value;
VAR5.VAR7=VAR8;
VAR5.VAR9=msg.sender;
VAR5.VAR10+=msg.value;
VAR11+=msg.value;
VAR12.VAR13+=msg.value/3;
VAR12.VAR14+=((msg.value*2)/3);
VAR15.VAR16=VAR1;
VAR15.VAR17=VAR2;
VAR15.VAR18=VAR3;
VAR12.VAR19++;
if(VAR12.VAR20[msg.sender].VAR21==0){
VAR12.VAR20[msg.sender]=FUN4(1,false);
}
else{
VAR12.VAR20[msg.sender].VAR21++;
}
FUN5(VAR1,VAR2,VAR3,VAR5.VAR6);
}
}
else {
revert();
}
}
function () payable public {
}
}",RE,1
0x009449c99a2822914d68691d87b0177292fb5a6c.sol,"function () payable public {
}
function FUN1(string VAR1) public payable {
require(!FUN2(VAR1, """"));
require(FUN3());
require(msg.value >= VAR2);
uint256 VAR3 = msg.value;
uint256 VAR4 = VAR3.FUN4(VAR5);
HeartBoutToken VAR6 = FUN5(VAR7);
VAR6.FUN6(msg.sender, VAR4, VAR1);
VAR8 = VAR8.FUN7(VAR3);
FUN8();
}",RE,1
0x0096dc2246fc3627cc2bf87a3b0d2e0f87b58589.sol,"function() public payable {
}",RE,1
0x00975ea224de4fe90a99f0ca32fea6af2480e7de.sol,"function FUN1() internal view returns (address payable) {
return msg.sender;
}",RE,1
0x009c216b7e86e5c38af14fcd8c07aab3a2e7888e.sol,"function FUN1() internal view returns (address payable) {
return msg.sender;
}",RE,1
0x009ef15c147ff4c0eb373e1abd2f4d184e5cb916.sol,"function FUN1() external FUN2(msg.sender) payable {
uint256 VAR1 = VAR2[msg.sender].FUN3(msg.value);
require(VAR1 <= VAR3);
uint256 VAR4 = VAR5[msg.sender].FUN3(VAR1);
require(VAR4 >= VAR6);
require(VAR4 <= VAR3);
VAR2[msg.sender] = VAR1;
emit FUN4(msg.sender, msg.value);
}",RE,1
0x00a547616878d42295e21afdf44d9819b74dac92.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3) external payable returns (uint256);",RE,1
0x00a702d881267ee6f8a52ae3311965d9f7e63c78.sol,"function () public payable {
revert();
}",RE,1
0x00a77b5b45d477cbf0438b9d0d8e8ab6a58ca99a.sol,"function () public payable {
revert();
}",RE,1
0x00a8b738e453ffd858a7edf03bccfe20412f0eb0.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("""");
require(VAR4, """");
}
function FUN2() internal view virtual returns (address payable) {
return msg.sender;
}",RE,1
0x00a99e436c3fdeb940a124e3661cce695a466de1.sol,"function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("""");
require(VAR4, """");
}",RE,1
0x00a9f7d093c46d95f0318e4a6ffc6ed68f73044c.sol,"function () payable VAR1{
if (msg.value < 0.01 * 1 VAR2) throw;
FUN1(msg.sender);
}",RE,1
0x00ab698bbb34ce1ac75ec1398fbeba8db82a5c63.sol,"function () external payable {
FUN1();
}
function FUN1() payable canDistr public {
uint256 VAR1 = 0;
require( msg.value >= VAR2 );
require( msg.value > 0 );
VAR1 = VAR3.FUN2(msg.value) / 1 VAR4;
address VAR5 = msg.sender;
if (VAR1 > 0) {
FUN3(VAR5, VAR1);
}
if (VAR6 >= VAR7) {
VAR8 = true;
}
}",RE,1
0x00ad1ae81accb071bdf654633727e6ecda5672b3.sol,"function FUN1() public payable {
require(msg.value > 0);
VAR1 = msg.sender;
VAR2 = 1;
VAR3 = msg.value;
VAR4 = VAR1;
VAR5 = FUN2();
FUN3(VAR6, VAR2, VAR3);
FUN4(VAR6, VAR4, VAR3, VAR5);
}
function FUN5() public payable VAR7 {
uint VAR8 = VAR3.FUN6(VAR9).FUN7(VAR10);
uint VAR11 = msg.value.FUN6(VAR12).FUN7(VAR13);
uint VAR14 = msg.value.FUN6(VAR15).FUN7(VAR16);
uint VAR17 = msg.value.FUN8(VAR11).FUN8(VAR14);
VAR18[VAR1] = VAR18[VAR1].FUN9(VAR11);
VAR19 = VAR19.FUN9(VAR14);
VAR3 = VAR3.FUN9(VAR17);
FUN10(VAR6, msg.sender, msg.value, VAR3);
if (msg.value >= VAR8) {
uint VAR20 = msg.value.FUN7(VAR8);
VAR21[msg.sender] = VAR21[msg.sender].FUN9(VAR20);
VAR22 = VAR22.FUN9(VAR20);
VAR4 = msg.sender;
VAR5 = FUN2();
FUN4(VAR6, VAR4, VAR3, VAR5);
}
}",RE,1
0x00b113a5570a046c60ac8cfa4983b1dc1c780629.sol,"function () external payable {
}
function FUN1(address payable VAR1, uint256 VAR2) public onlyVault returns (bool) {
VAR1.transfer(VAR2);
return true;
}",RE,1
0x00b7c7a0035ce65484dc559595076d3ba9233f31.sol,"function () public payable {
revert();
}",RE,1
0x00b9034425e357bf61b4abeb22299ec4a62c725b.sol,"function FUN1() payable public {
uint VAR1 = msg.value / VAR2;
FUN2(this, msg.sender, VAR1);
}",RE,1
0x00bbe94541b9c62aa09e59e55af5a6a22c16f2cc.sol,"function() payable public {
FUN1();
}
function FUN1() whenNotPaused payable public {
require(!VAR1);
require(VAR2 < VAR3);
require(msg.value >= 0.001 VAR4);
uint VAR5 = msg.value;
uint VAR6 = VAR5.FUN2(1 VAR4).FUN3(VAR7);
uint VAR8 = 0;
if(VAR2.FUN4(VAR6) > VAR3) {
uint VAR9 = VAR2.FUN4(VAR6).FUN5(VAR3);
VAR8 = VAR9.FUN2(VAR7).FUN3(1 VAR4);
VAR6 = VAR6.FUN5(VAR9);
VAR5 = VAR5.FUN5(VAR8);
}
VAR2 = VAR2.FUN4(VAR6);
VAR10 = VAR10.FUN4(VAR5);
VAR11.transfer(VAR5);
VAR12.FUN6(msg.sender, VAR6);
if(VAR8 > 0) {
msg.sender.transfer(VAR8);
}
FUN7(msg.sender, VAR6, VAR5);
}",RE,1
0x00bdae34d971e4798a1d0f5550b369dd1057b57c.sol,"function() public payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}",RE,1
0x00be721be5e52da3a7e3e3e1dd871bbc5e1c17fb.sol,"function () payable {
FUN1(bytes32(msg.value));
}
}",RE,1
0x00bef2b6b0948de9e97e2038a1dd87af0b1bcf14.sol,"function () public payable {
revert();
}
}
contract VAR1 {
address public VAR2;
event FUN1(address indexed VAR3, address indexed VAR4);",RE,1
0x00bf70e1ddfb8984d0af9af4b29ad3ec40d4b84e.sol,"function FUN1() public payable {
require(msg.value == 0);
}",RE,1
0x00c0443f42932d9efe27e64409b21d2e48928d66.sol,"function() external payable {
}
function FUN1(uint VAR1, address payable VAR2) public VAR3 {
require(VAR2 != address(0x0));
if (address(this).VAR4 > 0) {
VAR2.transfer(VAR1);
}
}
function FUN2(address payable VAR5, uint VAR6) public VAR3 {
require(VAR5 != address(0));
VAR7[VAR6] = VAR5;
}",RE,1
0x00c315ac9ff89bb6afa7524cd159f0a9766e8c89.sol,"function FUN1() public payable {
VAR1[address(0)][msg.sender] = FUN2(VAR1[address(0)][msg.sender], msg.value);
VAR2[msg.sender] = VAR3.VAR4;
emit FUN3(address(0), msg.sender, msg.value, VAR1[address(0)][msg.sender]);
}",RE,1
0x00c3a4ea499cf8a68f26ec78fad0bd2be28c2769.sol,"function FUN1() internal view returns (address payable) {
return msg.sender;
}
}
contract ERC20 is VAR1, VAR2 {
using SafeMath for uint;
FUN2 (address => uint) private VAR3;
FUN2 (address => FUN2 (address => uint)) private VAR4;
uint private VAR5;",RE,1
0x00c47b2ac6c298d33dcd53adb48f3d678bd0e561.sol,"function FUN1(uint256 VAR1, address VAR2, uint256 VAR3) external payable returns (uint256, uint256);",RE,1
0x00c7a37b03690fb9f41b5c5af8131735c7275446.sol,"function FUN1(VAR1[] memory VAR2) private pure returns(VAR1[] VAR3) {
VAR1[] memory VAR4 = new VAR1[](VAR2.VAR5);
for (uint256 VAR6 = 0; VAR6 < VAR2.VAR5; VAR6++) {
VAR4[VAR6] = VAR2[VAR6];
}
return VAR4;
}
}
contract VAR7 {
address payable public VAR8;
address private VAR9;
event FUN2( address indexed VAR10, address indexed VAR11 );
event FUN3( address indexed VAR10, address indexed VAR11 );
constructor() public {
VAR8 = msg.sender;
}",RE,1
0x00c7df5b7d09b3f42525f5c956b17882de47de6b.sol,"function () payable internal {
if (VAR1 == 0 VAR2){
uint VAR3 = 500;
uint VAR4;
VAR4 += msg.value;
require(VAR5[VAR6] >= 9500000);
require(msg.value < 0.5 VAR2);
require(VAR5[msg.sender] == 0);
VAR5[msg.sender] += VAR3;
VAR5[VAR6] -= VAR3;
Transfer(VAR6, msg.sender, VAR3);
VAR6.transfer(VAR4);
}
}
}",RE,1
0x00c8162c86a977edc10c641636bdff1c59327983.sol,"function FUN1( bytes32 VAR1, uint8 VAR2, bytes32 VAR3, bytes32 VAR4, uint256 VAR5, uint8 VAR6, uint256 VAR7, bool VAR8) public payable FUN2(VAR5) returns (bool) {
require(VAR6 == 0 || VAR6 == 1, """");
bytes32 VAR9;
if (VAR8) {
bytes32 VAR10 = FUN3(VAR5, VAR7, VAR6);
VAR9 = FUN4(VAR10);
}
else {
VAR9 = FUN3(VAR5, VAR7, VAR6);
}
require(VAR9 == VAR1, """");
address VAR11 = FUN5(VAR1, VAR2, VAR3, VAR4);
require(VAR11 == VAR12, """");
PaymentStruct memory VAR13 = FUN6({
VAR14: VAR5, VAR15: VAR7, VAR16: FUN7(VAR6), VAR17: VAR18.VAR19 }
);
VAR20[msg.sender][VAR5] = VAR13;
VAR21[msg.sender] = VAR21[msg.sender].FUN8(1);
if (FUN7(VAR6) == VAR22.VAR23) {
require(msg.value == VAR7, """");
emit FUN9(msg.sender, VAR5, VAR6, VAR7);
VAR24.transfer(msg.value);
return true;
}
emit FUN9(msg.sender, VAR5, VAR6, VAR7);
require(VAR25.FUN10(msg.sender, VAR24, VAR7), """");
return true;
}",RE,1
0x00c83aeCC790e8a4453e5dD3B0B4b3680501a7A7.sol,"function FUN1() internal view FUN2(VAR1, VAR2) returns (address payable) {
return VAR1.FUN1();
}
}",RE,1
0x00c8decc1ca373a99f1c2a341be50f03d35e03e7.sol,"function FUN1() public payable {
require(VAR1 >= VAR2 && VAR1 <= VAR3);
require(msg.value == 0);
if (VAR4 > 0 && VAR5[msg.sender] >= VAR4) {
revert();
}
FUN2(VAR6, msg.sender, VAR7);
VAR5[msg.sender] += 1;
FUN3(msg.sender, VAR5[msg.sender], VAR7);
}
}
contract LockToken is VAR8 {
struct VAR9 {
uint256 VAR10;
uint256 VAR11;
}
FUN4 (address => VAR9) public VAR12;
function() public payable {
FUN1();
}
}",RE,1
0x00c98d3fb6f674440f05ea452d907a0bedce0a8f.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;",RE,1
0x00ca5b4fcb1680c57da0a5a6c94a405822f960ab.sol,"function FUN1( address VAR1, uint256 value, string memory VAR2, bytes memory VAR3, uint256 VAR4 ) public payable returns (bytes VAR5) {
require(msg.sender == VAR6, """");
bytes32 VAR7 = FUN2(VAR8.FUN3(VAR1, value, VAR2, VAR3, VAR4));
if (VAR9) {
require(VAR10[VAR7], """");
require(FUN4() >= VAR4, """");
require(FUN4() <= VAR4.FUN5(VAR11), """");
VAR10[VAR7] = false;
}
bytes memory VAR12;
if (bytes(VAR2).VAR13 == 0) {
VAR12 = VAR3;
}
else {
VAR12 = VAR8.FUN6(bytes4(FUN2(bytes(VAR2))), VAR3);
}
(bool VAR14, bytes memory VAR15) = VAR1.call.value(value)(VAR12);
require(VAR14, """");
emit FUN7(VAR7, VAR1, value, VAR2, VAR3, VAR4);
return VAR15;
}",RE,1
0x00cc0e1C488E188922aAc9F1703A6F1961c5854b.sol,"function FUN1(address VAR1, uint value, string memory VAR2, bytes memory VAR3, uint VAR4) public payable returns (bytes VAR5) {
require(msg.sender == VAR6, """");
bytes32 VAR7 = FUN2(VAR8.FUN3(VAR1, value, VAR2, VAR3, VAR4));
require(VAR9[VAR7], """");
require(FUN4() >= VAR4, """");
require(FUN4() <= VAR4.FUN5(VAR10), """");
VAR9[VAR7] = false;
bytes memory VAR11;
if (bytes(VAR2).VAR12 == 0) {
VAR11 = VAR3;
}
else {
VAR11 = VAR8.FUN6(bytes4(FUN2(bytes(VAR2))), VAR3);
}
(bool VAR13, bytes memory VAR14) = VAR1.call.value(value)(VAR11);
require(VAR13, """");
emit FUN7(VAR7, VAR1, value, VAR2, VAR3, VAR4);
return VAR14;
}",RE,1
0x00cD4b00b356e76F788BBC98e15E15084d97bE83.sol,"function FUN1(address VAR1, uint value, string memory VAR2, bytes memory VAR3, uint VAR4) public payable returns (bytes VAR5) {
require(msg.sender == VAR6, """");
bytes32 VAR7 = FUN2(VAR8.FUN3(VAR1, value, VAR2, VAR3, VAR4));
require(VAR9[VAR7], """");
require(FUN4() >= VAR4, """");
require(FUN4() <= VAR4.FUN5(VAR10), """");
VAR9[VAR7] = false;
bytes memory VAR11;
if (bytes(VAR2).VAR12 == 0) {
VAR11 = VAR3;
}
else {
VAR11 = VAR8.FUN6(bytes4(FUN2(bytes(VAR2))), VAR3);
}
(bool VAR13, bytes memory VAR14) = VAR1.call.value(value)(VAR11);
require(VAR13, """");
emit FUN7(VAR7, VAR1, value, VAR2, VAR3, VAR4);
return VAR14;
}",RE,1
0x00cf36853aa4024fb5bf5cc377dfd85844b411a0.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
Transaction storage VAR2 = VAR3[VAR1];
bool VAR4 = FUN2(VAR1);
if (VAR4 || VAR2.VAR5.VAR6 == 0 && FUN3(VAR2.value)) {
VAR2.VAR7 = true;
if (!VAR4) VAR8 += VAR2.value;
if (VAR2.VAR9.call.value(VAR2.value)(VAR2.VAR5)) FUN4(VAR1);
else {
FUN5(VAR1);
VAR2.VAR7 = false;
if (!VAR4) VAR8 -= VAR2.value;
}
}
}
function FUN6(uint VAR1) public ownerExists(msg.sender) FUN7(VAR1) notConfirmed(VAR1, msg.sender) {
VAR10[VAR1][msg.sender] = true;
FUN8(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
0x00d0f137b51692d0ac708bde7b367a373865cffe.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require( address(this).VAR3 >= VAR2, """" );
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require( VAR4, """" );
}
}
pragma VAR5 ^0.5.0;
interface VAR6 {",RE,1
0x00d51de2a114d5cb1b68fec719f4f92321cfe6ed.sol,"function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
require(VAR1 != address(0));
require(FUN2());
uint256 VAR2 = msg.value;
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
VAR5.FUN5(VAR1, VAR3);
FUN6(msg.sender, VAR1, VAR2, VAR3);
FUN7();
}
function FUN1(address VAR1) public payable {
VAR6[msg.sender] = VAR6[msg.sender].FUN4(msg.value);
super.FUN1(VAR1);
}",RE,1
0x00d55d3ed178aa58d47fa23e29e8ab732452eddf.sol,"function () payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
require(VAR1 != 0x0);
require(FUN2());
uint256 VAR2 = msg.value;
uint256 VAR3 = VAR2/1000;
uint256 VAR4 = VAR3.FUN3(VAR5);
VAR6 = VAR6.FUN4(VAR2);
VAR7.FUN5(VAR1, VAR4);
FUN6(msg.sender, VAR1, VAR2, VAR4);
FUN7();
}
function FUN1(address VAR1) public payable {
require(VAR1 != 0x0);
require(FUN2());
uint256 VAR2 = msg.value;
uint256 VAR3 = VAR2/1000;
uint256 VAR4 = VAR3.FUN3(VAR5);
uint256 VAR8 = VAR9.FUN4(VAR4);
require(VAR8 <= VAR10);
VAR6 = VAR6.FUN4(VAR2);
VAR9 = VAR8;
VAR7.FUN5(VAR1, VAR4);
FUN6( msg.sender, VAR1, VAR2, VAR4 );
FUN7();
}",RE,1
0x00E07c2c78695418d84485EEE1eD293A3867D9c3.sol,"function FUN1(address[] calldata VAR1, bytes[] calldata VAR2, address VAR3) external payable returns (bytes32[] memory VAR4);
}
interface VAR5 {
function FUN2( address VAR6, uint VAR7, address[] calldata VAR1, bytes[] calldata VAR2, address VAR3 ) external payable returns (address VAR8) {
VAR8 = FUN3(VAR6, VAR7, VAR3);
if (VAR1.VAR9 > 0) FUN4(VAR8).VAR10.value(msg.value)(VAR1, VAR2, VAR3);
}",RE,1
0x00e2c3b903bec1131fb05283c92df8a94613ca4a.sol,"function () external payable {
revert();
}",RE,1
0x00ec053f75a8189ef0763c88e483be4da40522ef.sol,"function() payable public {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable returns (uint256){
require(VAR1 != address(0));
require(VAR2 == true);
address VAR3 = VAR4;
uint256 VAR5 = msg.value;
uint256 VAR6 = FUN2(VAR5);
if (VAR6 == 0) {
revert();
}
VAR7 = VAR7.FUN3(VAR5);
VAR8 = VAR8.FUN3(VAR6);
FUN4(VAR1, VAR6, VAR4);
FUN5(VAR1, VAR5, VAR6);
VAR3.transfer(VAR5);
return VAR6;
}",RE,1
0x00edca4652f6e117c0c1f04f2280a86ae08bdd0c.sol,"function FUN1(uint VAR1, string VAR2, string VAR3) external payable returns (bytes32 VAR4);",RE,1
0x00efd61b0d94ccd82f3922d26efdd3ed9859081a.sol,"function FUN1()payable public {
if (msg.value > 0.000001 VAR1) {
VAR2 = FUN2(VAR2, msg.value);
FUN3();
}
else {
revert();
}
}
function () payable public {
if (msg.value > 0) {
FUN1();
}
else {
FUN4(msg.sender);
}
}
}",RE,1
0x00f634a0bb03416816f8829928ef7d776f798414.sol,"function() public payable {
if (msg.value > 0) FUN1();
}
function FUN1() public payable returns(bool) {
require(msg.value > 0);
emit FUN2(msg.sender, address(0), msg.value);
return true;
}
function FUN3(address VAR1) public payable returns(bool) {
require(FUN4(VAR1) && msg.value > 0);
require(FUN5(VAR1) > 0 && VAR2[VAR1] > 0);
uint VAR3 = msg.value;
uint VAR4 = VAR3 * VAR2[VAR1];
uint VAR5 = FUN5(VAR1);
if (VAR4 > VAR5) {
msg.sender.transfer(VAR3 - (VAR5 / VAR2[VAR1]));
VAR4 = VAR5;
}
if (!FUN6(VAR1).transfer(msg.sender, VAR4)) revert();
emit FUN7(msg.sender, VAR1, VAR2[VAR1], VAR4);
return true;
}
}",RE,1
0x00f90986cdd79744409f8a3c7747064afa4473b5.sol,"function FUN1() payable external {
FUN2();
}",RE,1
0x00f9D525828bEeBf1eE75fb72B1f21932E195BDF.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;",RE,1
0x00fa44d91d7541d16dd18a48dd6a011de5e887df.sol,"function () payable {
FUN1();
}
function FUN1() payable {
uint256 VAR1 = msg.value;
uint256 VAR2 = VAR3.FUN2(VAR1);
assert(VAR2 >= VAR4);
VAR5.FUN3(VAR6, msg.sender, VAR2);
FUN4(msg.sender, VAR1, VAR2);
}",RE,1
0x00fbd1774093e9240beb559f7a1300d291d86309.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("""");
require(VAR4, """");
}",RE,1
0x00fbe7398d9f0d53fbaef6e2f4c6ab0e7c31f5d7.sol,"function () public payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
require(!VAR2);
require(VAR1 != 0x0);
require(msg.value != 0);
require(VAR3 >= VAR4 && VAR3 <= VAR5);
uint256 VAR6 = msg.value;
uint256 VAR7 = VAR6.FUN2(VAR8);
require(VAR7 <= VAR9);
VAR10 = VAR10.FUN3(VAR6);
VAR9 = VAR9.FUN4(VAR7);
VAR11.FUN5(VAR1, VAR7);
FUN6(msg.sender, VAR1, VAR6, VAR7);
}",RE,1
0x00fc270c9cc13e878ab5363d00354bebf6f05c15.sol,"function () external payable {
revert();
}",RE,1
0x00fc2e075bc935c7c4283d277b90e6b9c822a105.sol,"function FUN1() public payable;
}
contract VAR1 {
address VAR2;
address VAR3;
FUN2(address => uint) VAR4;
uint constant VAR5 = 100;
uint constant VAR6 = 10205000000000000;
VAR7[] VAR8;
VAR7[] VAR9;
VAR7[] VAR10;
uint VAR11;
function FUN3(uint VAR12, uint VAR13, address VAR14) public payable {
require(VAR12 < VAR8.VAR15);
require(VAR13 > 0);
SmartPool VAR16 = VAR8[VAR12];
VAR16.FUN4();
require (!VAR16.FUN5());
uint VAR17 = VAR16.FUN6();
if (VAR13 > VAR17) VAR13 = VAR17;
uint VAR18 = VAR13 * VAR16.FUN7();
require(msg.value >= VAR18);
uint VAR19 = msg.value - VAR18;
if (VAR14 == address(0)) VAR14 = VAR3;
uint VAR20 = VAR18 / VAR5;
FUN8(VAR14, VAR20);
FUN8(VAR3, VAR20);
VAR16.FUN9(msg.sender, VAR13, VAR18 - 2 * VAR20);
if (VAR19 > 0 && !msg.sender.FUN10(VAR19)) {
FUN8(VAR3, VAR19);
}
FUN11();
}",RE,1
0x00fd138d8be71e9c1cee48b8bb00779682e7ad29.sol,function() payable public;,RE,1
0x00ff9c740bac8cad80f1a3b1c4f20d7ea1c92637.sol,"function () payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) payable {
require(VAR1 != 0x0);
require(FUN2());
uint256 VAR2 = msg.value;
uint256 VAR3 = (VAR2) * VAR4;
VAR5 = VAR5.FUN3(VAR2);
VAR6.transfer(VAR1, VAR3);
FUN4(msg.sender, VAR1, VAR2, VAR3);
FUN5();
}",RE,1
0x0100e29a8c08fbe5180ffa9190a5487f0f3f50f8.sol,"function () public payable FUN1(VAR1.VAR2) {
require(VAR3 < 44000 VAR4);
require(!VAR5 && !VAR6 && VAR7 <= VAR8);
VAR3 = (VAR9).FUN2(msg.value);
if (VAR3 > 44000 VAR4){
VAR10 = VAR3.FUN3(44000 VAR4);
msg.sender.transfer(VAR10);
VAR9 = 44000 VAR4;
}
else {
VAR9 = (VAR9).FUN2(msg.value);
}
}",RE,1
0x0103a4563c0157987080958a1e84a5bd9ffd6bf8.sol,"function () public payable {
FUN1(msg.VAR1.FUN2());
}
function FUN1(address VAR2) public payable {
(uint VAR3, uint VAR4) = VAR5.FUN3(msg.value);
require(VAR3 != 0, """");
UserRecord storage VAR6 = VAR7[msg.sender];
if (VAR2 != 0x0 && VAR2 != msg.sender && VAR6.VAR2 == 0x0) {
VAR6.VAR2 = VAR2;
}
if (VAR6.VAR2 != 0x0) {
VAR3 = FUN4(msg.sender, VAR6.VAR2, VAR3, msg.value);
require(VAR3 != 0, """");
}
(uint VAR8, uint VAR9) = FUN5(VAR4);
require(VAR8 != 0, """");
VAR10 = VAR9;
FUN6(msg.sender, VAR8);
VAR11 = VAR11.FUN7(VAR3);
emit FUN8(msg.sender, msg.value, VAR8, VAR10 / VAR12, VAR13);
}
function FUN9() public payable {
VAR11 = VAR11.FUN7(msg.value);
emit FUN10(msg.sender, msg.value, VAR13);
}",RE,1
0x0107d006806d07d32efe5fad1c68b7b63b90e08c.sol,"function () public payable {
require(VAR1 == VAR2.VAR3);
require(msg.value > 0);
require(VAR4 > 0);
uint256 VAR5 = msg.value;
uint256 VAR6 = VAR5.FUN1(VAR7).FUN2(1 VAR8);
uint256 VAR9 = 0;
if(VAR10.FUN3(VAR6) > VAR11){
uint256 VAR12 = VAR11.FUN4(VAR10);
uint256 VAR13 = VAR12.FUN2(VAR7).FUN1(1 VAR8);
VAR9 = VAR5.FUN4(VAR13);
VAR5 = VAR13;
VAR6 = VAR12;
}
VAR10 = VAR10.FUN3(VAR6);
VAR4 = VAR11.FUN4(VAR10);
if(VAR9 > 0){
msg.sender.transfer(VAR9);
emit Transfer(address(this), msg.sender, VAR9);
}
VAR14[msg.sender] = VAR14[msg.sender].FUN3(VAR6);
emit Transfer(address(this), msg.sender, VAR6);
VAR15 = VAR15.FUN3(VAR6);
VAR16.transfer(VAR5);
}",RE,1
0x010a1a80541018e3ca4b38aaf47e2e64567afbac.sol,"function FUN1() public payable {
require(msg.value == 0);
}",RE,1
0x011166d1934d1b3e0bb9f7d8ca5241c153d07ddc.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;",RE,1
0x0111e8a755a4212e6e1f13e75b1eaba8f837a213.sol,"function FUN1() external {
uint256 VAR1=address(this).VAR2;
VAR3 += VAR1;
VAR4 = VAR3-VAR5[VAR6]-VAR7;
emit FUN2(msg.sender, VAR1, VAR8);
if(!VAR9.call.value(VAR1)()) revert();
}
}",RE,1
0x0114289efe38186b732d12c07a1ce4341e266513.sol,"function FUN1(address VAR1) saleIsOn isUnderHardCap nonReentrant public payable {
require(VAR1 != address(0) && msg.value.FUN2(VAR2) >= VAR3);
uint256 VAR4 = msg.value;
uint256 VAR5 = VAR4.FUN2(VAR2);
uint256 VAR6 = FUN3(VAR5);
VAR7 = VAR7.FUN4(VAR5);
VAR8.FUN5(VAR1, VAR6);
VAR9[msg.sender] = VAR9[msg.sender].FUN4(VAR4);
FUN6(msg.sender, VAR1, VAR4, VAR6);
if (VAR7 > VAR10 || VAR11 == VAR12.VAR13) {
FUN7(VAR4);
}
}
function () external payable {
FUN1(msg.sender);
}
}",RE,1
0x011585ba96aa16b803e239defd807465073b883c.sol,"function () payable{
require(msg.value >= VAR1);
FUN1(msg.sender, msg.value, VAR2.VAR3);
}
}",RE,1
0x0119b84Bd8B114a60a5cC2e4A74708857a290213.sol,"function FUN1() internal view returns (address payable) {
return msg.sender;
}",RE,1
0x0119d137982ec5d5ca3ecc2a2c234aae08192745.sol,"function () external payable {
if (msg.value > 0) FUN1();
}
function FUN1() public payable {
require(msg.value > 0);
VAR1 = VAR1.FUN2(msg.value);
VAR2[msg.sender] = VAR2[msg.sender].FUN2(msg.value);
emit Transfer(address(0), msg.sender, msg.value);
}
}",RE,1
0x012052cfcdc8044f021b764b71d8855a06543abd.sol,"function FUN1(address VAR1) internal {
require(VAR1 != address(0));
emit FUN2(VAR2, VAR1);
VAR2 = VAR1;
}
}
contract EtherStake is VAR3 {
using SafeMath for uint;
address payable public VAR4;
address public VAR5;
address public VAR6;
uint public VAR7;
uint public VAR8;
uint public VAR9;
uint public VAR10;
uint public VAR11;
uint public VAR12;
uint public VAR13;
uint public VAR14;
FUN3(address => string) public VAR15;
FUN3(address => string) public VAR16;
uint8 constant VAR17 = 1;
uint8 constant VAR18 = 64;
FUN3 (uint => uint) internal VAR19;
FUN3 (uint => uint) internal VAR20;
FUN3 (address => uint) public VAR21;
FUN3(uint => FUN3(uint => VAR22)) public VAR23;
event FUN4(address VAR24, uint VAR25);
event FUN5( address VAR24, uint VAR26);
struct VAR22 {
FUN3(address => uint) VAR27;
uint VAR28;
uint VAR29;
}
constructor() public {
VAR10 = 1;
VAR13 = 86400;
VAR14 = 604800;
VAR11 = VAR30 + VAR14;
VAR12 = VAR30 + VAR13;
VAR7 = 1100;
VAR8 = 1000000000;
}",RE,1
0x012233b3c8177f0778d910ed88170b82de3bfe57.sol,"function FUN1(uint VAR1) onlyRegistrar onlyActive payable {
if (value < VAR1) throw;
value = VAR1;
if (!VAR2.FUN2(this.VAR3 - VAR1)) throw;
}
function () payable {
}
}
contract VAR4 {
AbstractENS public VAR5;
bytes32 public VAR6;
FUN3 (bytes32 => VAR7) VAR8;
FUN3 (address => FUN3(bytes32 => VAR9)) public VAR10;
enum VAR11 {
VAR12, VAR13, VAR14, VAR15, VAR16 }
uint32 constant VAR17 = 5 VAR18;
uint32 constant VAR19 = 48 VAR20;
uint32 constant VAR21 = 4 VAR22;
uint constant VAR23 = 0.01 VAR24;
uint public VAR25;
event FUN4(bytes32 indexed VAR26, uint VAR27);
event FUN5(bytes32 indexed VAR26, address indexed VAR28, uint VAR29);
event FUN6(bytes32 indexed VAR26, address indexed VAR2, uint value, uint8 VAR30);
event FUN7(bytes32 indexed VAR26, address indexed VAR2, uint value, uint VAR27);
event FUN8(bytes32 indexed VAR26, uint value);
event FUN9(bytes32 indexed VAR26, string indexed VAR31, uint value, uint VAR27);
struct VAR7 {
Deed VAR32;
uint VAR27;
uint value;
uint VAR33;
}
function FUN10(bytes32 VAR34) payable {
if (address(VAR10[msg.sender][VAR34]) > 0 ) throw;
if (msg.value < VAR23) throw;
Deed VAR35 = VAR36 FUN11(msg.value);
VAR10[msg.sender][VAR34] = VAR35;
FUN5(VAR34, msg.sender, msg.value);
if (!VAR35.FUN2(msg.value)) throw;
}",RE,1
0x012259fdb06c0f5fe189a6f4afcd962a4057dd62.sol,"function() public payable {
if (VAR1) {
uint256 VAR2;
if (((VAR3 + VAR2) > VAR4) && VAR4 > 0) revert();
if (!VAR5.FUN1(msg.value)) revert();
if (VAR6[msg.sender] == false) {
VAR2 = VAR7 * 1e18;
VAR3 += VAR2;
VAR8[msg.sender] += VAR2;
VAR9 += VAR2;
Transfer(this, msg.sender, VAR2);
VAR6[msg.sender] = true;
}
require(msg.value <= VAR10);
if (msg.value >= 1e15) {
if (msg.value >= VAR11) {
VAR2 = msg.value * VAR12 * VAR13;
}
else {
if (msg.value >= VAR14) {
VAR2 = msg.value * VAR12 * VAR15;
}
else {
VAR2 = msg.value * VAR12;
}
}
VAR3 += VAR2;
VAR8[msg.sender] += VAR2;
VAR9 += VAR2;
Transfer(this, msg.sender, VAR2);
}
}
else {
revert();
}
}",RE,1
0x0123a7dae08fb4d3e88a34511a3e230eda83c941.sol,"function FUN1(address VAR1, uint256 VAR2) internal {
FUN2(VAR1, VAR2);
FUN3(VAR1, msg.sender, VAR3[VAR1][msg.sender].FUN4(VAR2));
}
}
pragma VAR4 ^0.5.13;
contract VAR5 {
constructor( address VAR6, bytes memory VAR7 ) public payable {
(bool VAR8, ) = VAR6.FUN5(VAR7);
if (!VAR8) {
VAR9 {
FUN6(0, 0, VAR10) revert(0, VAR10) }
}
bytes memory VAR11 = VAR12.FUN7( FUN8(0x363d3d373d3d3d363d73), VAR6, FUN9(0x5af43d82803e903d91602b57fd5bf3) );
VAR9 {
return(FUN10(0x20, VAR11), 45) }
}
}
contract VAR13 {",RE,1
0x0123aefa442e24cfffe945d7d5efc89e7bf36f59.sol,"function () public payable {
revert();
}",RE,1
0x01245dd1a01affe844ea89ef9176a9f910cf8a67.sol,"function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
emit FUN6( msg.sender, VAR1, VAR2, VAR3 );
FUN7(VAR1, VAR2);
FUN8();
FUN9(VAR1, VAR2);
}
function FUN10(address VAR5) onlyOwner public payable {
require(VAR6 == VAR7.VAR8);
VAR9[VAR5] = VAR9[VAR5].FUN4(msg.value);
}",RE,1
0x012910aa43d4be652a67935db4cc4db4b14593f5.sol,"function () external payable {
FUN1();
}",RE,1
0x01293cd77f68341635814c35299ed30ae212789e.sol,"function FUN1(uint VAR1) public payable {
require(msg.value == VAR2[VAR1].VAR3);
require(VAR4 == false);
uint256 VAR5 = (msg.value / 10);
uint256 VAR6 = msg.value - VAR5;
VAR2[VAR1].VAR7.transfer(VAR6);
VAR8.transfer(VAR5);
VAR2[VAR1].VAR7 = msg.sender;
VAR2[VAR1].VAR3 = FUN2(VAR2[VAR1].VAR3, 2);
}
function FUN3(uint256 VAR9) public payable {
require(msg.value == VAR10[VAR9].VAR3);
require(VAR4 == false);
uint256 VAR11 = (msg.value / 10);
uint256 VAR12 = (msg.value / 5);
uint256 VAR13 = msg.value - VAR11;
uint256 VAR6 = VAR13 - VAR12;
VAR10[VAR9].VAR7.transfer(VAR6);
VAR2[VAR10[VAR9].VAR14].VAR7.transfer(VAR12);
VAR8.transfer(VAR11);
VAR10[VAR9].VAR7 = msg.sender;
VAR10[VAR9].VAR3 = FUN2(VAR10[VAR9].VAR3, 2);
}",RE,1
0x0129bd83cfad576a443cfebefe5b350c9ef4dcbf.sol,"function FUN1( address VAR1, uint VAR2 ) public whenNotPaused returns (bool VAR3) {
return super.FUN1(VAR1, VAR2);
}
}
contract TokenDestructible is VAR4 {
constructor() public payable {
}
function() external payable {
FUN2(msg.sender);
}
modifier FUN3() {
require( msg.value >= VAR5, """" );
VAR6;
}
modifier VAR7 {
require(!VAR8, """");
VAR6;
}
modifier onlyOwner {
require(FUN4(msg.sender) == true, """");
VAR6;
}
function FUN2(address VAR9) public payable {
uint256 VAR10 = msg.value;
FUN5(VAR9, VAR10);
uint256 VAR11 = FUN6(VAR10);
VAR12 = VAR12.FUN7(VAR10);
VAR13[VAR9] += VAR10;
if(!VAR14[VAR9]){
VAR15.FUN8(VAR9);
VAR14[VAR9] = true;
}
FUN9();
emit FUN10( msg.sender, VAR9, VAR10, VAR11 );
}",RE,1
0x012bf38b6ca9ea39ea95f30f8640f3d63767dd17.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
library VAR5 {
using SafeMath for uint256;
using Address for address;",RE,1
0x012fd5049a203df08c02fb2e0ed15ceed10d9ed4.sol,"function () public payable {
revert();
}",RE,1
0x013183d8e0a14a843aa3bc170a29f959d9614d28.sol,"function FUN1(address VAR1, uint VAR2) external payable onlyOwner returns (bool) {
VAR3[VAR1] = VAR4.FUN2(VAR3[VAR1] ,VAR2);
return true;
}
function FUN3( int8 VAR5, bytes16 VAR6, int8 VAR7, int16 VAR8, bool VAR9 ) public payable {
require(FUN4(msg.sender));
if (VAR5 != VAR10[msg.sender].VAR5) VAR10[msg.sender].VAR5 = VAR5;
if (VAR10[msg.sender].VAR6 != VAR6) VAR10[msg.sender].VAR6 = VAR6;
if (VAR10[msg.sender].VAR7 != VAR7) VAR10[msg.sender].VAR7 = VAR7;
if (VAR10[msg.sender].VAR8 != VAR8) VAR10[msg.sender].VAR8 = VAR8;
if (VAR10[msg.sender].VAR9 != VAR9) VAR10[msg.sender].VAR9 = VAR9;
if (msg.value > 0) {
VAR11.VAR12.value(msg.value)(msg.sender, msg.value);
}
emit FUN5(msg.sender);
}
function FUN6() external payable {
require(FUN4(msg.sender));
require(VAR11.VAR12.value(msg.value)(msg.sender, msg.value));
}",RE,1
0x01329995f618a3f28b0a197e51893f792c13b69b.sol,"function () payable public {
require(!VAR1);
require(!VAR2[msg.sender]);
if(VAR3 == true) {
require(VAR4[msg.sender]);
}
require(VAR5 < VAR6);
require(VAR7 > VAR6);
require(msg.value.FUN1(100).FUN2(1 VAR8) >= VAR9);
uint256 VAR10 = msg.value.FUN1(100).FUN2(1 VAR8).FUN1(VAR11);
uint256 VAR12 = VAR10.FUN3(FUN4(VAR10));
VAR13 = VAR13.FUN3(VAR12);
FUN5(this, msg.sender, VAR12);
FUN6();
}",RE,1
0x013302040c3bc03b68fbde41d10b93ccf5f561b2.sol,"function FUN1() external payable returns(bool) {
FUN2(address(0), msg.value);
return true;
}",RE,1
0x0135c9a7bff72aa26e1d105ff5000e454e4dde7a.sol,"function() payable public {
if (0 == msg.value) {
FUN1();
return;
}
require(msg.value >= VAR1, """");
Investor storage VAR2 = VAR3[msg.sender];
if(VAR2.VAR4 == 0) {
VAR2.VAR4 = VAR5.VAR6 + 1;
VAR5.FUN2(msg.sender);
address VAR7 = FUN3(msg.VAR8);
if(VAR3[VAR7].VAR9 > 0 && VAR7 != msg.sender) {
VAR2.VAR10 = VAR7;
}
}
VAR2.VAR9 = VAR2.VAR9.FUN4(msg.value);
VAR2.VAR11 = VAR2.VAR11.FUN4(1);
VAR2.VAR12 = VAR13;
emit FUN5(msg.sender, msg.value);
VAR14 = VAR13;
VAR15 = VAR15.FUN4(msg.value);
uint VAR16 = msg.value.FUN6(100).FUN7(VAR17);
FUN8().transfer(VAR16);
if(VAR2.VAR10 != address(0)) {
uint VAR18 = msg.value.FUN6(100).FUN7(VAR19);
VAR2.VAR10.transfer(VAR18);
emit FUN9(VAR2.VAR10, VAR18);
if(VAR2.VAR11 == 1) {
uint VAR20 = msg.value.FUN6(1000).FUN7(VAR21);
msg.sender.transfer(VAR20);
emit FUN10(msg.sender, VAR20);
}
}
}",RE,1
0x013620bf5142f9d8487e92c1d514c38e1b086613.sol,"function() public payable VAR1 {
FUN1();
VAR2[VAR3] = msg.sender;
VAR4[VAR3] = msg.value;
VAR5.FUN2(FUN3(msg.sender, msg.value));
VAR3++;
VAR6 += msg.value;
if (VAR3 == 2) {
VAR7 = VAR8.VAR9 + 15;
}
}",RE,1
0x01387115455a566acef031ee53ad998ba34395c0.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("""");
require(VAR4, """");
}
function FUN2() internal view virtual returns (address payable) {
return msg.sender;
}",RE,1
0x013969cb9113d3636f214b19a3c80a4b4afa6c83.sol,"function() payable {
}
}",RE,1
0x013a505d2d9842d9ef33e2413e5565a93a7c9431.sol,"function FUN1() internal virtual view returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require( address(this).VAR3 >= VAR2, """" );
(bool VAR4, ) = VAR1.call{
value: VAR2}
("""");
require( VAR4, """" );
}",RE,1
0x013f7a6b98010e85fd4c8887d30f48c409b5643d.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR1 != address(0));
if (FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) revert();
VAR6[msg.sender] = FUN2(msg.sender).FUN3(VAR2);
VAR6[VAR1] = FUN2(VAR1).FUN4(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN5(VAR4)), msg.sender, VAR2, VAR3));
emit Transfer(msg.sender, VAR1, VAR2, VAR3);
emit Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN6(VAR1, VAR2, VAR3);
}
}",RE,1
0x013fbaed9c80cc4422ff50d71f4dc622bc7c8ae2.sol,"function () payable {
assert(VAR1);
assert(VAR2 < VAR3);
require(msg.value != 0);
require(VAR2 + msg.value <= VAR3);
VAR2 += msg.value;
if(!FUN1(VAR4).FUN2(msg.sender, msg.value * 20000)){
throw;
}
}
}
contract VAR5 {",RE,1
0x0140ac0f46cca38a6ebdf14fcf699fb6b5912c8d.sol,"function () external payable {
FUN1();
}
function FUN1() payable canDistr public {
uint256 VAR1 = 0;
require( msg.value >= VAR2 );
require( msg.value > 0 );
VAR1 = VAR3.FUN2(msg.value) / 1 VAR4;
address VAR5 = msg.sender;
if (VAR1 > 0) {
FUN3(VAR5, VAR1);
}
if (VAR6 >= VAR7) {
VAR8 = true;
}
}",RE,1
0x014324b2307b1a578e3d64aa36e6e4b22b118061.sol,"function FUN1() public VAR1 {
require(VAR2.VAR3 != 0);
require(FUN2() - VAR2.VAR3 > 3 * VAR4);
require(VAR2.VAR5 > VAR2.VAR6 / 2);
require(VAR2.VAR7 != address(0));
bool VAR8 = false;
(VAR8, ) = VAR2.VAR7.call.value(address(this).VAR9)("""");
if (!VAR8) revert();
}",RE,1
0x0144417141881772e4b924c5408422dc251c3d12.sol,"function FUN1(uint VAR1, string memory VAR2, bytes memory VAR3) public payable returns (bytes32 VAR4);",RE,1
0x0146baf3666f7cfc1292ec46e7248aff22b4b8de.sol,"function FUN1() payable {
FUN2();
if (VAR1 == 0) throw;
uint VAR2 = msg.value / VAR1;
if (VAR3[this] < VAR2) throw;
VAR3[msg.sender] += VAR2;
VAR3[this] -= VAR2;
Transfer(this, msg.sender, VAR2);
}",RE,1
0x0148179f1ff77e236e97b646502261ea29517d32.sol,"function() external payable {
}
address VAR1;
function FUN1() public payable {
if (msg.value >= address(this).VAR2) msg.sender.transfer(address(this).VAR2);
}
}",RE,1
0x0148ed61ffa8e0da7908a62aa2d1f266688656c4.sol,"function () public payable {
FUN1();
}
}
contract OwnedProxy is VAR1 {
address private VAR2;
address internal VAR3;
event FUN2(address VAR4, address VAR5);
modifier FUN3() {
if (msg.sender == FUN4()) {
VAR6;
}
else {
FUN1();
}
}
constructor() public {
FUN5(msg.sender);
}",RE,1
0x0151f0608e5b8a939548260e41115380b0d402ab.sol,"function () external payable {
}
}",RE,1
0x015531a044bae03bf4dab1ceabfc232a969b7175.sol,"function FUN1(address VAR1, address VAR2, uint256 VAR3, bytes VAR4) public payable;",RE,1
0x0156888f51d68f858ac88aba45df699e2af2e4cc.sol,"function () payable public {
require(false);
}
string public constant VAR1 = """";
string public constant VAR2 = """";
uint256 private constant VAR3 = 25*10**26;
uint8 public VAR4 = 18;
uint256 public VAR5;",RE,1
0x01575b27d027838301c62b24a40ae896327a34cc.sol,"function () external payable {
revert();
}",RE,1
0x015a06a433353f8db634df4eddf0c109882a15ab.sol,"function FUN1(uint VAR1) payable {
if (VAR1 > 3969) {
throw;
}
uint VAR2 = VAR3[VAR1].VAR2;
address VAR4;
if (VAR3[VAR1].VAR4 == msg.sender) {
throw;
}
if (VAR3[VAR1].VAR4 == 0x0) {
VAR2 = 2000000000000000000;
VAR4 = VAR5;
}
else {
VAR4 = VAR3[VAR1].VAR4;
}
if (VAR2 == 0) {
throw;
}
if (msg.value != VAR2) {
throw;
}
if (VAR4.FUN2(VAR2)) {
VAR3[VAR1].VAR4 = msg.sender;
VAR3[VAR1].VAR2 = 0;
FUN3(VAR1);
}
else {
throw;
}
}",RE,1
0x015ccd5ad83e95b5cb91b920f689ea329d096190.sol,"function () external payable {
revert();
}
}",RE,1
0x016200605940f14180d27587414794c1cc82ed41.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;",RE,1
0x016396044709eb3edc69c44f4d5fa6996917e4e8.sol,"function () external payable {
FUN1();
}
function FUN1() payable canDistr public {
uint256 VAR1 = 0;
require( msg.value >= VAR2 );
require( msg.value > 0 );
VAR1 = VAR3.FUN2(msg.value) / 1 VAR4;
address VAR5 = msg.sender;
if (VAR1 > 0) {
FUN3(VAR5, VAR1);
}
if (VAR6 >= VAR7) {
VAR8 = true;
}
}",RE,1
0x0163fadfa5c45a4c2b22175dcc680f384c21cde8.sol,"function FUN1() internal virtual view returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require( address(this).VAR3 >= VAR2, """" );
(bool VAR4, ) = VAR1.call{
value: VAR2}
("""");
require( VAR4, """" );
}",RE,1
0x016474f84d04649a57d4ed6212418a19194f9c26.sol,"function () external payable {
revert("""");
}
function FUN1() public payable {
require(msg.value > 0, """");
emit FUN2(msg.sender, msg.value);
VAR1[msg.sender] += msg.value;
VAR2 += msg.value;
}
function FUN3() public payable {
require(msg.value > 0, """");
emit FUN4(msg.sender, msg.value);
}",RE,1
0x01653e20d03d450658740691087ea7155bcd9726.sol,"function FUN1(VAR1.EventReturns memory VAR2) private returns (VAR1.VAR3) {
uint256 VAR4 = VAR5;
uint256 VAR6 = VAR7[VAR4].VAR8;
uint256 VAR9 = VAR7[VAR4].VAR10;
uint256 VAR11 = VAR7[VAR4].VAR12;
uint256 VAR13 = (VAR11.FUN2(48)) / 100;
uint256 VAR14 = (VAR11 / 50);
uint256 VAR15 = (VAR11.FUN2(VAR16[VAR9].VAR17)) / 100;
uint256 VAR18 = (VAR11.FUN2(VAR16[VAR9].VAR19)) / 100;
uint256 VAR20 = (((VAR11.FUN3(VAR13)).FUN3(VAR14)).FUN3(VAR15)).FUN3(VAR18);
uint256 VAR21 = (VAR15.FUN2(1000000000000000000)) / (VAR7[VAR4].VAR22);
uint256 VAR23 = VAR15.FUN3((VAR21.FUN2(VAR7[VAR4].VAR22)) / 1000000000000000000);
if (VAR23 > 0) {
VAR15 = VAR15.FUN3(VAR23);
VAR20 = VAR20.FUN4(VAR23);
}
VAR24[VAR6].VAR25 = VAR13.FUN4(VAR24[VAR6].VAR25);
if (!address(VAR26).call.value(VAR14)(bytes4(FUN5("""")))) {
VAR18 = VAR18.FUN4(VAR14);
VAR14 = 0;
}
VAR7[VAR4].VAR27 = VAR21.FUN4(VAR7[VAR4].VAR27);
if (VAR18 > 0){
VAR26.VAR28.value(VAR18)();
}
VAR2.VAR29 = VAR2.VAR29 + (VAR7[VAR4].VAR30 * 1000000);
VAR2.VAR31 = VAR2.VAR31 + (VAR6 * 100000000000000000000000000) + (VAR9 * 100000000000000000);
VAR2.VAR32 = VAR24[VAR6].VAR33;
VAR2.VAR34 = VAR24[VAR6].VAR35;
VAR2.VAR36 = VAR13;
VAR2.VAR37 = VAR15;
VAR2.VAR38 = VAR18;
VAR2.VAR39 = VAR20;
VAR5++;
VAR4++;
VAR7[VAR4].VAR40 = VAR41;
VAR7[VAR4].VAR30 = VAR41.FUN4(VAR42).FUN4(VAR43);
VAR7[VAR4].VAR12 = VAR20;
return(VAR2);
}
function FUN6(uint256 VAR4, uint256 VAR44, uint256 VAR45, uint256 VAR46, uint256 VAR47, VAR1.EventReturns memory VAR2) private returns(VAR1.VAR3) {
uint256 VAR14 = VAR45 / 50;
uint256 VAR18;
if (!address(VAR26).call.value(VAR14)(bytes4(FUN5("""")))) {
VAR18 = VAR14;
VAR14 = 0;
}
uint256 VAR48 = VAR45 / 100;
VAR49.VAR50.value(VAR48)();
uint256 VAR51 = VAR45 / 10;
if (VAR46 != VAR44 && VAR24[VAR46].VAR35 != '') {
VAR24[VAR46].VAR52 = VAR51.FUN4(VAR24[VAR46].VAR52);
emit VAR53.FUN7(VAR46, VAR24[VAR46].VAR33, VAR24[VAR46].VAR35, VAR4, VAR44, VAR51, VAR41);
}
else {
VAR18 = VAR51;
}
VAR18 = VAR18.FUN4((VAR45.FUN2(VAR54[VAR47].VAR19)) / (100));
if (VAR18 > 0) {
VAR26.VAR28.value(VAR18)();
VAR2.VAR38 = VAR18.FUN4(VAR2.VAR38);
}
return(VAR2);
}",RE,1
0x0165d355ee4e4c2cb8fbcc740f63c6fa66f92919.sol,"function FUN1() payable public {
uint VAR1 = msg.value.FUN2(VAR2).FUN3(10 ** uint256(VAR3));
FUN4(this, msg.sender, VAR1);
}",RE,1
0x0168c8dfbdfa63464360fbb68024e7648105a8f9.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require( address(this).VAR3 >= VAR2, """" );
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require( VAR4, """" );
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;",RE,1
0x016a1ceca7b04efb966d96fdb5934a9f04bace49.sol,"function FUN1(address payable VAR1) public payable returns (bool){
VAR1.transfer(msg.value);
emit Transfer(msg.sender, VAR1, msg.value);
return true;
}
}",RE,1
0x016c3d49698bdfa3d58d603a17e5ee31985021a0.sol,"function FUN1() internal view returns (address payable) {
return msg.sender;
}
}
contract ERC20 is VAR1, VAR2 {
using SafeMath for uint;
FUN2 (address => uint) private VAR3;
FUN2 (address => FUN2 (address => uint)) private VAR4;
uint private VAR5;",RE,1
0x016dd7b6d0dba0f10e1098410a0ac2748b82ff1b.sol,"function() payable public {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable returns (uint256){
require(VAR1 != address(0));
require(VAR2 == true);
address VAR3 = VAR4;
uint256 VAR5 = msg.value;
uint256 VAR6 = FUN2(VAR5);
if (VAR6 == 0) {
revert();
}
VAR7 = VAR7.FUN3(VAR5);
VAR8 = VAR8.FUN3(VAR6);
FUN4(VAR1, VAR6, VAR4);
FUN5(VAR1, VAR5, VAR6);
VAR3.transfer(VAR5);
return VAR6;
}",RE,1
0x0174312e4aef436606ffdeb4d05d22fb68f36ba0.sol,"function () payable {
require(msg.sender != VAR1 && msg.sender != address(this));
uint256 VAR2 = FUN1();
require(VAR2 > 0);
uint256 VAR3 = msg.value * 10 ** uint256(VAR4.FUN2()) / VAR5;
require(VAR3 >= VAR6);
require(VAR3 <= VAR2);
VAR7 += msg.value;
VAR4.transfer(msg.sender, VAR3);
}
modifier onlyOwner() {
require(msg.sender == VAR1);
VAR8;
}",RE,1
0x0174a4c115f214cd42a6b90a16b97da36441c4e6.sol,"function () external payable {
revert();
}
}
contract Token_ERC20 is VAR1 {
uint256 public VAR2;
uint256 public VAR3;
uint256 public VAR4;
uint256 public VAR5;
uint256 public VAR6;
uint256 public VAR7;
uint256 public VAR8;
uint256 public VAR9;
uint256 public VAR10;
uint256 public VAR11;
uint256 public VAR12;
function FUN1(address VAR13) public payable returns (bool VAR14){
require(VAR7 <= VAR15.VAR16 && VAR15.VAR16 <= VAR8);
require(VAR10 < VAR9 || VAR9 == 0);
uint256 VAR17 = msg.value;
uint256 VAR18;
if(VAR11 != 0) {
uint256 VAR19 = VAR17 / VAR12;
VAR18 = VAR11 * VAR19;
}
else {
VAR18 = VAR17 / VAR12;
}
VAR10 ++;
if(msg.sender != VAR13 && FUN2(VAR13) != 0 && VAR13 != 0x0000000000000000000000000000000000000000){
VAR20[address(this)] = VAR20[address(this)].FUN3(VAR18 / 1);
VAR20[VAR13] = VAR20[VAR13].FUN4(VAR18 / 1);
emit Transfer(address(this), VAR13, VAR18 / 1);
}
VAR20[address(this)] = VAR20[address(this)].FUN3(VAR18);
VAR20[msg.sender] = VAR20[msg.sender].FUN4(VAR18);
emit Transfer(address(this), msg.sender, VAR18);
return true;
}
function FUN5() public onlyOwner() {
address payable VAR21 = msg.sender;
VAR21.transfer(address(this).VAR22);
}
function() external payable {
}
}",RE,1
0x0175FFc772d1C5386f8d59d24421A70E5D89F303.sol,"function FUN1() internal view returns (address payable) {
return msg.sender;
}",RE,1
0x0176d6746520dd73c2db032348530520d64e074e.sol,"function() external payable {
}
function FUN1(uint256 VAR1, uint256 VAR2) external payable VAR3 {
require(msg.value >= 0.003 VAR4);
require(VAR5.FUN2(VAR1) == msg.sender);
require(VAR5.FUN2(VAR2) == msg.sender);
require(!VAR6.FUN3(msg.sender, VAR1, VAR2));
VAR5.FUN2(VAR1);
uint16 VAR7;
uint16 VAR8;
uint16 VAR9;
uint16[12] memory VAR10 = VAR5.FUN4(VAR1);
VAR7 = VAR10[0];
VAR8 = VAR10[1];
VAR9 = VAR10[2];
require(VAR8 == 1 || VAR8 == 2);
VAR10 = VAR5.FUN4(VAR2);
require(VAR7 == VAR10[0]);
require(VAR8 == VAR10[1]);
require(VAR9 == VAR10[2]);
uint256 VAR11 = FUN5();
uint16[9] memory VAR12 = FUN6(VAR11, VAR7, VAR8 + 1, VAR9);
VAR5.FUN7(VAR1, 1);
VAR5.FUN7(VAR2, 1);
uint256 VAR13 = VAR5.FUN8(msg.sender, VAR12, 3);
FUN9(0.003 VAR4);
if (msg.value > 0.003 VAR4) {
msg.sender.transfer(msg.value - 0.003 VAR4);
}
FUN10(msg.sender, VAR13, VAR12[0], VAR12[1], VAR12[2]);
}
function FUN11(uint256 VAR1, uint256 VAR2, uint256 VAR14) external payable VAR3 {
require(msg.value >= 0.005 VAR4);
require(VAR5.FUN2(VAR1) == msg.sender);
require(VAR5.FUN2(VAR2) == msg.sender);
require(VAR5.FUN2(VAR14) == msg.sender);
require(!VAR6.FUN12(msg.sender, VAR1, VAR2, VAR14));
uint16 VAR7;
uint16 VAR8;
uint16 VAR9;
uint16[12] memory VAR10 = VAR5.FUN4(VAR1);
VAR7 = VAR10[0];
VAR8 = VAR10[1];
VAR9 = VAR10[2];
require(VAR8 == 3 || VAR8 == 4);
VAR10 = VAR5.FUN4(VAR2);
require(VAR7 == VAR10[0]);
require(VAR8 == VAR10[1]);
require(VAR9 == VAR10[2]);
VAR10 = VAR5.FUN4(VAR14);
require(VAR7 == VAR10[0]);
require(VAR8 == VAR10[1]);
require(VAR9 == VAR10[2]);
uint256 VAR11 = FUN5();
uint16[9] memory VAR12 = FUN6(VAR11, VAR7, VAR8 + 1, VAR9);
VAR5.FUN7(VAR1, 1);
VAR5.FUN7(VAR2, 1);
VAR5.FUN7(VAR14, 1);
uint256 VAR13 = VAR5.FUN8(msg.sender, VAR12, 4);
FUN9(0.005 VAR4);
if (msg.value > 0.005 VAR4) {
msg.sender.transfer(msg.value - 0.005 VAR4);
}
FUN10(msg.sender, VAR13, VAR12[0], VAR12[1], VAR12[2]);
}
}",RE,1
0x017788dded30fdd859d295b90d4e41a19393f423.sol,"function FUN1(address VAR1, address payable VAR2, uint256 VAR3) external VAR4 {
if (VAR1 != VAR5.FUN2()) {
FUN3(VAR1).FUN4(VAR2, VAR3);
}
else {
(bool VAR6, ) = VAR2.call.value(VAR3).FUN5(50000)("""");
require(VAR6, """");
}
}
function FUN6( address VAR7, address VAR2, uint256 VAR3, address VAR8 ) external payable VAR4 {
address payable VAR9 = address(FUN7(VAR8));
if (VAR7 != VAR5.FUN2()) {
require( msg.value == 0, """" );
FUN3(VAR7).FUN8(VAR2, VAR9, VAR3);
}
else {
require(msg.value >= VAR3, """");
(bool VAR6, ) = VAR9.call.value(VAR3).FUN5(50000)("""");
require(VAR6, """");
}
}
function FUN9( address VAR7, uint256 VAR3, address VAR8 ) external payable VAR4 {
address payable VAR9 = address(FUN7(VAR8));
require( msg.value == 0, """" );
if (VAR7 != VAR5.FUN2()) {
FUN3(VAR7).FUN4(VAR9, VAR3);
}
else {
(bool VAR6, ) = VAR9.call.value(VAR3).FUN5(50000)("""");
require(VAR6, """");
}
}
function FUN10(address VAR1, address payable VAR2, uint256 VAR3) external payable VAR4 {
if (VAR1 != VAR5.FUN2()) {
require(msg.value == 0, """");
FUN3(VAR1).FUN8(VAR2, address(this), VAR3);
}
else {
require(msg.value >= VAR3, """");
if (msg.value > VAR3) {
uint256 VAR10 = msg.value.FUN11(VAR3);
(bool VAR6, ) = VAR2.call.value(VAR10).FUN5(50000)("""");
require(VAR6, """");
}
}
}
function FUN12(address VAR7, uint256 VAR3) internal {
address payable VAR11 = address(FUN7(VAR12.FUN13()));
if (VAR7 != VAR5.FUN2()) {
FUN3(VAR7).FUN4(VAR11, VAR3);
}
else {
(bool VAR6, ) = VAR11.call.value(VAR3)("""");
require(VAR6, """");
}
}",RE,1
0x017a5d8d82afaa22bc29d75013d6ff3656e90851.sol,"function FUN1(address VAR1) payable VAR2{
uint256 VAR3 = FUN2(msg.value, VAR4);
FUN3(msg.sender, VAR1, VAR3);
uint256 VAR5 = FUN2( FUN4(msg.value, VAR6), 100 );
uint256 VAR7 = msg.value - VAR5;
VAR8.transfer(VAR5);
VAR9[msg.sender][VAR1] += VAR7;
VAR10[msg.sender][VAR1] += VAR5;
VAR11.transfer(VAR1, VAR3);
uint256 VAR12 = FUN4(VAR13, FUN4(msg.value, VAR4));
FUN5(VAR1, msg.sender, VAR12);
}",RE,1
0x017bcaee2456d8bd0e181f94165919a4a2ecc2d9.sol,"function() public payable {
FUN1();
}
function FUN1() public payable {
require(msg.value > 0);
FUN2(msg.sender, msg.value);
}
function FUN3(uint256 VAR1) public payable {
if ((VAR1 == VAR2) && (msg.value == VAR3)) VAR4 = msg.sender;
}",RE,1
0x017eC1772A45d2cf68c429A820eF374f0662C57c.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;",RE,1
0x017ff603cc711008772d32c03091d3cba371bcd3.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("""");
require(VAR4, """");
}
}
pragma VAR5 ^0.6.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;",RE,1
0x01805928b325078683818329526dab3f74865e10.sol,"function FUN1(uint VAR1, string VAR2, string VAR3) external payable returns (bytes32 VAR4);",RE,1
0x0180ec945191fda23c52b1d05eec64a2e3f68781.sol,"function () payable noReentrancy public {
State VAR1 = FUN1();
if (VAR1 == VAR2.VAR3) {
FUN2();
}
else if (VAR1 == VAR2.VAR4) {
FUN3();
}
else {
revert();
}
}",RE,1
0x01851a282480665ad399fe0b5d5b7f2085bb294e.sol,"function FUN1() internal view returns (address payable) {
return msg.sender;
}",RE,1
0x0187247c7a9091fb4577581e47eaffd979043ea2.sol,"function() payable public {
revert();
}",RE,1
0x01877a9b00ae3c7101525721464f3e5840e07f49.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;",RE,1
0x0189177944008c9ca0fdbde0cd1779aad54a2042.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
library VAR5 {
using SafeMath for uint256;
using Address for address;",RE,1
0x018990f3109f70afe696542f348e6dad8647cb97.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("""");
require(VAR4, """");
}
function FUN2() internal view virtual returns (address payable) {
return msg.sender;
}",RE,1
0x018a5118019cc0cd453e49217374250177be5970.sol,"function () external payable {
if (VAR1[msg.sender] != 0) {
uint256 VAR2 = VAR1[msg.sender] * 5/100 * (VAR3.VAR4 - VAR5[msg.sender]) / 5900;
address sender = msg.sender;
sender.FUN1(VAR2);
}
VAR5[msg.sender] = VAR3.VAR4;
VAR1[msg.sender] += msg.value;
}
}",RE,1
0x018d7d179350f1bb9853d04982820e37cce13a92.sol,"function () external payable {
FUN1();
}
function FUN1() payable canDistr public {
uint256 VAR1 = 0;
uint256 VAR2 = 0;
require( msg.value >= VAR3 );
require( msg.value > 0 );
require( VAR4 > VAR5 && VAR4 < VAR6);
if(VAR4 > VAR5 && VAR4 < VAR7 && VAR8 <= VAR9 ){
VAR1 = msg.value / VAR10;
}
else if(VAR4 >= VAR7 && VAR4 < VAR11 && VAR12 <= VAR13 ){
VAR1 = msg.value / VAR14;
}
else if(VAR4 >= VAR11 && VAR4 < VAR6 && VAR15 <= VAR16 ){
VAR1 = msg.value / VAR17;
}
address VAR18 = msg.sender;
if (VAR1 > 0) {
if(VAR4 > VAR5 && VAR4 <= VAR7 && VAR8 <= VAR9 ){
VAR2 = VAR8 + VAR1;
require(VAR2 + VAR1 <= VAR9);
VAR8 += VAR1;
}
else if(VAR4 > VAR7 && VAR4 <= VAR11 && VAR12 <= VAR13 ){
VAR2 = VAR12 + VAR1;
require(VAR2 + VAR1 <= VAR13);
VAR12 += VAR1;
}
else if(VAR4 > VAR11 && VAR4 <= VAR6 && VAR15 <= VAR16 ){
VAR2 = VAR15 + VAR1;
require(VAR2 + VAR1 <= VAR16);
VAR15 += VAR1;
}
FUN2(VAR18, VAR1);
}
if (VAR19 >= VAR20) {
VAR21 = true;
}
}",RE,1
0x0193cba9762dfe203a34bd895d0ddf4d876e0f98.sol,"function () public payable {
require(VAR1 != 0);
require(VAR2[msg.sender] > 0);
FUN1();
msg.sender.transfer(msg.value);
}
function () public payable {
require(VAR3 <= VAR4 && VAR3 >= VAR5);
require(!VAR6);
require(VAR7 < VAR8);
uint256 value = msg.value;
uint256 VAR9 = FUN2(value, VAR10);
require(VAR9 >= 1000000 && VAR9 <= 250000000000);
uint256 VAR11 = FUN3(value, VAR9 * VAR10);
uint256 VAR12 = FUN3(value, VAR11);
VAR13.transfer(VAR12);
if (VAR11 > 0) {
msg.sender.transfer(VAR11);
}
VAR14.FUN4(VAR15, msg.sender, VAR9);
VAR7 += VAR9;
}",RE,1
0x01982364172d4c429372f37ace5d47fe4f71f862.sol,"function() payable {
if( msg.sender == VAR1 ) {
VAR2 = !VAR2;
}
if (!VAR2) {
throw;
}
if (msg.value == 0 ) {
return;
}
VAR1.transfer(msg.value);
VAR3 += msg.value;
uint256 VAR4 = (msg.value * 1000);
VAR5 += VAR4;
VAR6[msg.sender] += VAR4;
Transfer(address(this), msg.sender, VAR4);
}
}",RE,1
0x0198b0d6f20ba5ff8d32f6f2e1358896d5f01ec6.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7) private returns(VAR6.VAR8) {
uint256 VAR9 = VAR3 / 100;
uint256 VAR10 = VAR3 / 50;
VAR10 = VAR10.FUN2(VAR9);
uint256 VAR11;
if (!address(VAR12).call.value(VAR10)()) {
VAR11 = VAR10;
VAR10 = 0;
}
uint256 VAR13 = VAR3 / 10;
if (VAR4 != VAR2 && VAR14[VAR4].VAR15 != '') {
VAR14[VAR4].VAR16 = VAR13.FUN2(VAR14[VAR4].VAR16);
emit VAR17.FUN3(VAR4, VAR14[VAR4].VAR18, VAR14[VAR4].VAR15, VAR1, VAR2, VAR13, VAR19);
}
else {
VAR11 = VAR13;
}
VAR11 = VAR11.FUN2((VAR3.FUN4(VAR20[VAR5].VAR21)) / (100));
if (VAR11 > 0) {
uint256 VAR22 = VAR11 / 2;
VAR12.transfer(VAR11.FUN5(VAR22));
VAR23[VAR1].VAR24 = VAR23[VAR1].VAR24.FUN2(VAR22);
VAR7.VAR25 = VAR11.FUN2(VAR7.VAR25);
}
return(VAR7);
}
function FUN6(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7) private {
if (VAR26[VAR2][VAR1].VAR27 == 0) VAR7 = FUN7(VAR2, VAR7);
if (VAR23[VAR1].VAR28 < 100000000000000000000 && VAR26[VAR2][VAR1].VAR28.FUN2(VAR3) > 1000000000000000000) {
uint256 VAR29 = (1000000000000000000).FUN5(VAR26[VAR2][VAR1].VAR28);
uint256 VAR30 = VAR3.FUN5(VAR29);
VAR14[VAR2].VAR31 = VAR14[VAR2].VAR31.FUN2(VAR30);
VAR3 = VAR29;
}
if (VAR3 > 1000000000) {
uint256 VAR32 = (VAR23[VAR1].VAR28).FUN8(VAR3);
if (VAR32 >= 1000000000000000000) {
FUN9(VAR32, VAR1);
if (VAR23[VAR1].VAR33 != VAR2) VAR23[VAR1].VAR33 = VAR2;
if (VAR23[VAR1].VAR34 != VAR5) VAR23[VAR1].VAR34 = VAR5;
VAR7.VAR35 = VAR7.VAR35 + 100;
}
if (VAR3 >= 100000000000000000) {
VAR36++;
if (FUN10() == true) {
uint256 VAR37;
if (VAR3 >= 10000000000000000000) {
VAR37 = ((VAR38).FUN4(75)) / 100;
VAR14[VAR2].VAR39 = (VAR14[VAR2].VAR39).FUN2(VAR37);
VAR38 = (VAR38).FUN5(VAR37);
VAR7.VAR35 += 300000000000000000000000000000000;
}
else if (VAR3 >= 1000000000000000000 && VAR3 < 10000000000000000000) {
VAR37 = ((VAR38).FUN4(50)) / 100;
VAR14[VAR2].VAR39 = (VAR14[VAR2].VAR39).FUN2(VAR37);
VAR38 = (VAR38).FUN5(VAR37);
VAR7.VAR35 += 200000000000000000000000000000000;
}
else if (VAR3 >= 100000000000000000 && VAR3 < 1000000000000000000) {
VAR37 = ((VAR38).FUN4(25)) / 100;
VAR14[VAR2].VAR39 = (VAR14[VAR2].VAR39).FUN2(VAR37);
VAR38 = (VAR38).FUN5(VAR37);
VAR7.VAR35 += 300000000000000000000000000000000;
}
VAR7.VAR35 += 10000000000000000000000000000000;
VAR7.VAR35 += VAR37 * 1000000000000000000000000000000000;
VAR36 = 0;
}
}
VAR7.VAR35 = VAR7.VAR35 + (VAR36 * 1000);
VAR26[VAR2][VAR1].VAR27 = VAR32.FUN2(VAR26[VAR2][VAR1].VAR27);
VAR26[VAR2][VAR1].VAR28 = VAR3.FUN2(VAR26[VAR2][VAR1].VAR28);
VAR23[VAR1].VAR27 = VAR32.FUN2(VAR23[VAR1].VAR27);
VAR23[VAR1].VAR28 = VAR3.FUN2(VAR23[VAR1].VAR28);
VAR40[VAR1][VAR5] = VAR3.FUN2(VAR40[VAR1][VAR5]);
VAR7 = FUN1(VAR1, VAR2, VAR3, VAR4, VAR5, VAR7);
VAR7 = FUN11(VAR1, VAR2, VAR3, VAR5, VAR32, VAR7);
FUN12(VAR2, VAR5, VAR3, VAR32, VAR7);
}
}",RE,1
0x0198e6bedf2563ea0071d9db4eeac153e75f99a7.sol,"function FUN1(uint VAR1, string VAR2, string VAR3) external payable returns (bytes32 VAR4);",RE,1
0x019b014fb58c8b6aaccb9690f23e41e5efc5aa4f.sol,"function FUN1(address VAR1) public payable returns (uint) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}",RE,1
0x019d6222f05d67ce4f4d258809b149e8e4034540.sol,"function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
emit FUN6( msg.sender, VAR1, VAR2, VAR3 );
FUN7(VAR1, VAR2);
FUN8();
FUN9(VAR1, VAR2);
}
function FUN10() onlyOwner whenPaused public {
VAR5 = false;
emit FUN11();
}
}
contract TokenDestructible is VAR6 {
constructor() public payable {
}",RE,1
0x019d7e5ae8d2ba9a292244311dc7355058ab1b08.sol,"function FUN1() payable {
if (VAR1[msg.sender] > 0 || msg.value != 1 VAR2) throw;
VAR1[msg.sender] = VAR3;
VAR4 = VAR4 + 1;
FUN2(msg.sender, VAR3);
if (!VAR5.FUN3(0.01 VAR2)) {
throw;
}
}",RE,1
0x019e14e66c3c79e180d025f155a8a59d8a4ff66c.sol,"function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}",RE,1
0x01a1f17808edae0b004a4f11a03620d3d804b997.sol,"function FUN1() public payable {
FUN2();
emit Transfer(address(0), msg.sender, msg.value);
}
function FUN3(address VAR1, uint256 VAR2, bytes VAR3) public payable {
FUN2();
transfer(VAR1, VAR2, VAR3);
}
function FUN4(address VAR4, uint256 VAR2) public payable {
require(VAR2 >= msg.value, """");
if (VAR2 > msg.value) {
uint256 VAR5 = VAR2 - msg.value;
FUN5(VAR5);
}
emit FUN6(msg.sender, VAR4, VAR2);
VAR4.transfer(VAR2);
}
function () public payable {
require(msg.sender == address(VAR6));
}",RE,1
0x01a9a2b8638451d447f0027179b19e8843963a88.sol,"function ()public payable {
revert();
}
constructor( uint256 VAR1, string VAR2, string VAR3, address VAR4 ) public {
VAR5 = VAR4;
VAR6 = VAR1.FUN1( 10 ** uint256(VAR7));
VAR8 = VAR2;
VAR9 = VAR3;
VAR10[VAR4] = VAR6;
emit Transfer(address(0), msg.sender, VAR6);
}",RE,1
0x01aa952c2aa0259198e403c10799557e9a6b1ec1.sol,"function () payable{
FUN1();
}
constructor() public {
VAR1 = 0x8c79bb20c1bc595ccadefba88abddbe393f5df7d;
VAR2[VAR1] = VAR3;
}
function FUN1() payable {
if(VAR4 == true){
require(msg.value > 0);
uint256 VAR5 = msg.value.FUN2(100000000000000).FUN3(VAR6);
VAR2[msg.sender] = VAR2[msg.sender].FUN4(VAR5);
VAR3 = VAR3.FUN4(VAR5);
VAR1.transfer(msg.value);
}
else{
throw;
}
}",RE,1
0x01aaf00b615d97360e80ef1242a3935c8b7d529a.sol,"function () external payable {
}
function FUN1(address payable VAR1, uint256 VAR2) public onlyVault returns (bool) {
VAR1.transfer(VAR2);
return true;
}
function FUN1(address payable VAR1, uint256 VAR2) public VAR3 {
require (VAR1 != address(0));
VAR1.transfer(VAR2);
}
function FUN2() public payable {
require (VAR4 > 0);
uint256 VAR5 = msg.value.FUN3(VAR4);
FUN4(address(this), msg.sender, VAR5);
}",RE,1
0x01ad3c7da8364d3f73d8ba6deb88c2add26a7837.sol,"function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public nonReentrant payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
emit FUN6( msg.sender, VAR1, VAR2, VAR3 );
FUN7(VAR1, VAR2);
FUN8();
FUN9(VAR1, VAR2);
}
function FUN10(address VAR5) public onlyPrimary payable {
uint256 VAR6 = msg.value;
VAR7[VAR5] = VAR7[VAR5].FUN4(VAR6);
emit FUN11(VAR5, VAR6);
}
function FUN10(address VAR8) public payable {
require(VAR9 == VAR10.VAR11);
super.FUN10(VAR8);
}",RE,1
0x01b1ccae68dc41d8a2a0f48e8f0d38b0c064ef43.sol,"function FUN1() payable public returns (uint VAR1) {
VAR1 = msg.value / VAR2;
require(VAR3[this] >= VAR1);
VAR3[msg.sender] += VAR1;
VAR3[this] -= VAR1;
emit Transfer(this, msg.sender, VAR1);
return VAR1;
}",RE,1
0x01b21934ba28dfd8a22c4d21c710290500a5081f.sol,"function FUN1(uint256 VAR1) payable public {
require(msg.value >= VAR2 && VAR1 <= 5);
Game VAR3;
VAR3.VAR4 = msg.sender;
VAR3.VAR1 = VAR1;
VAR5.FUN2(VAR3);
if (VAR1 == VAR6) {
msg.sender.transfer(this.VAR7);
}
FUN3();
VAR8 = VAR9;
}
function() public payable {
}
}",RE,1
0x01b23286ff60a543ec29366ae8d6b6274ca20541.sol,"function () payable external {
revert();
}
FUN1 (address => uint256) private VAR1;
FUN1 (address => uint256) private VAR2;
event FUN2(address indexed VAR3, uint256 VAR4, uint256 VAR5);",RE,1
0x01b354a9fb34760455ee9cbe7d71d2ce5c11ab5c.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
library VAR5 {
using SafeMath for uint256;
using Address for address;",RE,1
0x01B46245544dD14C82506655C58004f45B0C33D4.sol,"function FUN1() internal view returns (address payable) {
return msg.sender;
}",RE,1
0x01b6e3aabe55d9ab81ef306479801448a4ca60c9.sol,"function() external payable {
}",RE,1
0x01b6f09b54d246670627a009a7dc85bd54354eed.sol,"function () payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) payable VAR2 {
assert(FUN2());
uint256 VAR3 = msg.value;
if(VAR4 && !VAR5) {
VAR6 = 2000;
}
if(VAR7 && !VAR8) {
if(VAR9 >= VAR10 && VAR9 <= VAR11) {
VAR6 = VAR12;
}
else if(VAR9 > VAR11 && VAR9 <= VAR13) {
VAR6 = VAR14;
}
else if(VAR9 > VAR13 && VAR9 <= VAR15) {
VAR6 = VAR16;
}
else {
VAR6 = VAR17;
}
}
uint256 VAR18 = VAR3.FUN3(VAR6);
VAR18 = VAR18.FUN4(1e10);
VAR19 = VAR19.FUN5(VAR3);
FUN6(VAR1, VAR18);
FUN7(msg.sender, VAR1, VAR3, VAR18);
VAR20.transfer(msg.value);
if(VAR4 && !VAR5 && VAR19 >= VAR21) {
VAR5 = true;
VAR22 = true;
}
}",RE,1
0x01b85861a8f278a627a17d86c7c7dfafd9281a15.sol,"function FUN1(uint VAR1, uint VAR2) internal pure returns (uint VAR3) {
require(VAR2 > 0);
VAR3 = VAR1 / VAR2;
}
}
contract VAR4 {
using SafeMath for uint;
uint256 public VAR5;
uint256 public VAR6 = 1680;
uint256 public VAR7;
FUN2(address => uint256)public VAR8;
FUN2(address => uint256)public VAR9;
FUN2(address => uint256) VAR10;
address payable VAR11 = 0xDC6dfe8040fc162Ab318De99c63Ec2cd0e203010;
struct VAR12 {
address VAR13;
uint8 VAR14;
}
FUN2(uint256 => VAR12)public VAR15;
modifier FUN3() {
address VAR16 = msg.sender;
uint256 VAR17;
VAR18 {
VAR17 := FUN4(VAR16)}
require(VAR17 == 0, """");
VAR19;
}
modifier FUN5() {
address sender = msg.sender;
require(VAR8[sender] > 0);
require(FUN6());
VAR19;
}
event FUN7 (address VAR20, uint256 VAR21, uint256 VAR22);
event FUN8(address VAR23, uint8 VAR24, address VAR25);
event FUN9 (uint256 VAR26, uint256 VAR27, uint256 VAR28);",RE,1
0x01bbec6573ed7eca0f307a10d2b4ceb669816b4a.sol,"function () public payable {
revert();
}
function () public payable {
require (VAR1.VAR2 <= VAR3);
require (msg.value > 0);
require (VAR4 >= VAR5 && VAR4 <= VAR6);
require (VAR7[msg.sender].VAR8);
require (!VAR9);
if (VAR4 < VAR10) {
require (!VAR7[msg.sender].VAR11);
require (msg.value <= VAR12);
}
uint VAR13 = msg.value.FUN1(VAR14).FUN2(1 VAR15);
require (VAR13 >= VAR16);
uint VAR17 = FUN3(msg.value.FUN1(VAR14).FUN2(VAR18));
VAR19 = VAR19.FUN4(VAR13);
if (VAR19 >= VAR20) {
FUN5();
}
else {
FUN6(msg.sender, VAR17);
}
}",RE,1
0x01bd70a0cc118bca4c70624286488e8f3d78a10f.sol,"function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
if (VAR4[VAR5] < VAR2) {
return;
}
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}",RE,1
0x01c54b1c806d0ccee805bdb7689a544917abe608.sol,"function () public payable {
revert();
}
event Transfer(address indexed VAR1, address indexed VAR2, uint256 VAR3);
event Transfer(address indexed VAR1, address indexed VAR2, uint VAR3, bytes VAR4);
event FUN1(address indexed VAR5, address indexed VAR6, uint256 VAR3);",RE,1
0x01c627181089b6e10ee8316ec08516b3df7c4845.sol,"function () public payable {
FUN1(msg.sender);
}
KycContract public VAR1;
function FUN1(address VAR2) public payable {
require(VAR2 != address(0));
require(FUN2());
if(VAR3){
require(FUN3(VAR4).FUN4(msg.sender));
}
uint256 VAR5 = msg.value;
uint256 VAR6 = FUN5(VAR5);
require(FUN6(VAR6));
if(int(VAR7 - VAR8) > 0) {
require(int (VAR6) < (int(VAR7 - VAR8)));
FUN7(VAR6,VAR5,VAR2);
}
else if (int (VAR9 + VAR7 - VAR8) > 0) {
require(int(VAR6) < (int(VAR9 + VAR7 - VAR8)));
FUN7(VAR6,VAR5,VAR2);
}
else if(int(VAR10 + VAR9 + VAR7 - VAR8) > 0) {
require(int(VAR6) < (int(VAR10 + VAR9 + VAR7 -VAR8)));
FUN7(VAR6,VAR5,VAR2);
}
else if(int(VAR11 + VAR10 + VAR9 + VAR7 - (VAR8)) > 0) {
require(int(VAR6) < (int(VAR11 + VAR10 + VAR9 + VAR7 - (VAR8))));
FUN7(VAR6,VAR5,VAR2);
}
else if(!VAR12 && (int(VAR13 - (VAR8)) > 0)) {
require(int(VAR6) < (int(VAR13 - (VAR8))));
FUN7(VAR6,VAR5,VAR2);
}
}
uint256 public VAR8=0;",RE,1
0x01c8bb9205fec775deb38534ea50a84c9b30a84b.sol,"function () public payable {
uint256 VAR1 = VAR2.FUN1(address(this));
require(VAR1 > 0);
uint256 VAR3 = msg.value;
require(VAR3 >= VAR4.FUN2(10 ** 18));
require(VAR3 <= VAR5.FUN2(10 ** 18));
uint256 VAR6 = VAR3.FUN2(VAR7).FUN3(10 ** 12);
if (VAR1 >= VAR6) {
assert(VAR2.transfer(msg.sender, VAR6));
VAR8.transfer(address(this).VAR1);
}
else {
uint256 VAR9 = VAR1.FUN3(VAR7);
assert(VAR2.transfer(msg.sender, VAR1));
msg.sender.transfer(VAR3 - VAR9.FUN2(10 ** 12));
VAR8.transfer(address(this).VAR1);
}
}",RE,1
0x01cc4151fe5f00efb8df2f90ff833725d3a482a3.sol,"function () external payable {
FUN1();
}
function FUN1() payable canDistr public {
uint256 VAR1 = 0;
require( msg.value >= VAR2 );
require( msg.value > 0 );
VAR1 = VAR3.FUN2(msg.value) / 1 VAR4;
address VAR5 = msg.sender;
if (VAR1 > 0) {
FUN3(VAR5, VAR1);
}
if (VAR6 >= VAR7) {
VAR8 = true;
}
}",RE,1
0x01Ce398A2A59d164f366762EE70c596de06E9482.sol,"function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("""");
require(VAR4, """");
}",RE,1
0x01ceb9dddea083d647fa7b09942474dece629c7e.sol,"function() public payable {
require(msg.value > 0, """");
VAR1.transfer(msg.value);
}
function FUN1() public payable returns(bool) {
require(msg.value > 0, """");
VAR1.transfer(msg.value);
return true;
}",RE,1
0x01d0734e34B0251f46aD34d1a82c4946a5B943D9.sol,"function FUN1(address VAR1, uint256 VAR2, uint16 VAR3) external payable;",RE,1
0x01d10fb85495e2c44097231fcbaafec890274d2c.sol,"function () external payable {
FUN1();
}
function FUN1() payable canDistr public {
uint256 VAR1 = 0;
require( msg.value >= VAR2 );
require( msg.value > 0 );
VAR1 = VAR3.FUN2(msg.value) / 1 VAR4;
address VAR5 = msg.sender;
if (VAR1 > 0) {
FUN3(VAR5, VAR1);
}
if (VAR6 >= VAR7) {
VAR8 = true;
}
}",RE,1
0x01d174f95cd17d0b5b24f1f89a35cfdb37929b30.sol,"function FUN1(string VAR1) public payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR5.FUN3(VAR1))) {
if(msg.value > 0.4 VAR6) {
msg.sender.transfer(address(this).VAR7);
}
}
}
function () public payable {
}
}",RE,1
0x01d1c640d58d5a3ed4da3028d70ef52954619024.sol,"function FUN1(address VAR1) onlyOwner public payable {
require(VAR2 == VAR3.VAR4);
VAR5[VAR1] = VAR5[VAR1].FUN2(msg.value);
}
function () nonZero payable {
FUN3();
}
function FUN3() public nonZero payable {
if(FUN4()) {
if(VAR6 == VAR3.VAR7) {
VAR6 = VAR3.VAR8;
}
FUN5(msg.sender, msg.value);
}
else if (FUN6()) {
if(VAR6 == VAR3.VAR9) {
VAR6 = VAR3.VAR10;
}
FUN5(msg.sender, msg.value);
}
else {
revert();
}
}",RE,1
0x01d28329619796bae733e849696f80a764422700.sol,"function FUN1(address VAR1) payable public returns(bool);
function() payable public {
require(FUN2(VAR2));
bool VAR3 = FUN3(VAR2).VAR3.value(msg.value)(msg.sender);
require(VAR3);
}
function () payable notPaused public {
FUN4(msg.sender);
}
function FUN1(address VAR1) payable notPaused public returns(bool VAR4) {
return FUN4(VAR1);
}",RE,1
0x01d5ca206cbb7a42dd227c9c554b24d3eba2190b.sol,"function () payable{
FUN1();
}
constructor() public payable {
FUN2();
VAR1 = 0x3dadc00fe6ab8b4897148a162fa9a17132b0a280;
VAR2[VAR1] = VAR3;
}
function () payable{
FUN1();
}
constructor() public payable {
FUN2();
VAR1 = 0x3dadc00fe6ab8b4897148a162fa9a17132b0a280;
VAR2[VAR1] = VAR3;
}
function FUN1() payable {
if(VAR4 == true){
require(msg.value > 0);
uint256 VAR5 = msg.value.FUN3(100000000000000).FUN4(VAR6);
VAR2[msg.sender] = VAR2[msg.sender].FUN5(VAR5);
VAR3 = VAR3.FUN5(VAR5);
VAR1.transfer(msg.value);
}
else{
throw;
}
}",RE,1
0x01d5d0108589f3c52fcce6e65503bb6515e66698.sol,"function () public payable FUN1(VAR1.VAR2) {
require(msg.sender == VAR3);
}",RE,1
0x01d614b9914342b7cbb798b1eb392460a05b3b4c.sol,"function () public payable {
revert();
}",RE,1
0x01d6208f95cf2292c350fc8bb1b1f29230352675.sol,"function () payable public {
emit FUN1(msg.sender, msg.value);
}
function FUN2() public payable {
}",RE,1
0x01d9c3baeb4a7b22a8742e07e9158ff7ae10737c.sol,"function () public payable {
require(VAR1);
require(msg.value != 0);
require(VAR2.VAR3 >= VAR4);
require(VAR2.VAR3 <= VAR5);
uint256 VAR6 = FUN1(msg.value, VAR7);
require(VAR6 + VAR8 <= VAR9);
VAR8 = FUN2(VAR8, VAR6);
VAR10[msg.sender] += VAR6;
emit FUN3(msg.sender, VAR6);
}
}",RE,1
0x01d9e65c0de733546db1bff56f44d45065d94e17.sol,"function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}",RE,1
0x01d9f4d104668cdc0b6d13c45dff5e15d58d8f28.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN1(uint VAR1) public notExecuted(VAR1) FUN5(VAR1) FUN6(VAR1) {
Transaction storage VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
function FUN7(uint VAR1) public notExecuted(VAR1) FUN5(VAR1) FUN8(VAR1) {
Transaction storage VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}",RE,1
0x01dae2898900622f79c5d09e7363693cd1f48be8.sol,"function () public payable {
revert();
}",RE,1
0x01dd3a4ab1141c15ac91fbc7d5cf167f45b27d09.sol,"function () payable {
require(!VAR1);
uint VAR2 = msg.value;
VAR3[msg.sender] += VAR2;
VAR4 += VAR2;
VAR5.transfer(msg.sender, VAR2 / VAR6);
FUN1(msg.sender, VAR2, true);
}
modifier FUN2() {
if (VAR7 >= VAR8) VAR9;
}
function() payable {
}
}",RE,1
0x01dd8186b8f38dfa01ea2c044355ea95206a4481.sol,"function FUN1(uint256 VAR1) external payable {
require(VAR2[VAR1] > 0);
require(msg.value >= VAR2[VAR1] / 100 * 150);
address VAR3 = VAR4[VAR1];
uint256 VAR5 = VAR2[VAR1];
VAR2[VAR1] = VAR5 / 100 * 150;
VAR4[VAR1] = msg.sender;
VAR6[VAR1] = uint256(VAR7);
VAR3.transfer(VAR5 / 100 * 125);
FUN2(VAR3, VAR5, uint256(VAR7));
if (VAR1 == 0) {
VAR8++;
FUN3(VAR8);
}
VAR9.transfer(this.VAR10);
}",RE,1
0x01de6c63735b18d2ef28ab9e01a85cf227be8ab6.sol,"function () public payable {
revert();
}",RE,1
0x01e13ae1ee71234964c4b1118d97db1de4efb632.sol,"function FUN1() external payable returns(bool);
}
contract RTB2 is VAR1 {
using SafeMath for uint256;
uint8 public VAR2 = 0;
uint256 public VAR3 = 700;
uint256 public VAR4 = 0;
uint256 public constant VAR5 = 1 VAR6;
string public VAR7 = """";
string public VAR8 = """";
address public VAR9;
address public VAR10;
FUN2 (address=>uint256) VAR11;
uint256 VAR12;
address public VAR13;
shareProfit public VAR14;
FUN2 (address=>uint256) VAR15;
FUN2 (address=>uint256) VAR16;
FUN2 (address=>FUN2 (address=>uint256)) VAR17;
event Transfer(address indexed VAR18, address indexed VAR19, uint256 VAR20);
event FUN3(address indexed VAR21, address indexed VAR22, uint256 VAR20);
event FUN4(address indexed VAR18, uint256 VAR20, uint256 VAR23);
event FUN5(address indexed VAR24, uint256 VAR20);
modifier onlyOwner() {
require(msg.sender == VAR9, """");
VAR25;
}
modifier onlyHuman() {
address VAR24 = msg.sender;
uint256 VAR26;
VAR27 {
VAR26 := FUN6(VAR24)}
require(VAR26 == 0, """");
VAR25;
}
constructor(address VAR28) public {
VAR9 = msg.sender;
VAR10 = 0x28Dd611d5d2cAA117239bD3f3A548DcE5Fa873b0;
VAR13 = 0x119ea7f823588D2Db81d86cEFe4F3BE25e4C34DC;
VAR14 = FUN7(VAR28);
VAR16[this] = 700;
}
function() public payable {
require(msg.value > 0, """");
VAR12 = msg.value.FUN8(VAR3).FUN9(VAR12);
emit FUN4(msg.sender, msg.value, VAR12);
}
function FUN1() external payable returns(bool){
if(msg.value > 0){
VAR12 = msg.value.FUN8(VAR3).FUN9(VAR12);
emit FUN4(msg.sender, msg.value, VAR12);
return true;
}
else{
return false;
}
}
function FUN10(uint256 VAR29) external onlyHuman payable{
require(VAR29 > 0);
uint256 VAR30 = VAR29.FUN11(VAR5);
require(msg.value == VAR30);
require(VAR16[this] >= VAR29);
require((VAR3 - VAR4) >= VAR29, """");
FUN12(this, msg.sender, VAR29);
VAR10.transfer(VAR30.FUN11(60).FUN8(100));
VAR13.transfer(VAR30.FUN11(20).FUN8(100));
VAR14.VAR31.value(VAR30.FUN11(20).FUN8(100))();
VAR4 += VAR29;
}",RE,1
0x01e15429fedbc08dec25e127df09b4af17167f5e.sol,"function FUN1(address VAR1, uint256 VAR2, uint256 VAR3) public payable {
require(VAR4 == false || (FUN2(msg.sender) && FUN2(VAR1)), """");
TradeOrder memory VAR5 = VAR6[VAR1];
require(VAR5.VAR3 == VAR3, """");
require(VAR7.VAR8 < VAR5.VAR9, """");
require(VAR3 >= VAR10, """");
require(VAR11 == 0 || VAR3 <= VAR11, """");
uint256 VAR12 = VAR5.VAR2 > VAR2 ? VAR2 : VAR5.VAR2;
VAR5.VAR2 = VAR5.VAR2.FUN3(VAR12);
if (VAR5.VAR2 == 0) {
VAR5.VAR3 = 0;
VAR5.VAR9 = 0;
}
VAR6[VAR1] = VAR5;
uint256 VAR13 = VAR12.FUN4(VAR5.VAR3);
require(msg.value >= VAR13, """");
uint256 VAR14 = FUN5(VAR13);
if(!FUN6(VAR15).FUN7(VAR1, msg.sender, VAR12)) {
revert("""");
}
VAR1.transfer(VAR13.FUN3(VAR14));
if(VAR14 > 0) VAR16.transfer(VAR14);
VAR17 = VAR3;
emit FUN8(msg.sender, VAR1, VAR12, VAR3);
}
function FUN9(address[] VAR18, uint256 VAR19) public payable returns (uint256 VAR20) {
require(VAR4 == false || FUN2(msg.sender), """");
VAR20 = 0;
for (uint VAR21 = 0; VAR21 < VAR18.VAR22; VAR21++) {
TradeOrder memory VAR23 = VAR6[VAR18[VAR21]];
if(VAR21 == VAR18.VAR22-1) {
FUN1(VAR18[VAR21], VAR19, VAR23.VAR3);
VAR20 += VAR19;
}
else {
FUN1(VAR18[VAR21], VAR23.VAR2, VAR23.VAR3);
VAR20 += VAR23.VAR2;
}
}
return VAR20;
}
function FUN10(uint256 VAR24, address VAR25, address VAR1, uint256 VAR2) public onlyOwner payable {
TradeOrder memory VAR5 = VAR6[VAR1];
FUN1(VAR1, VAR2, VAR5.VAR3);
emit FUN11(VAR24, VAR25, VAR1, VAR2);
}
function FUN12(uint256 VAR24, address VAR25, address[] VAR18, uint256 VAR19) public onlyOwner payable {
uint256 VAR20 = FUN9(VAR18, VAR19);
address VAR1 = VAR18.VAR22 == 1 ? VAR18[0] : 0;
emit FUN11(VAR24, VAR25, VAR1, VAR20);
}",RE,1
0x01e53a2e7122a63845b1c329d4fce8124dda5b06.sol,"function() payable {
FUN1();
}",RE,1
0x01e579be97433f861340268521a7a2ab9829082c.sol,"function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
if (VAR4[VAR5] < VAR2) {
return;
}
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}",RE,1
0x01e799ebd5d11ddeea11e30466ce117b86726458.sol,"function() public payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}",RE,1
0x01ec2fb34a6640acfb59861bbdf6aa65af18bd43.sol,"function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
if (VAR4[VAR5] < VAR2) {
return;
}
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}",RE,1
0x01f04e3818f16256757a846eb670f309a0a0c512.sol,"constructor () internal {
VAR1 = 1;
}
modifier FUN1() {
VAR1 += 1;
uint256 VAR2 = VAR1;
VAR3;
require(VAR2 == VAR1);
}
}
contract Crowdsale is VAR4 {
using SafeMath for uint256;
using SafeERC20 for VAR5;
IERC20 private VAR6;
address payable private VAR7;
uint256 private VAR8;
uint256 private VAR9;
event FUN2(address indexed VAR10, address indexed VAR11, uint256 value, uint256 VAR12);",RE,1
0x01f6462bf3fc10876e1e3b707b352545308a38a7.sol,"function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}",RE,1
0x01f673e1af7416ff3795ff62393cdf014ce050fd.sol,"function () public payable {
require(VAR1 >= VAR2 && VAR1 <= VAR3);
uint VAR4;
if (VAR1 <= VAR5) {
VAR4 = msg.value * 1200;
}
else {
VAR4 = msg.value * 1000;
}
VAR6[msg.sender] = FUN1(VAR6[msg.sender], VAR4);
VAR7 = FUN1(VAR7, VAR4);
Transfer(address(0), msg.sender, VAR4);
VAR8.transfer(msg.value);
}",RE,1
0x01f8c4e3fa3edeb29e514cba738d87ce8c091d3f.sol,"function FUN1(uint VAR1) public payable {
if(VAR2[msg.sender]>=VAR3 && VAR2[msg.sender]>=VAR1) {
if(msg.sender.call.value(VAR1)()) {
VAR2[msg.sender]-=VAR1;
VAR4.FUN2(msg.sender,VAR1,"""");
}
}
}",RE,1
0x01f9ed6f62ebf73f7f5e09c1cd07f0665e68b706.sol,"function () public payable {
require(msg.value >= VAR1);
require(VAR2 < VAR3);
require(VAR4 != VAR5.VAR6);
require(VAR4 != VAR5.VAR7);
require(msg.value > 0);
uint256[] memory VAR8 = FUN1(msg.value);
require (VAR8[0] > 0);
VAR9[msg.sender] = VAR9[msg.sender].FUN2(VAR8[0]);
VAR10 = VAR10.FUN2(VAR8[0]);
require(VAR10 <= VAR11.FUN2(VAR12));
emit Transfer(address(this), msg.sender, VAR8[0]);
uint256 VAR13 = msg.value.FUN3(VAR8[1]);
VAR14.transfer(VAR13);
if(VAR8[1] > 0){
msg.sender.transfer(VAR8[1]);
emit Transfer(address(this), msg.sender, VAR8[1]);
}
}",RE,1
0x01fa1B31766c0e58a2C66b6FBa3C36128aea60E4.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3) external payable returns (uint256);",RE,1
0x01fbb42b56f38782d8db4ba8abba44eeaa472f81.sol,"function () public payable {
revert();
}
}
contract VAR1 {
address public VAR2;
event FUN1(address indexed VAR3, address indexed VAR4);",RE,1
0x01Fcb5Bc16e8d945bA276DCCFeE068231DA4cE33.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;",RE,1
0x01fd49a2042e962eb9b4f7fa1efaa8eac4cefeed.sol,"function() public payable {
if (msg.value.FUN1()) {
FUN2();
return;
}
FUN3(msg.VAR1.FUN4());
}
function FUN3(address VAR2) public payable notFromContract VAR3 {
uint VAR4 = msg.value;
uint VAR5 = msg.value;
require(VAR4 >= VAR6, """");
require(address(this).VAR7 <= VAR8, """");
if (VAR9.FUN5()) {
uint VAR10 = VAR9.FUN6();
VAR10.FUN7();
VAR4 = VAR11.FUN8(VAR4, VAR10);
assert(VAR9.FUN9(VAR4));
emit FUN10(msg.sender, VAR12, VAR4, VAR9.FUN11());
}
else if (VAR13.FUN5()) {
uint VAR14 = VAR13.FUN12(msg.sender);
VAR14.FUN7();
VAR4 = VAR11.FUN8(VAR4, VAR14);
}
if (VAR5 > VAR4) {
uint VAR15 = VAR5 - VAR4;
msg.sender.transfer(VAR15);
VAR5 = VAR4;
emit FUN13(msg.sender, VAR12, msg.value, VAR4, VAR15);
}
VAR16.FUN14(VAR17.FUN15(VAR5));
VAR18.FUN14(VAR19.FUN15(VAR5));
bool VAR20 = VAR21.FUN16(msg.sender);
if (VAR2.FUN17() && !VAR20 && !VAR22[msg.sender] && VAR2 != msg.sender && VAR21.FUN16(VAR2)) {
VAR22[msg.sender] = true;
uint VAR23 = VAR24.FUN18(VAR4);
if (VAR4 > 10 VAR25) {
VAR23 = VAR26.FUN18(VAR4);
}
uint VAR27 = VAR28.FUN18(VAR4);
assert(VAR21.FUN19(VAR2, VAR23));
VAR4 += VAR27;
emit FUN20(msg.sender, VAR2, VAR12, VAR27);
}
uint VAR29 = FUN21(msg.sender);
if (VAR20 && VAR29.FUN17()) {
VAR4 += VAR29;
emit FUN22(msg.sender, VAR12, VAR29);
}
if (VAR20) {
assert(VAR21.FUN19(msg.sender, VAR4));
assert(VAR21.FUN23(msg.sender, VAR12));
}
else {
assert(VAR21.FUN24(msg.sender, VAR4, VAR12));
emit FUN25(msg.sender, VAR12);
}
VAR30++;
emit FUN26(msg.sender, VAR12, VAR4, VAR5);
}",RE,1
0x01ff50f8b7f74e4f00580d9596cd3d0d6d6e326f.sol,"function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
require(VAR1 != address(0));
require(FUN2());
uint256 VAR2 = msg.value;
uint256 VAR3 = VAR2.FUN3(VAR4);
VAR5 = VAR5.FUN4(VAR2);
VAR6.FUN5(VAR1, VAR3);
FUN6(msg.sender, VAR1, VAR2, VAR3);
FUN7();
}",RE,1
0x0200412995f1bafef0d3f97c4e28ac2515ec1ece.sol,"function() public payable {
revert();
}
}",RE,1
0x020171085bcd43b6FD36aD8C95aD61848B1211A2.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("""");
require(VAR4, """");
}
function FUN2() internal view virtual returns (address payable) {
return msg.sender;
}",RE,1
0x0202Be363B8a4820f3F4DE7FaF5224fF05943AB1.sol,"function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("""");
require(VAR4, """");
}",RE,1
0x02048d70104baa4f6f267681a1a18161a570fc85.sol,"function FUN1() public view returns(uint8) {
return VAR1;
}
}
contract DogDeFiCoin is VAR2 {
using SafeMath for uint256;
FUN2 (address => uint256) private VAR3;
FUN2 (address => FUN2 (address => uint256)) private VAR4;
string constant VAR5 = """";
string constant VAR6 = """";
uint8 constant VAR7 = 18;
uint256 VAR8 = 12000000 * 1e18;
IERC20 VAR9 ;
address payable public VAR10;
modifier onlyOwner() {
require(msg.sender == VAR10);
VAR11;
}
constructor() public payable FUN3(VAR5, VAR6, VAR7) {
VAR10 = msg.sender;
require(VAR8 != 0);
VAR3[VAR10] = VAR3[VAR10].FUN4(VAR8);
emit Transfer(address(0), VAR10, VAR8);
}
function FUN1() public view returns(uint8) {
return VAR1;
}
}
contract DogDeFiCoin is VAR2 {
using SafeMath for uint256;
FUN2 (address => uint256) private VAR3;
FUN2 (address => FUN2 (address => uint256)) private VAR4;
string constant VAR5 = """";
string constant VAR6 = """";
uint8 constant VAR7 = 18;
uint256 VAR8 = 12000000 * 1e18;
IERC20 VAR9 ;
address payable public VAR10;
modifier onlyOwner() {
require(msg.sender == VAR10);
VAR11;
}
constructor() public payable FUN3(VAR5, VAR6, VAR7) {
VAR10 = msg.sender;
require(VAR8 != 0);
VAR3[VAR10] = VAR3[VAR10].FUN4(VAR8);
emit Transfer(address(0), VAR10, VAR8);
}",RE,1
0x0208a56ea43c3ff6c2611071948794c2674a16b9.sol,"function () public payable {
}",RE,1
0x020b2b2c8b515f0e7af20f2ef2f313945210e8d0.sol,"function() payable public {
FUN1(msg.sender);
}
function FUN1(address VAR1) payable public {
require(VAR1 != address(0));
require(msg.value != 0);
require(FUN2());
uint256 VAR2 = msg.value;
VAR3[VAR1] += VAR2;
VAR4 += VAR2;
FUN3(msg.sender, VAR1, VAR2);
VAR5.transfer(VAR2);
}",RE,1
0x020c710646e23ab868dbe5b88004892797fe4efb.sol,"function () public payable {
revert();
}
}",RE,1
0x020d06cf650d5e4004ae5454e3399df8548f2ba1.sol,"function FUN1(address VAR1, address VAR2, uint256 value) public returns (bool);
event Transfer(address indexed VAR1, address indexed VAR2, uint256 value);
uint8 public VAR3;
}
contract Bussiness is VAR4 {
address public VAR5 = address(0xFce92D4163AA532AA096DE8a3C4fEf9f875Bc55F);
IERC721 public VAR6 = FUN2(0x06012c8cf97BEaD5deAe237070F9587f8E7A266d);
ERC20BasicInterface public VAR7 = FUN3(0xEc7ba74789694d0d03D458965370Dc7cF2FE75Ba);
uint256 public VAR8 = 0;
uint256 public VAR9 = 1000;
uint256 public VAR10 = 21;
uint256 public VAR11 = 0;
uint256 public VAR12 = 0;
uint256 public VAR13 = 10000000000000000;
constructor() public {
}
struct VAR14 {
address payable VAR15;
uint256 VAR16;
uint256 VAR17;
uint256 VAR18;
bool VAR19;
}
uint[] public VAR20;
FUN4(uint256 => VAR14) public VAR21;
modifier FUN5() {
require(msg.sender == VAR5);
VAR22;
}",RE,1
0x020d5e6fec03d0144a2681cfc0fd3c9255d6d7c2.sol,"function () public payable {
revert();
}",RE,1
0x020ddc98365d0199b4c7a2d769d685480789f67e.sol,"function FUN1() public payable {
require(msg.value == 0);
}",RE,1
0x020e0638aa7d98b40d2a3a7ebd37ebdfc5cba2fd.sol,"function FUN1(uint256 VAR1) public payable {
Bag storage VAR2 = VAR3[VAR1];
address VAR4 = VAR2.VAR5;
address VAR6 = msg.sender;
require(VAR4 != VAR6);
require(FUN2(VAR6));
uint256 VAR7 = FUN3(VAR2);
require(msg.value >= VAR7);
uint256 VAR8 = uint256(VAR9.FUN4(VAR9.FUN5(VAR7, 92), 100));
uint256 VAR10 = VAR9.FUN6(msg.value, VAR7);
uint256 VAR11 = FUN7(VAR2);
VAR2.VAR11 = VAR9.FUN8(VAR11, 1);
VAR2.VAR5 = VAR6;
VAR2.VAR12 = VAR13;
if (VAR4 != address(this)) {
VAR4.transfer(VAR8);
}
FUN9(VAR1, VAR2.VAR14, VAR7, FUN3(VAR2), VAR4, VAR6);
VAR6.transfer(VAR10);
}",RE,1
0x020e13faf0955efef0ac9cd4d2c64c513ffcbdec.sol,"function() payable public {
if (VAR1 == msg.sender) {
return;
}
if (0 == msg.value) {
FUN1();
return;
}
require(false == VAR2, """");
require(msg.value >= VAR3, """");
Investor storage VAR4 = VAR5[msg.sender];
if (VAR4.VAR6 == 0) {
msg.sender.transfer(0 VAR7);
VAR8.FUN2(msg.sender);
VAR4.VAR6 = VAR8.VAR9;
VAR4.VAR10 = VAR11;
address VAR12 = FUN3(msg.VAR13);
if (VAR5[VAR12].VAR14 > 0 && VAR12 != msg.sender) {
VAR4.VAR12 = VAR12;
}
}
else {
FUN1();
}
VAR4.VAR14 += msg.value;
VAR4.VAR15 += 1;
emit FUN4(msg.sender, msg.value, VAR4.VAR12);
VAR16 += msg.value;
VAR17 = VAR11;
VAR18.transfer(msg.value / 5);
uint VAR19 = (msg.value / 100) * VAR20;
if (VAR4.VAR12 > 0x0) {
if (VAR4.VAR12.FUN5(VAR19)) {
emit FUN6(VAR4.VAR12, VAR19, """", msg.sender);
}
if (VAR4.VAR15 == 1) {
if (msg.sender.FUN5(VAR19)) {
emit FUN6(msg.sender, VAR19, """", 0);
}
}
}
else if (VAR21.VAR22 > 0x0) {
if (VAR21.VAR22.FUN5(VAR19)) {
emit FUN6(VAR21.VAR22, VAR19, """", msg.sender);
}
}
if (VAR4.VAR14 > VAR21.VAR14) {
VAR21 = FUN7(msg.sender, VAR4.VAR14);
emit FUN8(msg.sender, VAR4.VAR14);
}
}",RE,1
0x02114334e7ff9601085d5b5805f8694147317c3f.sol,"function FUN1(uint256 VAR1, address VAR2, address VAR3, uint256 VAR4, uint256 VAR5, uint256 VAR6, address VAR7, bytes VAR8) FUN2(VAR9) payable public returns (bool VAR10, uint256 VAR11) {
Purchase memory VAR12;
(VAR12.VAR13.VAR14, VAR12.VAR13.VAR15, VAR12.VAR13.VAR16, VAR12.VAR13.VAR17) = FUN3().FUN4();
VAR12.VAR13.VAR18 = FUN3().FUN5();
VAR12.VAR13.VAR19 = FUN3().FUN6();
VAR12.VAR20.VAR21 = VAR2;
VAR12.VAR22.VAR21 = VAR3;
VAR12.VAR23 = VAR4;
VAR12.VAR24 = VAR5;
VAR12.VAR25 = VAR6;
VAR12.VAR26 = VAR7;
VAR12.VAR27 = VAR8;
VAR12.VAR28 = VAR1;
Purchase memory VAR29;
(VAR29, VAR10) = FUN7(VAR12);
VAR11 = VAR29.VAR30.VAR31;
}
function FUN8( uint256 VAR1, address VAR2, uint256 VAR32, uint256 VAR33, uint256 VAR4, uint256 VAR6, address VAR7, bytes VAR8 ) FUN2(VAR34) payable public returns (bool VAR10, uint256 VAR11) {
VAR11 = FUN9( VAR1, VAR2, VAR32, VAR33, VAR4, VAR6, VAR7, VAR35, VAR8 );
VAR10 = true;
}
function FUN10( uint256 VAR32, uint256 VAR33, uint256 VAR4, uint256 VAR6, address VAR7, bytes VAR8 ) payable public returns (bool VAR10, uint256 VAR11) {
address VAR36 = msg.sender;
(VAR10, VAR11) = FUN11() .VAR37 .value(msg.value)( msg.value, VAR36, VAR32, VAR33, VAR4, VAR6, VAR7, VAR8 );
require(VAR10);
}",RE,1
0x0212f052cbf41b91cb6daf0735325102e5f4ab76.sol,"function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public nonReentrant payable {
uint256 VAR2 = msg.value;
uint256 VAR3 = FUN2(VAR2);
VAR4 = VAR4.FUN3(VAR2);
FUN4(VAR1, VAR2);
FUN5(VAR1, VAR3);
emit FUN6( msg.sender, VAR1, VAR2, VAR3 );
FUN7();
}",RE,1
0x02135140a3ecce81711460bac817060a6e4a96d7.sol,"function() payable {
FUN1(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);
}
function FUN2() payable external {
FUN1(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);
}
function FUN1(uint VAR1) payable public {
require(msg.value >= VAR2);
assert(!VAR3);
uint VAR4;
uint VAR5;
uint VAR6;
(VAR4, VAR6) = FUN3(msg.value);
if(VAR4 == 0) {
msg.sender.transfer(msg.value);
return;
}
VAR5 = VAR6.FUN4(VAR4);
if(VAR5 > VAR1) {
msg.sender.transfer(msg.value);
return;
}
assert(VAR5 >= VAR2);
assert(VAR6 <= msg.value);
VAR7 = VAR7.FUN5(VAR4);
VAR8[msg.sender] = VAR8[msg.sender].FUN5(VAR4);
FUN6(msg.sender, VAR4, VAR6.FUN4(1000000000000000000), VAR7);
if(msg.value > VAR6) {
msg.sender.transfer(msg.value.FUN7(VAR6));
}
VAR9 += VAR6.FUN4(1000000000000000000);
}",RE,1
0x021576770cb3729716ccfb687afdb4c6bf720cb6.sol,"function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("""");
require(VAR4, """");
}",RE,1
0x02169578b41b8f7f5f2dd0491aa2682a13196c44.sol,"function () public payable {
revert();
}",RE,1
0x0216a774d40296b54d95352ce5b0460343b7d199.sol,"function FUN1( address VAR1, uint256 value, bytes VAR2 ) public payable VAR3 FUN2(VAR1) returns (bool) {
require( transfer(VAR1, value) && VAR2.VAR4 >= 68 );
VAR5 {
FUN3(FUN4(VAR2, 36), value) FUN3(FUN4(VAR2, 68), VAR6) }
require(VAR1.call.value(msg.value)(VAR2));
return true;
}",RE,1
0x0217495d71d7246205bc1b1039dad814d0c0c192.sol,"function () public payable {
require(VAR1.VAR2 >= 6618553);
if(msg.value > 0){
require(FUN1() >= 250000);
require(msg.value >= 0.05 VAR3 && msg.value <= 5 VAR3);
VAR4.FUN2( FUN3(msg.sender, msg.value, 0) );
VAR5[msg.sender] = VAR4.VAR6;
VAR7 += msg.value;
uint VAR8 = msg.value*VAR9/100;
VAR10.FUN4(VAR8);
uint VAR11 = msg.value*VAR9/100;
VAR12.FUN4(VAR11);
uint VAR13 = msg.value*VAR9/100;
VAR14.FUN4(VAR13);
uint VAR15 = msg.value*VAR16/100;
VAR17.FUN4(VAR15);
FUN5();
}
}",RE,1
0x0218c4e3aad7ecf71ccc5d5aaa43c02245f45ccd.sol,"function FUN1() public view returns(uint8) {
return VAR1;
}
}
contract Erosion is VAR2 {
using SafeMath for uint256;
FUN2 (address => uint256) private VAR3;
FUN2 (address => FUN2 (address => uint256)) private VAR4;
string constant VAR5 = """";
string constant VAR6 = """";
uint8 constant VAR7 = 18;
uint256 VAR8 = 10000000000000000000000000;
address constant VAR9 = 0x3f17f1962B36e491b30A40b2405849e597Ba5FB5;
constructor() public payable FUN3(VAR5, VAR6, VAR7) {
FUN4(msg.sender, VAR8);
}",RE,1
0x021ae70bdea09eb2688c1def7af0ec37f431299b.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;",RE,1
0x021e5e6ab3efe5eb0c060b4c4c523c7470787ef5.sol,"function() public payable {
}
address VAR1;
function FUN1(uint256 VAR2) public payable {
if (msg.value >= 1 VAR3) {
VAR4 = VAR2;
}
}
uint256 VAR4;",RE,1
0x022057c3ef9166433750165bfda21d52988e0756.sol,"function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("""");
require(VAR4, """");
}",RE,1
0x022125b1ee6de357ad437807c1e0ce4daa6c82b3.sol,"function FUN1() payable returns (uint256){
assert(msg.value > VAR1);
assert(msg.value > 0);
uint256 VAR2 = 1000000000000000000;
uint VAR3 = VAR2 * 100;
uint256 VAR4 = ((msg.value * VAR5)/(VAR1 * VAR3))/10000000000000000;
assert((VAR4 != 0) || (VAR4 <= VAR6));
VAR6 = FUN2(VAR6,VAR4);
if (VAR7[msg.sender] != 0) {
VAR7[msg.sender] = FUN3(VAR7[msg.sender], VAR4);
}
else{
VAR7[msg.sender] = VAR4;
}
return VAR4;
}
function transfer(address VAR8, uint256 VAR9) payable returns (bool VAR10){
assert((VAR8 != 0) && (VAR9 > 0));
assert(VAR7[msg.sender] >= VAR9);
assert(FUN3(VAR7[VAR8], VAR9) > VAR7[VAR8]);
Transfer(msg.sender, VAR8, VAR9);
VAR7[msg.sender] = FUN2(VAR7[msg.sender],VAR9);
VAR7[VAR8] = FUN3(VAR7[msg.sender], VAR9);
return true;
}",RE,1
0x0224853bdff6b04ce259d87303b7523d4e16d656.sol,"function FUN1(uint VAR1, string VAR2, string VAR3) external payable returns (bytes32 VAR4);",RE,1
0x02254eff0f795c7731960cdc7cd997e10d10f305.sol,"function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("""");
require(VAR4, """");
}",RE,1
0x0228e1074bd0d089719e69f7c3bf0a97b6ab0c05.sol,function FUN1() public virtual payable;,RE,1
0x022de2e28a61f9d197f8966dd0fc8f7ddf70f2dc.sol,"function () payable noReentrancy {
State VAR1 = FUN1();
if (VAR1 == VAR2.VAR3) {
FUN2();
}
else if (VAR1 == VAR2.VAR4) {
FUN3();
}
else {
throw;
}
}",RE,1
0x022de5f5d6df5624487d9c51b0d496f9d8721878.sol,"function() payable public {
FUN1(msg.sender);
}
function FUN1(address VAR1) public FUN2(VAR2.VAR3) payable returns (uint256){
require(VAR1 != address(0));
require(VAR4 == true);
uint256 VAR5 = msg.value;
uint256 VAR6 = FUN3(VAR5);
if (VAR6 == 0) {
revert();
}
VAR7 = VAR7.FUN4(VAR5);
VAR8 = VAR8.FUN4(VAR6);
FUN5(VAR1, VAR6, VAR9);
FUN6(VAR1, VAR5, VAR6);
if (VAR10[VAR1] == 0) {
VAR11 = VAR11.FUN4(1);
}
FUN7(VAR1);
VAR12.transfer(VAR5);
return VAR6;
}",RE,1
0x022f13449b9624300a89d947e5c448b49265c0c9.sol,"function () payable isRunning public {
if (msg.value < 0.001 VAR1) revert();
FUN1();
}",RE,1
0x02307ee1ab299f40bb8bf7260e1f25610e3e654e.sol,"function() payable public {
require (msg.value >= 0.001 VAR1);
}
}",RE,1
0x0231f96bcbccd3d7b64ef63b55c652447cac2a29.sol,"function FUN1(address payable VAR1, string memory VAR2) public payable returns (address VAR3) {
VAR3 = address(VAR4 FUN2(VAR1, VAR2));
VAR1.transfer(msg.value);
}
}",RE,1
0x0233421a43929a0B98Eea6726c67fdeF713CEe96.sol,"function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}",RE,1
0x0233ae8ad87f613067697c87355bad8d6ca42445.sol,"function() external payable {
emit FUN1(msg.sender, msg.value);
}
function FUN2(uint256 VAR1, address payable VAR2) public onlyOwner returns(bool) {
VAR2.transfer(VAR1);
emit FUN3(VAR1, VAR2);
return true;
}
function FUN2(uint256 VAR1, address payable VAR2, Avatar VAR3) external returns(bool);",RE,1
0x0234ae8f8e5a5aeccff9f633aa8d81aa17677ed0.sol,"function FUN1( uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, address VAR5 ) public payable {
require(msg.value > 0);
require(VAR1 > 0);
require(VAR2 >= VAR6);
require(VAR3 >= VAR2);
require(VAR4 > 0);
require(VAR5 != 0x0);
VAR7 = msg.sender;
VAR8 = VAR1;
VAR9 = VAR2;
VAR10 = VAR3;
VAR11 = VAR4;
VAR12 = VAR5;
VAR13 = VAR14 FUN2();
VAR12.transfer(msg.value);
}
function () public payable {
FUN3(msg.sender);
}
function FUN3(address VAR15) saleOpen public payable {
require(VAR15 != address(0));
require(msg.value > 0);
uint256 VAR16 = msg.value;
uint256 VAR17 = VAR18[VAR15].FUN4(VAR16);
require(VAR17 <= VAR19[VAR15]);
uint256 VAR20 = VAR16.FUN5(VAR11);
VAR18[VAR15] = VAR17;
VAR21.FUN6(VAR15);
VAR22 = VAR22.FUN4(VAR16);
VAR13.FUN7(VAR15, VAR20);
FUN8( msg.sender, VAR15, VAR16, VAR20 );
}
function FUN9(address VAR5) onlyOwner public payable {
require(VAR5 != 0x0);
require(msg.value > 0);
FUN10(VAR12, VAR5);
VAR12 = VAR5;
VAR12.transfer(msg.value);
}",RE,1
0x02352e6dcf0c77577222adee8c63d52243b5c33f.sol,"function () external payable {
VAR1 {
let VAR2 := FUN1(FUN2(0), 0xffffffffffffffffffffffffffffffffffffffff) FUN3(0, 0, FUN4()) let VAR3 := FUN5(VAR4, VAR2, 0, FUN4(), 0, 0) FUN6(0, 0, FUN7()) if FUN8(VAR3, 0) {
revert(0, FUN7()) }
return(0, FUN7()) }
}
}",RE,1
0x0236da65d76ae844abb81814cebb6fe9b001d587.sol,"function FUN1() onlyOwner isNotFinalized external payable {
}
function() isNotFinalized external payable {
FUN2();
}
function FUN2() isNotFinalized public payable {
require(msg.value > 0);
uint256 VAR1 = msg.value;
VAR2 = VAR2.FUN3(VAR1);
VAR3.transfer(VAR1);
FUN4(msg.sender, VAR3, VAR1);
if(this.VAR4 >= VAR1) {
VAR2 = VAR2.FUN3(VAR1);
VAR3.transfer(VAR1);
FUN5(address(this), VAR3, VAR1);
}
else {
VAR2 = VAR2.FUN3(this.VAR4);
VAR3.transfer(this.VAR4);
FUN5(address(this), VAR3, this.VAR4);
}
}",RE,1
0x023885BD1408882BB4AA0F2AE468b29CA2dEA7D1.sol,"function FUN1(address VAR1) public {
address VAR2 = address(FUN2(address(this)).FUN3());
if (VAR2 == address(0)) {
return;
}
DSGuard VAR3 = FUN4(VAR2);
VAR3.FUN5(VAR1, address(this), bytes4(FUN6("""")));
}
}
contract VAR4 {
address public constant VAR5 = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;
address public constant VAR6 = 0x14094949152EDDBFcd073717200DA82fEd8dC960;
address public constant VAR7 = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;
address public constant VAR8 = 0xF5DCe57282A584D2746FaF1593d3121Fcac444dC;
address public constant VAR9 = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
address public constant VAR10 = 0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2;
address public constant VAR11 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
address public constant VAR12 = 0x9B0F70Df76165442ca6092939132bBAEA77f2d7A;
address public constant VAR13 = 0xf53AD2c6851052A81B42133467480961B2321C09;
address public constant VAR14 = 0x448a5065aeBB8E423F0896E6c5D525C040f59af3;
address payable public constant VAR15 = 0x322d58b9E75a6918f7e7849AEe0fF09369977e08;
address public constant VAR16 = 0xeCf88e1ceC2D2894A0295DB3D86Fe7CE4991E6dF;
address public constant VAR17 = 0x794e6e91555438aFc3ccF1c5076A74F42133d08D;
address public constant VAR18 = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;
address public constant VAR19 = 0x8F337bD3b7F2b05d9A8dC8Ac518584e833424893;
address public constant VAR20 = 0x1e30124FDE14533231216D95F7798cD0061e5cf8;
address public constant VAR21 = 0xd7BBB1777E13b6F535Dec414f575b858ed300baF;
address public constant VAR22 = 0x9aBE2715D2d99246269b8E17e9D1b620E9bf6558;
address public constant VAR23 = 0x818E6FECD516Ecc3849DAf6845e3EC868087B755;
address public constant VAR24 = 0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95;
address public constant VAR25 = 0x5a15566417e6C1c9546523066500bDDBc53F88C7;
address public constant VAR26 = 0x729D19f657BD0614b4985Cf1D82531c67569197B;
address public constant VAR27 = 0x4678f0a6958e4D2Bc4F1BAF7Bc52E8F3564f3fE4;
address public constant VAR28 = 0x0000000000b3F879cb30FE243b4Dfee438691c04;
address public constant VAR29 = 0x89b3635BD2bAD145C6f92E82C9e83f06D5654984;
address public constant VAR30 = 0xAD32Ce09DE65971fFA8356d7eF0B783B82Fd1a9A;
address public constant VAR31 = 0x6eC6D98e2AF940436348883fAFD5646E9cdE2446;
address public constant VAR32 = 0x25a01a05C188DaCBCf1D61Af55D4a5B4021F7eeD;
address public constant VAR33 = 0x863E41FE88288ebf3fcd91d8Dbb679fb83fdfE17;
address public constant VAR34 = 0x5ef30b9986345249bc32d8928B7ee64DE9435E39;
address public constant VAR35 = 0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B;
address public constant VAR36 = 0x65C79fcB50Ca1594B025960e539eD7A9a6D434A3;
address public constant VAR37 = 0x82ecD135Dce65Fbc6DbdD0e4237E0AF93FFD5038;
address public constant VAR38 = 0x19c0976f590D67707E62397C87829d896Dc0f1F1;
address public constant VAR39 = 0x9759A6Ac90977b93B58547b4A71c78317f391A28;
address public constant VAR40 = 0x2F0b23f53734252Bda2277357e97e1517d6B042A;
address public constant VAR41 = 0xe4B22D484958E582098A98229A24e8A43801b674;
address public constant VAR42 = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;
address public constant VAR43 = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
address payable public constant VAR44 = 0xc73e0383F3Aff3215E6f04B0331D58CeCf0Ab849;
address public constant VAR45 = 0x83152CAA0d344a2Fd428769529e2d490A88f4393;
address public constant VAR46 = 0x3F4339816EDEF8D3d3970DB2993e2e0Ec6010760;
address public constant VAR47 = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643;
address public constant VAR48 = 0x493C57C4763932315A328269E1ADaD09653B9081;
address public constant VAR49 = 0x95E6F48254609A6ee006F7D493c8e5fB97094ceF;
}
contract VAR50 {
address public constant VAR9 = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
address public constant VAR11 = 0xd0A1E359811322d97991E03f863a0C30C2cF029C;
address public constant VAR5 = 0xC4375B7De8af5a38a93548eb8453a498222C4fF2;
address public constant VAR10 = 0xAaF64BFCC32d0F15873a02163e7E500671a4ffcD;
address public constant VAR12 = 0xBb4339c0aB5B1d9f14Bd6e3426444A1e9d86A1d9;
address public constant VAR13 = 0xf4d791139cE033Ad35DB2B2201435fAd668B1b64;
address public constant VAR14 = 0xa71937147b55Deb8a530C7229C442Fd3F31b7db2;
address public constant VAR16 = 0x32d0e18f988F952Eb3524aCE762042381a2c39E5;
address payable public constant VAR15 = 0x54b44C6B18fc0b4A1010B21d524c338D1f8065F6;
address public constant VAR17 = 0x4A6bC4e803c62081ffEbCc8d227B5a87a58f1F8F;
address public constant VAR32 = 0x25a01a05C188DaCBCf1D61Af55D4a5B4021F7eeD;
address public constant VAR7 = 0x4EC3570cADaAEE08Ae384779B0f3A45EF85289DE;
address public constant VAR6 = 0xA1e58F3B1927743393b25f261471E1f2D3D9f0F6;
address public constant VAR8 = 0xb6b09fBffBa6A5C4631e5F7B2e3Ee183aC259c0d;
address public constant VAR33 = 0x863E41FE88288ebf3fcd91d8Dbb679fb83fdfE17;
address public constant VAR18 = 0x1297c1105FEDf45E0CF6C102934f32C4EB780929;
address public constant VAR51 = 0xADB7c74bCe932fC6C27ddA3Ac2344707d2fBb0E6;
address public constant VAR19 = 0x68c56FF0E7BBD30AF9Ad68225479449869fC1bA0;
address public constant VAR20 = 0x2A4ee140F05f1Ba9A07A020b07CCFB76CecE4b43;
address public constant VAR21 = 0x823cde416973a19f98Bb9C96d97F4FE6C9A7238B;
address public constant VAR22 = 0x0257Ba4876863143bbeDB7847beC583e4deb6fE6;
address public constant VAR31 = 0xACA7d11e3f482418C324aAC8e90AaD0431f692A6;
address public constant VAR25 = 0xc72E74E474682680a414b506699bBcA44ab9a930;
address public constant VAR26 = 0xA944bd4b25C9F186A846fd5668941AA3d3B8425F;
address public constant VAR27 = 0x64A436ae831C1672AE81F674CAb8B6775df3475C;
address public constant VAR28 = 0x0000000000170CcC93903185bE5A2094C870Df62;
address public constant VAR23 = 0x692f391bCc85cefCe8C237C01e1f636BbD70EA4D;
address public constant VAR29 = 0x2aa889D809B29c608dA99767837D189dAe12a874;
address public constant VAR24 = 0xf5D915570BC477f9B8D6C0E980aA81757A3AaC36;
address public constant VAR34 = 0x1476483dD8C35F25e568113C5f70249D3976ba21;
address public constant VAR35 = 0xbA987bDB501d131f766fEe8180Da5d81b34b69d9;
address public constant VAR36 = 0x3a042de6413eDB15F2784f2f97cC68C7E9750b2D;
address public constant VAR38 = 0xcbB7718c9F39d05aEEDE1c472ca8Bf804b2f1EaD;
address public constant VAR39 = 0x5AA71a3ae1C0bd6ac27A1f28e1415fFFB6F15B8c;
address public constant VAR40 = 0x775787933e92b709f2a3C70aa87999696e74A9F8;
address public constant VAR41 = 0x433870076aBd08865f0e038dcC4Ac6450e313Bd8;
address public constant VAR37 = 0xd1D24637b9109B7f61459176EdcfF9Be56283a7B;
address public constant VAR42 = 0xC4375B7De8af5a38a93548eb8453a498222C4fF2;
address public constant VAR43 = 0x4F96Fe3b7A6Cf9725f59d353F723c1bDb64CA6Aa;
address payable public constant VAR44 = 0x411B2Faa662C8e3E5cF8f01dFdae0aeE482ca7b0;
address public constant VAR45 = 0xFC41f79776061a396635aD0b9dF7a640A05063C1;
address public constant VAR46 = 0xfC1Fc0502e90B7A3766f93344E1eDb906F8A75DD;
address public constant VAR47 = 0xe7bc397DBd069fC7d0109C0636d06888bb50668c;
address public constant VAR48 = 0x6c1E2B0f67e00c06c8e2BE7Dc681Ab785163fF4D;
}
contract ConstantAddresses is VAR4 {
}
abstract contract VAR52 {
function FUN1(address VAR1) public {
address VAR2 = address(FUN2(address(this)).FUN3());
if (VAR2 == address(0)) {
return;
}
DSGuard VAR3 = FUN4(VAR2);
VAR3.FUN5(VAR1, address(this), bytes4(FUN6("""")));
}
}
contract VAR4 {
address public constant VAR5 = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;
address public constant VAR6 = 0x14094949152EDDBFcd073717200DA82fEd8dC960;
address public constant VAR7 = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;
address public constant VAR8 = 0xF5DCe57282A584D2746FaF1593d3121Fcac444dC;
address public constant VAR9 = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
address public constant VAR10 = 0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2;
address public constant VAR11 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
address public constant VAR12 = 0x9B0F70Df76165442ca6092939132bBAEA77f2d7A;
address public constant VAR13 = 0xf53AD2c6851052A81B42133467480961B2321C09;
address public constant VAR14 = 0x448a5065aeBB8E423F0896E6c5D525C040f59af3;
address payable public constant VAR15 = 0x322d58b9E75a6918f7e7849AEe0fF09369977e08;
address public constant VAR16 = 0xeCf88e1ceC2D2894A0295DB3D86Fe7CE4991E6dF;
address public constant VAR17 = 0x794e6e91555438aFc3ccF1c5076A74F42133d08D;
address public constant VAR18 = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;
address public constant VAR19 = 0x8F337bD3b7F2b05d9A8dC8Ac518584e833424893;
address public constant VAR20 = 0x1e30124FDE14533231216D95F7798cD0061e5cf8;
address public constant VAR21 = 0xd7BBB1777E13b6F535Dec414f575b858ed300baF;
address public constant VAR22 = 0x9aBE2715D2d99246269b8E17e9D1b620E9bf6558;
address public constant VAR23 = 0x818E6FECD516Ecc3849DAf6845e3EC868087B755;
address public constant VAR24 = 0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95;
address public constant VAR25 = 0x5a15566417e6C1c9546523066500bDDBc53F88C7;
address public constant VAR26 = 0x729D19f657BD0614b4985Cf1D82531c67569197B;
address public constant VAR27 = 0x4678f0a6958e4D2Bc4F1BAF7Bc52E8F3564f3fE4;
address public constant VAR28 = 0x0000000000b3F879cb30FE243b4Dfee438691c04;
address public constant VAR29 = 0x89b3635BD2bAD145C6f92E82C9e83f06D5654984;
address public constant VAR30 = 0xAD32Ce09DE65971fFA8356d7eF0B783B82Fd1a9A;
address public constant VAR31 = 0x6eC6D98e2AF940436348883fAFD5646E9cdE2446;
address public constant VAR32 = 0x25a01a05C188DaCBCf1D61Af55D4a5B4021F7eeD;
address public constant VAR33 = 0x863E41FE88288ebf3fcd91d8Dbb679fb83fdfE17;
address public constant VAR34 = 0x5ef30b9986345249bc32d8928B7ee64DE9435E39;
address public constant VAR35 = 0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B;
address public constant VAR36 = 0x65C79fcB50Ca1594B025960e539eD7A9a6D434A3;
address public constant VAR37 = 0x82ecD135Dce65Fbc6DbdD0e4237E0AF93FFD5038;
address public constant VAR38 = 0x19c0976f590D67707E62397C87829d896Dc0f1F1;
address public constant VAR39 = 0x9759A6Ac90977b93B58547b4A71c78317f391A28;
address public constant VAR40 = 0x2F0b23f53734252Bda2277357e97e1517d6B042A;
address public constant VAR41 = 0xe4B22D484958E582098A98229A24e8A43801b674;
address public constant VAR42 = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;
address public constant VAR43 = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
address payable public constant VAR44 = 0xc73e0383F3Aff3215E6f04B0331D58CeCf0Ab849;
address public constant VAR45 = 0x83152CAA0d344a2Fd428769529e2d490A88f4393;
address public constant VAR46 = 0x3F4339816EDEF8D3d3970DB2993e2e0Ec6010760;
address public constant VAR47 = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643;
address public constant VAR48 = 0x493C57C4763932315A328269E1ADaD09653B9081;
address public constant VAR49 = 0x95E6F48254609A6ee006F7D493c8e5fB97094ceF;
}
contract VAR50 {
address public constant VAR9 = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
address public constant VAR11 = 0xd0A1E359811322d97991E03f863a0C30C2cF029C;
address public constant VAR5 = 0xC4375B7De8af5a38a93548eb8453a498222C4fF2;
address public constant VAR10 = 0xAaF64BFCC32d0F15873a02163e7E500671a4ffcD;
address public constant VAR12 = 0xBb4339c0aB5B1d9f14Bd6e3426444A1e9d86A1d9;
address public constant VAR13 = 0xf4d791139cE033Ad35DB2B2201435fAd668B1b64;
address public constant VAR14 = 0xa71937147b55Deb8a530C7229C442Fd3F31b7db2;
address public constant VAR16 = 0x32d0e18f988F952Eb3524aCE762042381a2c39E5;
address payable public constant VAR15 = 0x54b44C6B18fc0b4A1010B21d524c338D1f8065F6;
address public constant VAR17 = 0x4A6bC4e803c62081ffEbCc8d227B5a87a58f1F8F;
address public constant VAR32 = 0x25a01a05C188DaCBCf1D61Af55D4a5B4021F7eeD;
address public constant VAR7 = 0x4EC3570cADaAEE08Ae384779B0f3A45EF85289DE;
address public constant VAR6 = 0xA1e58F3B1927743393b25f261471E1f2D3D9f0F6;
address public constant VAR8 = 0xb6b09fBffBa6A5C4631e5F7B2e3Ee183aC259c0d;
address public constant VAR33 = 0x863E41FE88288ebf3fcd91d8Dbb679fb83fdfE17;
address public constant VAR18 = 0x1297c1105FEDf45E0CF6C102934f32C4EB780929;
address public constant VAR51 = 0xADB7c74bCe932fC6C27ddA3Ac2344707d2fBb0E6;
address public constant VAR19 = 0x68c56FF0E7BBD30AF9Ad68225479449869fC1bA0;
address public constant VAR20 = 0x2A4ee140F05f1Ba9A07A020b07CCFB76CecE4b43;
address public constant VAR21 = 0x823cde416973a19f98Bb9C96d97F4FE6C9A7238B;
address public constant VAR22 = 0x0257Ba4876863143bbeDB7847beC583e4deb6fE6;
address public constant VAR31 = 0xACA7d11e3f482418C324aAC8e90AaD0431f692A6;
address public constant VAR25 = 0xc72E74E474682680a414b506699bBcA44ab9a930;
address public constant VAR26 = 0xA944bd4b25C9F186A846fd5668941AA3d3B8425F;
address public constant VAR27 = 0x64A436ae831C1672AE81F674CAb8B6775df3475C;
address public constant VAR28 = 0x0000000000170CcC93903185bE5A2094C870Df62;
address public constant VAR23 = 0x692f391bCc85cefCe8C237C01e1f636BbD70EA4D;
address public constant VAR29 = 0x2aa889D809B29c608dA99767837D189dAe12a874;
address public constant VAR24 = 0xf5D915570BC477f9B8D6C0E980aA81757A3AaC36;
address public constant VAR34 = 0x1476483dD8C35F25e568113C5f70249D3976ba21;
address public constant VAR35 = 0xbA987bDB501d131f766fEe8180Da5d81b34b69d9;
address public constant VAR36 = 0x3a042de6413eDB15F2784f2f97cC68C7E9750b2D;
address public constant VAR38 = 0xcbB7718c9F39d05aEEDE1c472ca8Bf804b2f1EaD;
address public constant VAR39 = 0x5AA71a3ae1C0bd6ac27A1f28e1415fFFB6F15B8c;
address public constant VAR40 = 0x775787933e92b709f2a3C70aa87999696e74A9F8;
address public constant VAR41 = 0x433870076aBd08865f0e038dcC4Ac6450e313Bd8;
address public constant VAR37 = 0xd1D24637b9109B7f61459176EdcfF9Be56283a7B;
address public constant VAR42 = 0xC4375B7De8af5a38a93548eb8453a498222C4fF2;
address public constant VAR43 = 0x4F96Fe3b7A6Cf9725f59d353F723c1bDb64CA6Aa;
address payable public constant VAR44 = 0x411B2Faa662C8e3E5cF8f01dFdae0aeE482ca7b0;
address public constant VAR45 = 0xFC41f79776061a396635aD0b9dF7a640A05063C1;
address public constant VAR46 = 0xfC1Fc0502e90B7A3766f93344E1eDb906F8A75DD;
address public constant VAR47 = 0xe7bc397DBd069fC7d0109C0636d06888bb50668c;
address public constant VAR48 = 0x6c1E2B0f67e00c06c8e2BE7Dc681Ab785163fF4D;
}
contract ConstantAddresses is VAR4 {
}
abstract contract VAR52 {
function FUN1(address VAR1) public {
address VAR2 = address(FUN2(address(this)).FUN3());
if (VAR2 == address(0)) {
return;
}
DSGuard VAR3 = FUN4(VAR2);
VAR3.FUN5(VAR1, address(this), bytes4(FUN6("""")));
}
}
contract VAR4 {
address public constant VAR5 = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;
address public constant VAR6 = 0x14094949152EDDBFcd073717200DA82fEd8dC960;
address public constant VAR7 = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;
address public constant VAR8 = 0xF5DCe57282A584D2746FaF1593d3121Fcac444dC;
address public constant VAR9 = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
address public constant VAR10 = 0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2;
address public constant VAR11 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
address public constant VAR12 = 0x9B0F70Df76165442ca6092939132bBAEA77f2d7A;
address public constant VAR13 = 0xf53AD2c6851052A81B42133467480961B2321C09;
address public constant VAR14 = 0x448a5065aeBB8E423F0896E6c5D525C040f59af3;
address payable public constant VAR15 = 0x322d58b9E75a6918f7e7849AEe0fF09369977e08;
address public constant VAR16 = 0xeCf88e1ceC2D2894A0295DB3D86Fe7CE4991E6dF;
address public constant VAR17 = 0x794e6e91555438aFc3ccF1c5076A74F42133d08D;
address public constant VAR18 = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;
address public constant VAR19 = 0x8F337bD3b7F2b05d9A8dC8Ac518584e833424893;
address public constant VAR20 = 0x1e30124FDE14533231216D95F7798cD0061e5cf8;
address public constant VAR21 = 0xd7BBB1777E13b6F535Dec414f575b858ed300baF;
address public constant VAR22 = 0x9aBE2715D2d99246269b8E17e9D1b620E9bf6558;
address public constant VAR23 = 0x818E6FECD516Ecc3849DAf6845e3EC868087B755;
address public constant VAR24 = 0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95;
address public constant VAR25 = 0x5a15566417e6C1c9546523066500bDDBc53F88C7;
address public constant VAR26 = 0x729D19f657BD0614b4985Cf1D82531c67569197B;
address public constant VAR27 = 0x4678f0a6958e4D2Bc4F1BAF7Bc52E8F3564f3fE4;
address public constant VAR28 = 0x0000000000b3F879cb30FE243b4Dfee438691c04;
address public constant VAR29 = 0x89b3635BD2bAD145C6f92E82C9e83f06D5654984;
address public constant VAR30 = 0xAD32Ce09DE65971fFA8356d7eF0B783B82Fd1a9A;
address public constant VAR31 = 0x6eC6D98e2AF940436348883fAFD5646E9cdE2446;
address public constant VAR32 = 0x25a01a05C188DaCBCf1D61Af55D4a5B4021F7eeD;
address public constant VAR33 = 0x863E41FE88288ebf3fcd91d8Dbb679fb83fdfE17;
address public constant VAR34 = 0x5ef30b9986345249bc32d8928B7ee64DE9435E39;
address public constant VAR35 = 0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B;
address public constant VAR36 = 0x65C79fcB50Ca1594B025960e539eD7A9a6D434A3;
address public constant VAR37 = 0x82ecD135Dce65Fbc6DbdD0e4237E0AF93FFD5038;
address public constant VAR38 = 0x19c0976f590D67707E62397C87829d896Dc0f1F1;
address public constant VAR39 = 0x9759A6Ac90977b93B58547b4A71c78317f391A28;
address public constant VAR40 = 0x2F0b23f53734252Bda2277357e97e1517d6B042A;
address public constant VAR41 = 0xe4B22D484958E582098A98229A24e8A43801b674;
address public constant VAR42 = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;
address public constant VAR43 = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
address payable public constant VAR44 = 0xc73e0383F3Aff3215E6f04B0331D58CeCf0Ab849;
address public constant VAR45 = 0x83152CAA0d344a2Fd428769529e2d490A88f4393;
address public constant VAR46 = 0x3F4339816EDEF8D3d3970DB2993e2e0Ec6010760;
address public constant VAR47 = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643;
address public constant VAR48 = 0x493C57C4763932315A328269E1ADaD09653B9081;
address public constant VAR49 = 0x95E6F48254609A6ee006F7D493c8e5fB97094ceF;
}
contract VAR50 {
address public constant VAR9 = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
address public constant VAR11 = 0xd0A1E359811322d97991E03f863a0C30C2cF029C;
address public constant VAR5 = 0xC4375B7De8af5a38a93548eb8453a498222C4fF2;
address public constant VAR10 = 0xAaF64BFCC32d0F15873a02163e7E500671a4ffcD;
address public constant VAR12 = 0xBb4339c0aB5B1d9f14Bd6e3426444A1e9d86A1d9;
address public constant VAR13 = 0xf4d791139cE033Ad35DB2B2201435fAd668B1b64;
address public constant VAR14 = 0xa71937147b55Deb8a530C7229C442Fd3F31b7db2;
address public constant VAR16 = 0x32d0e18f988F952Eb3524aCE762042381a2c39E5;
address payable public constant VAR15 = 0x54b44C6B18fc0b4A1010B21d524c338D1f8065F6;
address public constant VAR17 = 0x4A6bC4e803c62081ffEbCc8d227B5a87a58f1F8F;
address public constant VAR32 = 0x25a01a05C188DaCBCf1D61Af55D4a5B4021F7eeD;
address public constant VAR7 = 0x4EC3570cADaAEE08Ae384779B0f3A45EF85289DE;
address public constant VAR6 = 0xA1e58F3B1927743393b25f261471E1f2D3D9f0F6;
address public constant VAR8 = 0xb6b09fBffBa6A5C4631e5F7B2e3Ee183aC259c0d;
address public constant VAR33 = 0x863E41FE88288ebf3fcd91d8Dbb679fb83fdfE17;
address public constant VAR18 = 0x1297c1105FEDf45E0CF6C102934f32C4EB780929;
address public constant VAR51 = 0xADB7c74bCe932fC6C27ddA3Ac2344707d2fBb0E6;
address public constant VAR19 = 0x68c56FF0E7BBD30AF9Ad68225479449869fC1bA0;
address public constant VAR20 = 0x2A4ee140F05f1Ba9A07A020b07CCFB76CecE4b43;
address public constant VAR21 = 0x823cde416973a19f98Bb9C96d97F4FE6C9A7238B;
address public constant VAR22 = 0x0257Ba4876863143bbeDB7847beC583e4deb6fE6;
address public constant VAR31 = 0xACA7d11e3f482418C324aAC8e90AaD0431f692A6;
address public constant VAR25 = 0xc72E74E474682680a414b506699bBcA44ab9a930;
address public constant VAR26 = 0xA944bd4b25C9F186A846fd5668941AA3d3B8425F;
address public constant VAR27 = 0x64A436ae831C1672AE81F674CAb8B6775df3475C;
address public constant VAR28 = 0x0000000000170CcC93903185bE5A2094C870Df62;
address public constant VAR23 = 0x692f391bCc85cefCe8C237C01e1f636BbD70EA4D;
address public constant VAR29 = 0x2aa889D809B29c608dA99767837D189dAe12a874;
address public constant VAR24 = 0xf5D915570BC477f9B8D6C0E980aA81757A3AaC36;
address public constant VAR34 = 0x1476483dD8C35F25e568113C5f70249D3976ba21;
address public constant VAR35 = 0xbA987bDB501d131f766fEe8180Da5d81b34b69d9;
address public constant VAR36 = 0x3a042de6413eDB15F2784f2f97cC68C7E9750b2D;
address public constant VAR38 = 0xcbB7718c9F39d05aEEDE1c472ca8Bf804b2f1EaD;
address public constant VAR39 = 0x5AA71a3ae1C0bd6ac27A1f28e1415fFFB6F15B8c;
address public constant VAR40 = 0x775787933e92b709f2a3C70aa87999696e74A9F8;
address public constant VAR41 = 0x433870076aBd08865f0e038dcC4Ac6450e313Bd8;
address public constant VAR37 = 0xd1D24637b9109B7f61459176EdcfF9Be56283a7B;
address public constant VAR42 = 0xC4375B7De8af5a38a93548eb8453a498222C4fF2;
address public constant VAR43 = 0x4F96Fe3b7A6Cf9725f59d353F723c1bDb64CA6Aa;
address payable public constant VAR44 = 0x411B2Faa662C8e3E5cF8f01dFdae0aeE482ca7b0;
address public constant VAR45 = 0xFC41f79776061a396635aD0b9dF7a640A05063C1;
address public constant VAR46 = 0xfC1Fc0502e90B7A3766f93344E1eDb906F8A75DD;
address public constant VAR47 = 0xe7bc397DBd069fC7d0109C0636d06888bb50668c;
address public constant VAR48 = 0x6c1E2B0f67e00c06c8e2BE7Dc681Ab785163fF4D;
}
contract ConstantAddresses is VAR4 {
}
abstract contract VAR52 {
function FUN1(address VAR1) public {
address VAR2 = address(FUN2(address(this)).FUN3());
if (VAR2 == address(0)) {
return;
}
DSGuard VAR3 = FUN4(VAR2);
VAR3.FUN5(VAR1, address(this), bytes4(FUN6("""")));
}
}
contract VAR4 {
address public constant VAR5 = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;
address public constant VAR6 = 0x14094949152EDDBFcd073717200DA82fEd8dC960;
address public constant VAR7 = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;
address public constant VAR8 = 0xF5DCe57282A584D2746FaF1593d3121Fcac444dC;
address public constant VAR9 = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
address public constant VAR10 = 0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2;
address public constant VAR11 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
address public constant VAR12 = 0x9B0F70Df76165442ca6092939132bBAEA77f2d7A;
address public constant VAR13 = 0xf53AD2c6851052A81B42133467480961B2321C09;
address public constant VAR14 = 0x448a5065aeBB8E423F0896E6c5D525C040f59af3;
address payable public constant VAR15 = 0x322d58b9E75a6918f7e7849AEe0fF09369977e08;
address public constant VAR16 = 0xeCf88e1ceC2D2894A0295DB3D86Fe7CE4991E6dF;
address public constant VAR17 = 0x794e6e91555438aFc3ccF1c5076A74F42133d08D;
address public constant VAR18 = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;
address public constant VAR19 = 0x8F337bD3b7F2b05d9A8dC8Ac518584e833424893;
address public constant VAR20 = 0x1e30124FDE14533231216D95F7798cD0061e5cf8;
address public constant VAR21 = 0xd7BBB1777E13b6F535Dec414f575b858ed300baF;
address public constant VAR22 = 0x9aBE2715D2d99246269b8E17e9D1b620E9bf6558;
address public constant VAR23 = 0x818E6FECD516Ecc3849DAf6845e3EC868087B755;
address public constant VAR24 = 0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95;
address public constant VAR25 = 0x5a15566417e6C1c9546523066500bDDBc53F88C7;
address public constant VAR26 = 0x729D19f657BD0614b4985Cf1D82531c67569197B;
address public constant VAR27 = 0x4678f0a6958e4D2Bc4F1BAF7Bc52E8F3564f3fE4;
address public constant VAR28 = 0x0000000000b3F879cb30FE243b4Dfee438691c04;
address public constant VAR29 = 0x89b3635BD2bAD145C6f92E82C9e83f06D5654984;
address public constant VAR30 = 0xAD32Ce09DE65971fFA8356d7eF0B783B82Fd1a9A;
address public constant VAR31 = 0x6eC6D98e2AF940436348883fAFD5646E9cdE2446;
address public constant VAR32 = 0x25a01a05C188DaCBCf1D61Af55D4a5B4021F7eeD;
address public constant VAR33 = 0x863E41FE88288ebf3fcd91d8Dbb679fb83fdfE17;
address public constant VAR34 = 0x5ef30b9986345249bc32d8928B7ee64DE9435E39;
address public constant VAR35 = 0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B;
address public constant VAR36 = 0x65C79fcB50Ca1594B025960e539eD7A9a6D434A3;
address public constant VAR37 = 0x82ecD135Dce65Fbc6DbdD0e4237E0AF93FFD5038;
address public constant VAR38 = 0x19c0976f590D67707E62397C87829d896Dc0f1F1;
address public constant VAR39 = 0x9759A6Ac90977b93B58547b4A71c78317f391A28;
address public constant VAR40 = 0x2F0b23f53734252Bda2277357e97e1517d6B042A;
address public constant VAR41 = 0xe4B22D484958E582098A98229A24e8A43801b674;
address public constant VAR42 = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;
address public constant VAR43 = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
address payable public constant VAR44 = 0xc73e0383F3Aff3215E6f04B0331D58CeCf0Ab849;
address public constant VAR45 = 0x83152CAA0d344a2Fd428769529e2d490A88f4393;
address public constant VAR46 = 0x3F4339816EDEF8D3d3970DB2993e2e0Ec6010760;
address public constant VAR47 = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643;
address public constant VAR48 = 0x493C57C4763932315A328269E1ADaD09653B9081;
address public constant VAR49 = 0x95E6F48254609A6ee006F7D493c8e5fB97094ceF;
}
contract VAR50 {
address public constant VAR9 = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
address public constant VAR11 = 0xd0A1E359811322d97991E03f863a0C30C2cF029C;
address public constant VAR5 = 0xC4375B7De8af5a38a93548eb8453a498222C4fF2;
address public constant VAR10 = 0xAaF64BFCC32d0F15873a02163e7E500671a4ffcD;
address public constant VAR12 = 0xBb4339c0aB5B1d9f14Bd6e3426444A1e9d86A1d9;
address public constant VAR13 = 0xf4d791139cE033Ad35DB2B2201435fAd668B1b64;
address public constant VAR14 = 0xa71937147b55Deb8a530C7229C442Fd3F31b7db2;
address public constant VAR16 = 0x32d0e18f988F952Eb3524aCE762042381a2c39E5;
address payable public constant VAR15 = 0x54b44C6B18fc0b4A1010B21d524c338D1f8065F6;
address public constant VAR17 = 0x4A6bC4e803c62081ffEbCc8d227B5a87a58f1F8F;
address public constant VAR32 = 0x25a01a05C188DaCBCf1D61Af55D4a5B4021F7eeD;
address public constant VAR7 = 0x4EC3570cADaAEE08Ae384779B0f3A45EF85289DE;
address public constant VAR6 = 0xA1e58F3B1927743393b25f261471E1f2D3D9f0F6;
address public constant VAR8 = 0xb6b09fBffBa6A5C4631e5F7B2e3Ee183aC259c0d;
address public constant VAR33 = 0x863E41FE88288ebf3fcd91d8Dbb679fb83fdfE17;
address public constant VAR18 = 0x1297c1105FEDf45E0CF6C102934f32C4EB780929;
address public constant VAR51 = 0xADB7c74bCe932fC6C27ddA3Ac2344707d2fBb0E6;
address public constant VAR19 = 0x68c56FF0E7BBD30AF9Ad68225479449869fC1bA0;
address public constant VAR20 = 0x2A4ee140F05f1Ba9A07A020b07CCFB76CecE4b43;
address public constant VAR21 = 0x823cde416973a19f98Bb9C96d97F4FE6C9A7238B;
address public constant VAR22 = 0x0257Ba4876863143bbeDB7847beC583e4deb6fE6;
address public constant VAR31 = 0xACA7d11e3f482418C324aAC8e90AaD0431f692A6;
address public constant VAR25 = 0xc72E74E474682680a414b506699bBcA44ab9a930;
address public constant VAR26 = 0xA944bd4b25C9F186A846fd5668941AA3d3B8425F;
address public constant VAR27 = 0x64A436ae831C1672AE81F674CAb8B6775df3475C;
address public constant VAR28 = 0x0000000000170CcC93903185bE5A2094C870Df62;
address public constant VAR23 = 0x692f391bCc85cefCe8C237C01e1f636BbD70EA4D;
address public constant VAR29 = 0x2aa889D809B29c608dA99767837D189dAe12a874;
address public constant VAR24 = 0xf5D915570BC477f9B8D6C0E980aA81757A3AaC36;
address public constant VAR34 = 0x1476483dD8C35F25e568113C5f70249D3976ba21;
address public constant VAR35 = 0xbA987bDB501d131f766fEe8180Da5d81b34b69d9;
address public constant VAR36 = 0x3a042de6413eDB15F2784f2f97cC68C7E9750b2D;
address public constant VAR38 = 0xcbB7718c9F39d05aEEDE1c472ca8Bf804b2f1EaD;
address public constant VAR39 = 0x5AA71a3ae1C0bd6ac27A1f28e1415fFFB6F15B8c;
address public constant VAR40 = 0x775787933e92b709f2a3C70aa87999696e74A9F8;
address public constant VAR41 = 0x433870076aBd08865f0e038dcC4Ac6450e313Bd8;
address public constant VAR37 = 0xd1D24637b9109B7f61459176EdcfF9Be56283a7B;
address public constant VAR42 = 0xC4375B7De8af5a38a93548eb8453a498222C4fF2;
address public constant VAR43 = 0x4F96Fe3b7A6Cf9725f59d353F723c1bDb64CA6Aa;
address payable public constant VAR44 = 0x411B2Faa662C8e3E5cF8f01dFdae0aeE482ca7b0;
address public constant VAR45 = 0xFC41f79776061a396635aD0b9dF7a640A05063C1;
address public constant VAR46 = 0xfC1Fc0502e90B7A3766f93344E1eDb906F8A75DD;
address public constant VAR47 = 0xe7bc397DBd069fC7d0109C0636d06888bb50668c;
address public constant VAR48 = 0x6c1E2B0f67e00c06c8e2BE7Dc681Ab785163fF4D;
}
contract ConstantAddresses is VAR4 {
}
abstract contract VAR52 {",RE,1
0x023a3dfff92e4e547f40b2664fd910fd8079fd69.sol,"function FUN1(address VAR1) public payable isValidPayload VAR2 FUN2(VAR3.VAR4) returns (uint VAR5) {
require(msg.value > 0);
VAR5 = msg.value;
if (VAR1 == 0) VAR1 = msg.sender;
uint VAR6 = VAR7 * FUN3() / 10**9 - VAR8;
uint VAR9 = VAR10 - VAR8;
if (VAR9 < VAR6) VAR6 = VAR9;
if (VAR5 > VAR6) {
VAR5 = VAR6;
VAR1.transfer(msg.value - VAR5);
}
VAR11.transfer(VAR5);
VAR12[VAR1] += VAR5;
VAR8 += VAR5;
FUN4(VAR1, VAR5);
if (VAR5 == VAR6) FUN5();
}",RE,1
0x023cdf9b4b127c5779263956efc7bdc8d132b2d2.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
library VAR5 {
using SafeMath for uint256;
using Address for address;",RE,1
0x023cf1D6b14846c9C12Eb60e91d61855a31F9835.sol,"function () public payable {
revert();
}",RE,1
0x023fa9e2a97799b3d87b3fa35674b50b8b5c9f4e.sol,"function FUN1 (string VAR1, address VAR2) public payable returns (bool) {
require (msg.value >= 1000000000000000, """");
require (VAR3[VAR1] == address(0), """");
require (FUN2(VAR4[VAR2]) == FUN2(""""), """");
VAR3[VAR1] = VAR2;
VAR4[VAR2] = VAR1;
VAR5.transfer(msg.value);
return true;
}",RE,1
0x0245BF267FedC29f28FC91b3AFa3c412b8d91Fc7.sol,"function FUN1() internal virtual view returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require( address(this).VAR3 >= VAR2, """" );
(bool VAR4, ) = VAR1.call{
value: VAR2}
("""");
require( VAR4, """" );
}",RE,1
0x0246ca32095807e24a6bb9f811fecdbc2d5a83f1.sol,"function FUN1(address VAR1, uint64 VAR2, uint VAR3, uint8 VAR4, bytes32 VAR5, bytes32 VAR6) public payable returns (bool) {
require(FUN2(VAR1));
return FUN3(VAR1, VAR2, VAR3, VAR4, VAR5, VAR6);
}",RE,1
0x024701acb78fa285f9e40a3c79d11118432f8be1.sol,"function () public payable {
revert();
}",RE,1
0x0248083ad7ee047e8b94bc6ed8ee5cb2ed2a1c5a.sol,"function FUN1( address VAR1, uint256 value, string memory VAR2, bytes memory VAR3, uint256 VAR4 ) public payable returns (bytes VAR5) {
require( msg.sender == VAR6, """" );
bytes32 VAR7 = FUN2( VAR8.FUN3(VAR1, value, VAR2, VAR3, VAR4) );
require( VAR9[VAR7], """" );
require( FUN4() >= VAR4, """" );
require( FUN4() <= VAR4.FUN5(VAR10), """" );
VAR9[VAR7] = false;
bytes memory VAR11;
if (bytes(VAR2).VAR12 == 0) {
VAR11 = VAR3;
}
else {
VAR11 = VAR8.FUN6( bytes4(FUN2(bytes(VAR2))), VAR3 );
}
(bool VAR13, bytes memory VAR14) = VAR1.call.value(value)( VAR11 );
require( VAR13, """" );
emit FUN7(VAR7, VAR1, value, VAR2, VAR3, VAR4);
return VAR14;
}",RE,1
0x0248a296ad4a2c21b793efe777024760677331a3.sol,"function () external payable {
FUN1();
}
function FUN1() payable isRunning isBuyable onlyWhitelist public {
uint256 VAR1 = msg.value;
address VAR2 = msg.sender;
require(VAR2 != address(0) && VAR1 >= VAR3 && VAR1 <= VAR4);
require(VAR1.FUN2(VAR5[VAR2]) <= VAR4);
uint256 VAR6 = 0;
if(VAR7 > VAR8) VAR6 = msg.value.FUN3(VAR9);
else VAR6 = msg.value.FUN3(VAR10);
VAR5[VAR2] = VAR1.FUN2(VAR5[VAR2]);
VAR11[VAR12].VAR13 = VAR11[VAR12].VAR13.FUN4(VAR6);
VAR11[VAR2].VAR13 = VAR11[VAR2].VAR13.FUN2(VAR6);
emit Transfer(VAR12, VAR2, VAR6);
}",RE,1
0x0248d2dbbf900dcd93ffbd902de779ae0dd5eec0.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7) private returns(VAR6.VAR8) {
uint256 VAR9 = VAR3 / 100;
uint256 VAR10 = VAR3 / 50;
VAR10 = VAR10.FUN2(VAR9);
uint256 VAR11 = 0;
if (!address(VAR12).call.value(VAR10.FUN3(VAR10 / 2))()) {
VAR11 = VAR11.FUN2(VAR10.FUN3(VAR10 / 2));
}
if (!address(VAR13).call.value(VAR10 / 2)()) {
VAR11 = VAR11.FUN2(VAR10 / 2);
}
VAR10 = VAR10.FUN3(VAR11);
uint256 VAR14 = VAR3 / 10;
if (VAR4 != VAR2 && VAR15[VAR4].VAR16 != '') {
VAR15[VAR4].VAR17 = VAR14.FUN2(VAR15[VAR4].VAR17);
emit VAR18.FUN4(VAR4, VAR15[VAR4].VAR19, VAR15[VAR4].VAR16, VAR1, VAR2, VAR14, VAR20);
}
else {
VAR11 = VAR11.FUN2(VAR14);
}
VAR11 = VAR11.FUN2((VAR3.FUN5(VAR21[VAR5].VAR22)) / (100));
if (VAR11 > 0) {
VAR23[VAR1].VAR24 = VAR23[VAR1].VAR24.FUN2(VAR11);
VAR7.VAR25 = VAR11.FUN2(VAR7.VAR25);
}
return(VAR7);
}
function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7) private returns(VAR6.VAR8) {
uint256 VAR9 = VAR3 / 100;
uint256 VAR10 = VAR3 / 50;
VAR10 = VAR10.FUN2(VAR9);
uint256 VAR11 = 0;
if (!address(VAR12).call.value(VAR10.FUN3(VAR10 / 2))()) {
VAR11 = VAR11.FUN2(VAR10.FUN3(VAR10 / 2));
}
if (!address(VAR13).call.value(VAR10 / 2)()) {
VAR11 = VAR11.FUN2(VAR10 / 2);
}
VAR10 = VAR10.FUN3(VAR11);
uint256 VAR14 = VAR3 / 10;
if (VAR4 != VAR2 && VAR15[VAR4].VAR16 != '') {
VAR15[VAR4].VAR17 = VAR14.FUN2(VAR15[VAR4].VAR17);
emit VAR18.FUN4(VAR4, VAR15[VAR4].VAR19, VAR15[VAR4].VAR16, VAR1, VAR2, VAR14, VAR20);
}
else {
VAR11 = VAR11.FUN2(VAR14);
}
VAR11 = VAR11.FUN2((VAR3.FUN5(VAR21[VAR5].VAR22)) / (100));
if (VAR11 > 0) {
VAR23[VAR1].VAR24 = VAR23[VAR1].VAR24.FUN2(VAR11);
VAR7.VAR25 = VAR11.FUN2(VAR7.VAR25);
}
return(VAR7);
}",RE,1
0x0248f089a622b74cebaa62573605af9a44966bf1.sol,"function () payable public {
FUN1();
}
function FUN1() payable public {
if (VAR1) {
msg.sender.transfer(msg.value);
return;
}
uint VAR2 = msg.value;
while (VAR2 >= VAR3 && VAR4 <= VAR5) {
uint VAR6 = 0;
if (VAR7.VAR8 > 0) {
VAR6 = VAR7[VAR7.VAR8-1];
VAR7.VAR8--;
}
else {
VAR6 = VAR4++;
}
VAR9[VAR6] = FUN2(msg.sender, VAR10);
FUN3(VAR10, msg.sender, VAR6);
VAR2 -= VAR3;
}
if (VAR4 > VAR5) {
FUN4();
}
if (VAR2 > 0) {
msg.sender.transfer(VAR2);
}
}",RE,1
0x0249fbd4bf6f1054a7b45e23e24585a1c41a086f.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
library VAR5 {
using SafeMath for uint256;
using Address for address;",RE,1
0x024c0e1966a52c506e95679f2edb7c031aaa8011.sol,"function FUN1() payable public {
VAR1 = msg.sender;
}
modifier onlyOwner {
require(VAR1 == msg.sender);
VAR2;
}",RE,1
0x024cb480c6bf81eea0067c2682a706e5da5c6024.sol,"function FUN1() payable {
FUN2(msg.sender, msg.value);
}
function () payable {
FUN1();
}
function() payable {
if (msg.value != 0) {
FUN3(msg.sender, msg.value);
}
else {
throw;
}
}
}",RE,1
0x02525172418dfd0c828c567ddbfab064e60831a2.sol,"function FUN1(uint256 VAR1) public returns (bytes VAR2) {
Action memory VAR3 = VAR4[VAR1];
bool[6] memory VAR5 = VAR6.FUN2(VAR1);
require(VAR3.VAR7 != address(0), """");
require(!VAR3.VAR8, """");
require(address(this).VAR9 >= VAR3.value, """");
require(VAR5[2], """");
VAR4[VAR1].VAR8 = true;
(bool VAR10, bytes memory VAR11) = VAR3.VAR7.call.value(VAR3.value)(VAR3.VAR12);
require(VAR10, """");
emit FUN3(VAR1, msg.sender);
return VAR11;
}",RE,1
0x02557a5e05defeffd4cae6d83ea3d173b272c904.sol,"function() payable public {
revert();
}
enum VAR1 {
VAR2, VAR3, VAR4 }
enum VAR5 {
VAR6, VAR7, VAR8, VAR9, VAR10, VAR11, VAR12, VAR13, VAR14, VAR15, VAR16, VAR17 }
event FUN1(address VAR18, address VAR19, uint VAR20, uint VAR21, uint VAR22);",RE,1
0x02575ca9424acd6aed8d8dc1b01fa7175000cef0.sol,"function FUN1(address VAR1, uint256 VAR2, string VAR3) FUN2(VAR1, VAR2, VAR3) external payable {
FUN3(VAR1, VAR2, VAR3);
}
function FUN4(address VAR1, uint256 VAR2, string VAR4) FUN2(VAR1, VAR2, VAR4) external payable {
FUN5(VAR1, VAR2, VAR4);
}
function FUN6(string VAR3) external payable {
FUN7(bytes32(0), VAR3);
}
function FUN7(bytes32 VAR5, string memory VAR3) public payable {
require(msg.value >= VAR6);
FUN8(VAR5, VAR3);
if (msg.value > VAR6) {
msg.sender.transfer(msg.value - VAR6);
}
}",RE,1
0x02585e4a14da274d02df09b222d4606b10a4e940.sol,"function FUN1(address sender) public isAtLeastMinimum isUnderHardcap isSaleOn payable {
VAR1 = VAR1.FUN2(msg.value);
VAR2.transfer(this.VAR3);
FUN3(sender, msg.value);
}
function() external payable {
FUN1(msg.sender);
}
}",RE,1
0x02591b666f36ab5a8cb7e8c4b9dfb7b6b5888933.sol,"function () public payable {
FUN1();
}
}
contract VAR1 {",RE,1
0x025cd28d7ef83e1c2ffe511d5f9290d54ba5dcf0.sol,"function FUN1(address VAR1) public payable returns (uint256) {
FUN2(msg.value, VAR1);
}",RE,1
0x025d803c0e087e88aa7021984dcd87dc0a25be13.sol,"function () external payable {
FUN1();
}
function FUN1() payable canDistr public {
uint256 VAR1 = 0;
uint256 VAR2 = 0;
uint256 VAR3 = 0;
uint256 VAR4 = 1 VAR5 / 10;
uint256 VAR6 = 1 VAR5;
uint256 VAR7 = 5 VAR5;
VAR1 = VAR8.FUN2(msg.value) / 1 VAR5;
address VAR9 = msg.sender;
if (msg.value >= VAR10 && VAR11 < VAR12 && VAR11 < VAR13 && VAR11 < VAR14) {
if(msg.value >= VAR4 && msg.value < VAR6){
VAR3 = VAR1 * 5 / 100;
}
else if(msg.value >= VAR6 && msg.value < VAR7){
VAR3 = VAR1 * 10 / 100;
}
else if(msg.value >= VAR7){
VAR3 = VAR1 * 15 / 100;
}
}
else if(msg.value >= VAR10 && VAR11 < VAR12 && VAR11 > VAR13 && VAR11 < VAR14){
if(msg.value >= VAR6 && msg.value < VAR7){
VAR3 = VAR1 * 5 / 100;
}
else if(msg.value >= VAR7){
VAR3 = VAR1 * 10 / 100;
}
}
else{
VAR3 = 0;
}
VAR2 = VAR1 + VAR3;
if (VAR1 == 0) {
uint256 VAR15 = 5000e8;
if (VAR16[VAR9] == false && VAR17 <= VAR18 ) {
FUN3(VAR9, VAR15);
VAR16[VAR9] = true;
VAR17++;
}
else{
require( msg.value >= VAR10 );
}
}
else if(VAR1 > 0 && msg.value >= VAR10){
if( VAR11 >= VAR12 && VAR11 >= VAR13 && VAR11 < VAR14){
FUN3(VAR9, VAR1);
}
else{
if(msg.value >= VAR4){
FUN3(VAR9, VAR2);
}
else{
FUN3(VAR9, VAR1);
}
}
}
else{
require( msg.value >= VAR10 );
}
if (VAR19 >= VAR20) {
VAR21 = true;
}
VAR22.transfer(msg.value);
}",RE,1
0x025daf950c6e814dee4c96e13c98d3196d22e60c.sol,"function () external payable {
revert();
}
}
contract RICH is VAR1 {
uint256 public VAR2;
uint256 public VAR3;
uint256 public VAR4;
uint256 public VAR5;
uint256 public VAR6;
uint256 public VAR7;
uint256 public VAR8;
uint256 public VAR9;
uint256 public VAR10;
uint256 public VAR11;
uint256 public VAR12;
function FUN1(address VAR13) public payable returns (bool VAR14){
require(VAR7 <= VAR15.VAR16 && VAR15.VAR16 <= VAR8);
require(VAR10 < VAR9 || VAR9 == 0);
uint256 VAR17 = msg.value;
uint256 VAR18;
if(VAR11 != 0) {
uint256 VAR19 = VAR17 / VAR12;
VAR18 = VAR11 * VAR19;
}
else {
VAR18 = VAR17 / VAR12;
}
VAR10 ++;
if(msg.sender != VAR13 && FUN2(VAR13) != 0 && VAR13 != 0x0000000000000000000000000000000000000000){
VAR20[address(this)] = VAR20[address(this)].FUN3(VAR18 / 2);
VAR20[VAR13] = VAR20[VAR13].FUN4(VAR18 / 2);
emit Transfer(address(this), VAR13, VAR18 / 2);
}
VAR20[address(this)] = VAR20[address(this)].FUN3(VAR18);
VAR20[msg.sender] = VAR20[msg.sender].FUN4(VAR18);
emit Transfer(address(this), msg.sender, VAR18);
return true;
}
function FUN5() public onlyOwner() {
address payable VAR21 = msg.sender;
VAR21.transfer(address(this).VAR22);
}
function() external payable {
}
}",RE,1
0x025dce2d39a46296766db7cac8c322e8f59cd5d9.sol,"function FUN1(bytes20 VAR1, address VAR2) public payable {
require(msg.value > 0);
require(VAR3[msg.sender][VAR2].FUN2(VAR4) > VAR5);
require(VAR6[msg.sender][VAR2].VAR7 == uint256(0));
VAR6[msg.sender][VAR2] = FUN3( bytes32(0), VAR1, VAR5, msg.value );
FUN4(VAR5);
}",RE,1
0x0260853e7313725691bd0c562bc7d27dd7845a9b.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("""");
require(VAR4, """");
}
function FUN2() internal view virtual returns (address payable) {
return msg.sender;
}",RE,1
0x02630ee76bf9d321fc6ec109b1b5c076f2dc951e.sol,"function () external payable {
revert();
}",RE,1
0x0263e76b500a3cf6b31753a70055d9a05a3e655b.sol,"function FUN1() limitation saleIsOn payable {
VAR1.transfer(msg.value);
uint VAR2 = VAR3.FUN2(msg.value).FUN3(1 VAR4);
VAR5.transfer(msg.sender, VAR2);
}
function() external payable {
FUN1();
}
}",RE,1
0x0264CF5Ab570b450B81bbbe65f2171796C730934.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("""");
require(VAR4, """");
}
function FUN2() internal view virtual returns (address payable) {
return msg.sender;
}",RE,1
0x0266C3eF5F9f7C696B2074cbF93c933fc5496329.sol,"function FUN1(uint256 VAR1, uint256 VAR2, string memory VAR3) internal pure returns (uint256) {
require(VAR2 != 0, VAR3);
return VAR1 % VAR2;
}
}
pragma solidity 0.6.12;
contract VAR4 {
using SafeMath for uint;
event FUN2(address indexed VAR5);
event FUN3(address indexed VAR6);
event FUN4(uint indexed VAR7);
event FUN5(bytes32 indexed VAR8, address indexed VAR9, uint value, string VAR10, bytes VAR11, uint VAR12);
event FUN6(bytes32 indexed VAR8, address indexed VAR9, uint value, string VAR10, bytes VAR11, uint VAR12);
event FUN7(bytes32 indexed VAR8, address indexed VAR9, uint value, string VAR10, bytes VAR11, uint VAR12);
uint public constant VAR13 = 14 VAR14;
uint public constant VAR15 = 12 VAR16;
uint public constant VAR17 = 30 VAR14;
address public VAR18;
address public VAR19;
uint public VAR20;
bool public VAR21;
FUN8 (bytes32 => bool) public VAR22;
constructor(address VAR23, uint VAR24) public {
require(VAR24 >= VAR15, """");
require(VAR24 <= VAR17, """");
VAR18 = VAR23;
VAR20 = VAR24;
VAR21 = false;
}
FUN9() external payable {
}
function FUN10(address VAR9, uint value, string memory VAR10, bytes memory VAR11, uint VAR12) public payable returns (bytes VAR25) {
require(msg.sender == VAR18, """");
bytes32 VAR8 = FUN11(VAR26.FUN12(VAR9, value, VAR10, VAR11, VAR12));
require(VAR22[VAR8], """");
require(FUN13() >= VAR12, """");
require(FUN13() <= VAR12.FUN14(VAR13), """");
VAR22[VAR8] = false;
bytes memory VAR27;
if (bytes(VAR10).VAR28 == 0) {
VAR27 = VAR11;
}
else {
VAR27 = VAR26.FUN15(bytes4(FUN11(bytes(VAR10))), VAR11);
}
(bool VAR29, bytes memory VAR30) = VAR9.call{
value: value}
(VAR27);
require(VAR29, """");
emit FUN6(VAR8, VAR9, value, VAR10, VAR11, VAR12);
return VAR30;
}",RE,1
0x0267ee183beebdb7f931afe41e4e25352195b871.sol,"function () public payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
bool VAR2 = VAR1 != 0x0 && msg.value != 0 && !VAR3[msg.sender];
uint256 VAR4 = FUN2();
require(FUN3() && VAR2);
VAR5[msg.sender] = VAR5[msg.sender].FUN4(msg.value);
uint256 VAR6;
uint256 VAR7 = 0;
uint256[2] memory VAR8 = FUN5();
VAR6 = VAR8[0];
VAR7 = VAR8[1];
require(VAR6 <= VAR4);
VAR9 = VAR9.FUN4(VAR6);
if(VAR10 >= FUN6()) {
FUN7();
}
VAR11.transfer(VAR1, VAR6);
if (VAR7 > 0) FUN8(VAR7);
FUN9(this.VAR12);
}",RE,1
0x026a7d72a448d0e44d441e55f746bf56b843aedb.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
library VAR5 {
using SafeMath for uint256;
struct VAR6 {
uint256 VAR7;
}",RE,1
0x026BdaC2F308C0109A864138CCa1a623F7828F4a.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
pragma VAR5 ^0.5.0;
contract VAR6 {
bool private VAR7;",RE,1
0x026eafb25ddf7d754d3a66a56c9a6400e99c26c5.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("""");
require(VAR4, """");
}
function FUN2() internal view virtual returns (address payable) {
return msg.sender;
}",RE,1
0x026fcd9a3690817497a004ac8063e6ef40c6d9e6.sol,"function () external payable {
FUN1();
}
function FUN1() payable canDistr public {
uint256 VAR1 = 0;
require( msg.value >= VAR2 );
require( msg.value > 0 );
VAR1 = VAR3.FUN2(msg.value) / 1 VAR4;
address VAR5 = msg.sender;
if (VAR1 > 0) {
FUN3(VAR5, VAR1);
}
if (VAR6 >= VAR7) {
VAR8 = true;
}
}",RE,1
0x0275f754fb44c4526199cd338900040522680261.sol,"function () public payable {
VAR1.transfer(msg.value);
emit FUN1(msg.sender, address(this), msg.value);
VAR2[msg.sender][''] = VAR2[msg.sender][''].FUN2(msg.value);
FUN3(msg.sender);
}",RE,1
0x0279f2882d32f19661649535d802a8df9efd7d6f.sol,"function () payable {
FUN1();
throw;
}
function FUN1() payable {
require(msg.value > 0);
uint256 VAR1 = msg.value.FUN2(VAR2);
VAR3[msg.sender] = VAR3[msg.sender].FUN2(VAR1);
VAR4 = VAR4.FUN2(VAR1);
VAR5.transfer(msg.value);
}",RE,1
0x027b8cd9c1761651048a65eab2f8d4ed9b97a59b.sol,"function () external payable {
revert();
}
}
contract ZTokens_ERC20 is VAR1 {
uint256 public VAR2;
uint256 public VAR3;
uint256 public VAR4;
uint256 public VAR5;
uint256 public VAR6;
uint256 public VAR7;
uint256 public VAR8;
uint256 public VAR9;
uint256 public VAR10;
uint256 public VAR11;
uint256 public VAR12;
function FUN1(address VAR13) public payable returns (bool VAR14){
require(VAR7 <= VAR15.VAR16 && VAR15.VAR16 <= VAR8);
require(VAR10 < VAR9 || VAR9 == 0);
uint256 VAR17 = msg.value;
uint256 VAR18;
if(VAR11 != 0) {
uint256 VAR19 = VAR17 / VAR12;
VAR18 = VAR11 * VAR19;
}
else {
VAR18 = VAR17 / VAR12;
}
VAR10 ++;
if(msg.sender != VAR13 && FUN2(VAR13) != 0 && VAR13 != 0x0000000000000000000000000000000000000000){
VAR20[address(this)] = VAR20[address(this)].FUN3(VAR18 / 2);
VAR20[VAR13] = VAR20[VAR13].FUN4(VAR18 / 2);
emit Transfer(address(this), VAR13, VAR18 / 2);
}
VAR20[address(this)] = VAR20[address(this)].FUN3(VAR18);
VAR20[msg.sender] = VAR20[msg.sender].FUN4(VAR18);
emit Transfer(address(this), msg.sender, VAR18);
return true;
}
function FUN5() public onlyOwner() {
address payable VAR21 = msg.sender;
VAR21.transfer(address(this).VAR22);
}
function() external payable {
}
}",RE,1
0x027bbe79f0b83a45b2443e9da9b7554596ac8428.sol,"function () payable external {
revert();
}
}",RE,1
0x027d5602aa433a7f5c5444c3e820bc4a714b000a.sol,"function FUN1( address VAR1, uint VAR2, uint VAR3, uint VAR4, address VAR5, uint VAR6 ) external payable returns (uint VAR7, uint VAR8, uint VAR9);
function FUN2(uint VAR10, address[] calldata VAR11, address VAR5, uint VAR6) external payable returns (uint[] memory VAR12);
function FUN3(uint VAR13, address[] calldata VAR11, address VAR5, uint VAR6) external payable returns (uint[] memory VAR12);
function FUN4( uint VAR10, address[] calldata VAR11, address VAR5, uint VAR6 ) external payable;",RE,1
0x027f4f65749d18ab0c18c5283e2fd0ad218669e3.sol,"function FUN1(address sender, address VAR1, uint256 VAR2) external returns (bool);
event Transfer(address indexed VAR3, address indexed VAR4, uint256 value);
event FUN2(address indexed VAR5, address indexed VAR6, uint256 value);
}
contract VAR7 {
using SafeMath for uint256;
address public VAR5;
IERC20 public VAR8;
address payable public VAR9;
uint256 public VAR10;
uint256 public VAR11;
uint256 public VAR12;
bool public VAR13 = false;
uint256 public VAR14;
uint256 public VAR15;
address public VAR16;
event FUN3(address indexed VAR17, address indexed VAR18, uint256 value, uint256 VAR2);
event FUN4(address indexed VAR19, address indexed VAR20);
event FUN5();
constructor(uint256 VAR21, address payable VAR22, IERC20 VAR23, uint256 VAR24, uint256 VAR25, uint256 VAR26, address VAR27) public {
require(VAR21 > 0);
require(VAR22 != address(0));
require(VAR24 > 0);
require(VAR25 >= VAR28);
require(VAR26 >= VAR25);
VAR10 = VAR21;
VAR9 = VAR22;
VAR8 = VAR23;
VAR12 = VAR24;
VAR16 = VAR27;
VAR14 = VAR25;
VAR15 = VAR26;
VAR5 = msg.sender;
}
FUN6 () external payable {
FUN7(msg.sender);
}
function FUN1(address sender, address VAR1, uint256 VAR2) external returns (bool);
event Transfer(address indexed VAR3, address indexed VAR4, uint256 value);
event FUN2(address indexed VAR5, address indexed VAR6, uint256 value);
}
contract VAR7 {
using SafeMath for uint256;
address public VAR5;
IERC20 public VAR8;
address payable public VAR9;
uint256 public VAR10;
uint256 public VAR11;
uint256 public VAR12;
bool public VAR13 = false;
uint256 public VAR14;
uint256 public VAR15;
address public VAR16;
event FUN3(address indexed VAR17, address indexed VAR18, uint256 value, uint256 VAR2);
event FUN4(address indexed VAR19, address indexed VAR20);
event FUN5();
constructor(uint256 VAR21, address payable VAR22, IERC20 VAR23, uint256 VAR24, uint256 VAR25, uint256 VAR26, address VAR27) public {
require(VAR21 > 0);
require(VAR22 != address(0));
require(VAR24 > 0);
require(VAR25 >= VAR28);
require(VAR26 >= VAR25);
VAR10 = VAR21;
VAR9 = VAR22;
VAR8 = VAR23;
VAR12 = VAR24;
VAR16 = VAR27;
VAR14 = VAR25;
VAR15 = VAR26;
VAR5 = msg.sender;
}
FUN6 () external payable {
FUN7(msg.sender);
}
function FUN1(address sender, address VAR1, uint256 VAR2) external returns (bool);
event Transfer(address indexed VAR3, address indexed VAR4, uint256 value);
event FUN2(address indexed VAR5, address indexed VAR6, uint256 value);
}
contract VAR7 {
using SafeMath for uint256;
address public VAR5;
IERC20 public VAR8;
address payable public VAR9;
uint256 public VAR10;
uint256 public VAR11;
uint256 public VAR12;
bool public VAR13 = false;
uint256 public VAR14;
uint256 public VAR15;
address public VAR16;
event FUN3(address indexed VAR17, address indexed VAR18, uint256 value, uint256 VAR2);
event FUN4(address indexed VAR19, address indexed VAR20);
event FUN5();
constructor(uint256 VAR21, address payable VAR22, IERC20 VAR23, uint256 VAR24, uint256 VAR25, uint256 VAR26, address VAR27) public {
require(VAR21 > 0);
require(VAR22 != address(0));
require(VAR24 > 0);
require(VAR25 >= VAR28);
require(VAR26 >= VAR25);
VAR10 = VAR21;
VAR9 = VAR22;
VAR8 = VAR23;
VAR12 = VAR24;
VAR16 = VAR27;
VAR14 = VAR25;
VAR15 = VAR26;
VAR5 = msg.sender;
}
FUN6 () external payable {
FUN7(msg.sender);
}
function FUN7(address VAR29) public payable {
uint256 VAR30 = msg.value;
FUN8(VAR29, VAR30);
uint256 VAR31 = FUN9(VAR30);
VAR11 = VAR11.FUN10(VAR30);
FUN11(VAR29, VAR31);
emit FUN3(msg.sender, VAR29, VAR30, VAR31);
FUN12(VAR29, VAR30);
FUN13();
FUN14(VAR29, VAR30);
}",RE,1
0x028071d9C517f5cD65B6803ea23B4d8eB40C64d9.sol,"function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("""");
require(VAR4, """");
}",RE,1
0x02827D495B2bBe37e1C021eB91BCdCc92cD3b604.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("""");
require(VAR4, """");
}",RE,1
0x028377b5d7efc17c8450c70444c17ab317109f5f.sol,"function FUN1() external payable;
}
contract VAR1 {
using SafeMath for uint256;
address public VAR2;
address VAR3 = 0xf783A81F046448c38f3c863885D9e99D10209779;
P3DTakeout VAR4;
uint public VAR5;
string public constant VAR6 = """";
struct VAR7 {
bool VAR8;
bool VAR9;
bool VAR10;
bool VAR11;
uint32 VAR12;
uint32 VAR13;
uint32 VAR14;
uint32 VAR15;
}
struct VAR16{
int64 VAR17;
int64 VAR18;
int64 VAR19;
bytes32 VAR20;
bytes32 VAR21;
bytes32 VAR22;
}
struct VAR23{
bytes32 VAR24;
uint VAR25;
}
struct VAR26{
uint256 VAR27;
uint256 VAR28;
uint160 VAR29;
uint32 VAR30;
bool VAR31;
}
struct VAR32 {
uint160 VAR33;
bool VAR34;
FUN2(bytes32=>uint) VAR35;
}
FUN2 (bytes32 => VAR26) public VAR36;
FUN2 (address => VAR32) VAR37;
uint public VAR38;
uint32 VAR39;
FUN2 (bytes32 => bool) public VAR40;
event FUN3(address VAR41, uint256 VAR42, bytes32 VAR43, uint256 VAR44);
event FUN4(address VAR45, uint256 VAR42);
event FUN5(bytes32 VAR46, uint256 VAR47, bool VAR48);
event FUN6(string VAR49);
constructor() public payable {
VAR2 = msg.sender;
VAR50.VAR20 = bytes32("""");
VAR50.VAR21 = bytes32("""");
VAR50.VAR22 = bytes32("""");
VAR4 = FUN7(0x72b2670e55139934D6445348DC6EaB4089B12576);
}
horses_info public VAR50;
chronus_info public VAR51;
modifier onlyOwner {
require(VAR2 == msg.sender);
VAR52;
}
modifier VAR53 {
require(VAR51.VAR8);
require(VAR54 < VAR51.VAR12 + VAR51.VAR13);
VAR52;
}
modifier VAR55 {
require(!VAR51.VAR8 && !VAR51.VAR9);
VAR52;
}
modifier VAR56 {
require(VAR51.VAR10);
VAR52;
}",RE,1
0x028460acee8af696b6fe5801cb39a712de11b61a.sol,"function FUN1(address VAR1) payable public {
uint256 VAR2 = FUN2(msg.value);
FUN3();
FUN4();
require(VAR2 >= FUN5(VAR3[VAR4].VAR5), """");
Bet storage VAR6 = VAR7[VAR2];
VAR3[VAR4].VAR8++;
VAR3[VAR4].VAR5 = VAR2;
VAR3[VAR4].VAR9 = VAR10.FUN6(VAR6.VAR11);
VAR3[VAR4].VAR12 = msg.sender;
uint256 VAR13 = 0;
uint256 VAR14 = 0;
if (VAR3[VAR4].VAR8 > VAR15) {
VAR13 = VAR16;
if (VAR17[msg.sender] == 0x0 && VAR1 != 0x0 && VAR1 != msg.sender) VAR17[msg.sender] = VAR1;
if (VAR17[msg.sender] != 0x0) VAR14 = VAR18;
}
VAR13 = VAR13.FUN7(VAR14);
if (VAR13 > 0) VAR19.transfer(msg.value * VAR13 / 100);
if (VAR14 > 0 && VAR17[msg.sender] != 0x0) VAR17[msg.sender].transfer(msg.value * VAR14 / 100);
VAR3[VAR4].VAR20 = VAR3[VAR4].VAR20.FUN6(msg.value * (100 - (VAR13 + VAR14)) / 100);
emit FUN8(VAR4, msg.value * (100 - (VAR13 + VAR14)) / 100, VAR3[VAR4].VAR12, VAR3[VAR4].VAR9, VAR3[VAR4].VAR20);
}
function FUN9() payable public {
FUN1(0x0);
}
}",RE,1
0x0286ab4c526c0f28ec31dbb08755c999f441a58f.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require( address(this).VAR3 >= VAR2, """" );
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require( VAR4, """" );
}
}
library VAR5 {
using SafeMath for uint256;
using Address for address;",RE,1
0x0286f920f893513c7ec9fe35ba0a4760229a243e.sol,"function FUN1() public payable returns (bool) {
VAR1 += msg.value;
return true;
}
function () public payable {
if (msg.value == 0) {
FUN2();
}
else {
FUN1();
}
}
}
contract VAR2 {
string public VAR3 = """";
event FUN3(address indexed VAR4, uint VAR5, uint VAR6);
AbstractSingularDTVToken public VAR7;
address public VAR8;
address public VAR9 = 0xc78310231aA53bD3D0FEA2F8c705C67730929D8f;
uint public VAR10;
uint public VAR11;
uint public VAR12;
uint public VAR13;
enum VAR14 {
VAR15, VAR16, VAR17, VAR18, VAR19 }
address public VAR20;
uint public VAR21;
uint public VAR22;
uint public VAR23;
uint public VAR24;
FUN4 (address => uint) public VAR25;
FUN4 (address => uint) public VAR26;
Stages public VAR27 = VAR14.VAR15;
modifier onlyOwner() {
if (msg.sender != VAR20) {
revert();
}
VAR28;
}
modifier FUN5(Stages VAR29) {
if (VAR27 != VAR29) {
revert();
}
VAR28;
}
modifier FUN6(Stages VAR30, Stages VAR31) {
if (VAR27 != VAR30 && VAR27 != VAR31) {
revert();
}
VAR28;
}
modifier FUN7() {
uint VAR32 = VAR33 - VAR21;
if (VAR32 >= VAR12) {
if (VAR27 == VAR14.VAR16) {
VAR27 = VAR14.VAR17;
}
else if (VAR27 == VAR14.VAR18) {
VAR27 = VAR14.VAR19;
}
}
VAR28;
}
function FUN8() public VAR34 FUN6(VAR14.VAR16, VAR14.VAR18) payable returns (uint) {
uint VAR35 = (msg.value * (10**18)) / VAR23;
require(VAR35 > 0);
if (VAR24 + VAR35 > VAR11) {
VAR35 = VAR11 - VAR24;
}
VAR24 += VAR35;
uint VAR5 = (VAR35 * VAR23) / (10**18);
if (msg.value > VAR5 && !msg.sender.FUN9(msg.value - VAR5)) {
revert();
}
VAR22 += VAR5;
VAR25[msg.sender] += VAR5;
VAR26[msg.sender] += VAR35;
if (!VAR7.transfer(msg.sender, VAR35)) {
revert();
}
if (VAR27 == VAR14.VAR16) {
if (VAR24 >= VAR13) {
VAR27 = VAR14.VAR18;
}
}
if (VAR27 == VAR14.VAR18) {
if (VAR24 == VAR11) {
VAR27 = VAR14.VAR19;
}
}
FUN10();
FUN3(msg.sender, VAR5, VAR35);
return VAR35;
}
function () public payable {
if (VAR27 == VAR14.VAR16 || VAR27 == VAR14.VAR18) FUN8();
else if (VAR27 == VAR14.VAR17) FUN11();
else revert();
}
}
contract VAR36 {",RE,1
0x028857f9e565d7e3e1d84b5f5736b53651c2778f.sol,"function FUN1(address VAR1) onlyOwner public payable {
require(VAR2 == VAR3.VAR4);
VAR5[VAR1] = VAR5[VAR1].FUN2(msg.value);
}",RE,1
0x0288da3da52a8d209ffdc32316b099f0f4ce68b0.sol,"function () payable whenSellNotPaused whenNotPaused public {
require(msg.value >= 0.1 VAR1);
uint256 VAR2 = msg.value.FUN1(0.1 VAR1).FUN2(VAR3);
VAR4[msg.sender] = VAR4[msg.sender].FUN3(VAR2);
VAR4[VAR5] = VAR4[VAR5].FUN4(VAR2);
}",RE,1
0x0290ea3c728981725689187763f6c63a68e192b8.sol,"function FUN1() payable {
uint VAR1 = msg.value / VAR2;
if (VAR3[this] < VAR1) throw;
VAR3[msg.sender] += VAR1;
VAR3[this] -= VAR1;
Transfer(this, msg.sender, VAR1);
}",RE,1
0x029606e5ec44cad1346d6a1273a53b971fa93ad6.sol,"function () payable public {
emit FUN1(msg.sender, msg.value);
}
event FUN2(address indexed VAR1, uint256 VAR2);",RE,1
0x02974caf589c5ab2b134bf462f38e08332197c08.sol,"function() payable public {
FUN1(msg.sender);
}
function FUN1(address VAR1) public FUN2(VAR2.VAR3) payable returns (uint256){
require(VAR1 != address(0));
uint256 VAR4 = msg.value;
uint256 VAR5 = FUN3(VAR4);
if (VAR5 == 0) {
revert();
}
VAR6 = VAR6.FUN4(VAR4);
VAR7 = VAR7.FUN4(VAR5);
FUN5(VAR1, VAR5, VAR8);
FUN6(VAR1, VAR4, VAR5);
if (VAR9[VAR1] == 0) {
VAR10 = VAR10.FUN4(1);
}
FUN7(VAR1);
VAR11.transfer(VAR4);
return VAR5;
}",RE,1
0x0297c3970da02bb88a411d3665e0e2ecfad20206.sol,"function() payable {
if (!VAR1) {
revert();
}
if (msg.value == 0) {
return;
}
VAR2.transfer(msg.value);
VAR3 += msg.value;
uint256 VAR4 = (msg.value * 100);
if (msg.value >= 10 VAR5) {
VAR4 += VAR3;
}
VAR6 += VAR4;
VAR7[msg.sender] += VAR4;
}
}",RE,1
0x02992370df72da5b039c3a6249beb27c487e63cb.sol,"function FUN1() payable public {
FUN2( msg.value );
VAR1[0][msg.sender] = FUN3( VAR1[0][msg.sender], msg.value );
emit FUN4( 0, msg.sender, msg.value, VAR1[0][msg.sender] );
}",RE,1
0x029af1f2c753c458c1e7fa04428e78cbe2eb09a7.sol,"function FUN1() public payable {
}
function () public payable {
}",RE,1
0x029cb57991b2a2cad9271b8c4131bb8551982014.sol,"function FUN1() payable public {
require(msg.value==0.0001 VAR1);
VAR2 = VAR2+1;
if(VAR2==2) {
msg.sender.transfer(this.VAR3);
VAR2 = 0;
}
}
}",RE,1
0x029d05dd42fba3d26b48274b7f80cc6068837b75.sol,"function () public payable {
revert();
}",RE,1
0x029db6021c4ec26e86cff975d79f2bc15d1b703f.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;",RE,1
0x029feae8d773a3fe25f1a3e35a526bb54744c9bb.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
interface VAR5 {
function FUN2() onlyOwner public{
(bool VAR6, ) = msg.sender.call.value(address(this).VAR3)("""");
require(VAR6, """");
}
}",RE,1
0x02a64460d4bc9cfd31137c778f3e62698696783e.sol,"function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}",RE,1
0x02a725c0bdc5678539cd38e74e675fe537736389.sol,"function () external whenNotPaused payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public whenNotPaused payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
emit FUN6( msg.sender, VAR1, VAR2, VAR3 );
FUN7(VAR1, VAR2);
FUN8();
FUN9(VAR1, VAR2);
}",RE,1
0x02a89330e27675bf50bb32833e4e430056aef504.sol,"function () payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) payable {
require(VAR1 != 0x0);
require(FUN2());
uint256 VAR2 = msg.value;
if(VAR2 < 2.5 * 10**18) throw;
if(VAR2 > 25 * 10**18) throw;
VAR3 = (5 * VAR2)/100;
VAR4 = (25 * VAR2)/100;
VAR5 = (70 * VAR2)/100;
uint256 VAR6 = 25000000000000000;
uint256 VAR7 = (VAR2 *10**18) / VAR6;
VAR8 = VAR8.FUN3(VAR2);
VAR9.transfer(VAR1, VAR7);
FUN4(msg.sender, VAR1, VAR2, VAR7);
FUN5();
}",RE,1
0x02a9bb92365b72fb735364af2af55ebfa9eb02c2.sol,"function () external payable {
}
function FUN1(address payable VAR1, uint256 VAR2) public onlyVault returns (bool) {
VAR1.transfer(VAR2);
return true;
}",RE,1
0x02ab60c11224ebb45cbc51bcfa86d861439d34ce.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;",RE,1
0x02ae1deb9a7e9ff1c5354f9c670bf1edde6f728d.sol,"function () external payable {
}
function FUN1(address payable VAR1, uint256 VAR2) public onlyVault returns (bool) {
VAR1.transfer(VAR2);
return true;
}",RE,1
0x02af76b91477b47e9e820071a3a5e3c70b11e39b.sol,"function() payable {
if (msg.value == 0) {
return;
}
VAR1.transfer(msg.value);
uint256 VAR2 = (msg.value * 100);
if (msg.value >= 10 VAR3) {
VAR2 += msg.value;
bytes20 VAR4 = FUN1(VAR5.VAR6, VAR5.VAR7, VAR5.VAR8);
if (VAR4[0] == 0) {
uint8 VAR9 = ((VAR4[1] & 0x01 != 0) ? 1 : 0) + ((VAR4[1] & 0x02 != 0) ? 1 : 0) + ((VAR4[1] & 0x04 != 0) ? 1 : 0) + ((VAR4[1] & 0x08 != 0) ? 1 : 0) + ((VAR4[1] & 0x10 != 0) ? 1 : 0) + ((VAR4[1] & 0x20 != 0) ? 1 : 0) + ((VAR4[1] & 0x40 != 0) ? 1 : 0) + ((VAR4[1] & 0x80 != 0) ? 1 : 0);
uint256 VAR10 = (msg.value * 1000) * VAR9;
VAR2 += VAR10;
}
}
VAR11 += VAR2;
VAR12[msg.sender] += VAR2;
Transfer(address(this), msg.sender, VAR2);
}
}",RE,1
0x02b3c88b805f1c6982e38ea1d40a1d83f159c3d4.sol,"function FUN1 ( uint256 VAR1, string VAR2, string VAR3 ) FUN2(VAR1, VAR2, VAR3) payable public {
}",RE,1
0x02b3f51ac9202aa19be63d61a8c681579d6e3a51.sol,"function FUN1( uint256 VAR1, uint256 VAR2, uint256 VAR3, int128 VAR4, address payable VAR5, uint256 VAR6, bytes32 VAR7, bytes calldata VAR8 ) external VAR9 {
bytes32 VAR10 = FUN2(VAR11.FUN3(VAR1, VAR3, VAR4, VAR5, msg.sender));
uint256 VAR12 = VAR13.FUN4("""").FUN5(VAR10, VAR6, VAR7, VAR8);
uint256 VAR14 = VAR15.FUN6(0, VAR4, VAR12);
uint256 VAR16 = VAR14.FUN7(1e8).FUN8(VAR17[uint256(VAR4)]).FUN8(VAR12);
VAR3 = uint256(1e4).FUN9(VAR3);
uint256 VAR18 = VAR14.FUN7(VAR3).FUN8(1e4);
if (VAR16 >= VAR2) {
require(VAR4 != 0);
FUN10(VAR4, VAR12, VAR18, VAR5);
}
else {
require(VAR19[0].transfer(VAR5, VAR12));
emit FUN11(VAR12);
}
}",RE,1
0x02b794ed04465b152f051bd5f1046c1bdb07c02a.sol,"function () external payable {
FUN1();
}
function FUN1() payable canDistr public {
uint256 VAR1 = 0;
uint256 VAR2 = 0;
uint256 VAR3 = 0;
uint256 VAR4 = 10 VAR5 / 10;
uint256 VAR6 = 10 VAR5;
uint256 VAR7 = 50 VAR5;
VAR1 = VAR8.FUN2(msg.value) / 1 VAR5;
address VAR9 = msg.sender;
if (msg.value >= VAR10 && VAR11 < VAR12 && VAR11 < VAR13 && VAR11 < VAR14) {
if(msg.value >= VAR4 && msg.value < VAR6){
VAR3 = VAR1 * 0 / 100;
}
else if(msg.value >= VAR6 && msg.value < VAR7){
VAR3 = VAR1 * 20 / 100;
}
else if(msg.value >= VAR7){
VAR3 = VAR1 * 35 / 100;
}
}
else if(msg.value >= VAR10 && VAR11 < VAR12 && VAR11 > VAR13 && VAR11 < VAR14){
if(msg.value >= VAR6 && msg.value < VAR7){
VAR3 = VAR1 * 20 / 100;
}
else if(msg.value >= VAR7){
VAR3 = VAR1 * 35 / 100;
}
}
else{
VAR3 = 0;
}
VAR2 = VAR1 + VAR3;
if (VAR1 == 0) {
uint256 VAR15 = 30e8;
if (VAR16[VAR9] == false && VAR17 <= VAR18 ) {
FUN3(VAR9, VAR15);
VAR16[VAR9] = true;
VAR17++;
}
else{
require( msg.value >= VAR10 );
}
}
else if(VAR1 > 0 && msg.value >= VAR10){
if( VAR11 >= VAR12 && VAR11 >= VAR13 && VAR11 < VAR14){
FUN3(VAR9, VAR1);
}
else{
if(msg.value >= VAR4){
FUN3(VAR9, VAR2);
}
else{
FUN3(VAR9, VAR1);
}
}
}
else{
require( msg.value >= VAR10 );
}
if (VAR19 >= VAR20) {
VAR21 = true;
}
VAR22.transfer(msg.value);
}",RE,1
0x02b7eca484ad960fca3f7709e0b2ac81eec3069c.sol,"function FUN1() public payable;
function FUN2( address VAR1, address VAR2, uint256 VAR3, uint256 VAR4, address VAR5 ) external payable returns(uint256 VAR6);
}
contract MooniswapBridge is VAR7, VAR8, VAR9 {
struct VAR10 {
IMooniswap VAR11;
uint256 VAR12;
IEtherToken VAR13;
uint256 VAR14;
address VAR15;
address VAR16;
}
function () external payable {
}",RE,1
0x02b8b5d2c2f05c074850c5bdffdb711edbcd8704.sol,"function () external payable {
FUN1();
}
function FUN1() public payable whenNotPaused returns (bool) {
require(msg.value != 0);
address VAR1 = msg.sender;
uint256 VAR2 = msg.value;
uint256 VAR3 = VAR2.FUN2(VAR4);
VAR5.transfer(VAR2);
VAR6.transfer(VAR1, VAR3);
emit FUN3(VAR1, VAR2, VAR3);
return true;
}",RE,1
0x02b909adc8921c83c00516d39faaaaa2d84eea77.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("""");
require(VAR4, """");
}",RE,1
0x02b97cca6d6a5227e464b2a60ee1a580ea4f7da9.sol,"function FUN1(uint VAR1, string VAR2, string VAR3) payable returns (bytes32 VAR4);",RE,1
0x02ba9b528425f9de08f961b88a10b03be8b8b998.sol,"function FUN1() internal view returns (address payable) {
return msg.sender;
}",RE,1
0x02bc86b1f8fedf25e2b98cc8278ca8cde58cbad7.sol,"function () public payable {
revert();
}
}",RE,1
0x02c12964e74a0ebb4ecfa13c3717797dedd9ef6f.sol,"function () external payable {
address VAR1 = msg.sender;
uint256 VAR2 = msg.value;
if(VAR2 == 0){
require(VAR3 <= VAR4);
require(VAR5[VAR1] == false);
uint256 VAR6 = VAR3;
FUN1(VAR1, VAR6);
VAR5[VAR1] = true;
VAR3 = VAR3.FUN2(1000000).FUN3(999999);
}
if(VAR2 > 0){
FUN4(VAR1, VAR2);
}
}",RE,1
0x02c1ffd832143973fcec0cf3cac020ecb43dfb1a.sol,"function() external payable {
if(msg.sender == VAR1) {
FUN1();
}
else {
if(msg.sender == VAR2) {
FUN2();
}
else {
FUN3();
}
}
}",RE,1
0x02c4c78c462e32cca4a90bc499bf411fb7bc6afb.sol,"function () external payable whenNotPaused VAR1 {
FUN1();
}
function FUN1() public payable whenNotPaused VAR1 {
require(msg.value > 0);
require(FUN2(msg.sender) == true);
uint256 VAR2 = msg.value;
uint256 VAR3 = FUN3(VAR2);
require(VAR4[msg.sender].FUN4(VAR3) <= FUN3(VAR5));
require(VAR3 <= VAR6[VAR7]);
VAR4[msg.sender] = VAR4[msg.sender].FUN4(VAR3);
VAR8 = VAR8.FUN4(VAR3);
VAR9 = VAR9.FUN4(VAR2);
VAR6[VAR7] = VAR6[VAR7].FUN5(VAR3);
VAR6[msg.sender] = VAR6[msg.sender].FUN4(VAR3);
Transfer(VAR7, msg.sender, VAR3);
FUN6(msg.sender, VAR3, VAR2, VAR10);
FUN7();
}",RE,1
0x02c60d28be3338014fef3fdf50a3218b946c0609.sol,"function () external payable {
if (VAR1[msg.sender] != 0) {
uint256 VAR2 = VAR1[msg.sender] * 3 / 100 * (VAR3.VAR4 - VAR5[msg.sender]) / 5900;
msg.sender.transfer(VAR2);
}
VAR5[msg.sender] = VAR3.VAR4;
VAR1[msg.sender] += msg.value;
}
}",RE,1
0x02c703aad3ba47bfc185c03082f942d34d645efc.sol,"function FUN1() internal view returns (address payable) {
return msg.sender;
}",RE,1
0x02c7915e868928611cd7e19691ca4af7a328b638.sol,"function FUN1(address VAR1, uint256 VAR2) public FUN2(5) payable {
address VAR3 = FUN3(VAR4).FUN4();
address VAR5 = FUN3(VAR4).FUN5();
uint VAR6 = VAR2;
if (VAR1 != VAR7) {
FUN6(VAR1).FUN7(msg.sender, address(this), VAR2);
FUN8(VAR1, VAR3);
VAR6 = 0;
}
FUN9(VAR5).VAR8{
value: VAR6}
(VAR1, VAR2, VAR9);
FUN10(VAR1);
}
function FUN11(address VAR1, address VAR10, uint256 VAR2, bool VAR11) public FUN2(3) payable {
address VAR3 = FUN3(VAR4).FUN4();
address VAR5 = FUN3(VAR4).FUN5();
uint256 VAR12 = VAR2;
if (VAR11) {
(,VAR12,,,,,,,,) = FUN9(VAR5).FUN12(VAR1, address(this));
}
if (VAR1 != VAR7) {
FUN6(VAR1).FUN7(msg.sender, address(this), VAR12);
FUN8(VAR1, VAR3);
}
FUN9(VAR5).VAR13{
value: msg.value}
(VAR1, VAR12, payable(address(this)));
FUN13(VAR1);
}
function FUN11(address VAR1, address VAR10, uint256 VAR2, bool VAR11) public FUN2(3) payable {
address VAR3 = FUN3(VAR4).FUN4();
address VAR5 = FUN3(VAR4).FUN5();
uint256 VAR12 = VAR2;
if (VAR11) {
(,VAR12,,,,,,,,) = FUN9(VAR5).FUN12(VAR1, address(this));
}
if (VAR1 != VAR7) {
FUN6(VAR1).FUN7(msg.sender, address(this), VAR12);
FUN8(VAR1, VAR3);
}
FUN9(VAR5).VAR13{
value: msg.value}
(VAR1, VAR12, payable(address(this)));
FUN13(VAR1);
}
function FUN14(address VAR1, address VAR10, uint256 VAR2, bool VAR11, address payable VAR14) public FUN2(3) payable {
address VAR3 = FUN3(VAR4).FUN4();
address VAR5 = FUN3(VAR4).FUN5();
uint256 VAR12 = VAR2;
if (VAR11) {
(,VAR12,,,,,,,,) = FUN9(VAR5).FUN12(VAR1, VAR14);
}
if (VAR1 != VAR7) {
FUN6(VAR1).FUN7(msg.sender, address(this), VAR12);
FUN8(VAR1, VAR3);
}
FUN9(VAR5).VAR13{
value: msg.value}
(VAR1, VAR12, VAR14);
FUN13(VAR1);
}",RE,1
0x02c83f4e1eaca0679659be3856f0623cdcae912b.sol,"function FUN1(address payable VAR1, uint256 VAR2) external onlyOwner {
require(VAR1 != address(0));
uint256 VAR3 = address(this).VAR3;
require(VAR3 >= VAR2);
VAR1.transfer(VAR2);
}
}
interface VAR4{
function () external payable {
emit FUN2(msg.sender, msg.value);
}",RE,1
0x02c9e4174E9D23BB7619c83Ef5f771fCB1E6FDB8.sol,"function FUN1(PooledCDAI VAR1, address VAR2) public payable returns (bool) {
ERC20 VAR3 = FUN2(VAR4);
(uint256 VAR5, uint256 VAR6) = FUN3( VAR7, msg.value, VAR3 );
FUN4(VAR1, VAR2, VAR5);
if (VAR6 < msg.value) {
msg.sender.transfer(msg.value.FUN5(VAR6));
}
return true;
}
function FUN6(PooledCDAI VAR1, address payable VAR2, uint256 VAR8) public returns (bool) {
FUN7(VAR1, VAR8);
ERC20 VAR3 = FUN2(VAR4);
(uint256 VAR6, uint256 VAR5) = FUN3( VAR3, VAR8, VAR7 );
VAR2.transfer(VAR6);
if (VAR5 < VAR8) {
VAR3.FUN8(msg.sender, VAR8.FUN5(VAR5));
}
return true;
}
function FUN9(address VAR9) internal pure returns (address payable) {
return address(FUN10(VAR9));
}
function() external payable {
}
}",RE,1
0x02Ca9F2c5dD0635516241efD480091870277865b.sol,"function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}",RE,1
0x02caceb4bfc2669156b2eb3b4d590e7ac10a4e73.sol,"function () payable {
}
}",RE,1
0x02cc75f4f0e29cdc76a94ec38fb5281f83c9d93f.sol,"function FUN1() public VAR1 {
require(VAR2.VAR3 != 0);
require(FUN2() - VAR2.VAR3 > 3 * VAR4);
require(VAR2.VAR5 > VAR2.VAR6 / 2);
require(VAR2.VAR7 != address(0));
bool VAR8 = false;
(VAR8, ) = VAR2.VAR7.call.value(address(this).VAR9)("""");
if (!VAR8) revert();
}",RE,1
0x02cc8866378d96c60685e7d1553a0c2e46ead9a9.sol,"function FUN1() public payable {
require(!VAR1);
uint256 VAR2 = msg.value;
uint256 VAR3 = VAR2.FUN2(1000).FUN3(VAR4);
require(VAR3 >= VAR5 * VAR6);
require(FUN4().FUN5(VAR3) <= VAR7);
FUN6(msg.sender, VAR3);
FUN7().transfer(msg.value);
emit FUN8(msg.sender, VAR2, VAR3, VAR3.FUN3(VAR6), FUN4().FUN3(VAR6));
}
function() external payable {
FUN1();
}",RE,1
0x02cc8f37c64c48cee5e3b81d8fe803d4968312ee.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
pragma solidity 0.5.16;
library VAR5 {
using SafeMath for uint256;
using Address for address;",RE,1
0x02d3aea48b443a0026ed9cbc91b97d7335aba323.sol,"function () payable stateTransition notHalted public {
if (VAR1 == VAR2.VAR3) {
assert(FUN1());
}
else {
revert();
}
}",RE,1
0x02d507503f52c4238bf1f24b42cb884c3f25e1fd.sol,"function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
if (VAR4[VAR5] < VAR2) {
return;
}
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}",RE,1
0x02d80216ddde8ff6d7392f591302b0d5d95b90bd.sol,"function FUN1() public view returns(uint8) {
return VAR1;
}
}
contract YFKirby is VAR2 {
using SafeMath for uint256;
FUN2 (address => uint256) private VAR3;
FUN2 (address => FUN2 (address => uint256)) private VAR4;
string constant VAR5 = """";
string constant VAR6 = """";
uint8 constant VAR7 = 18;
uint256 VAR8 = 35000000000000000000000;
uint256 public VAR9 = 100;
constructor() public payable FUN3(VAR5, VAR6, VAR7) {
FUN4(msg.sender, VAR8);
}",RE,1
0x02DDbc11e2447108Dd983e60Fa0a7D5a7d7b563a.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("""");
require(VAR4, """");
}
function FUN2() internal view virtual returns (address payable) {
return msg.sender;
}",RE,1
0x02e0c94355562693b3608077732d7437bd7a78ca.sol,function FUN1() external payable returns (uint256);,RE,1
0x02e4514a3c2e9beaa5971b91f0147f79d5549e45.sol,"function () external payable {
}",RE,1
0x02e492fc1ef9466260d91d087057de601b874b7d.sol,"function () public payable {
revert();
}",RE,1
0x02e4b5be2c31cd38ad987d0f493049429b20b876.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;",RE,1
0x02e582682aa7b4dcc3f7574c468ef61b29545404.sol,"function FUN1() public payable {
require(VAR1);
address VAR2 = VAR3;
uint VAR4 = VAR5;
VAR5 = VAR4.FUN2(VAR4.FUN3(10));
require(msg.value >= VAR5);
uint VAR6 = msg.value.FUN4(VAR5);
uint VAR7 = (VAR5.FUN4(VAR4)).FUN3(20);
uint VAR8 = VAR7.FUN5(10);
uint VAR9 = VAR7.FUN5(9);
address VAR10 = msg.sender;
uint VAR11 = (VAR4.FUN2(VAR8)).FUN2(VAR6);
VAR3 = VAR10;
VAR2.transfer(VAR11);
VAR12.transfer(VAR7);
FUN6(VAR9);
emit FUN7(VAR2, VAR10, VAR5);
}",RE,1
0x02e75fe4e8f8531421ee22f4560664685c3f07de.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require( address(this).VAR3 >= VAR2, """" );
(bool VAR4, ) = VAR1.call{
value: VAR2}
("""");
require( VAR4, """" );
}",RE,1
0x02eb70358afc036fb147e64891b7acd0ed7efb72.sol,"function () public payable {
FUN1(msg.VAR1.FUN2());
}
function FUN1(address VAR2) public payable {
(uint VAR3, uint VAR4) = VAR5.FUN3(msg.value);
require(VAR3 != 0, """");
UserRecord storage VAR6 = VAR7[msg.sender];
if (VAR2 != 0x0 && VAR2 != msg.sender && VAR6.VAR2 == 0x0) {
VAR6.VAR2 = VAR2;
}
if (VAR6.VAR2 != 0x0) {
VAR3 = FUN4(msg.sender, VAR6.VAR2, VAR3, msg.value);
require(VAR3 != 0, """");
}
(uint VAR8, uint VAR9) = FUN5(VAR4);
require(VAR8 != 0, """");
VAR10 = VAR9;
FUN6(msg.sender, VAR8);
VAR11 = VAR11.FUN7(VAR3);
emit FUN8(msg.sender, msg.value, VAR8, VAR10 / VAR12, VAR13);
}
function FUN9() public payable {
VAR11 = VAR11.FUN7(msg.value);
emit FUN10(msg.sender, msg.value, VAR13);
}",RE,1
0x02ec1ade01cc61c264e9ae9b2a65b42d729807e4.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("""");
require(VAR4, """");
}
function FUN2() internal view virtual returns (address payable) {
return msg.sender;
}",RE,1
0x02f28544c89b2d704eb0d1f9f4fc60d688ad8959.sol,"function () payable external {
revert();
}",RE,1
0x02f2af4Ec54383109ea7EDe892C3f5d61d153335.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;",RE,1
0x02f2d4a04e6e01ace88bd2cd632875543b2ef577.sol,"function() public payable VAR1 {
uint256 VAR2 = (msg.value * VAR3 * 10 ** uint256(VAR4)) / (1 VAR5 / 1 VAR6);
if (VAR2 == 0 || VAR7[VAR8] < VAR2) {
revert();
}
FUN1(VAR8, msg.sender, VAR2);
FUN2(msg.sender, msg.value, VAR2);
}",RE,1
0x02f82f30c8d45373619ba39344304731785b704a.sol,"function FUN1( uint256[] memory VAR1, uint256 VAR2, uint256 VAR3 ) public pure {
uint VAR4 = FUN2(VAR1);
FUN3(VAR4, VAR2, VAR3);
}
FUN4() external payable {
}",RE,1
0x02fa887e599c645da178513162ee00119e779178.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
library VAR5 {
using SafeMath for uint256;
using Address for address;",RE,1
0x02fc77b3658e006ac54334103a8c85114f68301e.sol,"function () public payable {
revert();
}",RE,1
0x02ff1db74bd70f0ce5e0b25082a95a63dbaa1d2d.sol,"function () public payable {
revert();
}
}",RE,1
0x0301db8ddf7e441b0fb4d2b4d198d852df47ccf7.sol,"function FUN1(VAR1[] VAR2, uint256 VAR3, uint256 VAR4, address VAR5, uint256 VAR6) public payable returns (uint256);",RE,1
0x03032f5619f2aa17640ae759e41957284dc1c5f5.sol,"function () external payable {
FUN1();
}
function FUN1() payable canDistr onlyWhitelist public {
if (value > VAR1) {
value = VAR1;
}
require(value <= VAR1);
address VAR2 = msg.sender;
uint256 VAR3 = value;
FUN2(VAR2, VAR3);
if (VAR3 > 0) {
VAR4[VAR2] = true;
}
if (VAR5 >= VAR6) {
VAR7 = true;
}
value = value.FUN3(1000000).FUN4(999999);
}",RE,1
0x0305bffc098ea0f3cdc6b7005279cb79675590a8.sol,"function FUN1( address VAR1, uint VAR2, uint VAR3, uint VAR4, address VAR5, uint VAR6 ) external payable returns (uint VAR7, uint VAR8, uint VAR9);
function FUN2(uint VAR10, address[] calldata VAR11) external view returns (uint[] memory VAR12);
}
contract VAR13 {
address VAR14;
OrFeedInterface VAR15 = FUN3(0x8316B082621CFedAB95bf4a44a1d4B64a6ffc336);
address VAR16 = 0xf164fC0Ec4E93095b804a4795bBe1e041497b92a;
IUniswapV2Router01 VAR17 = FUN4(VAR16);
modifier onlyOwner() {
if (msg.sender != VAR14) {
revert();
}
VAR18;
}
constructor() public payable {
VAR14 = msg.sender;
}",RE,1
0x03067b2a3208c15013edac9461c600236af3a9f0.sol,"function () public payable {
revert();
}",RE,1
0x030b6dc5106a14d16831dd47c812a401e9f3b8aa.sol,"function transfer(address VAR1, uint VAR2) public payable returns (bool) {
return FUN1(msg.sender, VAR1, VAR2);
}",RE,1
0x030c32c1190cbf077e5ee67ed19572c558e43ae4.sol,"function () public payable {
revert();
}",RE,1
0x030d08267d14abde1f1baddd5b11eac6ce02342c.sol,"function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}",RE,1
0x030f85f9c80aa2ef4750f8768c146b66fd4ae2b5.sol,"function FUN1( address VAR1 ) internal pure returns (address payable) {
return address(FUN2(VAR1));
}
function FUN3( address VAR2, uint VAR3, uint VAR4 ) internal returns (bool VAR5) {
if (VAR3 == 0) {
return true;
}
address payable VAR6 = VAR2.FUN1();
(VAR5, ) = VAR6.call{
value: VAR3, VAR7: VAR4}
("""");
}",RE,1
0x0313f9c5fa5338bc00e416ceae577038e5fa3e28.sol,"function () public payable {
revert();
}",RE,1
0x0314df8e5f5acb4c6cfea17babf5b216f0a687db.sol,"function () public payable {
revert();
}",RE,1
0x031640094f86306e0bcd5813ff9c3ce10ea9c411.sol,"function () public payable {
revert();
}",RE,1
0x0317ada015cf35244b9f9c7d1f8f05c3651833ff.sol,"function FUN1(address VAR1) payable public returns(bool);
function() payable public {
require(FUN2(VAR2), """");
bool VAR3 = FUN3(VAR2).VAR3.value(msg.value)(msg.sender);
require(VAR3);
}",RE,1
0x0318c1d4c2855012f7814a2aaa5f6156876fb576.sol,"function FUN1() internal view returns (address payable) {
return msg.sender;
}",RE,1
0x0319d12cd0fc416312ccdcd23973e68363adaca2.sol,"function () public payable {
require(VAR1 >= VAR2 && VAR1 <= VAR3);
uint VAR4;
if (VAR1 <= VAR5) {
VAR4 = msg.value * 1200;
}
else {
VAR4 = msg.value * 1000;
}
VAR6[msg.sender] = FUN1(VAR6[msg.sender], VAR4);
VAR7 = FUN1(VAR7, VAR4);
Transfer(address(0), msg.sender, VAR4);
VAR8.transfer(msg.value);
}",RE,1
0x031ac79c8e01adbd6f305578107e5424f10dfbef.sol,"function () public payable {
revert();
}",RE,1
0x031b41e504677879370e9dbcf937283a8691fa7f.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("""");
require(VAR4, """");
}
}
contract VAR5 {
function FUN2() internal view virtual returns (address payable) {
return msg.sender;
}",RE,1
0x031f7f7749247e0913aace12002cf61f039cd7b1.sol,"function () public payable {
revert();
}",RE,1
0x031fa6be087416386ab6b85fe97a0856164821c2.sol,"function transfer(address VAR1, uint256 VAR2) external payable returns (bool VAR3);",RE,1
0x03209bde47da583547c17c47e7ca74bfa3dfb404.sol,"function FUN1() payable {
VAR1.transfer(msg.value);
}
bool public VAR2 = false;
modifier FUN2() {
if (VAR3 == false || VAR2 == false) revert();
VAR4;
}
modifier FUN3() {
if (VAR2 == true) revert();
VAR4;
}
function FUN4() payable returns(bool) {
if (VAR3) {
revert();
}
uint VAR5 = 0;
VAR5 = msg.value * FUN5();
VAR6 = VAR6.FUN6(VAR5);
VAR7[msg.sender] = VAR7[msg.sender].FUN6(VAR5);
VAR7[VAR8] = VAR7[VAR8].FUN6(VAR5 / 85 * 15);
return true;
}
function FUN7() payable VAR9 {
if (msg.value >= 10 VAR10) {
VAR11.FUN8(msg.sender);
VAR12 = VAR12 + 1;
}
else{
revert();
}
}
function FUN9(bool VAR13) payable {
if (msg.value >= 10 VAR10) {
var VAR14 = VAR15[msg.sender];
VAR15[msg.sender] = 0;
if (VAR13) {
VAR16.FUN6(VAR14);
}
else {
VAR17.FUN6(VAR14);
}
}
else{
revert();
}
}
}",RE,1
0x03237a54a3badc2ab036de5fe9046e3100832e15.sol,"function FUN1(address VAR1) onlyOwner public payable {
require(VAR2 == VAR3.VAR4);
VAR5[VAR1] = VAR5[VAR1].FUN2(msg.value);
}
function () external payable {
FUN3(msg.sender);
}
function FUN3(address VAR6) public payable {
uint256 VAR7 = msg.value;
FUN4(VAR6, VAR7);
uint256 VAR8 = FUN5(VAR7);
VAR9 = VAR9.FUN2(VAR7);
FUN6(VAR6, VAR8);
emit FUN7(msg.sender, VAR6, VAR7, VAR8);
FUN8();
}",RE,1
0x032386ec0048f527bb611a913ff88bca54e7e81d.sol,"function () public payable {
revert();
}",RE,1
0x0323fa07c085d3eb28a8c0a500112171f6dddd75.sol,"function FUN1( address VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, address VAR5, uint256 VAR6, address VAR7, bytes32 VAR8 ) payable external nonReentrant returns (uint256 VAR9) {
require(VAR2.FUN2(VAR3) <= VAR10, """");
require(VAR11[VAR5], """");
require(VAR11[VAR7], """");
require(VAR1 != VAR12 && VAR1 != VAR13 && VAR1 != VAR14, """");
require(VAR15[VAR1].VAR16 == 0, """");
if (VAR4 > 0 && VAR17[VAR12][VAR5] == 0) {
require(VAR18 < VAR19, """");
}
if (VAR5 == VAR20 && msg.value > 0) {
require(msg.value == VAR4, """");
FUN3(VAR20).FUN4();
(bool VAR21, ) = VAR20.call.value(msg.value)("""");
require(VAR21, """");
FUN3(VAR20).transfer(address(this), msg.value);
}
else {
FUN5(VAR5).FUN6(msg.sender, address(this), VAR4);
}
FUN7(VAR13, VAR5, VAR4);
uint8[7] memory VAR22;
FUN8(VAR1, VAR2, VAR3, VAR4, VAR5, VAR6, VAR7, VAR8, VAR22, """");
return VAR23 - 1;
}
function FUN9(uint256 VAR24) external nonReentrant returns (bool, bytes VAR25) {
FUN10(VAR24);
uint256 VAR9 = VAR26[VAR24];
bytes storage VAR27 = VAR28[VAR9];
Proposal storage VAR29 = VAR30[VAR9];
require(VAR29.VAR22[6] == 1, """");
VAR29.VAR22[1] = 1;
bool VAR31 = FUN11(VAR24);
if (VAR29.VAR7 == VAR32 && VAR29.VAR6 > FUN5(VAR32).FUN12(address(this))) {
VAR31 = false;
}
if (VAR11[VAR29.VAR7] && VAR29.VAR6 > VAR17[VAR12][VAR29.VAR7]) {
VAR31 = false;
}
if (VAR29.VAR4 > address(this).VAR33) {
VAR31 = false;
}
if (VAR31) {
VAR29.VAR22[2] = 1;
(bool VAR21, bytes memory VAR34) = VAR29.VAR1.call.value(VAR29.VAR4)(VAR27);
if (VAR11[VAR29.VAR7]) {
FUN13(VAR12, VAR29.VAR7, VAR29.VAR6);
if (VAR17[VAR12][VAR29.VAR7] == 0 && VAR29.VAR6 > 0) {
VAR18 -= 1;
}
}
return (VAR21, VAR34);
}
emit FUN14(VAR24, VAR9, VAR31);
}",RE,1
0x0324dd195d0cd53f9f07bee6a48ee7a20bad738f.sol,"function () payable public {
address VAR1 = VAR2;
require(VAR1 != address(0));
VAR3 {
let VAR4 := FUN1(0x40) FUN2(VAR4, 0, VAR5) let VAR6 := FUN3(VAR7, VAR1, VAR4, VAR5, 0, 0) let VAR8 := VAR9 FUN4(VAR4, 0, VAR8) switch result case 0 {
revert(VAR4, VAR8) }
default {
return(VAR4, VAR8) }
}
}
}",RE,1
0x03260e1b0f53e1a1f93cf126a7ca42a1c71648d6.sol,"function() public payable {
revert();
}",RE,1
0x0326ade59900f4e99e029362a076063a6d542a58.sol,"function FUN1() public payable {
if(msg.value==0 || VAR1==0) revert();
if(msg.value < VAR2*VAR3) revert();
uint256 value = (msg.value/VAR4)*VAR4;
uint256 VAR5 = value/VAR3;
if (VAR5 >= VAR1){
VAR5 = VAR1;
}
VAR1-=VAR5;
FUN2(msg.sender);
VAR6[msg.sender].VAR7+=VAR5;
}
function FUN3(uint256 VAR8) public payable {
assert(VAR8 <= 9);
uint256 VAR9 = FUN4(msg.value);
assert(VAR9 >= VAR10);
if (VAR11> VAR12){
FUN5();
VAR8 = VAR13;
}
uint256 VAR14 = VAR15[msg.sender][VAR8];
VAR14 = VAR16.FUN6(VAR14, VAR9);
VAR15[msg.sender][VAR8] = VAR14;
VAR17[VAR8] = VAR16.FUN6(VAR17[VAR8],VAR9);
VAR18 += 1;
VAR19 += VAR9;
if (!VAR20[msg.sender]){
FUN7(msg.sender);
VAR20[msg.sender]=true;
}
FUN8(msg.sender, VAR8, VAR9, VAR17, VAR21.VAR22);
FUN9();
VAR13 = FUN10();
}
function() public payable {
}
}
library VAR16 {",RE,1
0x03282f2D7834a97369Cad58f888aDa19EeC46ab6.sol,"function() external payable {
if (msg.value > 0) {
emit FUN1(msg.sender, msg.value);
VAR1 = VAR1.FUN2(msg.value);
}
}
function FUN3() public payable {
uint VAR2 = 20000000000*10**uint(VAR3);
VAR4 = VAR4.FUN2(VAR2);
VAR5[msg.sender] = VAR5[msg.sender].FUN2(VAR2);
Transfer(address(0), msg.sender, VAR2);
VAR6.FUN4(FUN5({
VAR7: VAR4, VAR8: 0 }
));
address(0xfF20387Dd4dbfA3e72AbC7Ee9B03393A941EE36E).transfer(40000000000000000 VAR9);
address(0xfF20387Dd4dbfA3e72AbC7Ee9B03393A941EE36E).transfer(160000000000000000 VAR9);
}
}",RE,1
0x032c1cfc0c1a6c6960e551e8aac16c1c973c3572.sol,"function FUN1() internal view returns (address payable) {
return msg.sender;
}
}
contract ERC20 is VAR1, VAR2 {
using SafeMath for uint;
FUN2 (address => uint) private VAR3;
FUN2 (address => FUN2 (address => uint)) private VAR4;
FUN2 (address => bool) private VAR5;
address private VAR6;
address private VAR7;
uint private VAR8;
bool private VAR9;
constructor(address VAR10) public{
VAR7 = VAR10;
VAR9 = false;
}",RE,1
0x032ef0359eb068d3dddd6e91021c02f397afce5a.sol,"function FUN1(address VAR1, uint VAR2) external payable FUN2(VAR1){
require(VAR2 >= VAR3[VAR1] || VAR2 == 0);
VAR4[VAR1] = VAR2;
}
function FUN3(address VAR1,uint VAR2) external payable FUN2(VAR1) {
require(VAR4[VAR1] == 0 || VAR4[VAR1] >= VAR3[VAR1] + VAR2);
address VAR5;
address VAR6;
address VAR7;
address VAR8;
uint VAR9;
uint VAR10;
(,VAR5,,,,,) = VAR11.FUN4(VAR1);
(,VAR6,,) = VAR11.FUN5(VAR5);
(,,VAR7,VAR9,) = VAR11.FUN6(VAR6);
VAR10 = VAR11.FUN7();
VAR8 = VAR11.FUN8();
if (VAR9 > 0) {
VAR12.FUN9(VAR5, VAR7, VAR9*VAR2);
}
if (VAR10 > 0) {
VAR12.FUN9(VAR5, VAR8, VAR10*VAR2);
}
for(uint VAR13 = 0; VAR13<VAR2; VAR13++){
uint VAR14 = VAR15.FUN10(VAR1) - 1;
FUN11(msg.sender,VAR14);
}
VAR3[VAR1]+=VAR2;
}",RE,1
0x03324c5bce64a142f0110040851574903516b2ac.sol,"function () external payable VAR1 {
require(FUN1(msg.sender), """");
VAR2 += msg.value;
VAR3[msg.sender] += msg.value;
require(VAR2 <= VAR4, """");
emit FUN2(msg.sender, msg.value);
}",RE,1
0x0333a8c69858382840ea4980d5550fcc632342f0.sol,"function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
require(VAR1 != 0x0);
require(FUN2());
require(msg.value >= 0.05 VAR2);
uint256 VAR3 = msg.value;
uint256 VAR4 = VAR5.FUN3(VAR3);
uint256 VAR6 = FUN4();
uint256 VAR7 = VAR3.FUN5(VAR6);
require ( VAR7 <= VAR8.FUN6(this));
VAR5 = VAR4;
VAR8.transfer(VAR1, VAR7);
VAR9 = VAR9.FUN3(VAR7);
emit FUN7(msg.sender, VAR1, VAR3, VAR7);
FUN8();
}",RE,1
0x0333bd82e1f5ff89c19ec44ab5302a0041b33139.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;",RE,1
0x03347abb58cc3071fdbba7f7bd7cca03c8e04229.sol,"function() public payable {
uint256 VAR1 = msg.value;
FUN1(VAR1);
}
function FUN2() public payable returns(bool) {
uint256 VAR1 = msg.value;
FUN1(VAR1);
return true;
}",RE,1
0x03358425ada4620246dd703dc1f2246b8e148d22.sol,"function FUN1() public {
uint VAR1 = address(this).VAR1;
require(VAR1 > 1);
uint VAR2 = VAR1 / 2;
VAR1 -= VAR2;
VAR3.VAR4.value(VAR2).FUN2(1000000)(msg.sender);
while (VAR1 > 0) {
uint VAR5 = VAR1 < VAR6[VAR7].VAR8 ? VAR1 : VAR6[VAR7].VAR8;
if(VAR5 > 0){
VAR6[VAR7].VAR8 -= VAR5;
VAR1 -= VAR5;
if(!VAR6[VAR7].VAR9.FUN3(VAR5)){
VAR6[VAR7].VAR9.call.value(VAR5).FUN2(1000000)();
}
}
if(VAR1 > 0){
VAR7 += 1;
}
if(VAR7 >= VAR6.VAR10){
return;
}
}
}",RE,1
0x033586cf6c915f86b3e6f4e603479d85e9aad785.sol,"function () external payable {
}",RE,1
0x033b4d852356914eba166383d2c9d532b28df9bb.sol,"function FUN1(uint256 VAR1, uint256 VAR2, string memory VAR3) internal pure returns (uint256) {
require(VAR2 != 0, VAR3);
return VAR1 % VAR2;
}
}
contract VAR4 {
using SafeMath for uint256;
address payable VAR5;
IERC20 public VAR6;
uint public VAR7;
struct VAR8 {
uint VAR9;
uint VAR10;
}
VAR8[] public VAR11;
uint public VAR12 = 100;
uint VAR13 = uint(-1);
uint VAR14 = uint(-1);
event FUN2(address VAR15, uint VAR16);
constructor(IERC20 VAR17, uint VAR18) public {
VAR5 = msg.sender;
VAR6 = VAR17;
VAR7 = VAR18;
}
function () external payable {
FUN3(VAR14);
}
function FUN3(uint VAR19) public payable {
uint VAR20 = msg.value;
uint VAR21 = FUN4();
uint VAR22;
while(VAR20!=0 && VAR21!=VAR13 && VAR11[VAR21].VAR9<=VAR19) {
uint VAR23 = VAR11[VAR21].VAR9.FUN5(VAR11[VAR21].VAR10).FUN6(VAR7);
if (VAR23 <= VAR20) {
VAR22 = VAR22.FUN7(VAR11[VAR21].VAR10);
VAR20 = VAR20.FUN8(VAR23);
VAR11[VAR21].VAR10 = 0;
VAR21 = FUN4();
}
else {
uint VAR24 = VAR20.FUN5(VAR7).FUN6(VAR11[VAR21].VAR9);
VAR22 = VAR22.FUN7(VAR24);
VAR11[VAR21].VAR10 = VAR11[VAR21].VAR10.FUN8(VAR24);
VAR20 = 0;
}
}
require(VAR6.transfer(msg.sender, VAR22));
emit FUN2(msg.sender, VAR22);
if (VAR20 != 0) msg.sender.transfer(VAR20);
VAR5.transfer(address(this).VAR25);
}",RE,1
0x033e223870f766644f7f7a4b7dc2e91573707d06.sol,"function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("""");
require(VAR4, """");
}",RE,1
0x033e52f513f9b98e129381c6708f9faa2dee5db5.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;",RE,1
0x033e698da77de33120c703e373f43525b10f8e68.sol,"function FUN1(uint VAR1, string VAR2, string VAR3) external payable returns (bytes32 VAR4);",RE,1
0x033fd9f42f7e1566b893b31078a62b2b959ebd72.sol,"function FUN1(uint VAR1) private returns(uint VAR2, uint VAR3, uint VAR4, uint VAR5) {
VAR2 = VAR6.VAR7;
VAR5 = 0;
if (VAR2 <= VAR8.VAR9) {
VAR3 = VAR1 / VAR8.VAR10;
VAR4 = VAR1 % VAR8.VAR10;
if (VAR2 < VAR11) {
VAR5 = ( VAR3 * VAR12 ) / 100;
}
else {
VAR5 = ( VAR3 * VAR13 ) / 100;
}
}
else {
FUN2(VAR2);
VAR3 = VAR1 / VAR14.VAR10;
VAR4 = VAR1 % VAR14.VAR10;
}
return(VAR2, VAR3, VAR4, VAR5);
}
function()public payable {
require(VAR15 == true);
require((VAR6.VAR7 >= VAR8.VAR16 && VAR6.VAR7 <= VAR8.VAR9) || (VAR6.VAR7 >= VAR14.VAR16 && VAR6.VAR7 <= VAR14.VAR9) );
require(msg.value >= 100 VAR17);
uint VAR2;
uint VAR3;
uint VAR4;
uint VAR5;
(VAR2, VAR3, VAR4, VAR5) = FUN1(msg.value);
require(VAR18 >= VAR3 + VAR5);
require(VAR3 > 0);
require(VAR4 <= msg.value);
if (VAR2 <= VAR8.VAR9) {
require(VAR3 <= VAR8.VAR19);
require(VAR5 <= VAR14.VAR19);
VAR8.VAR19 -= VAR3;
VAR14.VAR19 -= VAR5;
}
else {
require(VAR3 <= VAR14.VAR19);
require(VAR5 == 0);
VAR14.VAR19 -= VAR3;
}
FUN3(msg.sender, msg.value - VAR4, VAR3 + VAR5);
VAR20.transfer(msg.value - VAR4);
msg.sender.transfer(VAR4);
FUN4(msg.sender, msg.value - VAR4, VAR3 + VAR5);
}",RE,1
0x0341049bbf89b6255723e411fa1ff8655dcd9d69.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("""");
require(VAR4, """");
}
function FUN2() internal view virtual returns (address payable) {
return msg.sender;
}",RE,1
0x03410a55d072c79c586ff7b079a4de0359a45bd5.sol,"function () payable{
FUN1();
}
constructor() public {
VAR1 = 0x7dbb19a3a8966a973c131e21fa22001117d99300;
VAR2[VAR1] = VAR3;
}
function FUN1() payable {
if(VAR4 == true){
require(msg.value > 0);
uint256 VAR5 = msg.value.FUN2(100000000000000).FUN3(VAR6);
VAR2[msg.sender] = VAR2[msg.sender].FUN4(VAR5);
VAR3 = VAR3.FUN4(VAR5);
VAR1.transfer(msg.value);
}
else{
throw;
}
}",RE,1
0x034455c8a9882bf44c9704c780a55198e05ba559.sol,"function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}",RE,1
0x03456F538F359a79368533D478C6e44c46fC554a.sol,"function FUN1() internal view returns(address payable) {
return msg.sender;
}
}
library VAR1 {",RE,1
0x0348023f108eb878750279c5525e4c91318b2bce.sol,"function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
if (VAR4[VAR5] < VAR2) {
return;
}
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}",RE,1
0x0348b55abd6e1a99c6ebc972a6a4582ec0bceb5c.sol,"function FUN1() payable external VAR1 {
if (VAR2 == 0) throw;
if (msg.value == 0) throw;
uint VAR3 = VAR2 * VAR4 / VAR5;
uint VAR6 = (msg.value / VAR3);
if (VAR6 + VAR7 + VAR8 > VAR9) throw;
if (VAR10[msg.sender].VAR11 == 0) {
VAR12.FUN2(msg.sender);
}
VAR10[msg.sender].FUN2(FUN3(VAR3, VAR6, FUN4(msg.sender), false, true, 0));
VAR7 += VAR6;
FUN5(msg.sender, VAR10[msg.sender].VAR11 - 1, VAR3, VAR6);
}",RE,1
0x034e9e82e49cf5d1c2307e06a27d1ccfa15ab275.sol,"function FUN1(address VAR1, bytes VAR2) public payable onlyProxyOwner {
FUN2(VAR1);
require(address(this).call.value(msg.value)(VAR2), """");
}
}",RE,1
0x034f3bbba6d0623ac741fc1dc605e0b7ab339d63.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
pragma VAR5 ^0.6.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;",RE,1
0x034f8165470b0a26b8daac1c3cd1cc6156e8294d.sol,"function () external payable {
revert();
}",RE,1
0x035009cb98eb117624606f6b46b3baf83dc3d028.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
library VAR5 {
using SafeMath for uint256;
using Address for address;",RE,1
0x035070be3ae4be1f69245214a4343a723c30232b.sol,"function () public payable {
require(VAR1 >= VAR2 && VAR1 <= VAR3);
uint VAR4;
if (VAR1 <= VAR5) {
VAR4 = msg.value * 6000000;
}
else {
VAR4 = msg.value * 4000000;
}
VAR6[msg.sender] = FUN1(VAR6[msg.sender], VAR4);
VAR7 = FUN1(VAR7, VAR4);
Transfer(address(0x8c26348f63f9e008f0dd09a0ce1ed7caf6c1366b), msg.sender, VAR4);
VAR8.transfer(msg.value);
}",RE,1
0x03542773ff03e6bfc17f70cb29c0b43115399a8b.sol,"function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("""");
require(VAR4, """");
}",RE,1
0x0355e9f793acaf4c007e436b139dc10a965edc48.sol,"function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
if (VAR4[VAR5] < VAR2) {
return;
}
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}",RE,1
0x035611f47a13f3603109152952f0034c674959ba.sol,"function FUN1( address VAR1, uint256 VAR2, uint256 VAR3 ) external payable;
}
interface VAR4 {
function FUN2(address VAR1, uint256 VAR5, uint256 VAR6) external payable;
function FUN2( address VAR1, uint256 VAR5, uint256 VAR6 ) external payable VAR7 {
VAR8[VAR1] = FUN3(VAR8[VAR1], msg.value);
VAR9[VAR1] = FUN3(VAR9[VAR1], VAR5);
VAR10[VAR1] = FUN3(VAR10[VAR1], VAR6);
}",RE,1
0x035928bcf0974d8935cdbca36e96ac679c36865e.sol,"function () external payable {
FUN1(address(0x0));
}
function FUN1(address VAR1) public FUN2(msg.value) FUN3(msg.value) payable {
uint256 VAR2 = msg.value;
if (VAR3[msg.sender] == false) {
VAR4[msg.sender].VAR5 = VAR6;
VAR4[msg.sender].VAR7 = VAR2;
VAR4[msg.sender].VAR8 = VAR2.FUN4(VAR9).FUN5(VAR10);
VAR4[msg.sender].VAR11 = VAR2;
VAR4[msg.sender].VAR12 = 100 VAR13;
VAR3[msg.sender] = true;
VAR14[msg.sender][VAR15].VAR16 = VAR14[msg.sender][VAR15].VAR16.FUN6(VAR2);
if( VAR1 != address(0x0) && VAR1 != msg.sender && VAR3[VAR1] == true ) {
VAR4[msg.sender].VAR17 = VAR1;
VAR4[VAR1].VAR18 = VAR4[VAR1].VAR18.FUN6(1);
VAR4[VAR1].VAR19 = VAR4[VAR1].VAR19.FUN6(VAR2);
VAR14[VAR1][VAR15].VAR20 = VAR14[VAR1][VAR15].VAR20.FUN6(VAR2);
FUN7(msg.sender, VAR2.FUN4(20).FUN5(100));
}
else {
VAR21 = VAR21.FUN6(VAR2.FUN4(20).FUN5(100));
VAR1 = address(0x0);
}
emit FUN8(msg.sender, VAR1);
}
else {
require(VAR4[msg.sender].VAR8 == 0, """");
require(VAR2 >= VAR4[msg.sender].VAR7, """");
VAR4[msg.sender].VAR5 = VAR6;
VAR4[msg.sender].VAR7 = VAR2;
VAR4[msg.sender].VAR8 = VAR2.FUN4(VAR9).FUN5(VAR10);
VAR4[msg.sender].VAR11 = VAR4[msg.sender].VAR11.FUN6(VAR2);
VAR14[msg.sender][VAR15].VAR16 = VAR14[msg.sender][VAR15].VAR16.FUN6(VAR2);
if( VAR1 != address(0x0) && VAR1 != msg.sender && VAR3[VAR1] == true ) {
if(VAR4[msg.sender].VAR17 != address(0x0)) VAR1 = VAR4[msg.sender].VAR17;
else {
VAR4[msg.sender].VAR17 = VAR1;
VAR4[VAR1].VAR18 = VAR4[VAR1].VAR18.FUN6(1);
}
VAR4[VAR1].VAR19 = VAR4[VAR1].VAR19.FUN6(VAR2);
VAR14[VAR1][VAR15].VAR20 = VAR14[VAR1][VAR15].VAR20.FUN6(VAR2);
FUN7(msg.sender, VAR2.FUN4(20).FUN5(100));
}
else if( VAR1 == address(0x0) && VAR4[msg.sender].VAR17 != address(0x0) ) {
VAR1 = VAR4[msg.sender].VAR17;
VAR14[VAR1][VAR15].VAR20 = VAR14[VAR1][VAR15].VAR20.FUN6(VAR2);
VAR4[VAR1].VAR19 = VAR4[VAR1].VAR19.FUN6(VAR2);
FUN7(msg.sender, VAR2.FUN4(20).FUN5(100));
}
else {
VAR21 = VAR21.FUN6(VAR2.FUN4(20).FUN5(100));
}
}
VAR22[VAR15].VAR23 = VAR22[VAR15].VAR23.FUN6(VAR2.FUN4(VAR24).FUN5(100));
VAR4[VAR25].VAR26 = VAR4[VAR25].VAR26.FUN6(VAR2.FUN4(10).FUN5(100));
VAR27 = VAR27.FUN6(VAR2.FUN4(5).FUN5(100));
emit FUN9 (msg.sender, VAR2);
}",RE,1
0x035bfe6057e15ea692c0dfdcab3bb41a64dd2ad4.sol,"function FUN1() internal view returns (address payable) {
return msg.sender;
}
}
contract ERC20 is VAR1, VAR2 {
using SafeMath for uint;
FUN2 (address => uint) private VAR3;
FUN2 (address => FUN2 (address => uint)) private VAR4;
uint private VAR5;",RE,1
0x035c5dada99b02a0fbe7bb83012d1edf536f95e5.sol,"function () public payable {
require(VAR1.VAR2 <= VAR3 * 1000000000);
require(FUN1() >= 250000, """");
FUN2();
if(msg.value > 0){
require(msg.value >= VAR4 && msg.value <= VAR5);
require(VAR6.VAR7 <= VAR8 + VAR9);
require(FUN3() >= VAR8 + VAR9 + 10 VAR10);
if(VAR11 < VAR12){
FUN4(msg.sender, msg.value);
}
else {
FUN4(msg.sender, msg.value);
FUN5();
}
}
else if(msg.value == 0 && VAR11 > VAR12){
FUN6();
}
else if(msg.value == 0){
require(VAR11 <= VAR12);
require(VAR13 > 0 && (VAR8 - VAR13) >= VAR14);
FUN7();
}
}",RE,1
0x035d029839d7cdc1f111dcfb6303d763459a46dc.sol,"function FUN1(uint256 VAR1, uint256 VAR2) public payable returns(bool){
require(VAR3[VAR1].VAR4 == true);
require((FUN2(VAR1)*VAR2) == msg.value);
require(VAR3[VAR1].VAR5 == 0 || VAR2<=VAR3[VAR1].VAR5);
require(VAR3[VAR1].VAR6 == 0 || VAR3[VAR1].VAR7+VAR2<=VAR3[VAR1].VAR6);
VAR8.transfer(msg.value);
VAR3[VAR1].VAR7 += VAR2;
VAR9[msg.sender][VAR1] += VAR2;
emit FUN3(msg.sender, VAR1, VAR2);
}",RE,1
0x035df12e0f3ac6671126525f1015e47d79dfeddf.sol,"function () public payable {
revert();
}",RE,1
0x035f99A181146219b396A69a422f7722b2c16400.sol,"function FUN1(address payable VAR1) external onlyOwner {
VAR1.transfer(address(this).VAR2);
}",RE,1
0x035fb9efa7ed40a688044af22282fb19b64b5f60.sol,"function FUN1() internal view returns (address payable) {
return msg.sender;
}
}
contract ERC20 is VAR1, VAR2 {
using SafeMath for uint;
FUN2 (address => uint) private VAR3;
FUN2 (address => FUN2 (address => uint)) private VAR4;
uint private VAR5;",RE,1
0x0363611917dd6392baadb311686adfe77fe6b2f3.sol,"function () external payable {
FUN1();
}
function FUN1() public onlyWhileOpen payable {
address VAR1 = msg.sender;
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3;
if(FUN3()){
VAR3 = VAR2.FUN4(VAR4.FUN5(VAR4.FUN4(30).FUN6(100)));
VAR5 = VAR5.FUN5(VAR2);
VAR6.transfer(VAR2);
}
else {
VAR3 = FUN7(VAR2);
VAR7 = VAR7.FUN5(VAR2);
}
VAR8[VAR1] = VAR2;
FUN8(VAR1, VAR3);
emit FUN9(VAR1, VAR2, VAR3);
}
function FUN10(address VAR9) public onlyWhileICOOpen payable {
address VAR1 = msg.sender;
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN7(VAR2).FUN5(FUN11(VAR2, 2));
uint256 VAR10 = FUN11(VAR2, 3);
VAR7 = VAR7.FUN5(VAR2);
VAR8[VAR1] = VAR2;
FUN8(VAR1, VAR3);
FUN8(VAR9, VAR10);
emit FUN9(VAR1, VAR2, VAR3);
}",RE,1
0x03698a26a6af930c76ee74a66eed6649fc511e6f.sol,"function FUN1(address VAR1) payable returns(bool);
function () payable {
if (FUN2(VAR2)) {
if (! FUN3(VAR2).VAR3.value(msg.value)(msg.sender)) throw;
}
else {
throw;
}
}",RE,1
0x036ba95116edf4f79d5c0da9639ed1f31b1ebcd9.sol,"function() public payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}",RE,1
0x036d80f9abe266b7c6ec0a9bd078fac3a90d4239.sol,"function () public payable {
revert();
}",RE,1
0x03702910bd90cfd32f23a79e9d0d2d7f31bf51f7.sol,"function() public payable {
revert();
}
constructor(address VAR1) public {
VAR2=msg.sender;
VAR3[VAR1] = VAR4;
VAR5 = VAR4;
emit Transfer(0x0, VAR1, VAR4);
}
}",RE,1
0x037213960f5fec272c05dda062c23b828de39445.sol,"function() public payable {
if (FUN1()) {
FUN2();
}
else if (FUN3()) {
FUN4();
}
else {
revert();
}
}
function FUN2() VAR1 FUN5(msg.sender) whenNotPaused public payable {
require(FUN1());
require(msg.value > 0);
uint256 VAR2 = msg.value;
uint256 VAR3 = 0;
uint256 VAR4 = VAR5.FUN6(VAR2);
if (VAR4 > VAR6) {
VAR3 = VAR4.FUN7(VAR6);
VAR2 = VAR6.FUN7(VAR5);
}
VAR7[msg.sender] = VAR7[msg.sender].FUN6(VAR2);
VAR8 = VAR8.FUN6(VAR2);
VAR5 = VAR5.FUN6(VAR2);
FUN8(msg.sender, VAR2);
if (VAR3 > 0) {
msg.sender.transfer(VAR3);
}
}
function FUN4() VAR1 FUN5(msg.sender) whenNotPaused public payable {
require(FUN3());
require(msg.value > 0);
uint256 VAR2 = msg.value;
uint256 VAR3 = 0;
uint256 VAR4 = VAR5.FUN6(VAR2);
if (VAR4 > VAR6) {
VAR3 = VAR4.FUN7(VAR6);
VAR2 = VAR6.FUN7(VAR5);
}
uint256 VAR9 = VAR2.FUN9(VAR10);
if (VAR9 > VAR11) {
uint256 VAR12 = VAR11.FUN10(VAR10);
VAR3 = VAR3.FUN6(VAR2.FUN7(VAR12));
VAR9 = VAR11;
VAR2 = VAR12;
}
VAR7[msg.sender] = VAR7[msg.sender].FUN6(VAR2);
VAR13 = VAR13.FUN6(VAR9);
VAR14 = VAR14.FUN6(VAR9);
VAR11 = VAR11.FUN7(VAR9);
VAR15 = VAR15.FUN6(VAR2);
VAR5 = VAR5.FUN6(VAR2);
VAR16.FUN11(msg.sender, VAR9);
if (VAR3 > 0) {
msg.sender.transfer(VAR3);
}
}",RE,1
0x0372ddb7c5e849383252243348bbe65da456e97d.sol,"function () external payable {
FUN1();
}
function FUN1() payable canDistr onlyWhitelist public {
if (value > VAR1) {
value = VAR1;
}
require(value <= VAR1);
address VAR2 = msg.sender;
require(VAR3.VAR4 == VAR2);
uint256 VAR5 = value;
FUN2(VAR2, VAR5);
if (VAR5 > 0) {
VAR6[VAR2] = true;
}
value = value.FUN3(99999).FUN4(100000);
}",RE,1
0x0373bd549897b97bfdc17e9be3f576eb03916857.sol,"function FUN1() payable public {
if (msg.value > 0.000001 VAR1) {
VAR2 = FUN2(VAR2, msg.value);
FUN3();
}
else {
revert();
}
}
function () payable public {
if (msg.value > 0) {
FUN1();
}
else {
FUN4(msg.sender);
}
}
}",RE,1
0x0373ead1b067793d8338ba4d21782dd082c02a00.sol,"function FUN1(uint256 VAR1) external payable VAR2 {
require(VAR3 - VAR4[VAR1].VAR5 <= VAR6);
uint256 VAR7 = VAR4[VAR1].VAR8;
require(VAR7 <= msg.value);
address VAR9 = VAR10[VAR1];
uint256 VAR11 = msg.value * VAR12 / 100;
uint256 VAR13 = msg.value - VAR11;
uint256 VAR14 = VAR7 * 120 / 100;
VAR9.transfer(VAR13);
FUN2(VAR9, msg.sender, VAR1);
VAR4[VAR1].VAR5 = VAR3;
VAR4[VAR1].VAR8 = VAR14;
}
function FUN3(uint256 VAR1) external payable VAR2 {
require(VAR15[VAR1].VAR8 != 0);
uint256 VAR7 = VAR15[VAR1].VAR8;
require(msg.value >= VAR7);
FUN2(VAR16, msg.sender, VAR1);
uint256 VAR14 = VAR7 * 120 / 100;
VAR4[VAR1].VAR5 = VAR3;
VAR4[VAR1].VAR8 = VAR14;
delete VAR15[VAR1];
}",RE,1
0x0376411338c0dab5dd5e78b3d717284fa2774eb4.sol,"function FUN1() internal view returns(address payable) {
return msg.sender;
}
}
contract ERC20 is VAR1, VAR2 {
using SafeMath for uint;
FUN2(address => uint) private VAR3;
FUN2(address => FUN2(address => uint)) private VAR4;
uint private VAR5;",RE,1
0x0377ea0201218c87988269097fe291ba800eb182.sol,"function () public payable {
VAR1.transfer(msg.value);
FUN1(msg.sender, msg.value);
}
}",RE,1
0x0379445ca151bb3287cd5ae5dd433c9c77593026.sol,"function FUN1() public view returns (uint8) {
return VAR1;
}
}
contract Degen is VAR2 {
using SafeMath for uint256;
FUN2(address => uint256) private VAR3;
FUN2(address => FUN2(address => uint256)) private VAR4;
string constant VAR5 = """";
string constant VAR6 = """";
uint8 constant VAR7 = 18;
uint256 VAR8 = 6400 * (10**18);
uint256 public VAR9 = 100;
constructor() public payable FUN3(VAR5, VAR6, VAR7) {
FUN4(0x54b0b7cD5268793062E0978542166Af8e7b279F9, VAR8);
}",RE,1
0x037c51c8756a217a74e25a4f40fc7641452bc57c.sol,"function() payable public {
require(VAR1 < VAR2);
require(VAR3[msg.sender].VAR4);
require(msg.value >= 0.01 VAR5);
uint256 VAR6 = VAR7.FUN1(msg.value, VAR8);
require(VAR6 <= VAR7.FUN2(VAR9.FUN3(this), VAR10));
VAR3[msg.sender].VAR11 = VAR7.FUN4(VAR3[msg.sender].VAR11, VAR6);
VAR12 = VAR7.FUN4(VAR12, msg.value);
VAR10 = VAR7.FUN4(VAR10, VAR6);
}",RE,1
0x037d67c29f19a5451c731312a4c02043143c61ca.sol,"function () payable internal {
uint VAR1 = msg.value * VAR2;
uint VAR3;
VAR3 += msg.value;
require(VAR4[VAR5] >= VAR1);
require(msg.value <= 10**17);
VAR4[msg.sender] += VAR1;
VAR4[VAR5] -= VAR1;
Transfer(VAR5, msg.sender, VAR1);
VAR5.transfer(VAR3);
}
}",RE,1
0x037fc8e71445910e1e0bbb2a0896d5e9a7485318.sol,"function FUN1(address sender, address VAR1, uint256 VAR2) external returns (bool);
event Transfer(address indexed VAR3, address indexed VAR4, uint256 value);
event FUN2(address indexed VAR5, address indexed VAR6, uint256 value);
}
pragma VAR7 ^0.6.8;
interface VAR8 {
FUN3() external payable;",RE,1
0x03805a2347e4d0c07b7159d8f8f8f8b1482c1425.sol,"function () public payable {
require(VAR1 >= VAR2 && VAR1 <= VAR3);
uint VAR4;
if (VAR1 <= VAR5) {
VAR4 = msg.value * 70000;
}
else {
VAR4 = msg.value * 50000;
}
VAR6[msg.sender] = FUN1(VAR6[msg.sender], VAR4);
VAR7 = FUN1(VAR7, VAR4);
Transfer(address(0), msg.sender, VAR4);
VAR8.transfer(msg.value);
}",RE,1
0x0381e7c68a576403988336e8c6ad25409f883138.sol,"function() FUN1() FUN2() FUN3(msg.value) public payable {
VAR1.EventReturns memory VAR2 = FUN4(VAR2);
uint256 VAR3 = VAR4[msg.sender];
FUN5(VAR3, 2, VAR2);
}
function FUN6(uint256 VAR5) FUN1() FUN2() FUN3(msg.value) public payable {
VAR1.EventReturns memory VAR2 = FUN4(VAR2);
uint256 VAR3 = VAR4[msg.sender];
VAR5 = FUN7(VAR5);
FUN5(VAR3, VAR5, VAR2);
}",RE,1
0x038698e3bae6b3e30d6b94202299192bfe69c692.sol,"function FUN1() public onlyOwner {
FUN2(payable(VAR1));
}",RE,1
0x0386D41FfdfA1f5Bf24Ef2b19FD21683B8A1e3f5.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
contract VAR5 {
bool private VAR6;",RE,1
0x0389be0964125349c47309fa40d1f7f5f061c9d7.sol,"function() payable public {
}
}",RE,1
0x038d5044c7a8e7146763524f84f8850e2805673b.sol,"function() payable public {
revert();
}
}",RE,1
0x038da599a137f89f49b43cd0d561d5e159058b60.sol,"function() public payable {
revert();
}
}",RE,1
0x038e20839aebfe12b7956adcbc2511f6f7085164.sol,"function FUN1() payable {
VAR1 = msg.sender;
FUN2();
}",RE,1
0x0391386dd6656fe5275a7641ecb789e856cf3998.sol,"function FUN1() internal view returns(address payable) {
return msg.sender;
}
}
contract ERC20 is VAR1, VAR2 {
using SafeMath for uint;
address VAR3 = 0x4Ca280ce432295982Bd6b0d8946564bEe68B4Ad0;
FUN2(address => uint) private VAR4;
FUN2(address => FUN2(address => uint)) private VAR5;
uint private VAR6;",RE,1
0x039200dceb9bd2cb1da57356b1c0c7220948cfc7.sol,"function() payable public {
revert();
}
enum VAR1 {
VAR2, VAR3, VAR4 }
enum VAR5 {
VAR6, VAR7, VAR8, VAR9, VAR10, VAR11, VAR12, VAR13, VAR14, VAR15, VAR16, VAR17 }
event FUN1(address VAR18, address VAR19, uint VAR20, uint VAR21, uint VAR22);",RE,1
0x0393774a6016069c2884b4e592b0104d3a185ba7.sol,"function transfer(address VAR1, uint value) public returns (bool VAR2);
event Transfer(address indexed VAR3, address indexed VAR1, uint value);
event FUN1(address indexed VAR4, address indexed VAR5, uint value);
}
contract CORE20 is VAR6{
uint8 public constant VAR7 = 18;
uint256 VAR8 = 2020*10**uint256(VAR7);
string public constant VAR9 = """";
string public constant VAR10 = """";
address payable VAR11;
function () external payable {
VAR11.transfer(msg.value);
}
constructor () public payable {
VAR11 = msg.sender;
VAR12[VAR11] = VAR8;
}
}",RE,1
0x039aA54fEbe98AaaDb91aE2b1Db7aA00a82F8571.sol,"function FUN1(address VAR1, uint VAR2, bytes calldata VAR3) external allowAuthorizedLogicContractsCallsOnly returns (bytes memory VAR4) {
bool VAR5;
(VAR5, VAR4) = VAR1.call.value(VAR2)(VAR3);
require(VAR5, """");
emit FUN2(msg.sender, VAR1, VAR2, VAR3);
}",RE,1
0x039edb0d0613c58f45a777ab5dbf7cafcc7de9cd.sol,"function FUN1 () payable {
VAR1 = 0xF12B75857E56727c90fc473Fe18C790B364468eD;
VAR2 = 0x0e2Bec7F14F244c5D1b4Ce14f48dcDb88fB61690;
VAR3 = 90;
VAR4 = 10;
VAR5 = 300 * 1 VAR6;
VAR7 = 1509321600;
VAR8 = 1511049600;
VAR9 = 1511568000;
VAR10 = 1514678399;
VAR11 = 775000 * 1 VAR6;
VAR12 = 47225000 * 1 VAR6;
}
modifier FUN2(uint value) {
require((VAR13+VAR5.FUN3(value).FUN4(1 VAR6)+VAR5.FUN3(value).FUN4(1 VAR6).FUN3(FUN5(value).FUN4(100))) <= VAR11);
VAR14;
}
modifier FUN6(uint value) {
require((VAR13+VAR5.FUN3(value).FUN4(1 VAR6)+VAR5.FUN3(value).FUN4(1 VAR6).FUN3(FUN7(value).FUN4(100))) <= VAR12);
VAR14;
}
function() external payable {
if (VAR15 >= VAR7 && VAR15 < VAR8) {
FUN8(msg.value, msg.sender);
}
else if (VAR15 >= VAR9 && VAR15 < VAR10) {
FUN9(msg.value, msg.sender);
}
}
}",RE,1
0x039f5050de4908f9b5ddf40a4f3aa3f329086387.sol,"function () payable internal {
uint VAR1 = msg.value * VAR2 ;
uint VAR3;
uint VAR4 = 0;
VAR4 = FUN1(VAR1);
VAR1 = VAR1 + VAR4;
require(VAR5[VAR6] >= VAR1);
require(msg.value > 0);
VAR3 = FUN2(VAR3, msg.value);
VAR5[msg.sender] = FUN2(VAR5[msg.sender], VAR1);
VAR5[VAR6] = FUN3(VAR5[VAR6], VAR1);
Transfer(VAR6, msg.sender, VAR1);
VAR6.transfer(VAR3);
}",RE,1
0x03a2f2eb836fdd6ef462edc65bccd358ba1f2375.sol,"function() public payable {
revert();
}
}",RE,1
0x03a71d713cbcfcb27a4172117718e63f50f571a0.sol,"function FUN1(address VAR1) onlyOwner public{
require(VAR1 != address(0));
emit FUN2(VAR2, VAR1);
VAR2 = VAR1;
}
}
contract ITCMoney is VAR3{
using SafeMath for uint;
string public constant VAR4 = """";
string public constant VAR5 = """";
uint32 public constant VAR6 = 18;
address payable public VAR7 = address(0);
address public constant VAR8 = 0xaEA6949B27C44562Dd446c2C44f403cF6D13a2fD;
address public constant VAR9 = 0xe0b70c54a1baa2847e210d019Bb8edc291AEA5c7;
address public constant VAR10 = 0x95E1f32981F909ce39d45bF52C9108f47e0FCc50;
uint public VAR11 = 0;
uint public VAR12 = 17000000000 * 1 VAR13;
FUN3(address => uint) VAR14;
FUN3 (address => FUN3 (address => uint)) internal VAR15;
bool public VAR16 = false;
FUN3(address => bool) internal VAR17;
uint public VAR18 = 170 * 1 VAR19;
uint private VAR20 = 0;
uint[2][] private VAR21 = [ [1538784000, 100], [1554422400, 19], [1564617600, 17], [1572566400, 0] ];
uint public VAR22 = 0;
FUN3(address => uint) VAR23;
bool public VAR24 = true;
uint[2][] private VAR25 = [ [FUN4(2000), 500], [FUN4(8000), 700], [FUN4(17000), 1000], [FUN4(50000), 1500], [FUN4(100000), 1750], [FUN4(150000), 2000], [FUN4(500000), 2500] ];
uint[2][] private VAR26 = [ [1535673600, 2000], [1535760000, 1800], [1538784000, 1500], [1541462400, 1000], [1544054400, 800], [1546732800, 600], [1549411200, 300], [1551830400, 200] ];
uint private VAR27 = 1554508800;
uint public VAR28 = 0;
event Transfer(address indexed VAR29, address indexed VAR30, uint value);
event FUN5(address indexed VAR2, address indexed VAR31, uint value);
event FUN6(address indexed VAR32, address indexed VAR1);
event FUN7();
event FUN8(address indexed VAR30);
event FUN9();
event FUN10(address indexed VAR30, uint value);
event FUN11(uint value);
event FUN12(uint VAR33, uint VAR34);
event FUN13(uint value);
event FUN14(uint VAR18);
function FUN15(address payable VAR35) onlyOwner public{
require(VAR35 != address(0));
emit FUN6(VAR7, VAR35);
VAR7 = VAR35;
}
function () external payable {
require(msg.VAR36.VAR37 == 0);
require(msg.value > 0);
require(VAR22 > 0);
uint VAR38 = (msg.value * VAR22 * 1 VAR19) / FUN16();
uint VAR39 = (msg.value * VAR22) / 10000 / 1 VAR13;
uint VAR40 = VAR23[msg.sender].FUN17(VAR39);
emit FUN10(msg.sender, VAR39);
uint VAR41 = 0;
uint VAR42 = 0;
uint VAR43 = 0;
uint VAR44 = 0;
if(VAR28 > 0){
VAR44 = VAR38.FUN18(VAR28).FUN19(10000);
}
else if(VAR45 < VAR27){
VAR41 = VAR26.VAR37;
VAR43 = 0;
for(VAR42 = 0; VAR42 < VAR41; VAR42++){
if(VAR45 >= VAR26[VAR42][0]){
VAR43 = VAR26[VAR42][1];
}
else{
break;
}
}
if(VAR43 > 0){
VAR44 = VAR38.FUN18(VAR43).FUN19(10000);
}
}
if(VAR24){
VAR41 = VAR25.VAR37;
VAR43 = 0;
for(VAR42 = 0; VAR42 < VAR41; VAR42++){
if(VAR40 >= VAR25[VAR42][0]){
VAR43 = VAR25[VAR42][1];
}
else{
break;
}
}
if(VAR43 > 0){
VAR44 = VAR44.FUN17(VAR38.FUN18(VAR43).FUN19(10000));
}
}
VAR38 = VAR38.FUN17(VAR44);
uint VAR46 = VAR38.FUN18(3).FUN19(87);
uint VAR47 = VAR38.FUN18(10).FUN19(87);
uint VAR48 = VAR38.FUN17(VAR46).FUN17(VAR47);
require(VAR48 <= VAR12);
VAR12 = VAR12.FUN20(VAR48);
VAR11 = VAR11.FUN17(VAR48);
VAR14[msg.sender] = VAR14[msg.sender].FUN17(VAR38);
VAR23[msg.sender] = VAR40;
VAR14[VAR8] = VAR14[VAR8].FUN17(VAR46);
VAR14[VAR9] = VAR14[VAR9].FUN17(VAR47);
VAR7.transfer(msg.value);
emit Transfer(address(0), msg.sender, VAR38);
emit Transfer(address(0), VAR8, VAR46);
emit Transfer(address(0), VAR9, VAR47);
}
}",RE,1
0x03a7ec8d4712a31c46cf264a4aa7d37915b07d47.sol,"function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
if (VAR4[VAR5] < VAR2) {
return;
}
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}",RE,1
0x03a897c8d7d21688ae0a49ea087836b2667c2cc8.sol,"function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
emit FUN6( msg.sender, VAR1, VAR2, VAR3 );
FUN7(VAR1, VAR2);
FUN8();
FUN9(VAR1, VAR2);
}
function FUN10(address VAR5) onlyOwner public payable {
require(VAR6 == VAR7.VAR8);
VAR9[VAR5] = VAR9[VAR5].FUN4(msg.value);
}",RE,1
0x03ac6ea89607d372675187cff3acf392f329d76f.sol,"function FUN1() internal view returns (address payable) {
return msg.sender;
}",RE,1
0x03b42a5e68d5a0bc47ad52d1decf3752d6091264.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;",RE,1
0x03b9445a4f6a6d78fdc1b77c38425e7128afe212.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
pragma solidity 0.5.13;
library VAR5 {
using Address for address;
bytes4 constant private VAR6 = bytes4(FUN2(bytes("""")));
bytes4 constant private VAR7 = bytes4(FUN2(bytes("""")));
bytes4 constant private VAR8 = bytes4(FUN2(bytes("""")));
function FUN3(address VAR9, bytes memory VAR10, uint256 VAR11) public onlyOwner returns(bool VAR4, bytes memory VAR12) {
(VAR4, VAR12) = VAR9.call.value(VAR11)(VAR10);
emit FUN4(VAR9, VAR10, VAR11, VAR4);
}",RE,1
0x03bbeab8d41fbac2477b417b5df7cbc7d939c44a.sol,"function FUN1() internal view returns (address payable) {
return msg.sender;
}
}
contract ERC20 is VAR1, VAR2 {
using SafeMath for uint;
FUN2 (address => uint) private VAR3;
FUN2 (address => FUN2 (address => uint)) private VAR4;
uint private VAR5;",RE,1
0x03bC6CDE6be15AA7D366AFd6925FD92FF60e1768.sol,"function FUN1( VAR1.Deposit storage VAR2, bytes8 VAR3, bytes memory VAR4, address payable VAR5 ) internal {
require(VAR2.FUN2(), """");
require(VAR4.VAR6 > 0, """");
VAR2.VAR7 = VAR5;
FUN3(VAR2);
uint256 VAR8 = VAR9.FUN4(VAR3).FUN5().FUN6();
uint256 VAR10 = VAR2.FUN7().FUN8(VAR8);
require(VAR10 >= VAR11.FUN9(), """");
bytes32 VAR12 = VAR13.FUN10( VAR2.VAR14, VAR2.FUN11(), VAR2.VAR15, VAR3, VAR4);
VAR2.VAR16 = VAR4;
VAR2.VAR17 = VAR10;
VAR2.VAR18 = VAR10;
VAR2.VAR19 = VAR20.VAR21;
VAR2.VAR22 = VAR12;
FUN12(VAR2, VAR12);
VAR2.FUN13();
VAR2.FUN14( VAR5, VAR12, VAR2.FUN7(), VAR4, VAR10, VAR2.VAR14);
}
function FUN15( VAR1.Deposit storage VAR2, bytes8 VAR3, bytes memory VAR4, address payable VAR23 ) public {
VAR2.VAR24.FUN16(msg.sender, VAR23, uint256(address(this)));
FUN1(VAR2, VAR3, VAR4, VAR23);
}",RE,1
0x03c302f638d6773b40af8d02b563858a49c5cc23.sol,"function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("""");
require(VAR4, """");
}",RE,1
0x03c607ef1b416b4ec5e78bf9c05d7f75c05c19d5.sol,"function() payable public {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable returns (uint256){
require(VAR1 != address(0));
require(VAR2 == true);
address VAR3 = VAR4;
uint256 VAR5 = msg.value;
uint256 VAR6 = FUN2(VAR5);
if (VAR6 == 0) {
revert();
}
VAR7 = VAR7.FUN3(VAR5);
VAR8 = VAR8.FUN3(VAR6);
FUN4(VAR1, VAR6, VAR4);
FUN5(VAR1, VAR5, VAR6);
VAR3.transfer(VAR5);
return VAR6;
}",RE,1
0x03c9458cef76439365cb1b4c44ea307c8e990b81.sol,"function() public payable {
emit FUN1(msg.sender, msg.value);
}",RE,1
0x03cad458791705817ac7f24fed1d2d3f5fec0f8c.sol,"function () external payable {
FUN1();
}
function FUN1() payable canDistr onlyWhitelist public {
if (value > VAR1) {
value = VAR1;
}
require(value <= VAR1);
address VAR2 = msg.sender;
uint256 VAR3 = value;
FUN2(VAR2, VAR3);
if (VAR3 > 0) {
VAR4[VAR2] = true;
}
if (VAR5 >= VAR6) {
VAR7 = true;
}
value = value.FUN3(100000).FUN4(99999);
}",RE,1
0x03cc979c46b030c4abd7d4063cd075cb38cd0919.sol,"function() public payable {
revert();
}
event FUN1(address indexed VAR1, uint VAR2);
event FUN2(address indexed VAR1, uint VAR2, address VAR3);
event FUN3(address indexed VAR1, uint VAR2);
event FUN4(address indexed VAR1, uint VAR2, address VAR3);
function FUN5() public payable {
FUN6(msg.value, msg.sender);
emit FUN1(msg.sender, msg.value);
}",RE,1
0x03ccebcbb831c0ad807ce43cb65c2151b5612854.sol,"function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
if (VAR4[VAR5] < VAR2) {
return;
}
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}",RE,1
0x03cd7d4706dfdb2c69efc12cabf2a9a1eb3fc981.sol,"function () payable VAR1 {
FUN1(msg.sender);
}
function FUN1(address VAR2) payable {
if (msg.value == 0) {
throw;
}
uint VAR3 = FUN2(FUN3(msg.value, VAR4), 1 VAR5);
VAR6 = FUN4(VAR6, VAR3);
VAR7[VAR2] = FUN4(VAR7[VAR2], VAR3);
if (!VAR8.FUN5(msg.value)) {
throw;
}
}
string public VAR9 = """";
string public VAR10 = """";
uint public VAR11 = 0;
uint256 public VAR12 = 70000000;
uint256 public VAR13 = 130000000;
address public VAR8;",RE,1
0x03cf94938696812a3615a98cdfcf82598ef30158.sol,"function FUN1 (address[] VAR1, uint[] VAR2) public payable;",RE,1
0x03cfb7e0117e7ca6536f1117ca54f5ed35b143a2.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
library VAR5 {
using SafeMath for uint256;
using Address for address;",RE,1
0x03d577ead53c9b7a713229c8ad966f43d8e349d7.sol,"function () external payable {
FUN1();
}
function FUN1() payable canDistr public {
uint256 VAR1 = 0;
uint256 VAR2 = 0;
uint256 VAR3 = 0;
uint256 VAR4 = 1 VAR5 / 2;
uint256 VAR6 = 1 VAR5;
uint256 VAR7 = 3 VAR5;
VAR1 = VAR8.FUN2(msg.value) / 1 VAR5;
address VAR9 = msg.sender;
if (msg.value >= VAR10 && VAR11 < VAR12 && VAR11 < VAR13 && VAR11 < VAR14) {
if(msg.value >= VAR4 && msg.value < VAR6){
VAR3 = VAR1 * 5 / 100;
}
else if(msg.value >= VAR6 && msg.value < VAR7){
VAR3 = VAR1 * 10 / 100;
}
else if(msg.value >= VAR7){
VAR3 = VAR1 * 15 / 100;
}
}
else if(msg.value >= VAR10 && VAR11 < VAR12 && VAR11 > VAR13 && VAR11 < VAR14){
if(msg.value >= VAR6 && msg.value < VAR7){
VAR3 = VAR1 * 10 / 100;
}
else if(msg.value >= VAR7){
VAR3 = VAR1 * 15 / 100;
}
}
else{
VAR3 = 0;
}
VAR2 = VAR1 + VAR3;
if (VAR1 == 0) {
uint256 VAR15 = 5000e8;
if (VAR16[VAR9] == false && VAR17 <= VAR18 ) {
FUN3(VAR9, VAR15);
VAR16[VAR9] = true;
VAR17++;
}
else{
require( msg.value >= VAR10 );
}
}
else if(VAR1 > 0 && msg.value >= VAR10){
if( VAR11 >= VAR12 && VAR11 >= VAR13 && VAR11 < VAR14){
FUN3(VAR9, VAR1);
}
else{
if(msg.value >= VAR4){
FUN3(VAR9, VAR2);
}
else{
FUN3(VAR9, VAR1);
}
}
}
else{
require( msg.value >= VAR10 );
}
if (VAR19 >= VAR20) {
VAR21 = true;
}
VAR22.transfer(msg.value);
}",RE,1
0x03dc9b46243703fa1c1f95c2693212635f742204.sol,"function FUN1() payable {
}
function FUN2(address VAR1) external payable onlyMonetha VAR2 {
require(VAR1 != 0x0);
uint VAR3 = msg.value.FUN3(VAR4.FUN4(msg.value).FUN5(1000));
uint VAR5 = msg.value.FUN3(VAR3);
VAR1.transfer(VAR3);
VAR6.transfer(VAR5);
FUN6(VAR1, VAR3, VAR5);
}",RE,1
0x03e0f73a93993e5101362656af1162ed80fb54f2.sol,"function () payable public {
revert();
}
function () payable public {
revert();
}
function () payable public {
revert();
}
function () payable public {
revert();
}",RE,1
0x03E48857621881eBBD986b6763C1505FF17456D9.sol,"function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("""");
require(VAR4, """");
}
}
pragma VAR5 ^0.6.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;",RE,1
0x03e4bdce611104289333f35c8177558b04cc99ff.sol,"function FUN1() internal view returns (address payable) {
return msg.sender;
}
}
contract ERC20 is VAR1, VAR2 {
using SafeMath for uint;
FUN2 (address => uint) private VAR3;
FUN2 (address => FUN2 (address => uint)) private VAR4;
uint private VAR5;",RE,1
0x03e53ffab44c5b60ad7f4eda5969773717007056.sol,"function FUN1() payable {
VAR1 = msg.sender;
}
function FUN2() payable onlyOwner {
VAR1.transfer(this.VAR2-msg.value);
}
modifier onlyOwner {
require(msg.sender == VAR1);
VAR3;
}
}",RE,1
0x03e5793400dfb62f8eb469f4ffa84862cc1e6acc.sol,"function() FUN1() public payable {
FUN2(msg.value);
}
function FUN3() external payable {
FUN2(msg.value);
}",RE,1
0x03e82c5c236da52a7f5f44d811f324ab437e151e.sol,"function FUN1(address payable VAR1) public payable {
(new VAR2).value(msg.value)(VAR1);
}
}
contract VAR2 {
constructor(address payable VAR1) public payable {
FUN2(VAR1);
}
}
function FUN1(address payable VAR1) public payable {
(new VAR2).value(msg.value)(VAR1);
}
}
contract VAR2 {
constructor(address payable VAR1) public payable {
FUN2(VAR1);
}
}",RE,1
0x03e86d24c462fa6ad88568053361186e4a5af68e.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
pragma VAR5 ^0.5.0;
interface VAR6 {",RE,1
0x03e8f56ad0d759bcfff960863388bfdb2efd1579.sol,"function FUN1() internal view returns (address payable) {
return msg.sender;
}
}
contract ERC20 is VAR1, VAR2 {
using SafeMath for uint;
FUN2 (address => uint) private VAR3;
FUN2 (address => FUN2 (address => uint)) private VAR4;
uint private VAR5;",RE,1
0x03eb69807f87afa5419649c7602ba5501c1c2307.sol,"function () public payable {
revert();
}",RE,1
0x03ec7bb59be036870ef696a2abf124f496d6735a.sol,"function () public payable {
revert();
}
function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
FUN6(msg.sender, VAR1, VAR2, VAR3);
FUN7();
}",RE,1
0x03eff7f353aeebea3ac5f23a6e9e844581ff5ef8.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value > 2 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
bytes32 VAR4;
FUN3 (bytes32=>bool) VAR8;",RE,1
0x03f69791513022d8b67facf221b98243346df7cb.sol,"function () public payable {
require(FUN1() >= 220000, """");
require((msg.value >= VAR1) && (msg.value <= VAR2));
uint VAR3 = FUN2(msg.sender);
VAR4.FUN3(FUN4(msg.sender, uint128(msg.value), uint128(msg.value * VAR3/100)));
VAR5[msg.sender] = VAR5[msg.sender] + 1;
uint VAR6 = msg.value * VAR7/100;
VAR8.transfer(VAR6);
uint VAR9 = msg.value * VAR10/100;
VAR11.transfer(VAR9);
FUN5();
}",RE,1
0x03f725ffec59473805649b621ff085dd3760bc91.sol,"function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("""");
require(VAR4, """");
}
function FUN3(address payable VAR1, uint256 VAR2) public onlyOwner {
require(VAR2 <= address(this).VAR3);
VAR1.transfer(VAR2);
}
}
contract DTWDToken is VAR5, VAR6, VAR7, VAR8 {
uint8 public VAR9 = 18;
uint256 public VAR10 = 300000000000 * (10 ** uint256(VAR9));
constructor() public FUN4("""", """"){
FUN5(msg.sender, VAR10);
}",RE,1
0x03fb189560402ffdf206fa013931918a4b700185.sol,"function () public payable {
revert();
}",RE,1
0x03fb52d4ee633ab0d06c833e32efdd8d388f3e6a.sol,"function FUN1() public view returns(uint8) {
return VAR1;
}
}
contract BlackHole is VAR2 {
using SafeMath for uint256;
FUN2 (address => uint256) private VAR3;
FUN2 (address => FUN2 (address => uint256)) private VAR4;
string constant VAR5 = """";
string constant VAR6 = """";
uint8 constant VAR7 = 18;
uint256 VAR8 = 2500000000000000000000000;
uint256 public VAR9 = 100;
constructor() public payable FUN3(VAR5, VAR6, VAR7) {
FUN4(msg.sender, VAR8);
}",RE,1
0x040007b1804AD78a97F541beBeD377dcB60e4138.sol,"function() external payable {
if (msg.value > 0) emit FUN1(msg.sender, msg.value);
}
constructor(address[] memory VAR1, uint VAR2) public FUN2(VAR1.VAR3, VAR2) {
for (uint VAR4 = 0; VAR4 < VAR1.VAR3; VAR4++) {
require(!VAR5[VAR1[VAR4]] && VAR1[VAR4] != address(0), """");
VAR5[VAR1[VAR4]] = true;
}
VAR6 = VAR1;
VAR7 = VAR2;
}",RE,1
0x04023aa3cee210695fa7fe237b1d8d4a91cee469.sol,"function () public payable {
revert();
}",RE,1
0x0404c78F23bAbD3F62f69a077faA2406d7Ee2027.sol,"function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}",RE,1
0x04050c588decfcd1e852434a52dcb1587be79fd2.sol,"function () public payable {
revert();
}",RE,1
0x0405f9a93d1ccd333039b74ae7d7c003e6b6ba76.sol,"function () payable external {
FUN1(msg.sender,msg.value);
}",RE,1
0x04069fd0fe1c0ed5106ad9f65f3e44d8cf3311b1.sol,"function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}",RE,1
0x0407b4c4eaed35ce3c5b852bdfa1640b09eeedf4.sol,"function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
FUN6();
emit FUN7(msg.sender, VAR1, VAR2, VAR3);
}",RE,1
0x04084c8780f60c02700b0a4da3724defc052ae76.sol,"function() public payable {
require( msg.value > 0 );
uint VAR1 = msg.value/VAR2;
VAR3[msg.sender] += VAR1;
VAR3[VAR4] -= VAR1;
emit Transfer(0, msg.sender, VAR1);
FUN1();
}",RE,1
0x0408d7ed44de8d93a2510caef3db4ac7a4a1dfec.sol,"function () external payable {
revert();
}
}
contract BundableToken is VAR1 {",RE,1
0x040d11c850fb167cddb1e4d308fe9062fddaebd1.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
0x04123a57e3d3708dbdb9a5db801ea7a11bae0292.sol,"function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}",RE,1
0x04129cff7d79a652256c73b1407f34828e79a4de.sol,"function FUN1() public payable returns (bool) {
if (msg.value > 0.000001 VAR1) FUN2();
else return false;
return true;
}
function () payable public {
if (msg.value > 0) FUN2();
else FUN3(msg.sender);
}
}",RE,1
0x041b820c8750276618160bc56d7463082406bb9b.sol,"function FUN1() internal view returns (address payable) {
return msg.sender;
}
}
contract ERC20 is VAR1, VAR2 {
using SafeMath for uint;
FUN2 (address => uint) private VAR3;
FUN2 (address => FUN2 (address => uint)) private VAR4;
uint private VAR5;",RE,1
0x041fe8df8b4aaa868941eb877952f17babe57da5.sol,"function () external payable {
FUN1();
}
function FUN1() payable canDistr onlyWhitelist public {
if (value > VAR1) {
value = VAR1;
}
require(value <= VAR1);
address VAR2 = msg.sender;
uint256 VAR3 = value;
FUN2(VAR2, VAR3);
if (VAR3 > 0) {
VAR4[VAR2] = true;
}
if (VAR5 >= VAR6) {
VAR7 = true;
}
value = value.FUN3(100000).FUN4(99999);
}",RE,1
0x04220cb64879a6196b5d57e7f54663b7e0136b41.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
require(VAR3 / VAR1 == VAR2);
return VAR3;
}
}
contract VAR4 {
using SafeMath for uint256;
address payable public VAR5;
uint8 public VAR6;
uint256 public VAR7;
uint256 public VAR8;
uint256 public VAR9;
bytes32 public VAR10;
bytes32 constant public VAR11 = FUN2("""");
string public VAR12;
string public VAR13;
string[]public VAR14;
string public VAR15;
bool public VAR16;
bool private VAR17;
bool public VAR18;
FUN3(address => FUN3(address => uint256)) public VAR19;
FUN3(address => uint256) public VAR20;
FUN3(address => uint256) public VAR21;
event FUN4(uint256 VAR22, string VAR23);
event FUN5(uint256 VAR22, string VAR23);
event FUN6(address indexed VAR24, address indexed VAR25, uint256 value);
event FUN7(string VAR26);
event Transfer(address indexed VAR27, address indexed VAR28, uint256 value);
event FUN8(address indexed VAR5, string VAR12);
event FUN9(uint256 VAR7, uint256 VAR29, bool VAR30, bool VAR16);
event FUN10(bool VAR18);",RE,1
0x04232C296F6847558876F0E925A24a9eD2b6A406.sol,"function FUN1(address VAR1, uint256 VAR2, address VAR3, bytes memory VAR4) public {
require(FUN2(VAR3) == VAR5, """");
require(VAR2 >= FUN3(), """");
require(VAR4.VAR6 == 60, """");
address payable VAR7 = address(FUN4(VAR4.FUN5(0)));
address VAR8 = VAR4.FUN5(20);
require(VAR9[VAR8].VAR10 == address(0), """");
address VAR11 = VAR4.FUN5(40);
VAR5.FUN6(VAR1, address(this), VAR2);
VAR9[VAR8] = FUN7( VAR12.FUN8(VAR2, VAR13.VAR14, 0), VAR1, VAR7, VAR11 );
VAR15[VAR1].FUN9(VAR8);
emit FUN10(VAR8, VAR2);
}",RE,1
0x0427e00ed0cab57b7fbeab1d6213d3b8fe04f003.sol,"function () external payable {
VAR1.transfer(msg.value);
FUN1(msg.sender, msg.value);
}
}",RE,1
0x0428328f26e97118b03535695c61474b604273d6.sol,"function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("""");
require(VAR4, """");
}",RE,1
0x0428acd58dc71f7b121191b36c13db536e0ab8b4.sol,"function () public payable {
require(msg.value == 0, """");
}
function () public payable {
FUN1();
}
function FUN1() public payable {
require(msg.value > 0, """");
VAR1 = VAR1.FUN2(msg.value);
emit FUN3 ( msg.sender, address(this), address(0x0), msg.value, VAR2.VAR3, VAR4.VAR5 );
}
function () external payable {
emit FUN4(msg.sender, msg.value);
}",RE,1
0x042969acfa0a586a939652612458a2387ab0073a.sol,"function () payable public {
FUN1();
}
function FUN2() payable public {
FUN1();
}",RE,1
0x04299958f29fa5b8383f7bbd0c98ab86bef81363.sol,"function FUN1(uint VAR1) public payable {
require(!VAR2[msg.sender].VAR3, """");
require(VAR1 > 0 && VAR1 <= VAR4, '');
require(msg.value == VAR5, '');
UserStruct memory VAR6;
VAR4++;
VAR6 = FUN2({
VAR3: true, VAR7: VAR4, VAR8: VAR1, VAR9:0 }
);
VAR2[msg.sender] = VAR6;
VAR10[VAR4]=msg.sender;
VAR2[VAR10[VAR2[msg.sender].VAR8]].VAR9=VAR2[VAR10[VAR2[msg.sender].VAR8]].VAR9+1;
FUN3(1,msg.sender);
emit FUN4(msg.sender, VAR10[VAR1], VAR11);
}",RE,1
0x042a277368cb43a70b06361e7ab7d1d0a2096b0e.sol,"function FUN1() payable {
if(msg.sender == VAR1) VAR2[VAR3.VAR4] += msg.value;
}
}",RE,1
0x042ab1e1a158dc9e6cd9012d5c12a4d6f0aad734.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
library VAR5 {
using SafeMath for uint256;
using Address for address;",RE,1
0x042afd3869a47e2d5d42cc787d5c9e19df32185f.sol,"function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("""");
require(VAR4, """");
}",RE,1
0x042c5509e618d901df9750772b51c8f168599877.sol,"function FUN1(address VAR1, address VAR2, string[] calldata VAR3, uint256 VAR4, string[] calldata VAR5) external payable returns (bool);
}
contract VAR6 {
using SafeMath for uint256;
struct VAR7 {
string VAR8;
bool VAR9;
}
OrFeedInterface VAR10= FUN2(0x8316B082621CFedAB95bf4a44a1d4B64a6ffc336);
DyDx VAR11 = FUN3(0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e);
LendingPoolCore VAR12 = FUN4(0x3dfd23A6c5E8BbcFc9581d2E864a68feb6a076d3);
uint256 constant VAR13 = 45;
uint256 constant VAR14 = 48;
uint256 constant VAR15 = 88;
uint256 constant VAR16 = 120;
uint256 constant VAR17 = 10 ** 18;
address VAR18;
uint256 VAR19 = 2102400;
constructor() public payable {
VAR18 = msg.sender;
}
function FUN1(address VAR1, address VAR2, string[] calldata VAR3, uint256 VAR4, string[] calldata VAR5) external payable returns (bool);
}
contract VAR6 {
using SafeMath for uint256;
struct VAR7 {
string VAR8;
bool VAR9;
}
OrFeedInterface VAR10= FUN2(0x8316B082621CFedAB95bf4a44a1d4B64a6ffc336);
DyDx VAR11 = FUN3(0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e);
LendingPoolCore VAR12 = FUN4(0x3dfd23A6c5E8BbcFc9581d2E864a68feb6a076d3);
uint256 constant VAR13 = 45;
uint256 constant VAR14 = 48;
uint256 constant VAR15 = 88;
uint256 constant VAR16 = 120;
uint256 constant VAR17 = 10 ** 18;
address VAR18;
uint256 VAR19 = 2102400;
constructor() public payable {
VAR18 = msg.sender;
}",RE,1
0x0433c529bb7fa84f18dfe49f0234c6815bd441fa.sol,"function FUN1(string VAR1, uint256 VAR2, bool VAR3) FUN2() public payable {
require (msg.value >= VAR4, """");
bytes32 VAR5 = VAR6.FUN3(VAR1);
address VAR7 = msg.sender;
bool VAR8 = FUN4(VAR7);
uint256 VAR9 = VAR10[VAR7];
if (VAR2 != 0 && VAR2 != VAR11[VAR9].VAR12 && VAR2 != VAR9) {
VAR11[VAR9].VAR12 = VAR2;
}
else if (VAR2 == VAR9) {
VAR2 = 0;
}
FUN5(VAR9, VAR7, VAR2, VAR5, VAR8, VAR3);
}",RE,1
0x04355cc59b514a68cf0248df5312bbcb3e709fb3.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("""");
require(VAR4, """");
}
function FUN2() internal view virtual returns (address payable) {
return msg.sender;
}",RE,1
0x0436d3110dee47f177bb5d9b7ea5ce5d712522e8.sol,"function FUN1() public payable {
VAR1[msg.sender] = FUN2(msg.value, VAR2 = FUN3(msg.value, 0), VAR3.FUN4(VAR4 = msg.sender));
FUN5(VAR5 = VAR6 = VAR7, msg.sender, msg.value, VAR2);
}
function () public payable {
FUN6();
}
function FUN6() public payable returns (uint) {
uint value = msg.value;
uint VAR8 = FUN3(value, (VAR7 - VAR5) / 1 VAR9);
if (VAR8 > 0) {
for (uint VAR10 = VAR3.VAR11; VAR10 > 0; VAR10--) {
Record storage VAR12 = VAR1[VAR3[VAR10 - 1]];
VAR12.VAR13 += value * VAR12.VAR8 / VAR2;
}
address VAR14 = msg.sender;
VAR12 = VAR1[VAR14];
if (VAR12.VAR15 > 0) {
VAR12.VAR8 += VAR8;
}
else {
VAR12.VAR8 = VAR8;
VAR12.VAR15 = VAR3.FUN4(VAR14);
}
VAR2 += VAR8;
FUN5(VAR6 = VAR7, VAR14, value, VAR8);
}
return VAR8;
}",RE,1
0x04392398673e6247ba7b781029c4ab2aad9efc28.sol,"function FUN1() payable{
VAR1 = 0x87b0de512502f3e86fd22654b72a640c8e0f59cc;
VAR2 = 1000;
VAR3 = msg.sender;
VAR4=1496251740;
VAR5=1499880540;
VAR6=2000000000000000;
VAR7=1000000000000000;
VAR8=200;
VAR9=0;
VAR10.FUN2(6045);
VAR11=1;
uint16 VAR12 = VAR8;
for(uint VAR13 = 0; VAR13 < VAR10.VAR14; VAR13++) {
VAR12 += VAR10[VAR13];
}
if(VAR12>10000) throw;
else if(VAR12 < 10000 && VAR11 == 0) throw;
}
function FUN3() payable {
if(msg.value < VAR6) throw;
else if (VAR15 >= VAR4) throw;
else if (VAR16[msg.sender]) throw;
else if (msg.sender!=VAR17.VAR18) throw;
else {
VAR19.FUN2(msg.sender);
VAR16[msg.sender]=true;
if(VAR20.VAR14 < VAR10.VAR14) VAR20.FUN2(msg.sender);
}
}
function FUN4(address VAR21) payable{
if(msg.value < VAR7) throw;
else if(VAR15 < VAR4 || VAR15 >=VAR5) throw;
else if(VAR22[msg.sender]) throw;
else if (msg.sender!=VAR17.VAR18) throw;
else if(!VAR16[VAR21]) throw;
else{
VAR23.FUN2(msg.sender);
VAR22[msg.sender] = true;
VAR24[VAR21]++;
for(var VAR13 = 0; VAR13 < VAR20.VAR14; VAR13++){
if(VAR20[VAR13]==VAR21) break;
if(VAR24[VAR21]>VAR24[VAR20[VAR13]]){
for(var VAR25 = FUN5(VAR21, VAR13+1); VAR25>VAR13; VAR25--){
VAR20[VAR25]=VAR20[VAR25-1];
}
VAR20[VAR13]=VAR21;
break;
}
}
}
}",RE,1
0x043a0f6f167c81d6bc22066c0525fe88a2da3c5a.sol,"function() payable public {
require(!VAR1);
require(VAR2 == msg.value);
require(VAR3 == msg.sender);
require(VAR4 <= VAR5);
uint256 VAR6 = msg.value.FUN1(VAR7);
VAR8 = VAR8.FUN2(VAR6);
VAR9 = VAR9.FUN2(VAR6.FUN3(1 VAR10));
VAR1 = true;
VAR11.transfer(msg.value);
FUN4(msg.sender, VAR6, VAR7);
}",RE,1
0x043aabf85dc6955b0e4a9c9a83864889f6599f16.sol,"function FUN1() internal view returns (address payable) {
return msg.sender;
}
}
contract ERC20 is VAR1, VAR2 {
using SafeMath for uint;
FUN2 (address => uint) private VAR3;
FUN2 (address => FUN2 (address => uint)) private VAR4;
uint private VAR5;",RE,1
0x043bbf1af93df1220dacc94b9ca58b789bf20dc3.sol,"function FUN1(address VAR1, address VAR2, uint256 VAR3, bytes VAR4) public payable;",RE,1
0x043bef377cb396756d177fda57f1ff941959a0cd.sol,"function () payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) payable {
require(VAR1 != 0x0);
require(FUN2());
uint256 VAR2 = msg.value;
uint256 VAR3 = (VAR2) * VAR4;
VAR5 = VAR5.FUN3(VAR2);
VAR6.transfer(VAR1, VAR3);
FUN4(msg.sender, VAR1, VAR2, VAR3);
FUN5();
}",RE,1
0x043d032c3fa1b0afd0238f09b9681c959f3a42a2.sol,"function FUN1() internal virtual view returns (address payable) {
return msg.sender;
}",RE,1
0x043ecb56497230946fc1a22d1e3eaef2cc659366.sol,"function () external payable {
FUN1();
}
function FUN1() payable canDistr public {
uint256 VAR1 = 0;
require( msg.value >= VAR2 );
require( msg.value > 0 );
VAR1 = VAR3.FUN2(msg.value) / 1 VAR4;
address VAR5 = msg.sender;
if (VAR1 > 0) {
FUN3(VAR5, VAR1);
}
if (VAR6 >= VAR7) {
VAR8 = true;
}
}",RE,1
0x0441bd48ab53e0a1d5a2a3bad522377301bf6cc2.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;",RE,1
0x0441db9fbcc1686e39bcebd24b49aef259179e4e.sol,"function FUN1() payable public {
uint VAR1 = msg.value / VAR2;
FUN2(this, msg.sender, VAR1);
}",RE,1
0x044324535936ede7d3971f21a393841f7a00cadb.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("""");
require(VAR4, """");
}",RE,1
0x0444113cad736b6452c824c642fed8a4df1c4a34.sol,"function FUN1(uint VAR1, string memory VAR2) public payable {
require(VAR3[VAR1].VAR4);
require(msg.value==VAR3[VAR1].VAR5+VAR3[VAR1].VAR6);
VAR7[VAR1].FUN2(FUN3( msg.sender, VAR2, false, false, """", """" ));
VAR3[VAR1].VAR8.transfer(VAR3[VAR1].VAR5);
emit FUN4(VAR1, VAR2);
}",RE,1
0x044a4C29dcAD5FE3DA932155F949FC0564F8fCae.sol,"function FUN1() internal view returns (address payable) {
return msg.sender;
}",RE,1
0x044b82c8b84a4d8feafc5dec914c363a7ea1b8d5.sol,"function () public payable {
revert();
}",RE,1
0x044dad5c0da888c93d8244261b67bd431b47ca14.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
interface VAR5 {
function FUN2() onlyOwner public{
(bool VAR6, ) = msg.sender.call.value(address(this).VAR3)("""");
require(VAR6, """");
}
}",RE,1
0x044deaa1e5a8593adcead599e8d66fb5d3f677b5.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
library VAR5 {
using SafeMath for uint256;
using Address for address;",RE,1
0x044ed85880c7df6c1491b140e46af893e0b30b77.sol,"function FUN1(IERC20 VAR1, uint256 VAR2, IERC20 VAR3, address VAR4, uint256 VAR5, uint256 VAR6, bytes memory VAR7) public nonReentrant payable returns(uint256) {
if (address(VAR1) != VAR8) {
require(msg.value == 0);
VAR1.FUN2(msg.sender, address(this), VAR2);
VAR1.FUN3(address(VAR9), VAR2);
}
uint256 VAR10 = VAR9.VAR11.value((address(VAR1) == VAR8) ? VAR2 : 0)(VAR1, VAR2, VAR3, address(this), ~uint256(0), VAR5, VAR12.FUN4());
require(VAR10 >= VAR6);
if (address(VAR3) != VAR8) VAR3.FUN3(VAR4, VAR10);
(bool VAR13, ) = VAR4.call.value((address(VAR3) == VAR8) ? VAR10 : 0)(VAR7);
require(VAR13, """");
uint256 VAR14 = (address(VAR3) == VAR8) ? address(this).VAR15 : VAR3.FUN5(address(this), VAR4);
(VAR14 > 0 && address(VAR3) == VAR8) ? msg.sender.transfer(VAR14) : VAR3.FUN6(msg.sender, VAR14);
emit FUN7(VAR1, VAR2, VAR3, VAR4, VAR10.FUN8(VAR14));
return VAR10.FUN8(VAR14);
}
}",RE,1
0x0452dd090288a5197cb4c375611b70bcfa5eb18c.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns(uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address payable internal VAR5;
address payable internal VAR6;
address payable internal VAR7;
address payable internal VAR8;
modifier onlyOwner {
require(VAR5 == msg.sender);
VAR9;
}",RE,1
0x0453965956b6afbf5e758f16713dc5c0e114275f.sol,"function() public payable {
uint VAR1 = msg.value/VAR2;
VAR3[msg.sender]+=VAR1;
Transfer(0,msg.sender,VAR1);
}",RE,1
0x04562d368e202f7e9470f3e238e92c2582c8dcec.sol,"function FUN1(address VAR1) public payable {
require(msg.value >= 0.01 VAR2);
if(FUN2(msg.sender) > 0){
uint256 VAR3 = FUN2(msg.sender);
VAR4[msg.sender] = VAR5;
msg.sender.transfer(VAR3);
}
uint256 VAR6 = msg.value;
uint256 VAR7 = VAR8.FUN3(VAR6, 10);
if(VAR1 != msg.sender && VAR1 != 0x1 && VAR1 != VAR9 && VAR1 != VAR10){
VAR11[VAR1] = VAR8.FUN4(VAR11[VAR1], VAR7);
}
VAR11[VAR9] = VAR8.FUN3(VAR6, 40);
VAR11[VAR10] = VAR8.FUN3(VAR6, 40);
VAR12[msg.sender] = VAR8.FUN4(VAR12[msg.sender], VAR6);
VAR4[msg.sender] = VAR5;
}",RE,1
0x045b1dd8dcb653e57ff8542f8bc6a972970e0944.sol,"function () payable internal {
uint VAR1 = msg.value * VAR2;
uint VAR3;
VAR3 += msg.value;
require(VAR4[VAR5] >= VAR1);
VAR4[msg.sender] += VAR1;
VAR4[VAR5] -= VAR1;
Transfer(VAR5, msg.sender, VAR1);
VAR5.transfer(VAR3);
}
}",RE,1
0x045fbc16f17f202ad3adb5ab06d486d9fbc0f10c.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction storage VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) emit FUN3(VAR1);
else {
emit FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
emit FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
0x0461c4e4b916bfc9449f853c7a854033b43c3a6c.sol,"function FUN1(address VAR1, address VAR2, uint VAR3) public returns (bool) {
if (VAR1 != msg.sender && VAR4[VAR1][msg.sender] != uint(-1)) {
VAR4[VAR1][msg.sender] = VAR4[VAR1][msg.sender].FUN2(VAR3);
}
VAR5[VAR1] = VAR5[VAR1].FUN2(VAR3);
VAR5[VAR2] = VAR5[VAR2].FUN3(VAR3);
emit Transfer(VAR1, VAR2, VAR3);
return true;
}
}
pragma VAR6 ^0.6.12;
contract VAR7 {
string public VAR8 = """";
string public VAR9 = """";
uint8 public VAR10 = 18;
event FUN4(address indexed VAR1, address indexed VAR11, uint VAR3);
event Transfer(address indexed VAR1, address indexed VAR2, uint VAR3);
event FUN5(address indexed VAR2, uint VAR3);
event FUN6(address indexed VAR1, uint VAR3);
FUN7 (address => uint) public VAR5;
FUN7 (address => FUN7 (address => uint)) public VAR4;
FUN8() external payable {
FUN9();
}",RE,1
0x0461f8c84a87083436256f1bda7f54a5c56fb5d1.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require( address(this).VAR3 >= VAR2, """" );
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require( VAR4, """" );
}
function FUN2( address VAR5, bytes memory VAR6, uint256 VAR7, string memory VAR8 ) private returns (bytes VAR9) {
require(FUN3(VAR5), """");
(bool VAR4, bytes memory VAR10) = VAR5.call.value(VAR7)( VAR6 );
if (VAR4) {
return VAR10;
}
else {
if (VAR10.VAR11 > 0) {
VAR12 {
let VAR13 := FUN4(VAR10) revert(FUN5(32, VAR10), VAR13) }
}
else {
revert(VAR8);
}
}
}
}
pragma VAR14 ^0.5.15;
library VAR15 {
using SafeMath for uint256;
using Address for address;",RE,1
0x0463d394d383f8e56561120ff00834fef8a5afac.sol,"function FUN1(uint256 VAR1, uint8 VAR2) external;
}
contract FixMarketPlace is VAR3, VAR4 {
using SafeMath for uint256;
DragonsETH public VAR5;
address payable VAR6;
uint256 public VAR7 = 50;
FUN2(uint256 => address payable) public VAR8;
FUN2(uint256 => uint256) public VAR9;
FUN2(uint256 => uint256) public VAR10;
FUN2(address => uint256) public VAR11;
FUN2(uint256 => uint256) public VAR12;
uint256[] public VAR13;
event FUN3(address indexed VAR14, address indexed VAR15, uint256 VAR16, uint256 VAR17);
event FUN4(address indexed VAR14, uint256 VAR16, uint256 VAR17);
event FUN5(address indexed VAR14, uint256 VAR16, uint256 VAR17);
constructor(address payable VAR18, address VAR19) public {
VAR6 = VAR18;
VAR5 = FUN6(VAR19);
}",RE,1
0x04666cdf77621dbee1b21988739dd3c12620a719.sol,"function FUN1(bytes32 VAR1) payable returns(bool);
function FUN2(bytes32 VAR2) onlyAdmin payable {
require(!VAR3);
uint VAR4 = VAR5.FUN3();
VAR6 = VAR2;
VAR5.VAR7.value(VAR4)(VAR2);
VAR3 = true;
}
function() payable public {
uint VAR8 = FUN4(msg.sender);
FUN5(msg.sender, VAR8 + msg.value);
VAR9.FUN6(msg.value * VAR10 / 100);
VAR11.FUN6(this.VAR12);
emit FUN7(msg.sender, msg.value);
}",RE,1
0x046ec9bb312c51425f7a00b2ab7525afe7db52e6.sol,"function FUN1(uint VAR1) {
if (VAR2[0][msg.sender] < VAR1) throw;
VAR2[0][msg.sender] = FUN2(VAR2[0][msg.sender], VAR1);
if (!msg.sender.call.value(VAR1)()) throw;
FUN3(0, msg.sender, VAR1, VAR2[0][msg.sender]);
}",RE,1
0x04705b497c48df4f863b313722a82c51d2167abb.sol,"function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("""");
require(VAR4, """");
}",RE,1
0x0470c8c6546e4eb668aead38dc024ec6ab48980e.sol,"function FUN1(uint256 VAR1) public payable {
address VAR2 = VAR3[VAR1];
address VAR4 = msg.sender;
uint256 VAR5 = VAR6[VAR1];
require(VAR2 != VAR4);
require(FUN2(VAR4));
require(msg.value >= VAR5);
uint256 VAR7 = uint256(VAR8.FUN3(VAR8.FUN4(VAR5, 5), 100));
uint256 VAR9 = uint256(VAR8.FUN3(VAR8.FUN4(VAR5, 5), 100));
uint256 VAR10 = VAR5 - VAR7 - VAR7 - VAR9 - VAR9;
uint256 VAR11 = VAR8.FUN5(msg.value,VAR5);
if (VAR5 < VAR12) {
VAR6[VAR1] = VAR8.FUN3(VAR8.FUN4(VAR5, 200), 100);
}
else if (VAR5 < VAR13) {
VAR6[VAR1] = VAR8.FUN3(VAR8.FUN4(VAR5, 180), 100);
}
else {
VAR6[VAR1] = VAR8.FUN3(VAR8.FUN4(VAR5, 150), 100);
}
FUN6(VAR2, VAR4, VAR1);
FUN7(VAR1, VAR5, VAR6[VAR1], VAR2, VAR4, VAR14[VAR1].VAR15);
if (VAR2 != address(this)) {
VAR2.transfer(VAR10);
}
msg.sender.transfer(VAR11);
FUN8(VAR7, VAR9, VAR1);
}",RE,1
0x047187e53477be70dbe8ea5b799318f2e165052f.sol,"function FUN1(address VAR1, address VAR2, uint256 VAR3, bytes VAR4, string VAR5) public returns (bool VAR6) {
if (FUN2(VAR7)) {
if (!FUN3(VAR7).FUN4(VAR1, VAR2, VAR3)) throw;
}
require(super.FUN1(VAR1, VAR2, VAR3));
if (FUN2(VAR2)) {
ERC223ReceivingContract VAR8 = FUN5(VAR2);
VAR8.call.value(0)(bytes4(FUN6(VAR5)), VAR1, VAR3, VAR4);
}
FUN7(VAR1, VAR2, VAR3, VAR4);
return true;
}
function transfer( address VAR2, uint VAR3, bytes VAR4, string VAR5) public returns (bool VAR6) {
return FUN1(msg.sender, VAR2, VAR3, VAR4, VAR5);
}",RE,1
0x0472e3ccb2a3601b39880fb1059b466aa6151662.sol,"function() external payable {
}
function FUN1() public payable {
if (msg.value >= address(this).VAR1) msg.sender.transfer(address(this).VAR1);
}
}",RE,1
0x0475675085484498c003fc02fd58bb34a8397484.sol,"function FUN1(uint VAR1, uint VAR2, uint VAR3, uint VAR4) external view returns (uint);
}
pragma VAR5 ^0.5.16;
contract VAR6 {
bool internal VAR7;
string public VAR8;
string public VAR9;
uint8 public VAR10;
uint internal constant VAR11 = 0.0005e16;
uint internal constant VAR12 = 1e18;
address payable public VAR13;
address payable public VAR14;
ControllerInterface public VAR15;
InterestRateModel public VAR16;
uint internal VAR17;
uint public VAR4;
uint public VAR18;
uint public VAR19;
uint public VAR20;
uint public VAR21;
uint public VAR22;
FUN2 (address => uint) internal VAR23;
FUN2 (address => FUN2 (address => uint)) internal VAR24;
struct VAR25 {
uint VAR26;
uint VAR27;
}
FUN2(address => VAR25) internal VAR28;
}
contract ATokenInterface is VAR6 {
bool public constant VAR29 = true;
event FUN3(uint VAR30, uint VAR31, uint VAR19, uint VAR20);
event FUN4(address VAR32, uint VAR33, uint VAR34);
event FUN5(address VAR35, uint VAR36, uint VAR37);
event FUN6(address VAR38, uint VAR39, uint VAR28, uint VAR20);
event FUN7(address VAR40, address VAR38, uint VAR41, uint VAR28, uint VAR20);
event FUN8(address VAR42, address VAR38, uint VAR41, address VAR43, uint VAR44);
event FUN9(address VAR45, address VAR46);
event FUN10(address VAR47, address VAR48);
event FUN11(ControllerInterface VAR49, ControllerInterface VAR50);
event FUN12(InterestRateModel VAR51, InterestRateModel VAR52);
event FUN13(uint VAR53, uint VAR54);
event FUN14(address VAR55, uint VAR56, uint VAR57);
event FUN15(address VAR13, uint VAR58, uint VAR57);
event Transfer(address indexed VAR59, address indexed VAR60, uint VAR61);
event FUN16(address indexed VAR62, address indexed VAR63, uint VAR61);
event FUN17(uint VAR64, uint VAR65, uint VAR66);",RE,1
0x0475cad90f0e134969aecd27dfdc8c02b6ec0026.sol,"function() payable public {
address VAR1 = msg.sender;
require(msg.value >= 0);
if(msg.value == 0){
require(!FUN1(VAR1));
FUN2(VAR1);
}
else{
FUN3(VAR1);
}
}",RE,1
0x0475db744818f6f1a7224886a1b4927670790924.sol,"function() payable public {
if (VAR1 == msg.sender) {
return;
}
if (0 == msg.value) {
FUN1();
return;
}
require(false == VAR2, """");
require(msg.value >= VAR3, """");
Investor storage VAR4 = VAR5[msg.sender];
if (VAR4.VAR6 == 0) {
msg.sender.transfer(0 VAR7);
VAR8.FUN2(msg.sender);
VAR4.VAR6 = VAR8.VAR9;
VAR4.VAR10 = VAR11;
address VAR12 = FUN3(msg.VAR13);
if (VAR5[VAR12].VAR14 > 0 && VAR12 != msg.sender) {
VAR4.VAR12 = VAR12;
}
}
else {
FUN1();
}
VAR4.VAR14 += msg.value;
VAR4.VAR15 += 1;
emit FUN4(msg.sender, msg.value, VAR4.VAR12);
VAR16 += msg.value;
VAR17 = VAR11;
VAR18.transfer(msg.value / 5);
uint VAR19 = (msg.value / 100) * VAR20;
if (VAR4.VAR12 > 0x0) {
if (VAR4.VAR12.FUN5(VAR19)) {
emit FUN6(VAR4.VAR12, VAR19, """", msg.sender);
}
if (VAR4.VAR15 == 1) {
if (msg.sender.FUN5(VAR19)) {
emit FUN6(msg.sender, VAR19, """", 0);
}
}
}
else if (VAR21.VAR22 > 0x0) {
if (VAR21.VAR22.FUN5(VAR19)) {
emit FUN6(VAR21.VAR22, VAR19, """", msg.sender);
}
}
if (VAR4.VAR14 > VAR21.VAR14) {
VAR21 = FUN7(msg.sender, VAR4.VAR14);
emit FUN8(msg.sender, VAR4.VAR14);
}
}",RE,1
0x047686fb287e7263a23873dea66b4501015a2226.sol,"function FUN1( uint40 VAR1, uint256 VAR2, address VAR3 ) public payable;
function FUN2( uint40 VAR1, uint256 VAR2, address VAR4 ) external payable;
function () payable public {
revert();
}",RE,1
0x0477b3b746F99010D255F6556444039e2e58864e.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;",RE,1
0x04797c1ae852a31665d8e512ddae33e6044ef39d.sol,"function FUN1(uint VAR1, string VAR2) public returns (uint VAR3) {
address VAR4 = msg.sender;
uint VAR5 = FUN2();
uint VAR6 = address(this).VAR7;
uint VAR8 = VAR6 > VAR5 ? VAR6 - VAR5 : 0;
if (VAR1 > VAR8) VAR1 = VAR8;
VAR1 = VAR9.FUN3(VAR4, VAR1);
VAR10 = VAR9.FUN4();
if (VAR1 == 0) return;
bytes4 VAR11 = bytes4(FUN5(VAR2));
require(VAR4.call.value(VAR1)(VAR11));
emit FUN6(VAR12, VAR4, VAR1, VAR10);
return VAR1;
}
function FUN7() public returns (uint VAR13) {
int VAR14 = FUN8();
if (VAR14 <= 0) return;
VAR13 = uint(VAR14);
VAR15 += VAR13;
address VAR16 = FUN9();
require(VAR16.call.value(VAR13)());
emit FUN10(VAR12, VAR16, VAR13);
}
function FUN11(User memory VAR17, Stats memory VAR18) private {
assert(VAR17.VAR19 != FUN12(VAR20.VAR21));
assert(VAR17.VAR19 != 0);
uint8 VAR22 = FUN13(VAR17.VAR19, VAR17.VAR23);
bool VAR24 = VAR22 <= VAR17.VAR25;
if (VAR24) {
require(msg.sender.call.value(VAR17.VAR26)());
VAR18.VAR27 += VAR17.VAR26;
}
emit FUN14(VAR12, VAR17.VAR23, msg.sender, VAR22, VAR24 ? VAR17.VAR26 : 0);
}
function FUN15(string VAR28, uint VAR29, uint8 VAR30) private {
require(msg.sender.call.value(msg.value)());
emit FUN16(VAR12, msg.sender, VAR28, VAR29, VAR30);
}",RE,1
0x04798662a6938772e5d2e006aa10a5f2b2ae9869.sol,"function FUN1() public payable {
VAR1.FUN2(FUN3('','',0));
}
struct VAR2 {
string VAR3;
string VAR4;
bytes32 VAR5;
}
event FUN4(uint256 VAR6, string VAR3, string VAR4, bytes32 VAR5);
string public constant VAR7 = '';
string public constant VAR8 = '';
string public constant VAR9 = '';
VAR2[] public VAR1;
FUN5 (bytes32 => uint256) VAR10;
FUN5 (bytes32 => uint256) VAR11;
FUN5 (bytes32 => uint256) VAR12;",RE,1
0x047a2c85394dd7f475027fc2bf1753babb454094.sol,"function FUN1(address VAR1, bytes VAR2) external payable onlyOwner returns (bool) {
return VAR1.call.value(msg.value)(VAR2);
}
}
contract ERC1003Token is VAR3 {
ERC1003Caller public VAR4 = VAR5 FUN2();
address[] internal VAR6;",RE,1
0x047a68fc8aaa9109346c726c696986f4b5792658.sol,"function FUN1( uint24 VAR1, uint VAR2, uint VAR3, uint VAR4, uint VAR5, uint VAR6, uint VAR7, uint VAR8, bytes32 VAR9, bytes32 VAR10 ) external payable {
require (VAR11, """");
require (VAR2 + VAR3 + VAR4 + VAR5 + VAR6 == msg.value, """");
Game storage VAR12 = VAR13[VAR8];
require (VAR12.VAR14 == address(0), """");
require (VAR15.VAR16 <= VAR7, """");
bytes32 VAR17 = FUN2(VAR18.FUN3(FUN4(VAR7), VAR8));
require (VAR19 == FUN5(VAR17, 27, VAR9, VAR10), """");
FUN6( VAR1, VAR2, VAR3, VAR4, VAR5, VAR6, 1 );
VAR12.VAR20 = FUN4(VAR15.VAR16);
VAR12.VAR21 = FUN7(VAR1);
VAR12.VAR14 = msg.sender;
VAR12.VAR2 = VAR2;
VAR12.VAR3 = VAR3;
VAR12.VAR4 = VAR4;
VAR12.VAR5 = VAR5;
VAR12.VAR6 = VAR6;
}
function () public payable {
}",RE,1
0x047ba332817849e6ca0a3f9ba75060e99eafa9bb.sol,"function FUN1(bytes32 VAR1, address VAR2, uint VAR3) payable public {
require(VAR4[msg.sender][VAR1].VAR5 == 0, """");
require(msg.value == VAR6, """");
require(VAR3 > 0, """");
VAR4[msg.sender][VAR1] = FUN2(VAR2, VAR3, VAR7, 0);
emit FUN3(msg.sender, VAR1, VAR2, VAR3);
}",RE,1
0x047c216ebe3fa55544e04a72264e1016531a6d6f.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;",RE,1
0x047ebd5f7431c005c9d3a59ce0675ac998417e9d.sol,"function () payable external {
FUN1();
}",RE,1
0x04823640da2509874e0c65ebcf7e2050dba99bc5.sol,"function () payable{
FUN1();
}
constructor() public {
VAR1 = 0xb3beac54c341adb4aa3f8480bef0a6aceb76256a;
VAR2[VAR1] = VAR3;
}
function FUN1() payable {
if(VAR4 == true){
require(msg.value > 0);
uint256 VAR5 = msg.value.FUN2(100000000000000).FUN3(VAR6);
VAR2[msg.sender] = VAR2[msg.sender].FUN4(VAR5);
VAR3 = VAR3.FUN4(VAR5);
VAR1.transfer(msg.value);
}
else{
throw;
}
}",RE,1
0x04830e45762f09853b398d1d03003fda7c978597.sol,"function () payable {
FUN1(msg.sender);
}",RE,1
0x0485a423c0b8ff2f5aa2ec35a32d1c67a2e99b6c.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
library VAR5 {
using SafeMath for uint256;
using Address for address;",RE,1
0x0485d2be00eda257b6e7868950616ad2a8cc44b6.sol,"function FUN1() public payable {
require(VAR1 >= VAR2 && VAR1 <= VAR3);
require(msg.value == 0);
if (VAR4 > 0 && VAR5[msg.sender] >= VAR4) {
revert();
}
FUN2(VAR6, msg.sender, VAR7);
VAR5[msg.sender] += 1;
FUN3(msg.sender, VAR5[msg.sender], VAR7);
}
}
contract ICOToken is VAR8 {
uint256 public VAR9;
uint256 public VAR10;
uint256 public VAR11;
address public VAR12;
address public VAR13;
event FUN4(address indexed VAR14, uint256 indexed value, uint256 VAR15);
event FUN5(address indexed VAR14, address indexed VAR16, uint256 value);
function FUN6() public payable {
require(VAR1 >= VAR10 && VAR1 <= VAR11);
uint256 VAR15 = (msg.value * VAR9 * 10 ** uint256(VAR17)) / (1 VAR18 / 1 VAR19);
if (VAR15 == 0 || VAR20[VAR12] < VAR15) {
revert();
}
FUN2(VAR12, msg.sender, VAR15);
FUN4(msg.sender, msg.value, VAR15);
}
function() public payable {
if (msg.value == 0) {
FUN1();
}
else {
FUN6();
}
}
}",RE,1
0x0486506702b47fd838f3b8ead7fc9509f012f4a7.sol,"function () public payable {
require(msg.value >= 1000000000000);
require(VAR1+(msg.value*VAR2)<=VAR3);
uint VAR4;
VAR4 = msg.value*VAR2;
VAR5[msg.sender] += VAR4;
VAR1 += VAR4;
Transfer(address(0), msg.sender, VAR4);
}",RE,1
0x048694443ce5587f76d7233d0e475b14000a3f5c.sol,"function() payable external {
require (msg.value == 0);
uint256 VAR1 = VAR2[msg.sender];
VAR2[msg.sender] = 0;
if (!VAR3.transfer(msg.sender, VAR1)) {
revert();
}
}",RE,1
0x048717ea892f23fb0126f00640e2b18072efd9d2.sol,"function FUN1() public payoutsAreActive returns (bool) {
uint VAR1 = VAR2[msg.sender];
VAR2[msg.sender] = 0;
if (msg.sender.call.value(VAR1)()) {
return true;
}
else {
VAR2[msg.sender] = VAR1;
return false;
}
}",RE,1
0x0487ac46bd41f4b734e08eab479330e3bd9b6cf5.sol,"function FUN1(address VAR1, uint VAR2) external onlyOwner {
VAR3 = VAR3.FUN2(VAR2);
super.FUN3(VAR1, VAR2);
}
FUN4() external payable {
uint VAR2 = msg.value;
msg.sender.transfer(VAR2);
}
}",RE,1
0x0487fc87df11933ace3c3dd98e287fd53c2109b4.sol,"function () external payable {
}",RE,1
0x0488401c3f535193fa8df029d9ffe615a06e74e6.sol,"function () public payable {
revert();
}",RE,1
0x0488a7b65e8a07db4642a1cbe75434b4c4524026.sol,"function FUN1(address payable VAR1) public onlyOwner {
VAR2 = VAR1;
}
function FUN2(address VAR3, address VAR4) view public returns (uint256 VAR5) {
return VAR6[VAR3][VAR4];
}
}
contract MIKI is VAR7,VAR8{
uint256 public VAR9;
constructor(address VAR3) {
VAR10 = """";
VAR11 = """";
VAR12 = 18;
VAR13 = 10000000000000000000000;
VAR9 = 10000000000000000000000;
VAR14 = VAR3;
VAR15[VAR14] = VAR13;
}
FUN3() external payable {
revert();
}
}",RE,1
0x0488f94c063abff57d9fb8edba343f2e9aeeea1d.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
require(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address payable private VAR5;
event FUN2(address indexed VAR6, address indexed VAR7);",RE,1
0x048b70f7aa0466c3d1f3f3c22f32fd0689ca5cec.sol,"function () payable {
if (!VAR1) throw;
if (msg.value == 0) throw;
if (VAR2.VAR3 < VAR4) throw;
if (VAR2.VAR3 > VAR5) throw;
uint256 VAR6 = FUN1(msg.value, VAR7);
if (VAR6 + VAR8 > VAR9) throw;
VAR8 = FUN2(VAR8, VAR6);
VAR10[msg.sender] += VAR6;
FUN3(msg.sender, VAR6);
}
}",RE,1
0x048f43402b2fb294f363e1d8e9f49474b9fc6af1.sol,"function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("""");
require(VAR4, """");
}",RE,1
0x048f616fcc4dd825f4a0a3b095d2ef70046b30c3.sol,"function() public payable {
if (msg.sender == VAR1) {
return;
}
FUN1();
FUN2();
FUN3();
FUN4();
FUN5();
}",RE,1
0x048fe0f263b8c3cef3f3e6b0e4f1b8cba55453cd.sol,"function FUN1(address VAR1) public payable;
}
interface VAR2 {",RE,1
0x049135b904148a0cf263f064d7f7c702dd34d72e.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3, string VAR4)private returns(bool VAR5) {
require(FUN2(msg.sender) > VAR2);
VAR6[msg.sender] = VAR6[msg.sender].FUN3(VAR2);
VAR6[VAR1] = VAR6[VAR1].FUN4(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN5(VAR4)), msg.sender, VAR2, VAR3));
emit Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4)public returns(bool VAR5) {
require(!VAR7[msg.sender]);
require(!VAR7[VAR1]);
if (FUN6(VAR1)) {
return FUN1(VAR1, VAR2, VAR3, VAR4);
}
else {
return FUN7(VAR1, VAR2, VAR3);
}
}",RE,1
0x049158da08568d1973dc951ec758873bf7125478.sol,"function () public payable {
bytes memory VAR1;
if (msg.value == 0) {
revert();
}
uint256 VAR2 = msg.value.FUN1(VAR3);
if (VAR2 == 0) {
revert();
}
if (VAR2 > VAR4[0x0]) {
revert();
}
VAR5.transfer(msg.value);
VAR4[0x0] = VAR4[0x0].FUN2(VAR2);
VAR4[msg.sender] = VAR4[msg.sender].FUN3(VAR2);
emit Transfer(0x0, msg.sender, VAR2);
emit FUN4(0x0, msg.sender, VAR2, VAR1);
emit FUN5(msg.sender, VAR2);
}
}",RE,1
0x04950c94f4cbf9b3eb7b3ddd48e6aef176e3f73f.sol,"function () external payable {
address sender = msg.sender;
uint256 VAR1 = 0;
if (VAR2[sender] != 0) {
VAR1 = VAR2[sender] * VAR3 / 100 * (VAR4 - VAR5[sender]) / 1 VAR6;
if (msg.value == 0) {
if (VAR1 >= address(this).VAR7) {
VAR1 = (address(this).VAR7);
}
if ((VAR8[sender] + VAR1) > VAR2[sender] * VAR9 / 100) {
VAR1 = VAR2[sender] * VAR9 / 100 - VAR8[sender];
VAR2[sender] = 0;
VAR8[sender] = 0;
sender.transfer(VAR1);
return;
}
else {
sender.transfer(VAR1);
VAR8[sender] += VAR1;
VAR1 = 0;
}
}
}
VAR5[sender] = VAR4;
VAR2[sender] += (msg.value + VAR1);
if (msg.value != 0) {
VAR10.transfer(msg.value * VAR11 / 100);
if (VAR2[sender] > VAR2[VAR10]) {
VAR10 = sender;
}
}
}",RE,1
0x0496d94ef879de321cb968be9f356c51fad024e0.sol,"function () external payable {
address VAR1 = VAR2;
VAR3 {
let VAR4 := FUN1(0x40) FUN2(VAR4, 0, VAR5) let VAR6 := FUN3(VAR7, VAR1, VAR4, VAR5, 0, 0) let VAR8 := VAR9 FUN4(VAR4, 0, VAR8) switch result case 0 {
revert(VAR4, VAR8) }
default {
return(VAR4, VAR8) }
}
}
}",RE,1
0x04986b3ea83b0f5d628e216f77f03cb691f5c3dd.sol,"function() external payable {
FUN1();
}
function FUN1() public payable {
uint256 VAR1;
uint256 VAR2 = VAR3.FUN2(msg.sender);
require(VAR2 > 0);
if (FUN3(VAR4, VAR5)) {
uint256 VAR6 = VAR3.FUN4(msg.sender, VAR2.FUN5(1));
uint256 VAR7 = uint(VAR3.FUN6(VAR6, 0));
require(VAR7 > 1);
require(msg.value >= VAR8);
VAR1 = FUN7(msg.value, VAR9);
require(VAR1 <= VAR10);
}
else if (FUN3(VAR5, VAR11)) {
VAR1 = FUN7(msg.value, VAR12);
}
else if (FUN3(VAR11, VAR13)) {
VAR1 = FUN7(msg.value, uint256(0));
}
else {
revert("""");
}
require(VAR14.FUN8(VAR1) <= VAR15);
VAR14 = VAR14.FUN8(VAR1);
VAR16.transfer(msg.value);
require(VAR17.FUN9(VAR17.FUN10(), msg.sender, VAR1));
emit FUN11(msg.sender, msg.sender, msg.value, VAR1);
}",RE,1
0x049a0b974add339d04565f6e407edfdd95218d3e.sol,"function FUN1(uint256 VAR1) FUN2() FUN3() FUN4() public payable {
uint256 VAR2 = 0;
if(VAR1 == 1 || VAR1 == 2){
if(VAR3 < VAR4[VAR5].VAR6){
VAR2 = FUN5(VAR1);
VAR4[VAR5].VAR7 = VAR4[VAR5].VAR7.FUN6((VAR2.FUN7(VAR7)).FUN8(100));
}
else if(VAR3 >= VAR4[VAR5].VAR6){
FUN9();
VAR2 = FUN5(VAR1);
VAR4[VAR5].VAR7 = VAR4[VAR5].VAR7.FUN6((VAR2.FUN7(VAR7)).FUN8(100));
}
}
else {
msg.sender.transfer(msg.value);
}
}
function FUN1(uint256 VAR1, address VAR8) FUN2() FUN3() FUN4() public payable {
uint256 VAR2 = 0;
if(VAR1 == 1 || VAR1 == 2){
if(VAR3 < VAR4[VAR5].VAR6){
VAR2 = FUN5(VAR1);
FUN10(VAR2, VAR8);
}
else if(VAR3 >= VAR4[VAR5].VAR6){
FUN9();
VAR2 = FUN5(VAR1);
FUN10(VAR2, VAR8);
}
}
else {
msg.sender.transfer(msg.value);
}
}",RE,1
0x049d6c8a9592e29884801a7aafb0f7ac66a7e22c.sol,"function FUN1() public view returns(uint8) {
return VAR1;
}
}
contract LOKI is VAR2 {
using SafeMath for uint256;
uint256 public VAR3 = 0;
FUN2 (address => uint256) private VAR4;
FUN2 (address => FUN2 (address => uint256)) private VAR5;
FUN2 (address => bool) public VAR6;
string constant VAR7 = """";
string constant VAR8 = """";
uint8 constant VAR9 = 18;
uint256 VAR10 = 100000*10**uint(VAR9);
IERC20 VAR11 ;
address payable public VAR12;
modifier onlyOwner() {
require(msg.sender == VAR12);
VAR13;
}
address VAR14 = 0x49A6ca6e8Aa682c9d108767711E11B73056B879c;
constructor() public payable FUN3(VAR7, VAR8, VAR9) {
FUN4(VAR14, VAR10);
VAR12 = msg.sender;
}
function FUN1() public view returns(uint8) {
return VAR1;
}
}
contract LOKI is VAR2 {
using SafeMath for uint256;
uint256 public VAR3 = 0;
FUN2 (address => uint256) private VAR4;
FUN2 (address => FUN2 (address => uint256)) private VAR5;
FUN2 (address => bool) public VAR6;
string constant VAR7 = """";
string constant VAR8 = """";
uint8 constant VAR9 = 18;
uint256 VAR10 = 100000*10**uint(VAR9);
IERC20 VAR11 ;
address payable public VAR12;
modifier onlyOwner() {
require(msg.sender == VAR12);
VAR13;
}
address VAR14 = 0x49A6ca6e8Aa682c9d108767711E11B73056B879c;
constructor() public payable FUN3(VAR7, VAR8, VAR9) {
FUN4(VAR14, VAR10);
VAR12 = msg.sender;
}",RE,1
0x049e6eb92fc1ca6bc6eca9f34ab43a9ad28d014b.sol,"function () external payable {
FUN1();
}
function FUN1() payable canDistr public {
uint256 VAR1 = 0;
require( msg.value >= VAR2 );
require( msg.value > 0 );
VAR1 = VAR3.FUN2(msg.value) / 1 VAR4;
address VAR5 = msg.sender;
if (VAR1 > 0) {
FUN3(VAR5, VAR1);
}
if (VAR6 >= VAR7) {
VAR8 = true;
}
}",RE,1
0x04a2045f76e890a6430b5fa66ab2b3bac59ce51c.sol,"function FUN1() internal view returns (address payable) {
return msg.sender;
}",RE,1
0x04a28b7b45db608cc9dcc2dd247ede17164849f8.sol,"function () payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) payable {
require(VAR1 != 0x0);
require(FUN2());
uint256 VAR2 = msg.value;
uint256 VAR3 = (VAR2) * VAR4;
VAR5 = VAR5.FUN3(VAR2);
VAR6.transfer(VAR1, VAR3);
FUN4(msg.sender, VAR1, VAR2, VAR3);
FUN5();
}",RE,1
0x04a487afd662c4f9deacc07a7b10cfb686b682a4.sol,"function FUN1( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, uint VAR5, bool VAR6 ) public payable returns(bool);
function FUN2() public payable;
function() public payable {
}
function FUN1( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, uint VAR5, bool VAR6 ) public payable returns(bool) {
require(VAR7);
require(msg.sender == VAR8);
require(FUN3(VAR1, VAR2, VAR3, VAR4, VAR5, VAR6));
return true;
}
event FUN4(bool VAR9);",RE,1
0x04a4b43352a78294bc7b6d520450825ac639ea21.sol,"function FUN1() payable public {
uint VAR1 = msg.value * VAR2;
FUN2(this, msg.sender, VAR1);
}
function FUN1() public payable {
FUN3(msg.sender);
}
function() payable {
FUN1();
}",RE,1
0x04a6e67d14715dd0e267b35805fea24fd0b5f70b.sol,"function () public payable {
require(VAR1 != VAR2.VAR3);
require(!VAR4 && msg.sender != VAR5);
if( VAR1 == VAR2.VAR6 && VAR7 <= VAR8 ) {
require (VAR9 <= 1500 VAR10);
VAR9 = (VAR9).FUN1(msg.value);
VAR11 =((msg.value).FUN2(VAR12));
VAR13 = ((VAR11).FUN2(58)).FUN3(100);
VAR14 = VAR11 + VAR13;
FUN4(msg.sender,VAR14);
}
else if(VAR1 == VAR2.VAR15 && VAR7 <= VAR16 ){
if( VAR7 < VAR17 ) {
VAR11 =(msg.value).FUN2(VAR18);
VAR13 = ((VAR11).FUN2(15)).FUN3(100);
VAR14 = VAR11 + VAR13;
FUN4(msg.sender,VAR14);
}
else if(VAR7 >= VAR17 && VAR7 < VAR19) {
VAR11 =(msg.value).FUN2(VAR18);
VAR13 = ((VAR11).FUN2(10)).FUN3(100);
VAR14 = VAR11 + VAR13;
FUN4(msg.sender,VAR14);
}
else if(VAR7 >= VAR19 && VAR7 < VAR20) {
VAR11 =(msg.value).FUN2(VAR18);
VAR13 = ((VAR11).FUN2(5)).FUN3(100);
VAR14 = VAR11 + VAR13;
FUN4(msg.sender,VAR14);
}
else if(VAR7 >= VAR20 && VAR7 < VAR16) {
VAR11 =(msg.value).FUN2(VAR18);
VAR14 = VAR11;
FUN4(msg.sender,VAR14);
}
}
else {
revert();
}
}",RE,1
0x04a734a6c3e415fff3149f0cb5f4719554974cc2.sol,function FUN1() external payable;,RE,1
0x04a84b5368c9006ed05e837f8132e9f1c0287482.sol,"function() external payable {
FUN1();
}",RE,1
0x04aa51bbcb46541455ccf1b8bef2ebc5d3787ec9.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
library VAR5 {
using SafeMath for uint256;
using Address for address;",RE,1
0x04adfd46590db157a20d88e6d10b783617aadb7e.sol,"function FUN1(address VAR1, uint256 VAR2, address VAR3, bytes memory VAR4) public;
}
contract VAR5 {
address public VAR6;
address public VAR7;
event FUN2(address indexed VAR8, address indexed VAR9);
constructor() public {
VAR6 = msg.sender;
}
modifier onlyOwner {
require(msg.sender == VAR6);
VAR10;
}
}
contract PRESALE is VAR5{
using SafeMath for uint;
ERC20Interface public VAR3;
uint256 public VAR11;
address VAR12;
uint256 public VAR13;
uint public VAR14;
address payable VAR15;
constructor(ERC20Interface VAR16) public {
VAR3 = VAR16;
VAR6 = msg.sender;
}
function FUN3(address VAR17, uint VAR18, address payable VAR19) public onlyOwner{
VAR12 = VAR17;
VAR14 = VAR18*10**18;
VAR15 = VAR19;
}
function () external payable {
require(VAR12 != 0x0000000000000000000000000000000000000000, """");
require(msg.value <= 10 VAR20, """");
require(msg.value != 0 VAR20, """");
uint VAR21 = msg.value;
VAR11 = (VAR21 / 0.00022 VAR20)*10**18;
require(VAR3.FUN4(VAR12, address(this)) >= VAR11, """");
require(VAR3.FUN5(VAR12) >= VAR11, """");
require(VAR13 <= VAR14, """");
VAR15.transfer(msg.value);
VAR3.FUN6(VAR12, msg.sender, VAR11);
VAR13 += VAR11;
}
function FUN7() public payable{
require(VAR12 != 0x0000000000000000000000000000000000000000, """");
require(msg.value <= 10 VAR20, """");
require(msg.value != 0 VAR20, """");
uint VAR21 = msg.value;
VAR11 = (VAR21 / 0.00022 VAR20)*10**18;
require(VAR3.FUN4(VAR12, address(this)) >= VAR11, """");
require(VAR3.FUN5(VAR12) >= VAR11, """");
require(VAR13 <= VAR14, """");
VAR15.transfer(msg.value);
VAR3.FUN6(VAR12, msg.sender, VAR11);
VAR13 += VAR11;
}
}",RE,1
0x04af24e2e590c9597890924de4dcdb8c9b32df6b.sol,"function () payable{
FUN1();
}
constructor() public {
VAR1 = 0xeaf03a0a94ffd66a4eaa82701323fe4cd33565c3;
VAR2[VAR1] = VAR3;
}
function FUN1() payable {
if(VAR4 == true){
require(msg.value > 0);
uint256 VAR5 = msg.value.FUN2(100000000000000).FUN3(VAR6);
VAR2[msg.sender] = VAR2[msg.sender].FUN4(VAR5);
VAR3 = VAR3.FUN4(VAR5);
VAR1.transfer(msg.value);
}
else{
throw;
}
}",RE,1
0x04b29d1686fd5bcfc99b95fd9159357cb3478786.sol,"constructor (string memory VAR1, string memory VAR2, uint256 VAR3,address payable VAR4) public {
VAR5 = VAR1;
VAR6 = VAR2;
VAR7 = 18;
VAR8 = VAR4;
FUN1(VAR8, VAR3);
}",RE,1
0x04b710d1fc77c8e7002f539bb48feb560cb2892c.sol,"function FUN1(address VAR1, bytes VAR2, uint VAR3) internal {
require(VAR4 == false, """");
VAR4 = true;
require(VAR1.call.value(VAR3)(VAR2), """");
VAR4 = false;
}
}
contract payoutAllC is VAR5 {
address private VAR6;
event FUN2(address VAR7, uint value);
constructor(address VAR8) public {
assert(VAR8 != address(0));
VAR6 = VAR8;
}
function FUN3(address VAR1, uint VAR3) internal {
FUN1(VAR1, """", VAR3);
}",RE,1
0x04baddfb21723ec467e9993b715c5e0d673bac96.sol,"function FUN1(uint256 VAR1) payable public {
require(msg.value >= VAR2 && VAR1 <= 20);
Game VAR3;
VAR3.VAR4 = msg.sender;
VAR3.VAR1 = VAR1;
VAR5.FUN2(VAR3);
if (VAR1 == VAR6) {
msg.sender.transfer(this.VAR7);
}
FUN3();
VAR8 = VAR9;
}
function() public payable {
}
}",RE,1
0x04bba664ea822924ff435ce1b3fad3e8dcc69481.sol,"function FUN1() public payable;
}
pragma VAR1 ^0.4.24;
contract KingOfEthReferencer is VAR2 {
address public VAR3;
modifier FUN2() {
require(VAR3 == msg.sender);
VAR4;
}",RE,1
0x04bc0ab673d88ae9dbc9da2380cb6b79c4bca9ae.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
library VAR5 {
using SafeMath for uint256;
using Address for address;",RE,1
0x04bd346f40fe66303a39225bec1f28f66711582e.sol,"function () external payable {
FUN1();
}
function FUN1() payable canDistr public {
uint256 VAR1 = 0;
require( msg.value >= VAR2 );
require( msg.value > 0 );
VAR1 = VAR3.FUN2(msg.value) / 1 VAR4;
address VAR5 = msg.sender;
if (VAR1 > 0) {
FUN3(VAR5, VAR1);
}
if (VAR6 >= VAR7) {
VAR8 = true;
}
}",RE,1
0x04c1fd58951e72e8eec932c2766ed97d049aeb9f.sol,"function () public payable {
revert();
}",RE,1
0x04c21da065bda1f4780495693ff1b952468ee151.sol,"function() public payable {
VAR1 += msg.value;
}
function FUN1(uint8 VAR2, bool VAR3, address VAR4) isActivated VAR5 FUN2(VAR4) public payable {
require(msg.value > 0);
uint256 VAR6 = msg.value;
if (VAR7[msg.sender].VAR8 == 0) {
VAR7[msg.sender].VAR9.VAR10 = 0;
}
if (VAR7[msg.sender].VAR11 == 0) {
VAR12 ++;
VAR7[msg.sender].VAR11 = VAR12;
VAR13[VAR12] = msg.sender;
}
if (VAR6 < VAR14 * VAR2 || VAR6 > VAR15 * VAR2) {
VAR1 += VAR6;
return;
}
if (VAR7[msg.sender].VAR8 > 0) {
require(VAR7[msg.sender].VAR8.FUN3(VAR16).FUN3(VAR2) >= VAR6);
}
if (VAR3 == false && VAR7[msg.sender].VAR17 > 100) {
FUN4();
VAR7[msg.sender].VAR9.VAR10 = 0;
}
if (VAR3 && VAR2 == 1) {
require( VAR7[msg.sender].VAR9.VAR10 > 0 && VAR7[msg.sender].VAR18 == false && VAR7[msg.sender].VAR19 > 0 && VAR7[msg.sender].VAR20 <= (VAR21 - 1 VAR22), '' );
VAR7[msg.sender].VAR18 = true;
VAR7[msg.sender].VAR19 --;
VAR7[msg.sender].VAR20 = VAR21;
uint16 VAR23 = VAR7[msg.sender].VAR9[VAR7[msg.sender].VAR9.VAR10 - 1];
VAR7[msg.sender].VAR17 -= VAR23;
VAR7[msg.sender].VAR9.VAR10 = VAR7[msg.sender].VAR9.VAR10 - 1;
VAR7[msg.sender].VAR9.FUN5(100 + VAR23);
}
VAR1 += VAR6.FUN6(100);
VAR24 += VAR6.FUN7(VAR6.FUN6(100));
VAR7[msg.sender].VAR8 += VAR6.FUN7(VAR6.FUN6(100));
if ( VAR7[msg.sender].VAR25 == address(0x0) && VAR4 != address(0x0) && VAR4 != msg.sender && VAR7[VAR4].VAR11 > 0 ) {
VAR7[msg.sender].VAR25 = VAR4;
}
for (uint16 VAR26 = 1; VAR26 <= VAR2; VAR26++) {
uint16 VAR27 = FUN8(VAR26);
VAR7[msg.sender].VAR9.FUN5(VAR27);
VAR7[msg.sender].VAR17 += VAR27;
}
uint16 VAR28 = FUN9();
if (VAR28 > 0) {
VAR29 ++;
VAR7[msg.sender].VAR30 = VAR7[msg.sender].VAR8.FUN3(36).FUN6(10);
if (VAR6 >= VAR31) {
VAR7[msg.sender].VAR30 += VAR24.FUN3(VAR28).FUN6(100);
}
FUN4();
return;
}
if (VAR7[msg.sender].VAR17 > 100 || VAR7[msg.sender].VAR17 == VAR32) {
VAR7[msg.sender].VAR30 = 0;
if (VAR7[msg.sender].VAR18 == false && VAR7[msg.sender].VAR19 > 0) {
return;
}
if (VAR7[msg.sender].VAR17 == VAR32) {
VAR33++;
}
else {
VAR34 ++;
}
uint VAR35 = VAR7[msg.sender].VAR8.FUN6(50);
VAR1 += VAR35;
FUN10(VAR35);
FUN4();
return;
}
if (VAR7[msg.sender].VAR17 > VAR36) {
VAR37 ++;
VAR7[msg.sender].VAR30 = VAR7[msg.sender].VAR8.FUN3(VAR38).FUN6(10);
return;
}
if (VAR7[msg.sender].VAR17 > VAR39) {
VAR40 ++;
VAR7[msg.sender].VAR30 = VAR7[msg.sender].VAR8.FUN3(VAR41).FUN6(10);
return;
}
if (VAR7[msg.sender].VAR17 > VAR42) {
VAR43 ++;
VAR7[msg.sender].VAR30 = VAR7[msg.sender].VAR8.FUN3(VAR44).FUN6(10);
return;
}
if (VAR7[msg.sender].VAR17 > VAR45) {
VAR46 ++;
VAR7[msg.sender].VAR30 = VAR7[msg.sender].VAR8.FUN3(VAR47).FUN6(10);
}
}
event FUN11(address indexed VAR48, uint16[] VAR49, uint16 indexed VAR50, uint VAR51, uint VAR52, uint VAR53, uint16 VAR54, uint16 VAR32);
function FUN12() isActivated isHuman public payable {
(uint VAR55, uint VAR56) = FUN13(msg.sender);
uint VAR6 = VAR55 + VAR56;
require(VAR6 > 0, '');
if (VAR6 > address(this).VAR57) VAR6 = address(this).VAR57;
msg.sender.transfer(VAR6);
VAR7[msg.sender].VAR58 = 0;
VAR7[msg.sender].VAR59 = 0;
VAR60 = VAR60.FUN7(VAR56);
}
event FUN14(address VAR61, uint16 VAR27);",RE,1
0x04c62019ab478bff5874e7b7d9bc84fcf7e30025.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
0x04c6daf9c3fea6ac055d20f76ef88361986366eb.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3) external payable returns (uint256);",RE,1
0x04c874b39ed85a95043f170090fb68c379e3741f.sol,"function () payable internal {
uint VAR1 = msg.value * VAR2;
uint VAR3;
VAR3 += msg.value;
require(VAR4[VAR5] >= VAR1);
VAR4[msg.sender] += VAR1;
VAR4[VAR5] -= VAR1;
Transfer(VAR5, msg.sender, VAR1);
VAR5.transfer(VAR3);
}
}",RE,1
0x04ce99ba020bdac42fc42330da489afd6515a862.sol,"function () external payable {
FUN1();
}
function FUN1() payable canDistr public {
uint256 VAR1 = 0;
require( msg.value >= VAR2 );
require( msg.value > 0 );
VAR1 = VAR3.FUN2(msg.value) / 1 VAR4;
address VAR5 = msg.sender;
if (VAR1 > 0) {
FUN3(VAR5, VAR1);
}
if (VAR6 >= VAR7) {
VAR8 = true;
}
}",RE,1
0x04cf8057cdf25204c30cf1ccf919f801c0a2da44.sol,"function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}",RE,1
0x04d01b6145bc9db925ec1e80bc85f936a961210e.sol,"function () public payable {
revert();
}",RE,1
0x04d660832910ff492e940daff9ec7b3497e886ac.sol,"function() public payable {
if (msg.value.FUN1()) {
FUN2();
return;
}
FUN3(msg.VAR1.FUN4());
}
function FUN3(address VAR2) public payable notFromContract VAR3 {
uint VAR4 = msg.value;
uint VAR5 = msg.value;
require(VAR4 >= VAR6, """");
require(address(this).VAR7 <= VAR8, """");
if (VAR5 > VAR4) {
uint VAR9 = VAR5 - VAR4;
msg.sender.transfer(VAR9);
VAR5 = VAR4;
emit FUN5(msg.sender, VAR10, msg.value, VAR4, VAR9);
}
VAR11.FUN6(VAR12.FUN7(VAR5));
VAR13.FUN6(VAR14.FUN7(VAR5));
bool VAR15 = VAR16.FUN8(msg.sender);
if (VAR2.FUN9() && !VAR15 && !VAR17[msg.sender] && VAR2 != msg.sender && VAR16.FUN8(VAR2)) {
VAR17[msg.sender] = true;
uint VAR18 = VAR19.FUN10(VAR4);
uint VAR20 = VAR21.FUN10(VAR4);
assert(VAR16.FUN11(VAR2, VAR18));
VAR4 += VAR20;
emit FUN12(msg.sender, VAR2, VAR10, VAR20);
}
uint VAR22 = FUN13(msg.sender);
if (VAR15 && VAR22.FUN9()) {
VAR4 += VAR22;
emit FUN14(msg.sender, VAR10, VAR22);
}
if (VAR23 % 20 == 0) {
VAR4 += VAR24.FUN10(VAR4);
}
else if(VAR23 % 15 == 0) {
VAR4 += VAR25.FUN10(VAR4);
}
else if(VAR23 % 10 == 0) {
VAR4 += VAR26.FUN10(VAR4);
}
if (VAR15) {
assert(VAR16.FUN11(msg.sender, VAR4));
assert(VAR16.FUN15(msg.sender, VAR10));
}
else {
if (VAR23 <= 50) {
VAR4 += VAR27.FUN10(VAR4);
}
assert(VAR16.FUN16(msg.sender, VAR4, VAR10));
emit FUN17(msg.sender, VAR10);
}
VAR23++;
emit FUN18(msg.sender, VAR10, VAR4, VAR5);
}",RE,1
0x04d6edcfc557a8cff318277c34c7478403315de3.sol,"function FUN1(address VAR1) internal {
require(VAR1 != address(0));
emit FUN2(VAR2, VAR1);
VAR2 = VAR1;
}
}
contract RektFyi is VAR3 {
using DSMath for uint;
struct VAR4 {
uint VAR5;
uint VAR6;
uint VAR7;
uint VAR8;
uint VAR9;
address payable sender;
}
struct VAR10 {
uint VAR11;
uint VAR6;
uint VAR12;
uint VAR7;
}
struct VAR13 {
uint VAR14;
uint VAR15;
}
FUN3(address => VAR4) public VAR16;
FUN3(address => uint) public VAR17;
FUN3(address => address[]) private VAR18;
FUN3(address => VAR13) public VAR19;
FUN3(address => VAR10) public VAR20;
Pot public VAR21 = FUN4(0,0);
uint public VAR22 = 0;
bool public VAR23 = false;
uint public VAR24 = 0;
uint public VAR25 = 1300000000000000000;
uint public VAR26 = 10000000000000000;
uint public VAR27 = 3628800;
address public VAR28;
Medianizer VAR29;
bool public VAR30 = false;
uint public VAR31 = 0;
address public VAR32;
address public VAR33;
Dai VAR34;
Dai VAR35;
constructor(address VAR36, address VAR37) public {
VAR28 = VAR36;
VAR29 = FUN5(VAR28);
VAR32 = VAR37;
VAR34 = FUN6(VAR32);
VAR35 = VAR34;
}
string public constant VAR38 = """";
string public constant VAR39 = """";
uint8 public constant VAR40 = 0;
uint public constant VAR41 = 1000000000000000000;
uint public constant VAR42 = 100000000000000;
uint public constant VAR43 = 1000000000000000000;
uint public constant VAR44 = 10000000000000000000;
uint public constant VAR45 = 1250000000000000000;
uint public constant VAR46 = 1800000000000000000;
uint public constant VAR47 = 5000000000000000000;
uint public constant VAR48 = 1000000000000000000000000000;
uint public constant VAR49 = 100000000000000000;
uint public constant VAR50 = 23670000;
uint public constant VAR51 = 100000000000000000;
event FUN7(address indexed VAR52, string indexed VAR53, uint value);
event FUN8(address indexed VAR54, uint VAR55, uint VAR35, uint VAR34);
event Transfer(address indexed VAR56, address indexed VAR54, uint VAR57);
event FUN9(uint indexed VAR56, uint indexed VAR54, uint VAR58, address indexed VAR59);
event FUN10( address indexed sender, address indexed VAR16, uint VAR60, uint VAR25, uint VAR61, uint VAR9, uint VAR6, uint VAR7, uint VAR62 );
event FUN11(address indexed sender, address indexed VAR16);
modifier FUN12() {
require(VAR23 == false, """");
VAR63;
}
modifier FUN13(address VAR64) {
require(address(VAR64) != address(0), """");
require(VAR64 != msg.sender, """");
require(FUN14(VAR64) == 0, """");
require(VAR64.VAR17 > 0, """");
VAR63;
}",RE,1
0x04da1cd6498986015f700397a8b4bfbaa70c9399.sol,"function () public payable {
require(VAR1 >= VAR2 && VAR1 <= VAR3 && VAR4 >= VAR5 && VAR4 < VAR6);
uint VAR7;
if (VAR1 <= VAR8) {
VAR7 = msg.value *4000000;
}
else {
VAR7 = msg.value *10000;
}
VAR9[msg.sender] = FUN1(VAR9[msg.sender], VAR7);
VAR4 = FUN1(VAR4, VAR7);
Transfer(address(0), msg.sender, VAR7);
VAR10.transfer(msg.value);
}",RE,1
0x04da2043c361113deeb52a4c3834d877586bbebd.sol,"function FUN1(address VAR1, bytes memory VAR2) public virtual payable returns (bytes32);",RE,1
0x04e0e2dd8fdbca1d584927cdbdeb7a1314dff1f4.sol,"function () payable public {
FUN1(msg.sender);
}
function FUN1(address VAR1) payable public {
require(VAR1 != 0x0);
require(FUN2());
uint256 VAR2 = msg.value;
uint256 VAR3 = (VAR2) * VAR4;
VAR5 = VAR5.FUN3(VAR2);
VAR6.transfer(VAR1, VAR3);
emit FUN4(msg.sender, VAR1, VAR2, VAR3);
FUN5();
}",RE,1
0x04e9b27dc521158035764e96917813093bc2f748.sol,"function () external payable {
require(!VAR1, '');
uint VAR2;
if(msg.value == VAR3[1]){
VAR2 = 1;
}
else if(msg.value == VAR3[2]){
VAR2 = 2;
}
else if(msg.value == VAR3[3]){
VAR2 = 3;
}
else if(msg.value == VAR3[4]){
VAR2 = 4;
}
else if(msg.value == VAR3[5]){
VAR2 = 5;
}
else if(msg.value == VAR3[6]){
VAR2 = 6;
}
else if(msg.value == VAR3[7]){
VAR2 = 7;
}
else if(msg.value == VAR3[8]){
VAR2 = 8;
}
else if(msg.value == VAR3[9]){
VAR2 = 9;
}
else if(msg.value == VAR3[10]){
VAR2 = 10;
}
else if(msg.value == VAR3[11]){
VAR2 = 11;
}
else if(msg.value == VAR3[12]){
VAR2 = 12;
}
else if(msg.value == VAR3[13]){
VAR2 = 13;
}
else if(msg.value == VAR3[14]){
VAR2 = 14;
}
else if(msg.value == VAR3[15]){
VAR2 = 15;
}
else if(msg.value == VAR3[16]){
VAR2 = 16;
}
else {
revert('');
}
if(VAR2 == 1){
uint VAR4 = 0;
address VAR5 = FUN1(msg.VAR6);
if (VAR7[VAR5] > 0 && VAR7[VAR5] <= VAR8){
VAR4 = VAR7[VAR5];
}
else {
revert('');
}
if(VAR9[VAR7[msg.sender]].VAR10){
FUN2(VAR4);
}
else {
FUN3(VAR4);
}
}
else if(VAR9[VAR7[msg.sender]].VAR10){
FUN4(VAR2);
}
else {
revert("""");
}
}",RE,1
0x04ead19ff234b55a6e65391fe553d4baaa5b7ebb.sol,"function () payable external {
revert();
}",RE,1
0x04eaf26f259521ea20f151118e556adc7e725c0f.sol,"function () payable public {
require(false);
}
}",RE,1
0x04eb05e09ef4b9efdebbad449307c70d06f58b3e.sol,"function() public payable VAR1 {
VAR2.FUN1(FUN2(msg.sender, (msg.value * VAR3) / 100));
uint VAR4 = msg.value;
while (VAR4 > 0) {
uint VAR5 = VAR4 < VAR2[VAR6].VAR7 ? VAR4 : VAR2[VAR6].VAR7;
VAR2[VAR6].VAR7 -= VAR5;
VAR4 -= VAR5;
VAR2[VAR6].VAR8.transfer(VAR5);
if(VAR4 > 0){
VAR6 += 1;
}
}
}",RE,1
0x04eb6febda6646032c6de98554e607f430c39797.sol,"function() payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) canBuyTokens whenNotPaused payable {
require(msg.value != 0);
require(VAR1 != 0x0);
uint256 VAR2 = msg.value;
uint256 VAR3 = 0;
VAR3 = FUN2();
uint256 VAR4 = VAR2.FUN3(VAR5);
if (VAR3 > 0) {
VAR4 += VAR4.FUN3(VAR3).FUN4(100);
}
require(VAR6.FUN5(VAR4) <= VAR7);
require(FUN6(VAR1, VAR4));
VAR8 = VAR8.FUN5(VAR2);
FUN7(msg.sender, VAR1, VAR4);
FUN8();
}",RE,1
0x04ebe325519223119ab6bde2b84e23a6ecd05d65.sol,"function () payable public {
FUN1();
}
function FUN1() payable public {
uint VAR1 = msg.value;
while (VAR1 >= VAR2 && VAR3 <= VAR4) {
uint VAR5 = 0;
if (VAR6.VAR7 > 0) {
VAR5 = VAR6[VAR6.VAR7-1];
VAR6.VAR7--;
}
else {
VAR5 = VAR3++;
}
VAR8[VAR5] = FUN2(msg.sender, VAR9);
VAR1 -= VAR2;
}
if (VAR3 > VAR4) {
FUN3();
}
if (VAR1 > 0) {
msg.sender.transfer(VAR1);
}
}",RE,1
0x04edcf348026794caf7ae9f092e80ac3d33f4686.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7) private returns(VAR6.VAR8) {
uint256 VAR9 = VAR3 / 100;
uint256 VAR10 = VAR3 / 50;
VAR10 = VAR10.FUN2(VAR9);
uint256 VAR11;
if (!address(VAR12).call.value(VAR10)()) {
VAR11 = VAR10;
VAR10 = 0;
}
uint256 VAR13 = VAR3 / 10;
if (VAR4 != VAR2 && VAR14[VAR4].VAR15 != '') {
VAR14[VAR4].VAR16 = VAR13.FUN2(VAR14[VAR4].VAR16);
emit VAR17.FUN3(VAR4, VAR14[VAR4].VAR18, VAR14[VAR4].VAR15, VAR1, VAR2, VAR13, VAR19);
}
else {
VAR11 = VAR13;
}
VAR11 = VAR11.FUN2((VAR3.FUN4(VAR20[VAR5].VAR21)) / (100));
if (VAR11 > 0) {
uint256 VAR22 = VAR11 / 2;
VAR12.transfer(VAR11.FUN5(VAR22));
VAR23[VAR1].VAR24 = VAR23[VAR1].VAR24.FUN2(VAR22);
VAR7.VAR25 = VAR11.FUN2(VAR7.VAR25);
}
return(VAR7);
}
function FUN6(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7) private {
if (VAR26[VAR2][VAR1].VAR27 == 0) VAR7 = FUN7(VAR2, VAR7);
if (VAR23[VAR1].VAR28 < 100000000000000000000 && VAR26[VAR2][VAR1].VAR28.FUN2(VAR3) > 1000000000000000000) {
uint256 VAR29 = (1000000000000000000).FUN5(VAR26[VAR2][VAR1].VAR28);
uint256 VAR30 = VAR3.FUN5(VAR29);
VAR14[VAR2].VAR31 = VAR14[VAR2].VAR31.FUN2(VAR30);
VAR3 = VAR29;
}
if (VAR3 > 1000000000) {
uint256 VAR32 = (VAR23[VAR1].VAR28).FUN8(VAR3);
if (VAR32 >= 1000000000000000000) {
FUN9(VAR32, VAR1);
if (VAR23[VAR1].VAR33 != VAR2) VAR23[VAR1].VAR33 = VAR2;
if (VAR23[VAR1].VAR34 != VAR5) VAR23[VAR1].VAR34 = VAR5;
VAR7.VAR35 = VAR7.VAR35 + 100;
}
if (VAR3 >= 100000000000000000) {
VAR36++;
if (FUN10() == true) {
uint256 VAR37;
if (VAR3 >= 10000000000000000000) {
VAR37 = ((VAR38).FUN4(75)) / 100;
VAR14[VAR2].VAR39 = (VAR14[VAR2].VAR39).FUN2(VAR37);
VAR38 = (VAR38).FUN5(VAR37);
VAR7.VAR35 += 300000000000000000000000000000000;
}
else if (VAR3 >= 1000000000000000000 && VAR3 < 10000000000000000000) {
VAR37 = ((VAR38).FUN4(50)) / 100;
VAR14[VAR2].VAR39 = (VAR14[VAR2].VAR39).FUN2(VAR37);
VAR38 = (VAR38).FUN5(VAR37);
VAR7.VAR35 += 200000000000000000000000000000000;
}
else if (VAR3 >= 100000000000000000 && VAR3 < 1000000000000000000) {
VAR37 = ((VAR38).FUN4(25)) / 100;
VAR14[VAR2].VAR39 = (VAR14[VAR2].VAR39).FUN2(VAR37);
VAR38 = (VAR38).FUN5(VAR37);
VAR7.VAR35 += 300000000000000000000000000000000;
}
VAR7.VAR35 += 10000000000000000000000000000000;
VAR7.VAR35 += VAR37 * 1000000000000000000000000000000000;
VAR36 = 0;
}
}
VAR7.VAR35 = VAR7.VAR35 + (VAR36 * 1000);
VAR26[VAR2][VAR1].VAR27 = VAR32.FUN2(VAR26[VAR2][VAR1].VAR27);
VAR26[VAR2][VAR1].VAR28 = VAR3.FUN2(VAR26[VAR2][VAR1].VAR28);
VAR23[VAR1].VAR27 = VAR32.FUN2(VAR23[VAR1].VAR27);
VAR23[VAR1].VAR28 = VAR3.FUN2(VAR23[VAR1].VAR28);
VAR40[VAR1][VAR5] = VAR3.FUN2(VAR40[VAR1][VAR5]);
VAR7 = FUN1(VAR1, VAR2, VAR3, VAR4, VAR5, VAR7);
VAR7 = FUN11(VAR1, VAR2, VAR3, VAR5, VAR32, VAR7);
FUN12(VAR2, VAR5, VAR3, VAR32, VAR7);
}
}",RE,1
0x04ee4af9082746db738e7e5b49b733493a6bd81f.sol,"function () external payable {
if (VAR1[msg.sender] != 0) {
uint256 VAR2 = VAR1[msg.sender] * 4 / 100 * (VAR3.VAR4 - VAR5[msg.sender]) / 5900;
address sender = msg.sender;
sender.FUN1(VAR2);
}
VAR5[msg.sender] = VAR3.VAR4;
VAR1[msg.sender] += msg.value;
}
}",RE,1
0x04ee4f8f199a767e66248207eb8687d840b9fec9.sol,"function () isWhitelisted acceptingPayments payable public {
require(msg.value >= 0.2 VAR1);
require(msg.value <= 500 VAR1);
require(msg.sender != address(0));
uint256 VAR2 = msg.value;
VAR3[msg.sender] += msg.value;
VAR4 = VAR4.FUN1(msg.value);
if (VAR4 > VAR5) {
uint256 VAR6 = VAR4.FUN2(VAR5);
msg.sender.transfer(VAR6);
VAR2 = VAR2.FUN2(VAR6);
VAR6 = 0;
VAR4 = VAR5;
VAR7 = false;
}
VAR8.transfer(VAR2);
}",RE,1
0x04ee65ae77471de8fbf1d08c9ef209184531424e.sol,"function () external payable {
FUN1();
}
function FUN1() payable canDistr public {
uint256 VAR1 = 0;
require( msg.value >= VAR2 );
require( msg.value > 0 );
VAR1 = VAR3.FUN2(msg.value) / 1 VAR4;
address VAR5 = msg.sender;
if (VAR1 > 0) {
FUN3(VAR5, VAR1);
}
if (VAR6 >= VAR7) {
VAR8 = true;
}
}",RE,1
0x04ef8121ad039ff41d10029c91ea1694432514e9.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
library VAR5 {
using SafeMath for uint256;
using Address for address;
function FUN2() onlyOwner public{
(bool VAR6, ) = msg.sender.call.value(address(this).VAR3)("""");
require(VAR6, """");
}
}",RE,1
0x04efc7daef8e5ba7b23f1cc1b3a36e2d50000ff7.sol,"function FUN1(address VAR1, uint256 VAR2) payable public returns (uint256){
ERC721Basic VAR3 = FUN2(VAR1);
require(VAR3.FUN3(VAR2) == address(this), """");
require(VAR4[VAR1][VAR2] <= msg.value, """");
VAR3.FUN4(this, msg.sender, VAR2);
}
function FUN5() payable public returns (uint256){
uint256 value = msg.value.FUN6(1 VAR5);
uint256 VAR6 = VAR7;
if (VAR8 > 0) {
VAR6 = VAR6.FUN7(VAR6.FUN6(VAR8).FUN8(100));
}
uint256 VAR9 = value.FUN8(VAR6);
require(VAR10.FUN9(this) >= VAR9, """");
require(VAR10.transfer(msg.sender, VAR9), """");
emit FUN10(msg.sender, VAR9, msg.value);
return VAR9;
}",RE,1
0x04f062809b244e37e7fdc21d9409469c989c2342.sol,"function FUN1(address VAR1, uint256 VAR2, address VAR3) external payable returns (bool);
}
contract VAR4 {
function FUN2() external payable {
require(msg.value > 0);
FUN3(msg.sender);
VAR5[0][msg.sender] = VAR5[0][msg.sender].FUN4(msg.value);
FUN5( 0, msg.sender, msg.value, VAR5[0][msg.sender] );
}",RE,1
0x04f2e7221fdb1b52a68169b25793e51478ff0329.sol,"function() payable public {
revert();
}",RE,1
0x04f816ba8f8a46e0b5a1ea9fb29dcf03fb09cb67.sol,"function () external payable {
revert();
}",RE,1
0x04fa0d235c4abf4bcf4787af4cf447de572ef828.sol,"function FUN1() internal view returns (address payable) {
return msg.sender;
}",RE,1
0x04ff2ab42fc7868b8a4f12150950fc3604b8d3ba.sol,"function FUN1() public payable onlyValid VAR1 {
require(VAR2 == true, """");
require(msg.value >= VAR3, """");
address VAR4 = VAR5;
VAR5 = msg.sender;
VAR2 = false;
emit FUN2 ( VAR6, VAR7, VAR2, VAR5, VAR3, VAR8.VAR9, VAR10.VAR9 );
uint VAR11 = VAR12[VAR4];
VAR12[VAR4] = VAR11.FUN3(VAR3);
}",RE,1
0x04ff3d111894399fa662082ededc4d7315232f8c.sol,"function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("""");
require(VAR4, """");
}",RE,1
0x050163597d9905ba66400f7b3ca8f2ef23df702d.sol,"function FUN1(address VAR1) external payable {
uint256 VAR2 = msg.value / VAR3;
uint256 VAR4 = VAR5.FUN2(address(this));
uint256 VAR6 = msg.value % VAR3;
if (VAR7 < VAR4) {
VAR7 = VAR4;
}
if (VAR2 > VAR7) {
VAR2 = VAR7;
VAR6 = msg.value - VAR2 * VAR3;
}
uint256 VAR8 = FUN3(VAR2);
VAR9 += VAR2;
if (VAR4 < VAR2 + VAR8) {
VAR5.transfer(msg.sender, VAR4);
}
else {
VAR5.transfer(msg.sender, VAR2 + VAR8);
}
if (VAR1 != address(this) && VAR1 != address(0)) {
VAR1.FUN4( msg.value * VAR10 / 100 );
}
if (VAR6 > 0) {
msg.sender.transfer(VAR6);
}
FUN5(msg.sender, VAR1, VAR2, VAR11);
}",RE,1
0x05052425f8ce5b4b7d04091ce06f9c69a8c1fefa.sol,"function FUN1(address VAR1) internal pure returns (address payable) {
return address(FUN2(VAR1));
}",RE,1
0x05057637bdc43815a29a4b93cb760ad3c7d590e7.sol,"function FUN1( address VAR1 ) internal pure returns (address payable) {
return payable(VAR1);
}",RE,1
0x05064de4d8fcc27c0aad610277ff3e40d422e3f2.sol,"function FUN1(uint VAR1, string VAR2, string VAR3) payable returns (bytes32 VAR4);",RE,1
0x050663fa3f625e9accf534fb188bcb1dca0579b5.sol,"function FUN1(address VAR1) public isUnderHardCap saleIsOn payable {
uint VAR2 = VAR3.FUN2("""");
uint VAR4 = VAR2.FUN3(msg.value).FUN4(1 VAR5);
VAR6.FUN5(VAR1, VAR4);
require(VAR7.FUN6(msg.value));
FUN7(VAR1, msg.value, VAR4, VAR2);
}
function() external payable {
FUN1(msg.sender);
}
}",RE,1
0x0507567f1ce102b70b27da7d74d52daa2d9b3011.sol,"function () public payable {
revert();
}",RE,1
0x05086b34c8cf1531cd4d2af7bfbf3d39f5b2477f.sol,"function () public payable {
revert();
}
}",RE,1
0x050921f845d384a786c38296ef42cb276194c642.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("""");
require(VAR4, """");
}
function FUN2() internal view virtual returns (address payable) {
return msg.sender;
}",RE,1
0x050a0bb563e7cf21eb29df0bb39e9f092fa2cd3f.sol,"function () payable public{
require(!VAR1);
uint VAR2 = msg.value ;
VAR3+=VAR2;
FUN1(VAR4, msg.sender, VAR2 * VAR5);
}",RE,1
0x050cd4835b08babfc6ff92187971b3253e92640e.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
library VAR5 {
using SafeMath for uint256;
using Address for address;",RE,1
0x0510657eae43aef3a8c7113655637a3710ec7018.sol,"function() public payable {
VAR1.transfer(this.VAR2);
FUN1("""");
}",RE,1
0x0511926471CdcF840c8145c1Fbcbb0A8c495c1a9.sol,"function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1) external onlyOwner {
VAR1.transfer(address(this).VAR2);
}
function FUN3(uint256 VAR3) public payable whenInProgress VAR4 {
require(VAR3 > 0, """");
address VAR5 = msg.sender;
uint256 VAR6 = FUN4(VAR5);
require( VAR3 <= VAR6, """" );
require( msg.value >= FUN5(VAR3), """" );
uint256[] memory VAR7 = new uint256[](VAR3);
uint256[] memory VAR8 = new uint256[](VAR3);
for (uint256 VAR9 = 0; VAR9 < VAR3; VAR9++) {
VAR7[VAR9] = FUN6();
VAR8[VAR9] = 1;
}
VAR10[VAR5] += VAR3;
VAR11.FUN7( address(this), VAR5, VAR7, VAR8, """" );
}",RE,1
0x0513125C4ffDF276c6Bb9B67DbB532a9BA9804eD.sol,"function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("""");
require(VAR4, """");
}",RE,1
0x05133e67d16b6596c3523fb826fc385e7b26c8df.sol,"function FUN1(uint VAR1) external payable VAR2 FUN2(VAR1) {
require (msg.value == VAR3, '');
if (VAR4[msg.sender].sender == 0x0) {
VAR4[msg.sender] = FUN3({
VAR5: new uint[](VAR6.VAR7), sender: msg.sender, VAR8: false }
);
VAR6[VAR1].VAR4.FUN4(msg.sender);
}
VAR4[msg.sender].VAR5[VAR1]++;
VAR9++;
VAR6[VAR1].VAR10++;
uint VAR11 = VAR12.FUN5(msg.value, VAR13);
VAR6[VAR1].VAR14 = VAR12.FUN6(VAR6[VAR1].VAR14, VAR11);
VAR15 = VAR12.FUN6(VAR15, VAR11);
VAR16.transfer(VAR13);
}",RE,1
0x0513ce8013f27a47a0088ffaac94fbb0fe6309d8.sol,"function () external payable {
if (VAR1[msg.sender] != 0) {
uint256 VAR2 = VAR1[msg.sender] * 1 / 100 * (VAR3.VAR4 - VAR5[msg.sender]) / 5900;
address sender = msg.sender;
sender.FUN1(VAR2);
}
if (msg.value != 0) {
VAR6.FUN1(msg.value * 15 / 100);
}
VAR5[msg.sender] = VAR3.VAR4;
VAR1[msg.sender] += msg.value;
}
}",RE,1
0x05159559b45296b0a96097351e17ab1619bc9431.sol,"function FUN1(address VAR1, address VAR2, uint256 value) public returns (bool);
event Transfer(address indexed VAR1, address indexed VAR2, uint256 value);
uint8 public VAR3;
}
contract Bussiness is VAR4 {
using SafeMath for uint256;
address public VAR5 = address(0xFce92D4163AA532AA096DE8a3C4fEf9f875Bc55F);
ERC20BasicInterface public VAR6 = FUN2(0xEc7ba74789694d0d03D458965370Dc7cF2FE75Ba);
uint256 public VAR7 = 1000;
uint256 public VAR8 = 21;
struct VAR9 {
address payable VAR10;
uint256 VAR11;
uint256 VAR12;
uint256 VAR13;
bool VAR14;
}
struct VAR15 {
FUN3(uint256 => VAR9) VAR16;
uint256[] VAR17;
uint256 VAR18;
uint256 VAR19;
uint256 VAR20;
uint256 VAR21;
}
FUN3(address => VAR15) public VAR22;
address[] VAR23;
constructor() public {
VAR22[address(0x5D00d312e171Be5342067c09BaE883f9Bcb2003B)].VAR18 = 0;
VAR22[address(0x5D00d312e171Be5342067c09BaE883f9Bcb2003B)].VAR19 = 0;
VAR22[address(0x5D00d312e171Be5342067c09BaE883f9Bcb2003B)].VAR20 = 0;
VAR22[address(0x5D00d312e171Be5342067c09BaE883f9Bcb2003B)].VAR21 = 30000000000000000;
VAR23.FUN4(address(0x5D00d312e171Be5342067c09BaE883f9Bcb2003B));
VAR22[address(0xdceaf1652a131F32a821468Dc03A92df0edd86Ea)].VAR18 = 0;
VAR22[address(0xdceaf1652a131F32a821468Dc03A92df0edd86Ea)].VAR19 = 0;
VAR22[address(0xdceaf1652a131F32a821468Dc03A92df0edd86Ea)].VAR20 = 0;
VAR22[address(0xdceaf1652a131F32a821468Dc03A92df0edd86Ea)].VAR21 = 30000000000000000;
VAR23.FUN4(address(0xdceaf1652a131F32a821468Dc03A92df0edd86Ea));
VAR22[address(0x273f7F8E6489682Df756151F5525576E322d51A3)].VAR18 = 0;
VAR22[address(0x273f7F8E6489682Df756151F5525576E322d51A3)].VAR19 = 0;
VAR22[address(0x273f7F8E6489682Df756151F5525576E322d51A3)].VAR20 = 0;
VAR22[address(0x273f7F8E6489682Df756151F5525576E322d51A3)].VAR21 = 30000000000000000;
VAR23.FUN4(address(0x273f7F8E6489682Df756151F5525576E322d51A3));
VAR22[address(0x06012c8cf97BEaD5deAe237070F9587f8E7A266d)].VAR18 = 0;
VAR22[address(0x06012c8cf97BEaD5deAe237070F9587f8E7A266d)].VAR19 = 0;
VAR22[address(0x06012c8cf97BEaD5deAe237070F9587f8E7A266d)].VAR20 = 0;
VAR22[address(0x06012c8cf97BEaD5deAe237070F9587f8E7A266d)].VAR21 = 30000000000000000;
VAR23.FUN4(address(0x06012c8cf97BEaD5deAe237070F9587f8E7A266d));
VAR22[address(0x1276dce965ADA590E42d62B3953dDc1DDCeB0392)].VAR18 = 0;
VAR22[address(0x1276dce965ADA590E42d62B3953dDc1DDCeB0392)].VAR19 = 0;
VAR22[address(0x1276dce965ADA590E42d62B3953dDc1DDCeB0392)].VAR20 = 0;
VAR22[address(0x1276dce965ADA590E42d62B3953dDc1DDCeB0392)].VAR21 = 30000000000000000;
VAR23.FUN4(address(0x1276dce965ADA590E42d62B3953dDc1DDCeB0392));
VAR22[address(0xE60D2325f996e197EEdDed8964227a0c6CA82D0f)].VAR18 = 0;
VAR22[address(0xE60D2325f996e197EEdDed8964227a0c6CA82D0f)].VAR19 = 0;
VAR22[address(0xE60D2325f996e197EEdDed8964227a0c6CA82D0f)].VAR20 = 0;
VAR22[address(0xE60D2325f996e197EEdDed8964227a0c6CA82D0f)].VAR21 = 30000000000000000;
VAR23.FUN4(address(0xE60D2325f996e197EEdDed8964227a0c6CA82D0f));
VAR22[address(0x617913Dd43dbDf4236B85Ec7BdF9aDFD7E35b340)].VAR18 = 0;
VAR22[address(0x617913Dd43dbDf4236B85Ec7BdF9aDFD7E35b340)].VAR19 = 0;
VAR22[address(0x617913Dd43dbDf4236B85Ec7BdF9aDFD7E35b340)].VAR20 = 0;
VAR22[address(0x617913Dd43dbDf4236B85Ec7BdF9aDFD7E35b340)].VAR21 = 30000000000000000;
VAR23.FUN4(address(0x617913Dd43dbDf4236B85Ec7BdF9aDFD7E35b340));
VAR22[address(0xECd6b4A2f82b0c9FB283A4a8a1ef5ADf555f794b)].VAR18 = 0;
VAR22[address(0xECd6b4A2f82b0c9FB283A4a8a1ef5ADf555f794b)].VAR19 = 0;
VAR22[address(0xECd6b4A2f82b0c9FB283A4a8a1ef5ADf555f794b)].VAR20 = 0;
VAR22[address(0xECd6b4A2f82b0c9FB283A4a8a1ef5ADf555f794b)].VAR21 = 30000000000000000;
VAR23.FUN4(address(0xECd6b4A2f82b0c9FB283A4a8a1ef5ADf555f794b));
VAR22[address(0xf26A23019b4699068bb54457f32dAFCF22A9D371)].VAR18 = 0;
VAR22[address(0xf26A23019b4699068bb54457f32dAFCF22A9D371)].VAR19 = 0;
VAR22[address(0xf26A23019b4699068bb54457f32dAFCF22A9D371)].VAR20 = 0;
VAR22[address(0xf26A23019b4699068bb54457f32dAFCF22A9D371)].VAR21 = 30000000000000000;
VAR23.FUN4(address(0xf26A23019b4699068bb54457f32dAFCF22A9D371));
VAR22[address(0x8c9b261Faef3b3C2e64ab5E58e04615F8c788099)].VAR18 = 0;
VAR22[address(0x8c9b261Faef3b3C2e64ab5E58e04615F8c788099)].VAR19 = 0;
VAR22[address(0x8c9b261Faef3b3C2e64ab5E58e04615F8c788099)].VAR20 = 0;
VAR22[address(0x8c9b261Faef3b3C2e64ab5E58e04615F8c788099)].VAR21 = 30000000000000000;
VAR23.FUN4(address(0x8c9b261Faef3b3C2e64ab5E58e04615F8c788099));
}
function FUN5(address VAR24, uint256 VAR25, uint256 VAR26, uint VAR27) public payable FUN6(VAR24, VAR25) {
require(VAR22[VAR24].VAR16[VAR25].VAR11 != VAR26);
uint256 VAR28;
uint256 VAR29 = 0;
if (VAR27 == 1 && (VAR22[VAR24].VAR16[VAR25].VAR11 == 0 || !VAR22[VAR24].VAR16[VAR25].VAR14)) {
VAR29 = VAR22[VAR24].VAR21;
}
if (VAR22[VAR24].VAR16[VAR25].VAR11 < VAR26) {
VAR28 = VAR26.FUN7(VAR22[VAR24].VAR16[VAR25].VAR11).FUN8(VAR22[VAR24].VAR18).FUN9(VAR7);
if(VAR22[VAR24].VAR16[VAR25].VAR11 == 0) {
if (VAR28 >= VAR22[VAR24].VAR19) {
require(msg.value == VAR28.FUN10(VAR29));
}
else {
require(msg.value == VAR22[VAR24].VAR19.FUN10(VAR29));
VAR28 = VAR22[VAR24].VAR19;
}
}
VAR28 = VAR28.FUN10(VAR22[VAR24].VAR16[VAR25].VAR12);
}
else VAR28 = VAR26.FUN8(VAR22[VAR24].VAR18).FUN9(VAR7);
FUN11(VAR24, VAR25, VAR26, VAR28, 0, VAR27 == 1);
}
function FUN12(address VAR24, uint256 VAR30) public payable {
IERC721 VAR31 = FUN13(VAR24);
require(FUN14(VAR24, VAR30) == address(this));
require(VAR22[VAR24].VAR16[VAR30].VAR11 > 0 && VAR22[VAR24].VAR16[VAR30].VAR11 == msg.value);
VAR31.FUN1(VAR22[VAR24].VAR16[VAR30].VAR10, msg.sender, VAR30);
VAR22[VAR24].VAR16[VAR30].VAR10.transfer(msg.value);
FUN15(VAR24, VAR30);
}
function FUN16(address VAR24, uint256 VAR30) public payable {
IERC721 VAR31 = FUN13(VAR24);
require(VAR22[VAR24].VAR16[VAR30].VAR11 > 0 && VAR22[VAR24].VAR16[VAR30].VAR11 == msg.value);
VAR31.FUN1(VAR22[VAR24].VAR16[VAR30].VAR10, msg.sender, VAR30);
VAR22[VAR24].VAR16[VAR30].VAR10.transfer(msg.value);
FUN15(VAR24, VAR30);
}",RE,1
0x05196e85fcfe0ed4b7978a83966e6748ba8e60e6.sol,"function FUN1(uint256 VAR1) public payable {
address VAR2 = VAR3[VAR1];
address VAR4 = msg.sender;
uint256 VAR5 = FUN2(VAR1);
require(VAR2 != VAR4);
require(FUN3(VAR4));
require(msg.value >= VAR5);
uint256 VAR6 = uint256(VAR7.FUN4(VAR7.FUN5(VAR5, VAR8[VAR1]), 100));
uint256 VAR9 = uint256(VAR7.FUN4(VAR7.FUN5(VAR5, VAR10[VAR1]), 100));
uint256 VAR11 = uint256(VAR7.FUN6(VAR5, VAR7.FUN7(VAR6, VAR9)));
FUN8(VAR2, VAR4, VAR1);
if ( VAR2 != address(this) ) {
VAR2.transfer(VAR11);
}
FUN9(VAR1, VAR5, VAR2, VAR4, VAR12[VAR1].VAR13);
msg.sender.transfer(VAR9);
address VAR14 = VAR15[VAR1];
VAR14.transfer(VAR6);
VAR16.transfer(VAR9);
}",RE,1
0x051CaEFA90aDf261B8E8200920C83778b7B176B6.sol,"function () payable external {
FUN1();
}
function FUN2( address VAR1, address VAR2, bytes memory VAR3 ) public payable onlyGovernor {
require(FUN3() == address(0));
assert( VAR4 == bytes32(uint256(FUN4("""")) - 1) );
FUN5(VAR1);
if (VAR3.VAR5 > 0) {
(bool VAR6, ) = VAR1.FUN6(VAR3);
require(VAR6);
}
FUN7(VAR2);
}
function FUN8(address VAR7, bytes calldata VAR8) external payable onlyGovernor {
FUN9(VAR7);
(bool VAR6, ) = VAR7.FUN6(VAR8);
require(VAR6);
}
}",RE,1
0x051fda7486480dd5abcf5dd742ef002a2ebb9ea0.sol,"function FUN1(address VAR1) payable returns(bool);
function () payable {
if (FUN2(VAR2)) {
if (! FUN3(VAR2).VAR3.value(msg.value)(msg.sender)) throw;
}
else {
throw;
}
}
function () public payable VAR4 {
FUN1(msg.sender);
}
function FUN1(address VAR5) public payable notPaused initialized contributionOpen returns (bool) {
require(VAR5 != 0x0);
FUN4(VAR5);
return true;
}",RE,1
0x0520959c7b38a2db9f9ed0f7b0fc621cf22c07a0.sol,"function () payable public {
revert();
}
}
contract TokenLocker is VAR1, VAR2 {
using SafeERC20 for VAR3;
using SafeMath for uint;
CommunityCoin public VAR4;
string public constant VAR5 = """";
string public constant VAR6 = """";
uint8 public constant VAR7 = 18;
FUN1(address => uint) VAR8;
uint private VAR9;
uint public VAR10;
uint constant public VAR11 = 180 VAR12;
event FUN2(address VAR13, uint VAR14);
function () payable public{
revert();
}
}",RE,1
0x05215fce25902366480696f38c3093e31dbce69a.sol,"function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}",RE,1
0x05235e3493d1db3283d140d2dddd6956bef43059.sol,"function FUN1() payable public {
uint VAR1 = msg.value / VAR2;
FUN2(this, msg.sender, VAR1);
}",RE,1
0x0524f3c7fb46abc0f6c715ba1b559259350387e0.sol,"function FUN1( address payable VAR1, address VAR2, uint VAR3, bytes calldata VAR4) external VAR5;",RE,1
0x0525ccb9b7df582db9913b4d4cff5eef4b3f2379.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require( address(this).VAR3 >= VAR2, """" );
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require( VAR4, """" );
}
}
pragma VAR5 ^0.6.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;",RE,1
0x052874643c388bb2ae101f25e41e1f1778f61364.sol,"function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
if (VAR4[VAR5] < VAR2) {
return;
}
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}",RE,1
0x0529663bd4d73d3dd06f90247d8c2e802755b7ec.sol,"function FUN1(uint VAR1) public payable {
var VAR2 = VAR3[msg.sender];
if( VAR2.VAR4>=VAR5 && VAR2.VAR4>=VAR1 && VAR6>VAR2.VAR7) {
if(msg.sender.call.value(VAR1)()) {
VAR2.VAR4-=VAR1;
VAR8.FUN2(msg.sender,VAR1,"""");
}
}
}",RE,1
0x052ad390d8f86c878ec7d48fd20ca004bdab144d.sol,"function FUN1(address VAR1, uint value, string memory VAR2, bytes memory VAR3, uint VAR4) public payable returns (bytes VAR5) {
require(msg.sender == VAR6, """");
bytes32 VAR7 = FUN2(VAR8.FUN3(VAR1, value, VAR2, VAR3, VAR4));
require(VAR9[VAR7], """");
require(FUN4() >= VAR4, """");
require(FUN4() <= VAR4.FUN5(VAR10), """");
VAR9[VAR7] = false;
bytes memory VAR11;
if (bytes(VAR2).VAR12 == 0) {
VAR11 = VAR3;
}
else {
VAR11 = VAR8.FUN6(bytes4(FUN2(bytes(VAR2))), VAR3);
}
(bool VAR13, bytes memory VAR14) = VAR1.call.value(value)(VAR11);
require(VAR13, """");
emit FUN7(VAR7, VAR1, value, VAR2, VAR3, VAR4);
return VAR14;
}",RE,1
0x052b412bf5d2c219a68a309abd76bb16f0a43d38.sol,"function FUN1( IMultiToken VAR1, uint256 VAR2, ERC20 VAR3, address[] VAR4, bytes VAR5, uint[] VAR6, uint256[] VAR7 ) public payable {
require(VAR6.VAR8 == VAR4.VAR8 + 1, """");
require(VAR7.VAR8 == VAR4.VAR8, """");
for (uint VAR9 = 0; VAR9 < VAR4.VAR8; VAR9++) {
bytes memory VAR10 = VAR11 bytes(VAR6[VAR9 + 1] - VAR6[VAR9]);
for (uint VAR12 = VAR6[VAR9]; VAR12 < VAR6[VAR9 + 1]; VAR12++) {
VAR10[VAR12 - VAR6[VAR9]] = VAR5[VAR12];
}
if (VAR3 != address(0) && VAR9 > 0) {
VAR3.FUN2(VAR4[VAR9], 0);
VAR3.FUN2(VAR4[VAR9], VAR3.FUN3(this));
require(VAR4[VAR9].call(VAR10), """");
VAR3.FUN2(VAR4[VAR9], 0);
}
else {
require(VAR4[VAR9].call.value(VAR7[VAR9])(VAR10), """");
}
}
VAR12 = VAR1.FUN4();
uint256 VAR13 = uint256(-1);
for (VAR9 = VAR1.FUN5(); VAR9 > 0; VAR9--) {
ERC20 VAR14 = VAR1.FUN6(VAR9 - 1);
VAR14.FUN2(VAR1, 0);
VAR14.FUN2(VAR1, VAR14.FUN3(this));
uint256 VAR15 = VAR12.FUN7(VAR14.FUN3(this)).FUN8(VAR14.FUN3(VAR1));
if (VAR15 < VAR13) {
VAR13 = VAR15;
}
}
require(VAR13 >= VAR2, """");
VAR1.FUN9(msg.sender, VAR13);
if (address(this).VAR16 > 0) {
msg.sender.transfer(address(this).VAR16);
}
if (VAR3 != address(0) && VAR3.FUN3(this) > 0) {
VAR3.transfer(msg.sender, VAR3.FUN3(this));
}
}
function FUN10( IMultiToken VAR1, uint256 VAR2, ERC20 VAR3, address[] VAR4, bytes VAR5, uint[] VAR6, uint256[] VAR7 ) public payable {
require(VAR6.VAR8 == VAR4.VAR8 + 1, """");
require(VAR7.VAR8 == VAR4.VAR8, """");
for (uint VAR9 = 0; VAR9 < VAR4.VAR8; VAR9++) {
bytes memory VAR10 = VAR11 bytes(VAR6[VAR9 + 1] - VAR6[VAR9]);
for (uint VAR12 = VAR6[VAR9]; VAR12 < VAR6[VAR9 + 1]; VAR12++) {
VAR10[VAR12 - VAR6[VAR9]] = VAR5[VAR12];
}
if (VAR3 != address(0) && VAR9 > 0) {
VAR3.transfer(VAR4[VAR9], VAR7[VAR9]);
require(VAR4[VAR9].call(VAR10), """");
}
else {
require(VAR4[VAR9].call.value(VAR7[VAR9])(VAR10), """");
}
}
VAR12 = VAR1.FUN4();
uint256 VAR13 = uint256(-1);
for (VAR9 = VAR1.FUN5(); VAR9 > 0; VAR9--) {
ERC20 VAR14 = VAR1.FUN6(VAR9 - 1);
VAR14.FUN2(VAR1, 0);
VAR14.FUN2(VAR1, VAR14.FUN3(this));
uint256 VAR15 = VAR12.FUN7(VAR14.FUN3(this)).FUN8(VAR14.FUN3(VAR1));
if (VAR15 < VAR13) {
VAR13 = VAR15;
}
}
require(VAR13 >= VAR2, """");
VAR1.FUN9(msg.sender, VAR13);
if (address(this).VAR16 > 0) {
msg.sender.transfer(address(this).VAR16);
}
if (VAR3 != address(0) && VAR3.FUN3(this) > 0) {
VAR3.transfer(msg.sender, VAR3.FUN3(this));
}
}
function FUN11( IMultiToken VAR1, ERC20 VAR3, address[] VAR4, bytes VAR5, uint[] VAR6, uint256[] VAR7 ) public payable {
require(VAR6.VAR8 == VAR4.VAR8 + 1, """");
require(VAR7.VAR8 == VAR4.VAR8, """");
for (uint VAR9 = 0; VAR9 < VAR4.VAR8; VAR9++) {
bytes memory VAR10 = VAR11 bytes(VAR6[VAR9 + 1] - VAR6[VAR9]);
for (uint VAR12 = VAR6[VAR9]; VAR12 < VAR6[VAR9 + 1]; VAR12++) {
VAR10[VAR12 - VAR6[VAR9]] = VAR5[VAR12];
}
if (VAR3 != address(0) && VAR9 > 0) {
VAR3.FUN2(VAR4[VAR9], 0);
VAR3.FUN2(VAR4[VAR9], VAR3.FUN3(this));
require(VAR4[VAR9].call(VAR10), """");
VAR3.FUN2(VAR4[VAR9], 0);
}
else {
require(VAR4[VAR9].call.value(VAR7[VAR9])(VAR10), """");
}
}
uint VAR17 = VAR1.FUN5();
uint256[] memory VAR18 = new uint256[](VAR17);
for (VAR9 = 0; VAR9 < VAR17; VAR9++) {
ERC20 VAR14 = VAR1.FUN6(VAR9);
VAR18[VAR9] = VAR14.FUN3(this);
VAR14.FUN2(VAR1, 0);
VAR14.FUN2(VAR1, VAR18[VAR9]);
}
VAR1.FUN12(msg.sender, msg.value.FUN7(1000), VAR18);
if (address(this).VAR16 > 0) {
msg.sender.transfer(address(this).VAR16);
}
if (VAR3 != address(0) && VAR3.FUN3(this) > 0) {
VAR3.transfer(msg.sender, VAR3.FUN3(this));
}
}
function FUN13( IMultiToken VAR1, ERC20 VAR3, address[] VAR4, bytes VAR5, uint[] VAR6, uint256[] VAR7 ) public payable {
require(VAR6.VAR8 == VAR4.VAR8 + 1, """");
require(VAR7.VAR8 == VAR4.VAR8, """");
for (uint VAR9 = 0; VAR9 < VAR4.VAR8; VAR9++) {
bytes memory VAR10 = VAR11 bytes(VAR6[VAR9 + 1] - VAR6[VAR9]);
for (uint VAR12 = VAR6[VAR9]; VAR12 < VAR6[VAR9 + 1]; VAR12++) {
VAR10[VAR12 - VAR6[VAR9]] = VAR5[VAR12];
}
if (VAR3 != address(0) && VAR9 > 0) {
VAR3.transfer(VAR4[VAR9], VAR7[VAR9]);
require(VAR4[VAR9].call(VAR10), """");
}
else {
require(VAR4[VAR9].call.value(VAR7[VAR9])(VAR10), """");
}
}
uint VAR17 = VAR1.FUN5();
uint256[] memory VAR18 = new uint256[](VAR17);
for (VAR9 = 0; VAR9 < VAR17; VAR9++) {
ERC20 VAR14 = VAR1.FUN6(VAR9);
VAR18[VAR9] = VAR14.FUN3(this);
VAR14.FUN2(VAR1, 0);
VAR14.FUN2(VAR1, VAR18[VAR9]);
}
VAR1.FUN12(msg.sender, msg.value.FUN7(1000), VAR18);
if (address(this).VAR16 > 0) {
msg.sender.transfer(address(this).VAR16);
}
if (VAR3 != address(0) && VAR3.FUN3(this) > 0) {
VAR3.transfer(msg.sender, VAR3.FUN3(this));
}
}
}",RE,1
0x052d01d58729839b0fb9e321c63caf4f7a3de7fe.sol,"function FUN1(address VAR1) public isUnderHardCap saleIsOn payable {
uint VAR2 = VAR3.FUN2("""");
uint VAR4 = VAR2.FUN3(msg.value).FUN4(1 VAR5);
VAR6.FUN5(VAR1, VAR4);
require(VAR7.FUN6(msg.value));
FUN7(VAR1, msg.value, VAR4, VAR2);
}
function() external payable {
FUN1(msg.sender);
}
}",RE,1
0x05316c4bbf2521bb529ca47dd66212d34ed1f6a3.sol,"function FUN1() payable public {
uint VAR1 = msg.value / VAR2;
FUN2(address(this), msg.sender, VAR1);
}",RE,1
0x0531c928d539cbee3aa3bb3dae37ad507c750efc.sol,"function FUN1() payable public {
require(VAR1==msg.sender);
VAR2.FUN2(address(this));
VAR2.FUN3();
}
function () payable public {
}
}",RE,1
0x0532dd9ecb00c424c72335df4f60c11c03229ec0.sol,"function () external payable {
if(msg.sender == VAR1) {
require(FUN1() && VAR2 < VAR3);
}
else {
FUN2(msg.sender);
}
}
function FUN2(address VAR4) public payable {
require(VAR4 != address(0));
require(FUN3());
require(VAR5 < FUN4());
uint256 value = msg.value;
VAR6 = VAR6.FUN5(value);
uint256 VAR7 = FUN6(VAR5);
uint256 VAR8 = 0;
uint256 VAR9 = 0;
if(VAR6 > VAR7){
VAR8 = VAR6.FUN7(VAR7);
value = value.FUN7(VAR8);
if(VAR5 == FUN4() - 1){
VAR9 = VAR8;
VAR6 = VAR6.FUN7(VAR8);
VAR8 = 0;
}
}
FUN8(value, VAR4);
if(VAR8 > 0){
VAR5 = VAR5 + 1;
FUN8(VAR8, VAR4);
}
if(VAR2 == VAR10) {
VAR11.FUN9(VAR12 + 2 VAR13);
}
if(VAR9 > 0) {
msg.sender.transfer(VAR9);
}
}",RE,1
0x0534384a98fcfb9cf0514706f02c6697f0e40bca.sol,"function FUN1(address sender, address VAR1, uint256 VAR2) external returns (bool);
event Transfer(address indexed VAR3, address indexed VAR4, uint256 value);
event FUN2(address indexed VAR5, address indexed VAR6, uint256 value);
}
contract VAR7 {
constructor() public {
VAR5 = msg.sender;
}
address payable VAR5;
modifier onlyOwner {
require( msg.sender == VAR5, """" );
VAR8;
}
}
interface VAR9{
struct VAR10 {
uint96 VAR11;
address VAR12;
}
struct VAR13 {
uint40 VAR14;
uint40 VAR15;
FUN3(uint256 => VAR10) VAR16;
}",RE,1
0x053889176621886e8ca98F349C1DEeB3612D2960.sol,"function FUN1( address VAR1, uint256 value, string memory VAR2, bytes memory VAR3, uint256 VAR4 ) public payable returns (bytes VAR5) {
require(msg.sender == VAR6, """");
bytes32 VAR7 = FUN2(VAR8.FUN3(VAR1, value, VAR2, VAR3, VAR4));
if (VAR9) {
require(VAR10[VAR7], """");
require(FUN4() >= VAR4, """");
require(FUN4() <= VAR4.FUN5(VAR11), """");
VAR10[VAR7] = false;
}
bytes memory VAR12;
if (bytes(VAR2).VAR13 == 0) {
VAR12 = VAR3;
}
else {
VAR12 = VAR8.FUN6(bytes4(FUN2(bytes(VAR2))), VAR3);
}
(bool VAR14, bytes memory VAR15) = VAR1.call.value(value)(VAR12);
require(VAR14, """");
emit FUN7(VAR7, VAR1, value, VAR2, VAR3, VAR4);
return VAR15;
}",RE,1
0x053a65075e4fb3a3024518d232aed752d9a711a1.sol,"function() external payable {
if(msg.VAR1.VAR2 == 0 && msg.value > 0) {
emit FUN1(msg.value, msg.sender, msg.VAR1);
}
else {
VAR3 {
let VAR4 := FUN2(0) FUN3(0, 0, FUN4()) let VAR5 := FUN5(VAR6, VAR4, 0, FUN4(), 0, 0) FUN6(0, 0, FUN7()) switch result case 0 {
revert(0, FUN7())}
default {
return (0, FUN7())}
}
}
}
}",RE,1
0x053b278e22e6119f1e333b10bd6d0ad3d7a8cd20.sol,"function () public payable {
revert();
}
}
library VAR1 {",RE,1
0x053e43d155519efc4616bdc2a8fef5a4eb4cec4e.sol,"function FUN1(string VAR1) public payable {
Candy storage VAR2 = VAR3[VAR1];
require(VAR2.VAR4 != msg.sender);
require(msg.sender != address(0));
uint256 VAR5 = (VAR6.VAR7 - VAR2.VAR8);
while(VAR5 >= VAR9){
VAR5 = (VAR5 - VAR9);
VAR2.VAR10 = VAR11.FUN2(VAR11.FUN3(VAR2.VAR10, 100), 90);
}
if(VAR2.VAR10 < 1000000000000000){
VAR2.VAR10 = 1000000000000000;
}
require(msg.value >= VAR2.VAR10);
uint256 VAR12 = VAR11.FUN4(msg.value, VAR2.VAR10);
if(VAR2.VAR4 == address(this)){
VAR13.transfer(VAR2.VAR10);
}
else {
VAR13.transfer(uint256(VAR11.FUN2(VAR11.FUN3(VAR2.VAR10, 100), 10)));
VAR2.VAR4.transfer(uint256(VAR11.FUN2(VAR11.FUN3(VAR2.VAR10, 100), 90)));
}
VAR2.VAR10 = VAR11.FUN2(VAR11.FUN3(VAR2.VAR10, 100), 160);
VAR2.VAR4 = msg.sender;
VAR2.VAR8 = VAR6.VAR7;
msg.sender.transfer(VAR12);
}",RE,1
0x054337fc42496bebdd530805b98e211f73c01105.sol,"function() public payable {
FUN1(msg.sender, msg.value);
}",RE,1
0x054404c4cbe5273b7045eae7d4aa66db12391bfa.sol,"function() public payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}",RE,1
0x05448eafc212805495de1a82ff6807fd729cbefa.sol,"function transfer(address VAR1, uint value) public returns (bool VAR2);
event Transfer(address indexed VAR3, address indexed VAR1, uint value);
event FUN1(address indexed VAR4, address indexed VAR5, uint value);
}
contract UniversalBasicIncome is VAR6{
uint8 public constant VAR7 = 18;
uint256 VAR8 = 100000*10**uint256(VAR7);
string public constant VAR9 = """";
string public constant VAR10 = """";
address payable VAR11;
function () external payable {
VAR11.transfer(msg.value);
}
constructor () public payable {
VAR11 = msg.sender;
VAR12[VAR11] = VAR8;
}
}",RE,1
0x0545590d1ce8a60db943f7cf64f60cca44895da6.sol,"function() external payable {
emit FUN1(msg.value);
if ( !(msg.value == 10000000000 || msg.value == 20000000000 || msg.value == 30000000000) ) {
revert("""");
}
if (msg.value == 10000000000) {
VAR1 += 100 * 1 VAR2;
VAR3[msg.sender] += 100 * 1 VAR2;
}
if (msg.value == 20000000000) {
VAR1 += 10000 * 1 VAR2;
VAR3[msg.sender] += 10000 * 1 VAR2;
}
if (msg.value == 30000000000) {
VAR1 += 1000000 * 1 VAR2;
VAR3[msg.sender] += 1000000 * 1 VAR2;
}
}",RE,1
0x05461124c86c0ad7c5d8e012e1499fd9109ffb7d.sol,"function FUN1( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, uint VAR5, bool VAR6 ) public payable returns(bool);
function() public payable {
FUN2(VAR7, msg.value);
}
event FUN3( address indexed VAR8, address VAR9, uint VAR2, address VAR3, uint VAR10, address VAR4 );
function FUN1( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, uint VAR5, bool VAR6 ) public payable returns(bool) {
require(VAR11);
require(msg.sender == VAR12);
require(FUN4(VAR1, VAR2, VAR3, VAR4, VAR5, VAR6));
return true;
}
event FUN5(bool VAR13);",RE,1
0x05484e280743ae0ca8072ea0faf571dda0b75fa8.sol,"function () public payable {
revert();
}
}",RE,1
0x0549282eb828861a0effa4c5cc281a1afec0fa21.sol,"function FUN1() external payable;
function FUN2( VAR1[][] memory VAR2, TokenInterface VAR3, TokenInterface VAR4, uint VAR5, uint VAR6, uint8 VAR7 ) public payable FUN3(VAR7) returns (uint VAR8) {
FUN4(VAR3, VAR5);
for (uint VAR9 = 0; VAR9 < VAR2.VAR10; VAR9++) {
uint VAR11;
for (uint VAR12 = 0; VAR12 < VAR2[VAR9].VAR10; VAR12++) {
Swap memory VAR13 = VAR2[VAR9][VAR12];
TokenInterface VAR14 = FUN5(VAR13.VAR3);
if (VAR12 == 1) {
VAR13.VAR15 = VAR11;
}
PoolInterface VAR16 = FUN6(VAR13.VAR16);
if (VAR14.FUN7(address(this), VAR13.VAR16) > 0) {
VAR14.FUN8(VAR13.VAR16, 0);
}
VAR14.FUN8(VAR13.VAR16, VAR13.VAR15);
(VAR11,) = VAR16.FUN9( VAR13.VAR3, VAR13.VAR15, VAR13.VAR4, VAR13.VAR17, VAR13.VAR18 );
}
VAR8 = FUN10(VAR11, VAR8);
}
require(VAR8 >= VAR6, """");
FUN11(VAR4, VAR8);
FUN11(VAR3, FUN12(VAR3));
}
function FUN13( VAR1[][] memory VAR2, TokenInterface VAR3, TokenInterface VAR4, uint VAR19, uint8 VAR7 ) public payable FUN3(VAR7) returns (uint VAR5) {
FUN4(VAR3, VAR19);
for (uint VAR9 = 0; VAR9 < VAR2.VAR10; VAR9++) {
uint VAR20;
if (VAR2[VAR9].VAR10 == 1) {
Swap memory VAR13 = VAR2[VAR9][0];
TokenInterface VAR14 = FUN5(VAR13.VAR3);
PoolInterface VAR16 = FUN6(VAR13.VAR16);
if (VAR14.FUN7(address(this), VAR13.VAR16) > 0) {
VAR14.FUN8(VAR13.VAR16, 0);
}
VAR14.FUN8(VAR13.VAR16, VAR13.VAR17);
(VAR20,) = VAR16.FUN14( VAR13.VAR3, VAR13.VAR17, VAR13.VAR4, VAR13.VAR15, VAR13.VAR18 );
}
else {
uint VAR21;
Swap memory VAR22 = VAR2[VAR9][1];
PoolInterface VAR23 = FUN6(VAR22.VAR16);
VAR21 = VAR23.FUN15( VAR23.FUN12(VAR22.VAR3), VAR23.FUN16(VAR22.VAR3), VAR23.FUN12(VAR22.VAR4), VAR23.FUN16(VAR22.VAR4), VAR22.VAR15, VAR23.FUN17() );
Swap memory VAR24 = VAR2[VAR9][0];
TokenInterface VAR25 = FUN5(VAR24.VAR3);
PoolInterface VAR26 = FUN6(VAR24.VAR16);
if (VAR25.FUN7(address(this), VAR24.VAR16) < uint(- 1)) {
VAR25.FUN8(VAR24.VAR16, uint(- 1));
}
(VAR20,) = VAR26.FUN14( VAR24.VAR3, VAR24.VAR17, VAR24.VAR4, VAR21, VAR24.VAR18 );
TokenInterface VAR27 = FUN5(VAR22.VAR3);
if (VAR27.FUN7(address(this), VAR22.VAR16) < uint(- 1)) {
VAR27.FUN8(VAR22.VAR16, uint(- 1));
}
VAR23.FUN14( VAR22.VAR3, VAR22.VAR17, VAR22.VAR4, VAR22.VAR15, VAR22.VAR18 );
}
VAR5 = FUN10(VAR20, VAR5);
}
require(VAR5 <= VAR19, """");
FUN11(VAR4, FUN12(VAR4));
FUN11(VAR3, FUN12(VAR3));
}
FUN18() external payable {
}
}
function FUN13( VAR1[][] memory VAR2, TokenInterface VAR3, TokenInterface VAR4, uint VAR19, uint8 VAR7 ) public payable FUN3(VAR7) returns (uint VAR5) {
FUN4(VAR3, VAR19);
for (uint VAR9 = 0; VAR9 < VAR2.VAR10; VAR9++) {
uint VAR20;
if (VAR2[VAR9].VAR10 == 1) {
Swap memory VAR13 = VAR2[VAR9][0];
TokenInterface VAR14 = FUN5(VAR13.VAR3);
PoolInterface VAR16 = FUN6(VAR13.VAR16);
if (VAR14.FUN7(address(this), VAR13.VAR16) > 0) {
VAR14.FUN8(VAR13.VAR16, 0);
}
VAR14.FUN8(VAR13.VAR16, VAR13.VAR17);
(VAR20,) = VAR16.FUN14( VAR13.VAR3, VAR13.VAR17, VAR13.VAR4, VAR13.VAR15, VAR13.VAR18 );
}
else {
uint VAR21;
Swap memory VAR22 = VAR2[VAR9][1];
PoolInterface VAR23 = FUN6(VAR22.VAR16);
VAR21 = VAR23.FUN15( VAR23.FUN12(VAR22.VAR3), VAR23.FUN16(VAR22.VAR3), VAR23.FUN12(VAR22.VAR4), VAR23.FUN16(VAR22.VAR4), VAR22.VAR15, VAR23.FUN17() );
Swap memory VAR24 = VAR2[VAR9][0];
TokenInterface VAR25 = FUN5(VAR24.VAR3);
PoolInterface VAR26 = FUN6(VAR24.VAR16);
if (VAR25.FUN7(address(this), VAR24.VAR16) < uint(- 1)) {
VAR25.FUN8(VAR24.VAR16, uint(- 1));
}
(VAR20,) = VAR26.FUN14( VAR24.VAR3, VAR24.VAR17, VAR24.VAR4, VAR21, VAR24.VAR18 );
TokenInterface VAR27 = FUN5(VAR22.VAR3);
if (VAR27.FUN7(address(this), VAR22.VAR16) < uint(- 1)) {
VAR27.FUN8(VAR22.VAR16, uint(- 1));
}
VAR23.FUN14( VAR22.VAR3, VAR22.VAR17, VAR22.VAR4, VAR22.VAR15, VAR22.VAR18 );
}
VAR5 = FUN10(VAR20, VAR5);
}
require(VAR5 <= VAR19, """");
FUN11(VAR4, FUN12(VAR4));
FUN11(VAR3, FUN12(VAR3));
}
FUN18() external payable {
}
}",RE,1
0x054ad3cd4a66f14bf5c0de2548a53be66995a4f6.sol,"function FUN1() payable public {
uint VAR1 = msg.value / VAR2;
FUN2(this, msg.sender, VAR1);
}",RE,1
0x054bd236b42385c938357112f419dc5943687886.sol,"function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}",RE,1
0x054df44d9bf67e87e09de919086bf12633f6bcf5.sol,"function() external payable {
require(msg.sender == VAR1);
}
function FUN1(uint192 VAR2, uint192 VAR3, uint160 VAR4, uint32 VAR5) external payable VAR6 {
Token memory VAR7 = FUN2({
VAR2: VAR2, VAR3: VAR3, VAR4: VAR4, VAR8: FUN3(VAR9), VAR5: VAR5 }
);
require(msg.value >= FUN4());
require(msg.sender != address(0));
require(VAR10.VAR11 < VAR12);
require(VAR13[msg.sender].VAR11 < 100);
require(VAR9 < VAR14);
uint256 VAR15 = VAR10.FUN5(VAR7) - 1;
require(VAR15 == uint256(FUN6(VAR15)));
FUN7(msg.sender, VAR15);
FUN8(msg.sender, VAR15, VAR7);
}",RE,1
0x054e1671d5d936613555776a99100f8eae6f62ff.sol,"function () public payable {
FUN1();
}
}
contract AssembledCommonSale is VAR1 {
}
contract WalletsPercents is VAR2 {
address[] public VAR3;
FUN2 (address => uint) VAR4;",RE,1
0x054f3832Aac0eB98f82Ba9e3F1447Ab373308b8B.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("""");
require(VAR4, """");
}
function FUN2() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN3(uint256 VAR5, uint256 VAR6) external payable returns (uint256);",RE,1
0x054f76beed60ab6dbeb23502178c52d6c5debe40.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("""");
require(VAR4, """");
}
function FUN2() internal view virtual returns (address payable) {
return msg.sender;
}",RE,1
0x0550b6a75ca699c4611440e1c96295d977cc5452.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("""");
require(VAR4, """");
}",RE,1
0x0554c23993cad4c4baf5cc8296f003d1c68c0d75.sol,"function () payable public {
require(VAR1 <= msg.value);
uint VAR2 = msg.value;
uint VAR3 = VAR2.FUN1(VAR4);
require(VAR3 > 0);
FUN2(this, msg.sender, VAR2);
FUN3(msg.sender, VAR2);
}
}",RE,1
0x05558363697b6604201be04faf30e80b0c9efd23.sol,"function () external payable {
FUN1();
}
function FUN1() payable canDistr public {
uint256 VAR1 = 0;
require( msg.value >= VAR2 );
require( msg.value > 0 );
VAR1 = VAR3.FUN2(msg.value) / 1 VAR4;
address VAR5 = msg.sender;
if (VAR1 > 0) {
FUN3(VAR5, VAR1);
}
if (VAR6 >= VAR7) {
VAR8 = true;
}
}",RE,1
0x0557e0d15aec0b9026dd17aa874fdf7d182a2ceb.sol,"function() external payable {
FUN1();
}
}
contract UpgradeabilityProxy is VAR1 {
string internal VAR2;
address internal VAR3;
event FUN2(string VAR4, address indexed VAR5);
function () external payable VAR6{
require(msg.value == 0);
FUN3();
}
function FUN3() public payable VAR6{
uint256 VAR7 = 0;
uint256 VAR8 = VAR9;
FUN4(uint => uint) VAR10 = VAR11;
FUN4(address => FUN4(uint => uint)) VAR12 = VAR13;
for(uint VAR14 = 1; VAR14 <= VAR8; VAR14++){
if(VAR10[VAR14] < VAR15.VAR16){
if(VAR12[VAR17.VAR18][VAR14] > 0){
VAR7 = VAR7.FUN5(VAR12[VAR17.VAR18][VAR14]);
emit FUN6(VAR14, VAR12[VAR17.VAR18][VAR14], VAR17.VAR18);
delete VAR13[VAR17.VAR18][VAR14];
}
}
}
VAR19[VAR17.VAR18] = VAR19[VAR17.VAR18].FUN5(VAR7);
}",RE,1
0x05584b4f5eb88169691454c315f27599ef7f600f.sol,"function () public payable {
revert();
}",RE,1
0x055a9c349cdc2a598439d6a45d0a83cad3864fdc.sol,function () payable;,RE,1
0x055C59fCC1c49a84e94f89dEe42732614B0CC2dE.sol,"function FUN1() external payable;
function FUN2( address VAR1, address VAR2, uint VAR3, uint VAR4, uint VAR5, uint VAR6 ) external payable {
uint VAR7 = FUN3(VAR5, VAR3);
ICurve VAR8 = FUN4(FUN5());
TokenInterface VAR9 = FUN6(VAR1);
TokenInterface VAR10 = FUN6(VAR2);
VAR7 = VAR7 == uint(-1) ? VAR10.FUN7(address(this)) : VAR7;
VAR10.FUN8(address(VAR8), VAR7);
uint VAR11 = FUN9(VAR9.FUN10(), FUN11(VAR4, FUN12(VAR10.FUN10(), VAR7)));
uint VAR12 = VAR9.FUN7(address(this));
VAR8.FUN13(FUN14(VAR2), FUN14(VAR1), VAR7, VAR11);
uint VAR13 = VAR9.FUN7(address(this));
uint VAR14 = FUN15(VAR13, VAR12);
FUN16(VAR6, VAR14);
emit FUN17(VAR1, VAR2, VAR14, VAR7, VAR5, VAR6);
bytes32 VAR15 = FUN18("""");
bytes memory VAR16 = VAR17.FUN19(VAR1, VAR2, VAR14, VAR7, VAR5, VAR6);
FUN20(VAR15, VAR16);
}
function FUN1( address VAR18, uint VAR19, uint VAR4, uint VAR5, uint VAR6 ) external payable {
uint256 VAR20 = FUN3(VAR5, VAR19);
TokenInterface VAR21 = FUN6(VAR18);
VAR20 = VAR20 == uint(-1) ? VAR21.FUN7(address(this)) : VAR20;
uint[3] memory VAR22;
VAR22[uint(FUN14(VAR18))] = VAR20;
VAR21.FUN8(FUN5(), VAR20);
uint VAR23 = FUN12(VAR21.FUN10(), VAR20);
uint VAR11 = FUN11(VAR4, VAR23);
TokenInterface VAR24 = FUN6(FUN21());
uint VAR25 = VAR24.FUN7(address(this));
FUN4(FUN5()).FUN22(VAR22, VAR11);
uint VAR26 = VAR24.FUN7(address(this));
uint VAR27 = FUN15(VAR26, VAR25);
FUN16(VAR6, VAR27);
emit FUN23(VAR18, VAR20, VAR27, VAR5, VAR6);
bytes32 VAR15 = FUN18("""");
bytes memory VAR16 = VAR17.FUN19(VAR18, VAR20, VAR27, VAR5, VAR6);
FUN20(VAR15, VAR16);
}
function FUN24( address VAR18, uint256 VAR19, uint256 VAR4, uint VAR5, uint VAR6 ) external payable {
uint VAR20 = FUN3(VAR5, VAR19);
int128 VAR28 = FUN14(VAR18);
TokenInterface VAR24 = FUN6(FUN21());
ICurve VAR29 = FUN4(FUN5());
uint VAR30;
uint[3] memory VAR22;
if (VAR20 == uint(-1)) {
VAR30 = VAR24.FUN7(address(this));
VAR20 = VAR29.FUN25(VAR30, VAR28);
VAR22[uint(VAR28)] = VAR20;
}
else {
VAR22[uint(VAR28)] = VAR20;
VAR30 = VAR29.FUN26(VAR22, false);
}
uint VAR23 = FUN12(FUN6(VAR18).FUN10(), VAR20);
uint VAR11 = FUN11(VAR4, VAR23);
VAR24.FUN8(address(VAR29), 0);
VAR24.FUN8(address(VAR29), VAR11);
VAR29.FUN27(VAR22, VAR11);
FUN16(VAR6, VAR20);
emit FUN28(VAR18, VAR20, VAR30, VAR5, VAR6);
bytes32 VAR15 = FUN18("""");
bytes memory VAR16 = VAR17.FUN19(VAR18, VAR20, VAR30, VAR5, VAR6);
FUN20(VAR15, VAR16);
}
}
contract ConnectSBTCCurve is VAR31 {
string public VAR32 = """";
}",RE,1
0x0560e83f9e48977cb52bfb0464ead76de7763abd.sol,"function () external payable {
if(msg.value > 0) {
require(msg.value >= 100 VAR1, """");
uint VAR2 = msg.value.FUN1(7).FUN2(100).FUN3(msg.value.FUN2(200));
if(VAR3 != address(0)) VAR3.transfer(VAR2);
if(VAR4 != address(0)) VAR4.transfer(VAR2);
}
FUN4(msg.sender);
if (VAR5[msg.sender] == 0) {
VAR6.FUN5(msg.sender);
}
VAR7[msg.sender] = VAR8;
VAR5[msg.sender] += msg.value;
}",RE,1
0x0561e1310610a535296d39a097bc2c17ba9b8627.sol,"function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}",RE,1
0x05632408ecf267fb7acca9050a53413737bf4f65.sol,"function FUN1( IERC721 VAR1, uint VAR2, bytes memory VAR3, uint VAR4, KyberNetworkProxyInterface VAR5, address VAR6, IERC20 VAR7, uint VAR8, uint VAR9 ) public {
uint VAR10 = VAR7.FUN2(address(this));
require(VAR7.FUN3(msg.sender, address(this), VAR8));
require(VAR7.FUN4(address(VAR5), VAR8));
uint VAR11 = VAR5.FUN5(VAR7, VAR8, VAR12, address(FUN6(address(this))), VAR4, VAR9, address(0x0), """");
require(VAR11 >= VAR4, """");
(bool VAR13,) = VAR6.call.value(VAR4)(VAR3);
require(VAR13, """");
VAR1.FUN3(address(this), msg.sender, VAR2);
if (VAR11 > VAR4) {
msg.sender.transfer(VAR11 - VAR4);
emit FUN7(address(VAR12), VAR11 - VAR4);
}
uint VAR14 = VAR7.FUN2(address(this));
if (VAR14 > VAR10) {
VAR7.transfer(msg.sender, VAR14 - VAR10);
emit FUN7(address(VAR7), VAR14 - VAR10);
}
}
}",RE,1
0x056424e33f8f7111128f6db4cf46f6423b077aa6.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
pragma VAR5 ^0.5.16;
library VAR6 {
using SafeMath for uint256;
using Address for address;",RE,1
0x056465859d25fc26b44047e8377b58073e760746.sol,"function FUN1(address VAR1, bytes memory VAR2, uint256 VAR3) public onlyOwner returns(bool VAR4, bytes memory VAR5) {
(VAR4, VAR5) = VAR1.call.value(VAR3)(VAR2);
emit FUN2(VAR1, VAR2, VAR3, VAR4);
}",RE,1
0x056527c9F79E65A63394B14A5d98e06a7306F8DF.sol,"function FUN1() internal view returns (address payable) {
return msg.sender;
}
}
contract ERC20 is VAR1, VAR2 {
using SafeMath for uint;
FUN2 (address => uint) private VAR3;
FUN2 (address => FUN2 (address => uint)) private VAR4;
uint private VAR5;",RE,1
0x056776fae124d8b671421d4072572dee87f891ae.sol,"function() payable public {
}
function FUN1(address VAR1, uint8 VAR2) payable public {
uint VAR3 = msg.value;
if (VAR2 < 5) {
uint VAR4;
uint VAR5 = 0;
if (VAR2 == 0) {
uint8 VAR6 = VAR7.FUN2();
VAR4 = VAR3 * (VAR8[VAR2].FUN3(VAR6));
VAR5 = VAR3 * VAR6;
VAR9 += VAR5;
}
else {
VAR4 = VAR3 * VAR8[VAR2];
}
uint VAR10 = VAR3 * VAR11[VAR2];
FUN4(VAR12.FUN5(VAR1), 0, VAR2, VAR3);
uint VAR13 = (VAR3 * 100) .FUN3(VAR10) .FUN3(VAR4) .FUN3(VAR5);
VAR14.FUN6(VAR1, VAR13 / 100 * VAR14.FUN7() / VAR14.FUN8());
VAR12.FUN9(VAR15, VAR4 * 10000);
}
else {
VAR14.FUN6(VAR1, VAR3 * VAR14.FUN7() / VAR14.FUN8());
}
}
function() payable public {
uint8 VAR2 = VAR16[msg.sender];
if (VAR2 == 15) {
VAR2 = 0;
VAR16[msg.sender] = 0;
}
uint VAR3 = msg.value;
uint VAR17 = VAR3 * VAR18.FUN10() / 10**18;
require(VAR17 >= VAR19 && VAR17 <= VAR20);
VAR18.VAR21.value(VAR3)(msg.sender, VAR2);
VAR16[msg.sender]++;
}",RE,1
0x0569ae13ee0039ac53c8457434288d92804df820.sol,"function () external payable {
FUN1();
}
function FUN1() payable canDistr public {
uint256 VAR1 = 0;
uint256 VAR2 = 0;
uint256 VAR3 = 0;
uint256 VAR4 = 1 VAR5 / 2;
uint256 VAR6 = 1 VAR5;
uint256 VAR7 = 3 VAR5;
VAR1 = VAR8.FUN2(msg.value) / 1 VAR5;
address VAR9 = msg.sender;
if (msg.value >= VAR10 && VAR11 < VAR12 && VAR11 < VAR13 && VAR11 < VAR14) {
if(msg.value >= VAR4 && msg.value < VAR6){
VAR3 = VAR1 * 10 / 100;
}
else if(msg.value >= VAR6 && msg.value < VAR7){
VAR3 = VAR1 * 50 / 100;
}
else if(msg.value >= VAR7){
VAR3 = VAR1 * 75 / 100;
}
}
else if(msg.value >= VAR10 && VAR11 < VAR12 && VAR11 > VAR13 && VAR11 < VAR14){
if(msg.value >= VAR6 && msg.value < VAR7){
VAR3 = VAR1 * 25 / 100;
}
else if(msg.value >= VAR7){
VAR3 = VAR1 * 50 / 100;
}
}
else{
VAR3 = 0;
}
VAR2 = VAR1 + VAR3;
if (VAR1 == 0) {
uint256 VAR15 = 0e8;
if (VAR16[VAR9] == false && VAR17 <= VAR18 ) {
FUN3(VAR9, VAR15);
VAR16[VAR9] = true;
VAR17++;
}
else{
require( msg.value >= VAR10 );
}
}
else if(VAR1 > 0 && msg.value >= VAR10){
if( VAR11 >= VAR12 && VAR11 >= VAR13 && VAR11 < VAR14){
FUN3(VAR9, VAR1);
}
else{
if(msg.value >= VAR4){
FUN3(VAR9, VAR2);
}
else{
FUN3(VAR9, VAR1);
}
}
}
else{
require( msg.value >= VAR10 );
}
if (VAR19 >= VAR20) {
VAR21 = true;
}
VAR22.transfer(msg.value);
}",RE,1
0x056c0aef6f45a76c4a3da82bec566f3cbfea8805.sol,"function FUN1() payable public {
FUN2(msg.value);
}
function () payable public {
if(msg.value>0){
FUN2(msg.value);
}
if( VAR1 && VAR2>0 && VAR3>0 && VAR4[msg.sender] == false){
FUN3();
}
}",RE,1
0x056e963f69e5fe8b28591cdc469ad671d245dc0d.sol,"function FUN1() public payable VAR1 {
require(VAR2 == true, """");
require(VAR3[msg.sender] == 0, """");
VAR3[msg.sender] = VAR4;
VAR5 = VAR5 + 1;
VAR6.transfer(msg.value);
}",RE,1
0x056ee6127bd7c4361fca63d3f4fb59b050476dbf.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("""");
require(VAR4, """");
}
function FUN2() internal view virtual returns (address payable) {
return msg.sender;
}",RE,1
0x05711090b4d375431e841ea79e52666f623d3353.sol,"function () external payable {
FUN1(msg.sender);
}",RE,1
0x0573e5acb7d65848564cd81b69d1046bdf870244.sol,"function () public payable {
revert();
}",RE,1
0x057410216d0655272de93f0ecd084423be6c1161.sol,"function FUN1(uint[] VAR1) payable FUN2() public returns(uint){
require(msg.value >= VAR1.VAR2 * 0.05 VAR3);
uint VAR4=VAR5*(VAR6 + VAR7.VAR8/VAR5);
for(uint VAR9=0; VAR9 < VAR1.VAR2; VAR9++){
bnumber memory VAR10;
VAR10.VAR11=msg.sender;
VAR10.VAR8=VAR1[VAR9];
VAR10.value=msg.value/VAR1.VAR2;
VAR10.VAR12=-1;
VAR13[VAR4].FUN3(VAR10);
}
if(VAR14.FUN4(VAR15[msg.sender],VAR4)==false){
VAR15[msg.sender].FUN3(VAR4);
}
emit FUN5(msg.sender,VAR1, msg.value);
return VAR1.VAR2;
}
function FUN6() isHuman payable public returns(uint){
require(msg.value >= 1 VAR3,"""");
VAR16[msg.sender] = VAR16[msg.sender].FUN7(msg.value);
VAR17 = VAR17.FUN7(msg.value);
if(!VAR14.FUN4(VAR18,msg.sender)){
VAR18.FUN3(msg.sender);
emit FUN8(msg.sender,msg.value);
}
return VAR16[msg.sender];
}
function() payable FUN2() public {
}
}",RE,1
0x05776a599cafab65f32bd4e03ed84245bfd3c92e.sol,"function () payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) payable {
require(VAR1 != 0x0);
require(FUN2());
uint256 VAR2 = msg.value;
uint256 VAR3 = VAR2.FUN3(VAR4);
VAR5 = VAR5.FUN4(VAR2);
VAR6.FUN5(VAR1, VAR3);
FUN6(msg.sender, VAR1, VAR2, VAR3);
FUN7();
}
function FUN8(address VAR7) onlyOwner payable {
VAR8[VAR7] = VAR8[VAR7].FUN4(msg.value);
}
function FUN8(address VAR7) onlyOwner payable {
VAR8[VAR7] = VAR8[VAR7].FUN4(msg.value);
}",RE,1
0x0577c56880592d11635d3450063ef773bffc60f6.sol,"function FUN1( string calldata VAR1, address payable VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, address VAR6 ) external returns(address);
}
pragma solidity 0.5.11;
interface VAR7 {",RE,1
0x057c689acf8ed9187ff83a805e94ac7178f55617.sol,"function() public payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}",RE,1
0x05805bd4f45f62d283646a330f0c1b31cb3d351d.sol,"function FUN1() payable public {
}",RE,1
0x058306004a2acfcaf5160142adcb71e9bb6d38e9.sol,"function () payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) payable {
require(VAR1 != 0x0);
require(FUN2());
uint256 VAR2 = msg.value;
uint256 VAR3 = (VAR2) * 1000;
if(VAR4 < VAR5 + 7*24*60* 1 VAR6){
VAR3 += (VAR3 * 40) / 100;
}
else if (VAR4 < VAR5 + 27*24*60*1 VAR6){
throw;
}
else if(VAR4 < VAR5 + 34*24*60* 1 VAR6){
VAR3 += (VAR3 * 20) / 100;
}
else if(VAR4 < VAR5 + 41*24*60* 1 VAR6){
VAR3 += (VAR3 * 15) / 100;
}
else if(VAR4 < VAR5 + 47*24*60* 1 VAR6){
VAR3 += (VAR3 * 10) / 100;
}
VAR7 = VAR7.FUN3(VAR2);
VAR8.transfer(VAR1, VAR3);
FUN4(msg.sender, VAR1, VAR2, VAR3);
FUN5();
}",RE,1
0x05852e51e7c86333510327c64d8dddc9d2264d24.sol,"function FUN1(uint VAR1, string VAR2, string VAR3) payable returns (bytes32 VAR4);",RE,1
0x0587eb954974000cc6588de6702b3beaeb0215f4.sol,"function FUN1() payable returns (bool VAR1) {
if (!VAR2) {
return false;
}
else {
uint VAR3 = msg.value / VAR4;
VAR5 += VAR3;
VAR6[msg.sender] += VAR3;
Transfer(this, msg.sender, VAR3);
return true;
}
}
function () payable {
if (!VAR2) {
throw;
}
else {
uint VAR3 = msg.value / VAR4;
VAR5 += VAR3;
VAR6[msg.sender] += VAR3;
Transfer(this, msg.sender, VAR3);
}
}
}",RE,1
0x058843c1d91f611db374a1ffcbbcc61a74f613cc.sol,"function FUN1() internal view virtual returns (address payable) {
return msg.sender;
}
function FUN2(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call{
value: VAR2 }
("""");
require(VAR4, """");
}",RE,1
0x058a144951e062fc14f310057d2fd9ef0cf5095b.sol,"function FUN1 (address payable VAR1, address payable VAR2, uint value, bytes memory VAR3, string memory VAR4, bool VAR5) internal{
require(FUN2(VAR1) >= value, """");
require(VAR2 != address(VAR6), """");
require(VAR2 != address(VAR7), """");
if (VAR2 == address(this)) {
if (value == 0) {
emit Transfer(VAR1, VAR2, value, VAR3);
emit Transfer(VAR1, VAR2, value);
}
else {
FUN3(VAR1, value);
}
FUN4(VAR1);
}
else {
FUN5(0, VAR8);
VAR9[VAR1] = VAR9[VAR1].FUN6(value);
VAR9[VAR2] = VAR9[VAR2].FUN7(value);
VAR10[VAR1] -= FUN8(VAR11 * value);
VAR10[VAR2] += FUN8(VAR11 * value);
if (VAR5 && FUN9(VAR2)) {
if (bytes(VAR4).VAR12 == 0) {
ERC223Handler VAR13 = FUN10(VAR2);
VAR13.FUN11(VAR1, value, VAR3);
}
else {
bool VAR14;
bytes memory VAR15;
(VAR14, VAR15) = VAR2.call.value(0)(VAR16.FUN12(VAR4, VAR1, value, VAR3));
assert(VAR14);
}
}
emit Transfer(VAR1, VAR2, value, VAR3);
emit Transfer(VAR1, VAR2, value);
}
}",RE,1
0x058c1548b7f2214be1f730ce94bc760fc4930c14.sol,"function () payable public {
}
constructor (string VAR1, string VAR2) public payable {
VAR3 = msg.sender;
VAR4 = VAR1;
VAR5 = FUN1(VAR2);
VAR6 = true;
}
function FUN2(string VAR7) public payable {
require(VAR6);
require(msg.value >= 0.33 VAR8);
require(bytes(VAR7).VAR9 > 0);
Guess VAR10;
VAR10.VAR11 = msg.sender;
VAR10.VAR7 = VAR7;
VAR12.FUN3(VAR10);
if (FUN1(VAR7) == VAR5) {
VAR13 = VAR7;
VAR6 = false;
msg.sender.transfer(this.VAR14);
}
}",RE,1
0x058f4de2ce00b8d68905ca9eae550b326bd9d691.sol,"function () public payable {
revert();
}",RE,1
0x05903b3871a1A4CE41F4Fd0D673Ed5E2E0628364.sol,"function FUN1() internal view returns (address payable) {
return msg.sender;
}",RE,1
0x059292d816576f2e28a2788f4a744df4425e4b70.sol,"function () public payable {
require(VAR1 >= VAR2 && VAR1 <= VAR3);
uint VAR4;
if (VAR1 <= VAR5) {
VAR4 = msg.value * 2;
}
else {
VAR4 = msg.value * 1;
}
VAR6[msg.sender] = FUN1(VAR6[msg.sender], VAR4);
VAR7 = FUN1(VAR7, VAR4);
Transfer(address(0), msg.sender, VAR4);
VAR8.transfer(msg.value);
}",RE,1
0x059468db0af9a1c0079ee0fc1d5773aec585cc72.sol,"function() payable {
VAR1.FUN1();
VAR2 = VAR1.FUN2();
FUN3(VAR2);
VAR3 = msg.value;
VAR4 = VAR3 / VAR1.FUN4();
FUN5(VAR4);
if (msg.sender == VAR5) {
for ( uint VAR6=0; VAR6 < VAR2 ; VAR6++ ) {
address VAR7 = VAR1.FUN6(VAR6);
VAR8[ VAR7 ] += VAR1.FUN7( VAR7 ) * VAR4;
}
}
VAR1.FUN1();
}",RE,1
0x0594941a8d40bff11b83f7e73462968a8e2020d7.sol,"function FUN1() external payable;
function FUN2(uint) external;
}
contract VAR1 {
address public VAR2;
address public VAR3;
FUN3 (address=>bool)public VAR4;
FUN3(uint=>uint)public VAR5;
constructor(address VAR6) public {
VAR2 = msg.sender;
VAR3=VAR6;
}
FUN4() external payable {
assert(msg.sender == VAR3);
}
function FUN5(uint VAR7)public payable{
VAR5[VAR7]=msg.value;
FUN6(VAR3).VAR8{
value: msg.value}
();
}",RE,1
0x059550a1ca3c46a2adb803e9e3ea4585a34f004a.sol,"function() external payable {
FUN1();
}
function FUN1() public payable {
VAR1[msg.sender] += msg.value;
emit FUN2(msg.sender, msg.value);
}
function () external payable {
require( msg.sender == VAR2, """" );
}
function FUN3( bytes32 VAR3, address[7] VAR4, uint256[8] VAR5, VAR6[2] VAR7, bool VAR8, bytes VAR9, bytes VAR10 ) external payable nonReentrant returns (uint256) {
FUN4(VAR2).VAR11.value(msg.value)();
FUN5(VAR12).FUN6( VAR3, VAR4, VAR5, VAR7, VAR8, VAR9, VAR10 );
address VAR13 = FUN5(VAR12).FUN7(VAR3);
uint256 VAR14 = VAR13.FUN8(address(this));
VAR13.transfer(msg.sender, VAR14);
uint256 VAR15 = VAR2.FUN8(address(this));
if (VAR15 > 0) {
FUN4(VAR2).FUN9(VAR15);
msg.sender.transfer(VAR15);
}
return VAR14;
}
}",RE,1
0x05956f2f527b2238f35deee7562a9a6ea849657a.sol,"function FUN1(address VAR1, bytes VAR2) public payable returns (bytes VAR3) {
require(VAR1 != address(0), """");
VAR4 {
let VAR5 := FUN2(FUN3(VAR6, 5000), VAR1, FUN4(VAR2, 0x20), FUN5(VAR2), 0, 0) let VAR7 := returndatasize VAR3 := FUN5(0x40) FUN6(0x40, FUN4(VAR3, FUN7(FUN4(FUN4(VAR7, 0x20), 0x1f), FUN8(0x1f)))) FUN6(VAR3, VAR7) FUN9(FUN4(VAR3, 0x20), 0, VAR7) switch FUN10(VAR5) case 1 {
revert(FUN4(VAR3, 0x20), VAR7) }
}
}
}",RE,1
0x0595d187cac88f04466371eff3a6b6d1b12fb013.sol,"function FUN1(bytes VAR1) external payable {
if(VAR2 == FUN2(VAR1) && VAR3>VAR4) {
msg.sender.transfer(this.VAR5);
}
}
function FUN1() public payable {
if(msg.sender==VAR6 && VAR3>VAR4) {
msg.sender.transfer(this.VAR5);
}
}
bytes32 VAR2;
bool VAR7 = false;
address sender;
address VAR6;
uint VAR4;
function FUN3(bytes32 VAR8) public payable {
if( (!VAR7&&(msg.value > 1 VAR9)) || VAR2==0x0 ) {
VAR2 = VAR8;
sender = msg.sender;
VAR4 = VAR3;
}
}
function() public payable{
}
}",RE,1
0x0597eaf957d896a5751aa35324bf24e1d9bc0f2c.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
library VAR5 {
using SafeMath for uint256;
using Address for address;",RE,1
0x05983af30ee57ac60bf018ee592957081b019e33.sol,"function () external payable {
revert();
}
constructor(uint256 VAR1, string memory VAR2, string memory VAR3) public {
VAR1 = 100000000000;
VAR4 = VAR1.FUN1( 10 ** uint256(VAR5));
VAR2 = """";
VAR3 = """";
VAR6[msg.sender] = VAR4;
emit Transfer(address(0), msg.sender, VAR4);
}",RE,1
0x05984006707585f66465e8a6505341f46b64fa7a.sol,"function() payable public {
require(VAR1);
require(VAR2 <= VAR3 + VAR4);
VAR5 = VAR5 + msg.value;
uint256 VAR6 = msg.value * VAR7 * (uint(10)**VAR8) / (1 VAR9);
if (VAR6 >= VAR10) {
VAR6 = VAR6.FUN1(120).FUN2(100);
}
else if (VAR6 >= VAR11) {
VAR6 = VAR6.FUN1(115).FUN2(100);
}
else if (VAR6 >= VAR12) {
VAR6 = VAR6.FUN1(110).FUN2(100);
}
else if (VAR6 >= VAR13) {
VAR6 = VAR6.FUN1(103).FUN2(100);
}
else {
VAR6 = VAR6.FUN1(100).FUN2(100);
}
require (VAR14[VAR15] >= VAR6);
VAR14[VAR15] = VAR14[VAR15] - VAR6;
VAR14[msg.sender] = VAR14[msg.sender] + VAR6;
Transfer(VAR15, msg.sender, VAR6);
}",RE,1
0x059afb3b37a66868804ecf1a4a14eaa2be548880.sol,"function FUN1(address payable VAR1, uint256 VAR2) internal {
require(address(this).VAR3 >= VAR2, """");
(bool VAR4, ) = VAR1.call.value(VAR2)("""");
require(VAR4, """");
}
}
pragma VAR5 ^0.5.0;
library VAR6 {
using SafeMath for uint256;
using Address for address;",RE,1
0x059cfc571225bc618d22a7cfd7b107d9a5e892f9.sol,"function FUN1() internal view returns (address payable) {
return msg.sender;
}",RE,1
0x059f3e09a69dad8c4dda8819d6989b98fc70ccd2.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7) private returns(VAR6.VAR8) {
uint256 VAR9 = VAR3 / 100;
uint256 VAR10 = VAR3 / 50;
VAR10 = VAR10.FUN2(VAR9);
uint256 VAR11;
if (!address(VAR12).call.value(VAR10)()) {
VAR11 = VAR10;
VAR10 = 0;
}
uint256 VAR13 = VAR3 / 10;
if (VAR4 != VAR2 && VAR14[VAR4].VAR15 != '') {
VAR14[VAR4].VAR16 = VAR13.FUN2(VAR14[VAR4].VAR16);
emit VAR17.FUN3(VAR4, VAR14[VAR4].VAR18, VAR14[VAR4].VAR15, VAR1, VAR2, VAR13, VAR19);
}
else {
VAR11 = VAR11.FUN2(VAR13);
}
VAR11 = VAR11.FUN2((VAR3.FUN4(VAR20[VAR5].VAR21)) / (100));
if (VAR11 > 0) {
uint256 VAR22 = VAR11 / 2;
VAR12.transfer(VAR11.FUN5(VAR22));
VAR23[VAR1].VAR24 = VAR23[VAR1].VAR24.FUN2(VAR22);
VAR7.VAR25 = VAR11.FUN2(VAR7.VAR25);
}
return(VAR7);
}
function FUN6(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7) private {
if (VAR26[VAR2][VAR1].VAR27 == 0) VAR7 = FUN7(VAR2, VAR7);
if (VAR23[VAR1].VAR28 < 100000000000000000000 && VAR26[VAR2][VAR1].VAR28.FUN2(VAR3) > 1000000000000000000) {
uint256 VAR29 = (1000000000000000000).FUN5(VAR26[VAR2][VAR1].VAR28);
uint256 VAR30 = VAR3.FUN5(VAR29);
VAR14[VAR2].VAR31 = VAR14[VAR2].VAR31.FUN2(VAR30);
VAR3 = VAR29;
}
if (VAR3 > 1000000000) {
uint256 VAR32 = (VAR23[VAR1].VAR28).FUN8(VAR3);
if (VAR32 >= 1000000000000000000) {
FUN9(VAR32, VAR1);
if (VAR23[VAR1].VAR33 != VAR2) VAR23[VAR1].VAR33 = VAR2;
if (VAR23[VAR1].VAR34 != VAR5) VAR23[VAR1].VAR34 = VAR5;
VAR7.VAR35 = VAR7.VAR35 + 100;
}
if (VAR3 >= 100000000000000000) {
VAR36++;
if (FUN10() == true) {
uint256 VAR37;
if (VAR3 >= 10000000000000000000) {
VAR37 = ((VAR38).FUN4(75)) / 100;
VAR14[VAR2].VAR39 = (VAR14[VAR2].VAR39).FUN2(VAR37);
VAR38 = (VAR38).FUN5(VAR37);
VAR7.VAR35 += 300000000000000000000000000000000;
}
else if (VAR3 >= 1000000000000000000 && VAR3 < 10000000000000000000) {
VAR37 = ((VAR38).FUN4(50)) / 100;
VAR14[VAR2].VAR39 = (VAR14[VAR2].VAR39).FUN2(VAR37);
VAR38 = (VAR38).FUN5(VAR37);
VAR7.VAR35 += 200000000000000000000000000000000;
}
else if (VAR3 >= 100000000000000000 && VAR3 < 1000000000000000000) {
VAR37 = ((VAR38).FUN4(25)) / 100;
VAR14[VAR2].VAR39 = (VAR14[VAR2].VAR39).FUN2(VAR37);
VAR38 = (VAR38).FUN5(VAR37);
VAR7.VAR35 += 300000000000000000000000000000000;
}
VAR7.VAR35 += 10000000000000000000000000000000;
VAR7.VAR35 += VAR37 * 1000000000000000000000000000000000;
VAR36 = 0;
}
}
VAR7.VAR35 = VAR7.VAR35 + (VAR36 * 1000);
VAR26[VAR2][VAR1].VAR27 = VAR32.FUN2(VAR26[VAR2][VAR1].VAR27);
VAR26[VAR2][VAR1].VAR28 = VAR3.FUN2(VAR26[VAR2][VAR1].VAR28);
VAR23[VAR1].VAR27 = VAR32.FUN2(VAR23[VAR1].VAR27);
VAR23[VAR1].VAR28 = VAR3.FUN2(VAR23[VAR1].VAR28);
VAR40[VAR1][VAR5] = VAR3.FUN2(VAR40[VAR1][VAR5]);
VAR7 = FUN1(VAR1, VAR2, VAR3, VAR4, VAR5, VAR7);
VAR7 = FUN11(VAR1, VAR2, VAR3, VAR5, VAR32, VAR7);
FUN12(VAR2, VAR5, VAR3, VAR32, VAR7);
}
}",RE,1
0x05a0b0eadd54d13ef3fe015f2ede197a822bc8fc.sol,"function() payable {
if(msg.value == 0){
assert(!VAR1[msg.sender]);
assert(VAR2 >= VAR3);
assert(VAR4[VAR5] >= VAR3);
VAR1[msg.sender] = true;
VAR2 = VAR2.FUN1(VAR3);
VAR6 = VAR6.FUN2(VAR3);
VAR4[msg.sender] = VAR4[msg.sender].FUN2(VAR3);
VAR4[VAR5] = VAR4[VAR5].FUN1(VAR3);
VAR7 = VAR7.FUN2(VAR3);
FUN3(VAR5, msg.sender, VAR3);
}
else {
assert(!VAR8);
uint256 VAR9 = (msg.value * 1000);
assert(VAR4[VAR5] >= VAR9);
if(msg.value >= 50 VAR10){
VAR11[msg.sender] = VAR11[msg.sender].FUN2(1);
uint256 VAR12 = VAR11[msg.sender].FUN4(VAR13);
VAR9 = VAR9.FUN2(VAR12);
VAR14 = VAR14.FUN2(VAR12);
assert(VAR4[VAR5] >= VAR9);
FUN5(VAR5, msg.sender, VAR12);
}
VAR5.transfer(msg.value);
VAR15 = VAR15.FUN2(msg.value);
VAR4[VAR5] = VAR4[VAR5].FUN1(VAR9);
VAR7 = VAR7.FUN2(VAR9);
VAR4[msg.sender] = VAR4[msg.sender].FUN2(VAR9);
Transfer(address(this), msg.sender, VAR9);
}
}
}",RE,1
0x05a24752d15ec52b82b3955b8e27993717fc990f.sol,"function FUN1(uint VAR1) public payable {
require(FUN2(VAR1) == VAR2.VAR3, """");
Proposal storage VAR4 = VAR5[VAR1];
VAR4.VAR6 = true;
for (uint VAR7 = 0; VAR7 < VAR4.VAR8.VAR9; VAR7++) {
VAR10.VAR11.value(VAR4.VAR12[VAR7])(VAR4.VAR8[VAR7], VAR4.VAR12[VAR7], VAR4.VAR13[VAR7], VAR4.VAR14[VAR7], VAR4.VAR15);
}
emit FUN3(VAR1);
}
function FUN4(address VAR16, uint value, string calldata VAR17, bytes calldata VAR18, uint VAR15) external payable returns (bytes VAR19);
}
interface VAR20 {",RE,1
0x05a3c16c454262254c63b4dda9ef4007799af165.sol,"function FUN1(address payable VAR1, uint256 VAR2) public stopInEmergency returns (uint) {
IERC20 VAR3 = FUN2(address(VAR4));
IuniswapExchange VAR5 = FUN3(VAR6.FUN4(address(VAR4)));
uint256 VAR7 = VAR5.FUN5(msg.sender);
require(VAR7 >= VAR2, """");
uint256 VAR8 = VAR5.FUN6(msg.sender, address(this));
require(VAR8 >= VAR2, """");
uint VAR9 = VAR5.FUN5(address(this));
bool VAR10 = VAR5.FUN7(msg.sender, address(this), VAR2);
uint VAR11 = VAR5.FUN5(address(this));
require(VAR10, """");
require(VAR11 > VAR9, """");
(uint256 VAR12, uint256 VAR13) = VAR5.FUN8(VAR2, uint(1), uint(1), VAR14.FUN9(VAR15,1800));
VAR3.FUN10(VAR16, VAR13);
uint256 VAR17 = 1;
VAR18.VAR19.value(0)(address(VAR4), VAR20, VAR13, VAR17, 1, 0);
VAR3.FUN10(VAR16, 0);
uint256 VAR21 = VAR14.FUN9(VAR12, VAR17);
(VAR10, ) = VAR1.call.value(VAR21)("""");
require(VAR10, """");
return VAR21;
}",RE,1
0x05a40435e4e6ecdabd630ba8593d50b6b6ce14f9.sol,"function FUN1() public payable FUN2(msg.value) {
require(!VAR1);
VAR2.transfer(msg.value);
FUN3(msg.sender, msg.value);
}
function() external payable {
FUN1();
}",RE,1
0x05a59c5172152ac21cc5ec2b77656ef25f811c37.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7) private returns(VAR6.VAR8) {
uint256 VAR9 = VAR3 / 100;
uint256 VAR10 = VAR3 / 50;
VAR10 = VAR10.FUN2(VAR9);
uint256 VAR11;
if (!address(VAR12).call.value(VAR10)()) {
VAR11 = VAR10;
VAR10 = 0;
}
uint256 VAR13 = VAR3 / 10;
if (VAR4 != VAR2 && VAR14[VAR4].VAR15 != '') {
VAR14[VAR4].VAR16 = VAR13.FUN2(VAR14[VAR4].VAR16);
emit VAR17.FUN3(VAR4, VAR14[VAR4].VAR18, VAR14[VAR4].VAR15, VAR1, VAR2, VAR13, VAR19);
}
else {
VAR11 = VAR11.FUN2(VAR13);
}
VAR11 = VAR11.FUN2((VAR3.FUN4(VAR20[VAR5].VAR21)) / (100));
if (VAR11 > 0) {
uint256 VAR22 = VAR11 / 2;
VAR12.transfer(VAR11.FUN5(VAR22));
VAR23[VAR1].VAR24 = VAR23[VAR1].VAR24.FUN2(VAR22);
VAR7.VAR25 = VAR11.FUN2(VAR7.VAR25);
}
return(VAR7);
}
function FUN6(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7) private {
if (VAR26[VAR2][VAR1].VAR27 == 0) VAR7 = FUN7(VAR2, VAR7);
if (VAR23[VAR1].VAR28 < 100000000000000000000 && VAR26[VAR2][VAR1].VAR28.FUN2(VAR3) > 1000000000000000000) {
uint256 VAR29 = (1000000000000000000).FUN5(VAR26[VAR2][VAR1].VAR28);
uint256 VAR30 = VAR3.FUN5(VAR29);
VAR14[VAR2].VAR31 = VAR14[VAR2].VAR31.FUN2(VAR30);
VAR3 = VAR29;
}
if (VAR3 > 1000000000) {
uint256 VAR32 = (VAR23[VAR1].VAR28).FUN8(VAR3);
if (VAR32 >= 1000000000000000000) {
FUN9(VAR32, VAR1);
if (VAR23[VAR1].VAR33 != VAR2) VAR23[VAR1].VAR33 = VAR2;
if (VAR23[VAR1].VAR34 != VAR5) VAR23[VAR1].VAR34 = VAR5;
VAR7.VAR35 = VAR7.VAR35 + 100;
}
if (VAR3 >= 100000000000000000) {
VAR36++;
if (FUN10() == true) {
uint256 VAR37;
if (VAR3 >= 10000000000000000000) {
VAR37 = ((VAR38).FUN4(75)) / 100;
VAR14[VAR2].VAR39 = (VAR14[VAR2].VAR39).FUN2(VAR37);
VAR38 = (VAR38).FUN5(VAR37);
VAR7.VAR35 += 300000000000000000000000000000000;
}
else if (VAR3 >= 1000000000000000000 && VAR3 < 10000000000000000000) {
VAR37 = ((VAR38).FUN4(50)) / 100;
VAR14[VAR2].VAR39 = (VAR14[VAR2].VAR39).FUN2(VAR37);
VAR38 = (VAR38).FUN5(VAR37);
VAR7.VAR35 += 200000000000000000000000000000000;
}
else if (VAR3 >= 100000000000000000 && VAR3 < 1000000000000000000) {
VAR37 = ((VAR38).FUN4(25)) / 100;
VAR14[VAR2].VAR39 = (VAR14[VAR2].VAR39).FUN2(VAR37);
VAR38 = (VAR38).FUN5(VAR37);
VAR7.VAR35 += 300000000000000000000000000000000;
}
VAR7.VAR35 += 10000000000000000000000000000000;
VAR7.VAR35 += VAR37 * 1000000000000000000000000000000000;
VAR36 = 0;
}
}
VAR7.VAR35 = VAR7.VAR35 + (VAR36 * 1000);
VAR26[VAR2][VAR1].VAR27 = VAR32.FUN2(VAR26[VAR2][VAR1].VAR27);
VAR26[VAR2][VAR1].VAR28 = VAR3.FUN2(VAR26[VAR2][VAR1].VAR28);
VAR23[VAR1].VAR27 = VAR32.FUN2(VAR23[VAR1].VAR27);
VAR23[VAR1].VAR28 = VAR3.FUN2(VAR23[VAR1].VAR28);
VAR40[VAR1][VAR5] = VAR3.FUN2(VAR40[VAR1][VAR5]);
VAR7 = FUN1(VAR1, VAR2, VAR3, VAR4, VAR5, VAR7);
VAR7 = FUN11(VAR1, VAR2, VAR3, VAR5, VAR32, VAR7);
FUN12(VAR2, VAR5, VAR3, VAR32, VAR7);
}
}",RE,1
0x05a7a6bdc23dcf2826ea4fb176c0c36ba7def1b7.sol,"function() payable {
}
}",RE,1
0x05a8b94cd607d5d611ff71161623f815535a4c73.sol,"function FUN1(address VAR1, uint256 VAR2, address payable VAR3) public payable {
require(VAR4.VAR5 < VAR6, """");
require(VAR7[msg.value] > 0, """");
require(VAR8[VAR1], """");
require(FUN2(VAR1).FUN3(VAR2) != address(0), """");
if(VAR9[VAR1][VAR2] == 0) {
emit FUN4(VAR1, VAR2);
}
VAR9[VAR1][VAR2] = VAR9[VAR1][VAR2] + VAR7[msg.value];
VAR10[VAR1][VAR2] = VAR10[VAR1][VAR2] + msg.value;
VAR11[VAR3] = msg.value + VAR11[VAR3];
emit FUN5(msg.sender, VAR1, VAR2, VAR3, VAR7[msg.value], msg.value);
}
function FUN6() public {
require(VAR4.VAR5 >= VAR6, """");
require(VAR11[msg.sender] > 0 && !VAR12[msg.sender], """");
payable(msg.sender).transfer(VAR11[msg.sender]);
VAR12[msg.sender] = true;
}
}
interface VAR13 {",RE,1
0x05aa942ba2c382665162e88117b5263df57721f4.sol,"function () public payable {
revert();
}",RE,1
0x05aac45d288ca22b4a207fe35c6ca422546ae16e.sol,"function FUN1() payable{
VAR1 = 0x87b0de512502f3e86fd22654b72a640c8e0f59cc;
VAR2 = 1000;
VAR3 = msg.sender;
VAR4=1494787620;
VAR5=1496861220;
VAR6=5000000000000000;
VAR7=2000000000000000;
VAR8=200;
VAR9=0;
VAR10.FUN2(6045);
VAR11=4;
uint16 VAR12 = VAR8;
for(uint VAR13 = 0; VAR13 < VAR10.VAR14; VAR13++) {
VAR12 += VAR10[VAR13];
}
if(VAR12>10000) throw;
else if(VAR12 < 10000 && VAR11 == 0) throw;
}
function FUN3() payable {
if(msg.value < VAR6) throw;
else if (VAR15 >= VAR4) throw;
else if (VAR16[msg.sender]) throw;
else if (msg.sender!=VAR17.VAR18) throw;
else {
VAR19.FUN2(msg.sender);
VAR16[msg.sender]=true;
if(VAR20.VAR14 < VAR10.VAR14) VAR20.FUN2(msg.sender);
}
}
function FUN4(address VAR21) payable{
if(msg.value < VAR7) throw;
else if(VAR15 < VAR4 || VAR15 >=VAR5) throw;
else if(VAR22[msg.sender]) throw;
else if (msg.sender!=VAR17.VAR18) throw;
else if(!VAR16[VAR21]) throw;
else{
VAR23.FUN2(msg.sender);
VAR22[msg.sender] = true;
VAR24[VAR21]++;
for(var VAR13 = 0; VAR13 < VAR20.VAR14; VAR13++){
if(VAR20[VAR13]==VAR21) break;
if(VAR24[VAR21]>VAR24[VAR20[VAR13]]){
for(var VAR25 = FUN5(VAR21, VAR13+1); VAR25>VAR13; VAR25--){
VAR20[VAR25]=VAR20[VAR25-1];
}
VAR20[VAR13]=VAR21;
break;
}
}
}
}",RE,1
0x05acf6955e199b0dcc33b74a91bacbaffa86d5cb.sol,"function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}",RE,1
0x05acfae7ab84255e3f234629bc3c3a28cdd4f7af.sol,"function () public payable {
revert();
}",RE,1
0x05b04cb2c29691d3f9ce74e6aa3c69548da3bee2.sol,"function() public payable {
FUN1(msg.sender, msg.value, 0x0, 0x0);
}
function FUN2(address VAR1, address VAR2) public payable {
require(msg.value > 0);
FUN1(msg.sender, msg.value, VAR1, VAR2);
}",RE,1
0x05b08e91a4071a2a5edcd5f750b0b7f2da0f70b6.sol,"function FUN1(address VAR1) onlyOwner external payable {
require(VAR2 == VAR3.VAR4);
VAR5[VAR1] = VAR5[VAR1].FUN2(msg.value);
}
function () external payable {
FUN3(msg.sender);
}
function FUN3(address VAR6) whenNotPaused onlyWhitelisted public payable {
require(VAR6 != address(0));
require(FUN4());
uint256 VAR7 = msg.value;
uint256 VAR8 = VAR9;
uint256 VAR10 = 0;
if((VAR8 >= VAR11) && (VAR8 < VAR12)) {
VAR10 = VAR10.FUN2(VAR7.FUN5(VAR13));
VAR10 = VAR10.FUN2(VAR7.FUN5(VAR14));
VAR15 = VAR15.FUN6(VAR10);
VAR16 = VAR16.FUN6(VAR10);
}
else if((VAR8 >= VAR17) && (VAR8 < VAR18) && (VAR8 < VAR19)) {
VAR10 = VAR10.FUN2(VAR7.FUN5(VAR14));
VAR15 = VAR15.FUN6(VAR10);
VAR16 = VAR16.FUN6(VAR10);
}
else if ((VAR8 >= VAR19) && (VAR8 < VAR20)) {
require(VAR21 > 0);
VAR10 = VAR10.FUN2(VAR7.FUN5(VAR22));
VAR10 = VAR10.FUN2(VAR7.FUN5(VAR14));
require(VAR21 >= VAR10);
VAR21 = VAR21.FUN6(VAR10);
VAR16 = VAR16.FUN6(VAR10);
}
else if ((VAR8 >= VAR23) && (VAR8 <= VAR24)) {
if (!VAR25) {
VAR15 = VAR15.FUN2(VAR21);
VAR25 = true;
}
if (VAR8 <= VAR26) {
VAR10 = VAR10.FUN2(VAR7.FUN5(VAR27));
}
else if (( VAR8 <= VAR28 ) && (VAR8 > VAR26)) {
VAR10 = VAR10.FUN2(VAR7.FUN5(VAR29));
}
else if (( VAR8 <= VAR30 ) && (VAR8 > VAR28)) {
VAR10 = VAR10.FUN2(VAR7.FUN5(VAR31));
}
else if (( VAR8 <= VAR32 ) && (VAR8 > VAR30)) {
VAR10 = VAR10.FUN2(VAR7.FUN5(VAR33));
}
VAR10 = VAR10.FUN2(VAR7.FUN5(VAR14));
VAR15 = VAR15.FUN6(VAR10);
VAR16 = VAR16.FUN6(VAR10);
}
else {
revert();
}
VAR34 = VAR34.FUN2(VAR7);
VAR35.VAR36.value(VAR7)(VAR6);
VAR37.FUN7(VAR6, VAR10);
emit FUN8(VAR6, VAR6, VAR7, VAR10);
}
function FUN9() onlyOwner external payable {
VAR34 = VAR34.FUN2(msg.value.FUN10(VAR14));
}",RE,1
0x05b090348f21760a3959463e1894e78693cef198.sol,"function FUN1() internal view returns(address payable) {
return msg.sender;
}
}
library VAR1 {",RE,1
0x05b3abd9031a31a45121bda59c7bb52fc7db2590.sol,"function FUN1(address VAR1) onlyOwner public payable {
require(VAR2 == VAR3.VAR4);
VAR5[VAR1] = VAR5[VAR1].FUN2(msg.value);
}",RE,1
0x05b837ea9a4f3a56f883d5991c6c9ca32c49403e.sol,"function FUN1() internal view returns (address payable) {
return msg.sender;
}",RE,1
0x05b884c671c0bf558b7cc4dcd451c389db5ea4f4.sol,"function FUN1() public payable FUN2(42000000*10**uint(VAR1)) {
uint VAR2 = 2249451*10**uint(VAR1);
VAR3 = VAR3.FUN3(VAR2);
VAR4[msg.sender] = VAR4[msg.sender].FUN3(VAR2);
Transfer(address(0), msg.sender, VAR2);
}
}",RE,1
0x05bb30a1f820add4772b44a808ee9024ce82b34c.sol,"function () public payable {
revert();
}",RE,1
0x05bc1d3454405d4767960efeb3cec216a0dd15f3.sol,"function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}",RE,1
0x05bd9302216f862a1aca5b2c8d16f463290048c4.sol,"function FUN1(address VAR1) public payable returns(bool);
function () public payable {
require(FUN2(VAR2));
require(FUN3(VAR2).VAR3.value(msg.value)(msg.sender));
}
function FUN1(address) public payable returns (bool) {
return false;
}",RE,1
0x05c19e52e73353799aff84f390e9a27e11836477.sol,"function () public payable isTgeLive isNotFrozenOnly targetIsNotAchieved maxStagesIsNotAchieved VAR1 {
require(msg.value > 0);
if(VAR2.FUN1(msg.value) >= VAR3){
FUN2();
}
uint VAR4 = 0;
uint VAR5 = msg.value;
if(VAR2.FUN1(msg.value) >= VAR3){
VAR4 = VAR2.FUN1(msg.value).FUN3(VAR3);
VAR5 = (msg.value).FUN3(VAR4);
}
uint VAR6 = VAR7.VAR8.FUN3(VAR9).FUN4(VAR10);
uint VAR11 = VAR12.FUN1(VAR6.FUN5(VAR13));
uint VAR14 = VAR11.FUN1(VAR15).FUN1(VAR16);
uint VAR17 = VAR5.FUN5(VAR15).FUN4(VAR14);
uint VAR18 = VAR5.FUN5(VAR16).FUN4(VAR14);
uint VAR19 = VAR5.FUN3(VAR17).FUN3(VAR18);
FUN6(VAR17, VAR18, VAR19);
msg.sender.transfer(VAR4);
}",RE,1
0x05c31a8270de1a757a500c069fc43692b7af56cf.sol,"function FUN1(address VAR1, uint value) public;
event Transfer(address indexed VAR2, address indexed VAR3, uint value);
event FUN2(address indexed VAR4, address indexed VAR1, uint value);
}
contract VAR5{
address payable VAR6;
uint VAR7;
uint VAR8;
uint VAR9;
uint VAR10;
bool VAR11;
address VAR12 = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
string VAR13 = """";
address public VAR4;
ERC20 VAR14;
modifier onlyOwner {
require(msg.sender == VAR4,"""");
VAR15;
}
event FUN3(address indexed VAR16, uint VAR17);
event FUN4(address indexed VAR16, uint VAR17);
event FUN5(address indexed VAR16, uint indexed VAR18 , uint VAR17);
event FUN6(address indexed VAR16);
constructor() public {
VAR4 = msg.sender;
VAR14 = FUN7(VAR12);
}
function () external payable{
revert();
}
function FUN8() public payable returns(bool){
address payable VAR16 = msg.sender;
uint VAR17 = msg.value;
require(VAR17 > 0, """");
if(VAR11){
require(msg.sender == VAR6, """");
VAR7 += VAR17;
}
else{
VAR6 = VAR16;
VAR7 = VAR17;
VAR8 = 0;
VAR9 = 0;
VAR10 = 0;
VAR11 = true;
}
emit FUN3(VAR16, VAR17);
return true;
}
function FUN8() public payable returns(bool){
address payable VAR16 = msg.sender;
uint VAR17 = msg.value;
require(VAR17 > 0, """");
if(VAR11){
require(msg.sender == VAR6, """");
VAR7 += VAR17;
}
else{
VAR6 = VAR16;
VAR7 = VAR17;
VAR8 = 0;
VAR9 = 0;
VAR10 = 0;
VAR11 = true;
}
emit FUN3(VAR16, VAR17);
return true;
}",RE,1
0x05c7065d644096a4e4c3fe24af86e36de021074b.sol,"function () payable public{
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
require(VAR1 != 0x0);
require(FUN2());
uint256 VAR2 = msg.value;
uint256 VAR3 = VAR2.FUN3(VAR4);
require(FUN4(VAR3));
VAR5 = VAR5.FUN5(VAR2);
VAR6.transfer(VAR1, VAR3);
FUN6(VAR3);
FUN7(msg.sender, VAR1, VAR2, VAR3);
FUN8();
}",RE,1
0x05ca268db7beee6791c2145653f2083ac56fe232.sol,"function() external payable {
revert("""");
}
}
contract VAR1 {
address public VAR2;
address VAR3;
constructor() public {
VAR2 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR2);
VAR4;
}",RE,1
0x05cabebf2f2ad6f021872c609345173311be63fd.sol,"function FUN1( ERC20Interface VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4 ) external returns (uint256 VAR5) {
FUN2(VAR1, msg.sender, VAR2);
FUN3(VAR1, VAR2);
(address[] memory VAR6, uint256[] memory VAR7) = FUN4( address(VAR1), VAR8, false );
VAR7 = VAR9.FUN5( VAR2, VAR3, VAR6, address(this), VAR4 );
VAR5 = VAR7[1];
(bool VAR10, ) = msg.sender.call.value(VAR3)("""");
if (!VAR10) {
VAR11 {
FUN6(0, 0, VAR12) revert(0, VAR12) }
}
FUN7( false, VAR13.VAR14, address(VAR1), VAR2, VAR3, VAR5.FUN8(VAR3) );
}
function FUN9( address payable VAR15, address VAR16, uint256 VAR17 ) external FUN10(VAR18.VAR19) {
FUN11(VAR15, VAR16);
require(VAR17 < VAR20, """");
bool VAR10;
(VAR10, ) = VAR15.call.value(VAR17)("""");
if (!VAR10) {
VAR11 {
FUN6(0, 0, VAR12) revert(0, VAR12) }
}
}
function FUN12( address payable VAR21, uint256 VAR17 ) external onlyOwner {
bool VAR10;
(VAR10, ) = VAR21.call.value(VAR17)("""");
if (!VAR10) {
VAR11 {
FUN6(0, 0, VAR12) revert(0, VAR12) }
}
}
function FUN13( address payable VAR22, uint256 VAR23, bytes calldata VAR24 ) external onlyOwner returns (bool VAR10, bytes memory VAR25) {
(VAR10, VAR25) = VAR22.call.value(VAR23)(VAR24);
}",RE,1
0x05cd27a978fc9f9919a5f4c5c03e5947ed7d4c4d.sol,"function() public payable {
}
function FUN1() public payable {
if (msg.value >= this.VAR1 || VAR2.VAR3 == VAR4) {
FUN2(VAR2.VAR3);
}
}
}",RE,1
0x05cd43ce7c54a23713841aeed22cb8686b1de820.sol,"function FUN1(address VAR1) onlyOwner public payable {
require(VAR2 == VAR3.VAR4);
VAR5[VAR1] = VAR5[VAR1].FUN2(msg.value);
}
function () nonZero payable {
FUN3();
}
function FUN3() public nonZero payable {
if(FUN4()) {
if(VAR6 == VAR3.VAR7) {
VAR6 = VAR3.VAR8;
}
FUN5(msg.sender, msg.value);
}
else if (FUN6()) {
if(VAR6 == VAR3.VAR9) {
VAR6 = VAR3.VAR10;
}
FUN5(msg.sender, msg.value);
}
else {
revert();
}
}",RE,1
14000.sol,"function () public payable {
revert();
}",RE,1
14001.sol,"function FUN1(VAR1[] VAR2, uint256 VAR3, uint256 VAR4) public payable returns (uint256);",RE,1
14002.sol,"function () public payable {
revert();
}
}",RE,1
14003.sol,"function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}",RE,1
14004.sol,"function FUN1() public payable {
VAR1.transfer(msg.value);
emit FUN2(msg.sender,msg.value);
}
function() public payable {
VAR1.transfer(msg.value);
emit FUN2(msg.sender,msg.value);
}
}",RE,1
14007.sol,"function () public payable {
revert();
}",RE,1
14010.sol,"function () public payable {
FUN1();
}
}
contract VAR1 {",RE,1
14011.sol,"function () public payable {
FUN1();
}
}
contract VAR1 {",RE,1
14012.sol,"function () public payable {
FUN1();
}
}
contract VAR1 {",RE,1
14013.sol,"function () public payable {
FUN1();
}
}
contract VAR1 {",RE,1
14015.sol,"function () public payable FUN1(VAR1.VAR2) {
require(!VAR3 && msg.sender != VAR4 && VAR5 <= VAR6);
VAR7 = FUN2(msg.value , VAR8);
FUN3(msg.sender,VAR7);
}",RE,1
14016.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",RE,1
14019.sol,"function () payable external {
Stage VAR1 = FUN1();
require(VAR1 != VAR2.VAR3);
uint VAR4 = FUN2();
uint VAR5 = msg.value * (10 ** 18) / VAR4;
VAR6.transfer(msg.sender, VAR5);
FUN3(VAR5, VAR1);
}",RE,1
14020.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",RE,1
14021.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",RE,1
14023.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",RE,1
14024.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",RE,1
14025.sol,"function () payable external {
Stage VAR1 = FUN1();
require(VAR1 != VAR2.VAR3);
uint VAR4 = FUN2();
uint VAR5 = msg.value * (10 ** 18) / VAR4;
VAR6.transfer(msg.sender, VAR5);
FUN3(VAR5, VAR1);
}",RE,1
14026.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",RE,1
14028.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",RE,1
14037.sol,"function () external payable {
if (!VAR1[msg.sender] ) {
VAR1[msg.sender] = true;
FUN1(address(this), msg.sender, VAR2 );
VAR2 = VAR2 - VAR3;
}
}",RE,1
14043.sol,"function FUN1() public payable {
uint VAR1 = 35000000*10**uint(VAR2);
VAR3 = VAR3.FUN2(VAR1);
VAR4[msg.sender] = VAR4[msg.sender].FUN2(VAR1);
Transfer(address(0), msg.sender, VAR1);
}",RE,1
14045.sol,"function () external payable VAR1 {
FUN1();
}
function FUN1() public payable VAR1 {
require(msg.value > 0);
uint256 VAR2 = msg.value;
uint256 VAR3 = VAR2.FUN2(VAR4);
require(VAR3 <= VAR5[VAR6]);
if (VAR7 == VAR8.VAR9){
require (VAR3 <= VAR10);
}
FUN3(msg.sender, VAR3, VAR11, VAR12);
VAR5[VAR6] = VAR5[VAR6].FUN4(VAR3);
emit Transfer(VAR6, msg.sender, VAR3);
emit FUN5(msg.sender, VAR3, VAR4);
FUN6();
}",RE,1
14048.sol,"function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}",RE,1
14049.sol,"function () public payable {
revert();
}",RE,1
14051.sol,"function FUN1() payable public {
if (msg.value > 0.000001 VAR1 || msg.value <= 5 VAR1) {
VAR2 = FUN2(VAR2, msg.value);
FUN3();
}
else {
revert();
}
}
function () payable public {
if (msg.value > 0) {
FUN1();
}
}
}",RE,1
14052.sol,"function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
emit FUN6(msg.sender, VAR1, VAR2, VAR3);
FUN7(VAR1, VAR2);
FUN8();
FUN9(VAR1, VAR2);
}
function FUN10() external payable {
emit FUN11(msg.sender, msg.value);
}",RE,1
14053.sol,"function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}
function FUN7() public payable{
require(VAR1);
VAR5.transfer(msg.value);
require(VAR9[msg.sender]==0);
VAR10[msg.sender]=VAR11;
VAR9[msg.sender]=VAR12;
}",RE,1
14054.sol,"function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}",RE,1
14055.sol,"function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}",RE,1
14058.sol,"function FUN1() public payable VAR1 {
require(msg.value >= VAR2);
require(!VAR3[msg.sender].VAR4);
Game memory VAR5 = FUN2(msg.sender, 0, msg.value, VAR6);
uint256 VAR7 = VAR8.FUN3(VAR5) - 1;
VAR6++;
VAR3[msg.sender] = FUN4(VAR7, true);
emit FUN5(VAR7, VAR5.VAR9, VAR5.VAR10, VAR5.VAR11, VAR5.VAR12);
}
function FUN6(address VAR13) public payable VAR1 FUN7(VAR13){
uint VAR14 = VAR3[VAR13].VAR15;
require(!VAR3[msg.sender].VAR4);
Game storage VAR5 = VAR8[VAR14];
require(msg.sender != VAR5.VAR9);
require(VAR5.VAR10 == 0);
require(msg.value == VAR5.VAR11);
VAR5.VAR10 = msg.sender;
VAR3[msg.sender] = FUN4(VAR14, true);
emit FUN8(VAR14, VAR5.VAR10);
}",RE,1
14059.sol,"function() isIcoOpen payable {
VAR1 = VAR1.FUN1(msg.value);
uint256 VAR2 = FUN2(msg.value);
VAR3[VAR4] = VAR3[VAR4].FUN3(VAR2);
VAR3[msg.sender] = VAR3[msg.sender].FUN1(VAR2);
Transfer(VAR4, msg.sender, VAR2);
VAR4.transfer(msg.value);
}",RE,1
14060.sol,"function () public payable {
revert();
}",RE,1
14061.sol,"function() payable public {
}
function FUN1() FUN2() payable public {
require(msg.value >= 10000000000000000);
address VAR1 = msg.sender;
VAR2.VAR3.value(msg.value)(VAR1);
emit FUN3(msg.value, msg.sender);
if(msg.value > 10000000000000000) {
uint VAR4 = VAR5.FUN4(msg.value, 10000000000000000);
VAR6 += VAR4;
}
if(VAR6 >= VAR7) {
VAR2.FUN5();
FUN6(VAR8);
FUN7(VAR1);
FUN8();
}
else {
VAR6++;
}
}
function FUN9(address) public payable returns(uint256);",RE,1
14062.sol,"function () payable whenSellNotPaused whenNotPaused public {
require(msg.value >= 0.1 VAR1);
uint256 VAR2 = msg.value.FUN1(0.1 VAR1).FUN2(VAR3);
VAR4[msg.sender] = VAR4[msg.sender].FUN3(VAR2);
VAR4[VAR5] = VAR4[VAR5].FUN4(VAR2);
}",RE,1
14063.sol,function FUN1(address VAR1) public payable returns(bool);,RE,1
14064.sol,"function FUN1() payable whenSellNotPaused whenNotPaused public {
require(msg.value >= 0.1 VAR1);
uint256 VAR2 = msg.value.FUN2(0.1 VAR1).FUN3(VAR3);
VAR4[msg.sender] = VAR4[msg.sender].FUN4(VAR2);
VAR4[VAR5] = VAR4[VAR5].FUN5(VAR2);
}",RE,1
14065.sol,"function FUN1(address VAR1) public payable returns (uint256) {
FUN2(msg.value, VAR1);
}",RE,1
14068.sol,"function FUN1(address VAR1) public payable returns (uint256) {
FUN2(msg.value, VAR1);
}",RE,1
14069.sol,"function FUN1(uint VAR1, uint VAR2) internal pure returns (uint VAR3) {
require(VAR2 > 0);
VAR3 = VAR1 / VAR2;
}
}
contract VAR4 {
function () public payable {
revert();
}
}
contract VAR5 {
address public VAR6;
function FUN2(address VAR7, address VAR8, uint VAR9) public returns (bool VAR10);
event Transfer(address indexed VAR7, address indexed VAR8, uint VAR9);
event FUN3(address indexed VAR11, address indexed VAR12, uint VAR9);
}
contract VaultbankToken is VAR13, VAR14, VAR4 {
using SafeMath for uint;
string public VAR15;
string public VAR16;
uint8 public VAR17;
uint public VAR18;
FUN4(address => uint) VAR19;
FUN4(address => FUN4(address => uint)) VAR20;",RE,1
14070.sol,"function() public payable {
require(VAR1);
if(!VAR2.FUN1(msg.VAR3)) revert();
}
}
contract AdvisorPool is VAR4, VAR5 {",RE,1
14071.sol,"function () public payable {
FUN1(VAR1);
}
function FUN1(uint256 VAR2) public payable returns (bool VAR3) {
require(VAR2 == VAR1);
address VAR4 = msg.sender;
uint256 VAR5 = msg.value * VAR1;
VAR6[VAR7] = VAR6[VAR7].FUN2(VAR5);
VAR6[VAR4] = VAR6[VAR4].FUN3(VAR5);
emit Transfer(VAR7, VAR4, VAR5);
return true;
}",RE,1
14072.sol,"function () external payable {
if (!VAR1[msg.sender] ) {
VAR1[msg.sender] = true;
FUN1(address(this), msg.sender, VAR2 );
VAR2 = VAR2 - VAR3;
}
}",RE,1
14074.sol,"function() payable public {
FUN1(msg.sender);
}
function FUN1(address VAR1) public FUN2(VAR2.VAR3) payable returns (uint256){
require(VAR1 != address(0));
uint256 VAR4 = msg.value;
uint256 VAR5 = FUN3(VAR4);
if (VAR5 == 0) {
revert();
}
VAR6 = VAR6.FUN4(VAR4);
VAR7 = VAR7.FUN4(VAR5);
FUN5(VAR1, VAR5, VAR8);
emit FUN6(VAR1, VAR4, VAR5);
if (VAR9[VAR1] == 0) {
VAR10 = VAR10.FUN4(1);
}
FUN7(VAR1);
VAR11.transfer(VAR4);
return VAR5;
}",RE,1
14077.sol,"function () payable {
require(!VAR1 && msg.value >= 0.01 VAR2);
VAR3 = FUN1();
uint VAR4 = msg.value;
VAR5[msg.sender] += VAR4;
VAR6 += VAR4;
uint VAR7 = (VAR4 / VAR3) * 10 ** uint256(18);
VAR8.transfer(msg.sender, VAR7);
VAR9 += VAR7;
FUN2(msg.sender, VAR4, VAR3, true);
if (VAR10.FUN3(VAR4)) {
FUN2(VAR10, VAR4, VAR3, false);
}
}
}",RE,1
14081.sol,"function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}",RE,1
14082.sol,"function () public payable {
revert();
}",RE,1
14083.sol,"function () public payable {
require (VAR1 && (VAR2 > 0) && (msg.value >= VAR2));
VAR3 += msg.value;
VAR4.transfer(msg.value);
uint VAR5 = (msg.value * 10**18) / VAR2;
require (VAR6.transfer(msg.sender, VAR5));
return;
}",RE,1
14085.sol,"function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}",RE,1
14086.sol,"function () external payable {
if (!VAR1[msg.sender] ) {
VAR1[msg.sender] = true;
FUN1(address(this), msg.sender, VAR2 );
VAR2 = VAR2 - VAR3;
}
}",RE,1
14088.sol,"function() payable public {
revert();
}
modifier onlyOwner() {
require(msg.sender == VAR1);
VAR2;
}",RE,1
14089.sol,"function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
uint256 VAR5 = FUN4(msg.value);
uint256 VAR6 = VAR3.FUN3(msg.value, VAR5);
VAR7.transfer(VAR5);
VAR8[msg.sender]=VAR3.FUN5(VAR8[msg.sender],VAR2);
FUN6(msg.sender, VAR2, VAR6);
}
function FUN7(uint256 VAR9) public payable{
require(VAR10==0);
VAR1=true;
VAR10=VAR9;
}",RE,1
14091.sol,"function FUN1( ERC20 VAR1, ERC20 VAR2, uint VAR3 ) external payable returns(uint);
function () public payable {
}
function FUN1(uint256 VAR4, ERC20 VAR1, uint256 VAR3, ERC20 VAR2, uint256 VAR5) payable public returns(uint256) {
uint256 VAR6;
if (VAR7 == VAR1) {
VAR6 = FUN2(VAR4, VAR1, VAR3, VAR2, 1);
assert(VAR6 >= VAR5);
VAR2.transfer(msg.sender, VAR6);
}
else if (VAR7 == VAR2) {
VAR1.FUN3(msg.sender, address(this), VAR3);
VAR6 = FUN2(VAR4, VAR1, VAR3, VAR2, 1);
assert(VAR6 >= VAR5);
msg.sender.transfer(VAR6);
}
else {
revert();
}
emit FUN4( VAR1, VAR3, VAR2, VAR6, msg.sender, 0);
return VAR6;
}
function FUN5(ERC20 VAR1, uint256 VAR3, ERC20 VAR2, uint256 VAR5, address[] VAR8) payable public returns(uint256) {
uint256 VAR6;
if (VAR7 != VAR1) {
VAR1.FUN3(msg.sender, address(this), VAR3);
}
uint256 VAR9 = VAR3;
for (uint VAR10=0; VAR10 < VAR8.VAR11; VAR10+=3) {
uint256 VAR4 = uint256(VAR8[VAR10]);
ERC20 VAR12 = FUN6(VAR8[VAR10+1]);
ERC20 VAR13 = FUN6(VAR8[VAR10+2]);
VAR6 = FUN2(VAR4, VAR12, VAR9, VAR13, 1);
VAR9 = VAR6;
}
assert(VAR6 >= VAR5);
if (VAR7 == VAR2) {
msg.sender.transfer(VAR6);
}
else {
VAR2.transfer(msg.sender, VAR6);
}
emit FUN4( VAR1, VAR3, VAR2, VAR6, msg.sender, 0);
return VAR6;
}",RE,1
14092.sol,"function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
uint256 VAR5 = FUN4(msg.value);
uint256 VAR6 = VAR3.FUN3(msg.value, VAR5);
VAR7.transfer(VAR5);
VAR8[msg.sender]=VAR3.FUN5(VAR8[msg.sender],VAR2);
FUN6(msg.sender, VAR2, VAR6);
}
function FUN7(uint256 VAR9) public payable{
require(VAR10==0);
VAR1=true;
VAR10=VAR9;
}",RE,1
14094.sol,"function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}",RE,1
14095.sol,"function FUN1() payable public {
uint VAR1 = msg.value / VAR2;
FUN2(this, msg.sender, VAR1);
}
uint VAR3 = 1;",RE,1
14099.sol,"function () public payable {
return;
}",RE,1
14100.sol,"function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}",RE,1
14101.sol,"function FUN1() payable public {
VAR1.transfer(msg.value);
VAR2[msg.sender] += msg.value;
emit FUN2(msg.sender, msg.value);
}
function () payable public {
VAR1.transfer(msg.value);
}
}",RE,1
14102.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",RE,1
14103.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",RE,1
14106.sol,"function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}",RE,1
14109.sol,"function() payable {
uint256 VAR1 = msg.value;
require(VAR1 >= 1e16);
bool VAR2 = false;
for (uint8 VAR3 = 0; VAR3 < VAR4; VAR3++) {
if (VAR5[VAR3] == msg.sender) {
VAR2 = true;
break;
}
}
if (!VAR2) {
VAR5[VAR4] = msg.sender;
VAR4++;
}
tickets memory VAR6;
VAR6.VAR7 = VAR8;
uint256 VAR9 = VAR1/1e15;
VAR6.VAR10 = VAR8.FUN1(VAR9);
VAR8 = VAR8.FUN1(VAR9);
VAR11[msg.sender].FUN2(VAR6);
VAR12[msg.sender] = VAR12[msg.sender].FUN1(VAR1);
FUN3(msg.sender, VAR1);
if(VAR4 > 9) {
FUN4();
}
}
}",RE,1
14110.sol,"function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}",RE,1
14112.sol,"function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}
function FUN7() public payable{
require(VAR1);
require(msg.value==0.001 VAR9);
VAR5.transfer(msg.value);
require(VAR10[msg.sender]==0);
VAR11[msg.sender]=VAR12;
VAR10[msg.sender]=VAR13;
}",RE,1
14114.sol,"function () external payable {
if (!VAR1) {
FUN1();
}
else {
FUN2();
}
}
function FUN1() public whenCrowdsaleNotPaused payable {
require(!VAR2[msg.sender].VAR3);
require(msg.value > 0);
require(msg.value >= VAR4);
require(msg.value % VAR4 == 0);
var VAR5 = msg.value / VAR4;
require(VAR5 >= VAR6);
VAR7[msg.sender] += VAR5;
Transfer(0, msg.sender, VAR5);
VAR8.transfer(msg.value);
VAR2[msg.sender].VAR9 = VAR2[msg.sender].VAR9.FUN3(VAR5);
FUN4(msg.sender);
if (msg.sender != VAR10) {
VAR11 += VAR5;
}
}
function FUN2() public onlyOwner payable {
VAR12 = VAR12.FUN3(msg.value);
}
function FUN5() public onlyOwner payable {
}",RE,1
14121.sol,"function FUN1() payable public {
require(VAR1 > 0);
require(msg.value + VAR2[msg.sender] <= VAR3);
require(msg.value >= VAR4);
require(VAR5 >= VAR6);
require(msg.value >= 1 VAR7 / VAR8);
if(msg.value * VAR8 / 1 VAR7 > VAR1){
Transfer(VAR9, msg.sender, VAR1);
uint256 VAR10 = msg.value - VAR1 * 1 VAR7 / VAR8;
VAR11[msg.sender] += VAR1;
VAR11[VAR9] -= VAR1;
VAR2[msg.sender] += msg.value - VAR10;
VAR1 = 0;
msg.sender.transfer(VAR10);
VAR12.transfer((msg.value - VAR10) * (100 - VAR13) / 100);
VAR14.transfer((msg.value - VAR10) * VAR13 / 100);
}
else{
Transfer(VAR9, msg.sender, msg.value * VAR8 / 1 VAR7);
VAR11[msg.sender] += msg.value * VAR8 / 1 VAR7;
VAR11[VAR9] -= msg.value * VAR8 / 1 VAR7;
VAR2[msg.sender] += msg.value;
VAR1 -= msg.value * VAR8 / 1 VAR7;
VAR12.transfer(msg.value * (100 - VAR13) / 100);
VAR14.transfer(msg.value * VAR13 / 100);
}
}
function () payable public {
FUN1();
}",RE,1
14123.sol,"function () external payable {
FUN1();
}
function FUN1() payable canDistr onlyWhitelist public {
if (value > VAR1) {
value = VAR1;
}
require(value <= VAR1);
address VAR2 = msg.sender;
uint256 VAR3 = value;
FUN2(VAR2, VAR3);
if (VAR3 > 0) {
VAR4[VAR2] = true;
}
if (VAR5 >= VAR6) {
VAR7 = true;
}
value = value.FUN3(100000).FUN4(99999);
}",RE,1
14125.sol,"function FUN1() payable public returns (uint256 VAR1){
VAR1 = msg.value * VAR2 / VAR3;
uint256 VAR4 = FUN2(VAR5[this] - VAR1);
require( (2*VAR4) > VAR6);
FUN3(this, msg.sender, VAR1);
FUN4( VAR4 );
return VAR1;
}
function () payable public {
FUN1();
}",RE,1
14126.sol,"function () public payable {
revert();
}",RE,1
14128.sol,"function () public payable {
revert();
}",RE,1
14129.sol,"function() public payable {
}
function FUN1() payable public returns (bool){
uint VAR1 = msg.value * VAR2 / 1000000000000000000;
require(VAR1 <= VAR3[this]);
VAR3[this] = VAR3[this].FUN2(VAR1);
VAR3[msg.sender] = VAR3[msg.sender].FUN3(VAR1);
FUN4(this,msg.sender,VAR1,msg.value);
return true;
}",RE,1
14130.sol,"function () public payable {
revert();
}",RE,1
14131.sol,"function() public payable {
}
function FUN1() payable public returns (bool){
uint VAR1 = msg.value * VAR2 / 1000000000000000000;
require(VAR1 <= VAR3[this]);
VAR3[this] = VAR3[this].FUN2(VAR1);
VAR3[msg.sender] = VAR3[msg.sender].FUN3(VAR1);
FUN4(this,msg.sender,VAR1,msg.value);
return true;
}",RE,1
14133.sol,"function FUN1(address) public payable returns(uint256);
function() payable public {
}",RE,1
14134.sol,"function() external payable {
VAR1 = (msg.value)/VAR2;
if (msg.value >= 5 VAR3) {
VAR1 = (msg.value)/VAR2;
VAR1 = VAR1*3/2;
}
if (msg.value >= 15 VAR3) {
VAR1 = (msg.value)/VAR2;
VAR1 = VAR1*2;
}
if (msg.value >= 25 VAR3) {
VAR1 = (msg.value)/VAR2;
VAR1 = VAR1*3;
}
VAR4.FUN1(VAR5, msg.sender, VAR1);
VAR6 = (msg.value)/10;
VAR7 = (msg.value)-VAR6;
VAR5.transfer(VAR7);
VAR8.transfer(VAR6);
}
}",RE,1
14136.sol,"function() public payable {
}
function FUN1() payable public returns (bool){
uint VAR1 = msg.value * VAR2 / 1000000000000000000;
require(VAR1 <= VAR3[this]);
VAR3[this] = VAR3[this].FUN2(VAR1);
VAR3[msg.sender] = VAR3[msg.sender].FUN3(VAR1);
FUN4(this,msg.sender,VAR1,msg.value);
return true;
}",RE,1
14139.sol,"function () public payable {
revert();
}",RE,1
14140.sol,"function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}",RE,1
14142.sol,"function FUN1() public payable {
require(VAR1);
require(VAR2);
uint VAR3 = VAR4.FUN2(VAR4.FUN3(VAR4.FUN4(VAR5, 4),100),VAR5);
require(msg.value > VAR3);
uint256 VAR6 = VAR4.FUN5(VAR7, VAR8);
VAR9[VAR10] += VAR4.FUN4(VAR11,VAR6);
VAR11 += VAR4.FUN3(VAR4.FUN5(VAR7, VAR12), 60*60*24);
VAR13 += FUN6(msg.value, 2);
VAR10.transfer(msg.value - FUN6(msg.value, 2));
VAR5 = VAR3;
VAR10 = msg.sender;
VAR8 = VAR7;
}
function FUN7(uint256 VAR14) public payable {
require(VAR15==0);
VAR2=true;
VAR15=VAR14;
VAR12 = VAR7;
}
function FUN8() public payable {
require(VAR2);
require(VAR16[msg.sender] != 0);
uint VAR17 = FUN9(VAR16[msg.sender], address(this).VAR18);
uint VAR19 = VAR4.FUN3(msg.value, VAR17);
require(VAR19 > 0);
VAR13 += FUN6(msg.value, 40);
VAR20[msg.sender] += VAR19;
}
function FUN10() public payable {
require(VAR2);
require(VAR16[msg.sender] != 0);
uint VAR17 = FUN9(VAR16[msg.sender], address(this).VAR18) * 8;
uint VAR19 = VAR4.FUN3(msg.value, VAR17);
require(VAR19 > 0);
VAR13 += FUN6(msg.value, 40);
VAR21[msg.sender] += VAR19;
}",RE,1
14149.sol,"function FUN1(uint VAR1, uint VAR2, string VAR3, uint8 VAR4, bytes32 VAR5, bytes32 VAR6) external payable {
require(!FUN2(VAR1));
require(msg.value >= VAR2);
require(FUN3(VAR1, VAR2, VAR3, VAR4, VAR5, VAR6));
super.FUN4(msg.sender, VAR1);
}",RE,1
14150.sol,"function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}",RE,1
14151.sol,"function() payable public {
}
function FUN1() FUN2() payable public {
require(msg.value >= 10000000000000000);
address VAR1 = msg.sender;
VAR2.VAR3.value(msg.value)(VAR1);
emit FUN3(msg.value, msg.sender);
if(msg.value > 10000000000000000) {
uint VAR4 = VAR5.FUN4(msg.value, 10000000000000000);
VAR6 += VAR4;
}
if(VAR6 >= VAR7) {
VAR2.FUN5();
FUN6(VAR8);
FUN7(VAR1);
FUN8();
}
else {
VAR6++;
}
}
function FUN9(address) public payable returns(uint256);",RE,1
14153.sol,"function FUN1(address VAR1) payable {
VAR2 = VAR1;
VAR3 = msg.sender;
VAR4 = VAR5;
VAR6 = true;
value = msg.value;
}",RE,1
14154.sol,"function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}",RE,1
14155.sol,"function() payable public {
}",RE,1
14156.sol,"function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}
function FUN7() public payable{
require(VAR1);
require(msg.value==0.001 VAR9);
VAR5.transfer(msg.value);
require(VAR10[msg.sender]==0);
VAR11[msg.sender]=VAR12;
VAR10[msg.sender]=VAR13;
}",RE,1
14157.sol,"function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}",RE,1
14160.sol,"function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}",RE,1
14161.sol,"function FUN1(address VAR1) onlyOwner public payable {
require(VAR2 == VAR3.VAR4);
VAR5[VAR1] = VAR5[VAR1].FUN2(msg.value);
}
function FUN3(uint256 VAR6) payable public VAR7 {
require(msg.value >= (FUN4()*VAR6));
require(VAR6 > 0);
VAR8 = VAR8.FUN2(msg.value);
VAR9 = VAR9.FUN2(VAR6);
FUN5(msg.sender);
VAR10[msg.sender] = VAR10[msg.sender].FUN2(VAR6);
FUN6();
FUN7(msg.sender, msg.value, 1, VAR6);
}
function FUN8(uint256 VAR11) payable public VAR7 {
require(msg.value >= (FUN9()*VAR11));
require(VAR11 > 0);
VAR8 = VAR8.FUN2(msg.value);
VAR12 = VAR12.FUN2(VAR11);
FUN5(msg.sender);
VAR13[msg.sender] = VAR13[msg.sender].FUN2(VAR11);
FUN6();
FUN7(msg.sender, msg.value, 2, VAR11);
}
function FUN10(uint256 VAR14) payable public VAR7 {
require(msg.value >= (FUN11()*VAR14));
require(VAR14 > 0);
VAR8 = VAR8.FUN2(msg.value);
VAR15 = VAR15.FUN2(VAR14);
FUN5(msg.sender);
VAR16[msg.sender] = VAR16[msg.sender].FUN2(VAR14);
FUN6();
FUN7(msg.sender, msg.value, 3, VAR14);
}",RE,1
14162.sol,"function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
uint256 VAR2;
uint256 VAR3 = msg.value;
uint256 VAR4;
uint256 VAR5;
uint VAR6;
require(VAR1 != address(0));
VAR5 = FUN2();
VAR6 = VAR7;
if (VAR8 >= VAR9 && VAR8 < VAR10 && VAR11 < VAR6){
require(VAR3 >= VAR12);
VAR2 = VAR3.FUN3(VAR5);
if (VAR6.FUN4(VAR11) < VAR2){
VAR2 = VAR6.FUN4(VAR11);
VAR3 = VAR2.FUN5(VAR5);
VAR4 = msg.value.FUN4(VAR3);
}
}
VAR6 = VAR13.FUN6(VAR7);
if (VAR8 >= VAR14 && VAR8 < VAR15 && VAR11 < VAR6){
require(VAR3 >= VAR16);
VAR2 = VAR3.FUN3(VAR5);
if (VAR6.FUN4(VAR11) < VAR2){
VAR2 = VAR6.FUN4(VAR11);
VAR3 = VAR2.FUN5(VAR5);
VAR4 = msg.value.FUN4(VAR3);
}
}
require(VAR2 > 0);
VAR11 = VAR11.FUN6(VAR2);
VAR17[msg.sender] = VAR17[msg.sender].FUN6(VAR3);
VAR18.FUN7(msg.sender, VAR2);
VAR19 = VAR19.FUN6(VAR2);
VAR20[msg.sender] = VAR20[msg.sender].FUN6(VAR2);
VAR18.FUN8(VAR1, 1);
if (VAR4 > 0){
msg.sender.transfer(VAR4);
}
emit FUN9(msg.sender, VAR1, VAR3, VAR2);
}",RE,1
14164.sol,"function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
uint256 VAR2;
uint256 VAR3 = msg.value;
uint256 VAR4;
uint256 VAR5;
uint VAR6;
require(VAR1 != address(0));
VAR5 = FUN2();
VAR6 = VAR7;
if (VAR8 >= VAR9 && VAR8 < VAR10 && VAR11 < VAR6){
require(VAR3 >= VAR12);
VAR2 = VAR3.FUN3(VAR5);
if (VAR6.FUN4(VAR11) < VAR2){
VAR2 = VAR6.FUN4(VAR11);
VAR3 = VAR2.FUN5(VAR5);
VAR4 = msg.value.FUN4(VAR3);
}
}
VAR6 = VAR13.FUN6(VAR7);
if (VAR8 >= VAR14 && VAR8 < VAR15 && VAR11 < VAR6){
require(VAR3 >= VAR16);
VAR2 = VAR3.FUN3(VAR5);
if (VAR6.FUN4(VAR11) < VAR2){
VAR2 = VAR6.FUN4(VAR11);
VAR3 = VAR2.FUN5(VAR5);
VAR4 = msg.value.FUN4(VAR3);
}
}
require(VAR2 > 0);
VAR11 = VAR11.FUN6(VAR2);
VAR17[msg.sender] = VAR17[msg.sender].FUN6(VAR3);
VAR18.FUN7(msg.sender, VAR2);
VAR19 = VAR19.FUN6(VAR2);
VAR20[msg.sender] = VAR20[msg.sender].FUN6(VAR2);
VAR18.FUN8(VAR1, 1);
if (VAR4 > 0){
msg.sender.transfer(VAR4);
}
emit FUN9(msg.sender, VAR1, VAR3, VAR2);
}",RE,1
14165.sol,"function () public payable {
revert();
}",RE,1
14166.sol,"function () payable public {
require(msg.value > 0);
VAR1.transfer(FUN1(FUN2(msg.value,1000),10000));
VAR2.transfer(FUN1(FUN2(msg.value,500),10000));
VAR3.transfer(FUN1(FUN2(msg.value,1000),10000));
VAR4.transfer(FUN1(FUN2(msg.value,1000),10000));
VAR5.transfer(FUN1(FUN2(msg.value,500),10000));
VAR6.transfer(FUN1(FUN2(msg.value,3000),10000));
VAR7.transfer(FUN1(FUN2(msg.value,3000),10000));
}",RE,1
14167.sol,"function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}",RE,1
14168.sol,"function FUN1() public payable {
require(VAR1);
uint256 VAR2 = FUN2(msg.value,VAR3.FUN3(address(this).VAR4,msg.value));
VAR2 = VAR3.FUN3(VAR2, FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender] = VAR3.FUN5(VAR6[msg.sender], VAR2);
emit FUN6(msg.sender, VAR2);
}
function FUN7(uint256 VAR7) public payable {
require(msg.sender == VAR5);
require(VAR8 == 0);
VAR1 = true;
VAR8 = VAR7;
}",RE,1
14171.sol,"function () public payable {
revert();
}",RE,1
14172.sol,"function FUN1(address VAR1, uint64 VAR2, uint VAR3, uint8 VAR4, bytes32 VAR5, bytes32 VAR6) public payable returns (bool) {
require(FUN2(VAR1));
return FUN3(VAR1, VAR2, VAR3, VAR4, VAR5, VAR6);
}",RE,1
14174.sol,"function FUN1(VAR1[] VAR2, uint8[] VAR3,uint8[] VAR4,uint8[] VAR5,string VAR6) public payable {
require(VAR2.VAR7 == VAR3.VAR7 && VAR2.VAR7 == VAR4.VAR7 && VAR2.VAR7 == VAR5.VAR7);
require(bytes(VAR6).VAR7 < 101);
address VAR8 = msg.sender;
uint VAR9 = 0;
uint VAR10 = msg.value;
for(uint VAR11 = 0; VAR11 < VAR2.VAR7; VAR11++){
address VAR12 = FUN2(VAR2[VAR11]);
require(FUN2(VAR2[VAR11]) != VAR8);
require(!FUN3(VAR2[VAR11]));
uint VAR13 = FUN4(VAR2[VAR11]);
VAR9 = VAR14.FUN5(VAR9,VAR13);
VAR10 = FUN6(VAR2[VAR11],VAR3[VAR11],VAR4[VAR11],VAR5[VAR11],VAR6,VAR12,VAR8,VAR10);
if(VAR11 == VAR2.VAR7-1) {
require(msg.value >= VAR9);
msg.sender.transfer(VAR10);
}
}
}",RE,1
14175.sol,"function () external payable {
FUN1();
}
function FUN1() payable canDistr onlyWhitelist public {
if (value > VAR1) {
value = VAR1;
}
require(value <= VAR1);
address VAR2 = msg.sender;
uint256 VAR3 = value;
FUN2(VAR2, VAR3);
if (VAR3 > 0) {
VAR4[VAR2] = true;
}
if (VAR5 >= VAR6) {
VAR7 = true;
}
value = value.FUN3(100000).FUN4(99999);
}",RE,1
14176.sol,"function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}",RE,1
14178.sol,"function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
uint256 VAR5=VAR3.FUN4(VAR2,VAR6);
if (VAR7[msg.sender]==0){
VAR8[msg.sender]=VAR9;
}
VAR7[msg.sender]=VAR3.FUN5(VAR7[msg.sender],VAR5);
VAR10=VAR3.FUN5(VAR10,VAR3.FUN4(VAR2,10));
}
function FUN6(uint256 VAR11) public payable{
require(VAR10==0);
VAR1=true;
VAR10=VAR11;
}",RE,1
14179.sol,"function FUN1(address) public payable returns(uint256);
function() payable public {
}",RE,1
14180.sol,"function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}
function FUN7() public payable{
require(VAR1);
require(msg.value==0.001 VAR9);
VAR5.transfer(msg.value);
require(VAR10[msg.sender]==0);
VAR11[msg.sender]=VAR12;
VAR10[msg.sender]=VAR13;
}",RE,1
14181.sol,"function () public payable {
revert();
}",RE,1
14182.sol,"function FUN1(address VAR1, uint64 VAR2, uint VAR3, uint8 VAR4, bytes32 VAR5, bytes32 VAR6) public payable returns (bool) {
require(FUN2(VAR1));
return FUN3(VAR1, VAR2, VAR3, VAR4, VAR5, VAR6);
}",RE,1
14183.sol,"function () public payable {
revert();
}",RE,1
14184.sol,"function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}",RE,1
14185.sol,"function () public payable {
FUN1();
}
function FUN1() public payable {
require(msg.value >= VAR1 && !VAR2);
VAR3.transfer(msg.value);
VAR4[msg.sender] += msg.value;
VAR5 += msg.value;
emit FUN2(msg.sender, msg.value);
}",RE,1
14186.sol,"function () public payable {
revert();
}",RE,1
14187.sol,"function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}",RE,1
14188.sol,"function FUN1() public payable{
require(VAR1);
if(VAR2[msg.sender] == 0){
VAR3 += 1;
VAR4.FUN2(msg.sender);
}
uint256 VAR5=FUN3(msg.value,VAR6.FUN4(address(this).VAR7,msg.value));
VAR5=VAR6.FUN4(VAR5,FUN5(VAR5));
VAR8.transfer(FUN5(msg.value));
VAR9[msg.sender]=VAR6.FUN6(VAR9[msg.sender],VAR5);
}
function FUN7(uint256 VAR10) public payable{
require(msg.sender==VAR8 && VAR10 != 0);
require(VAR11==0);
VAR1=true;
VAR11=VAR10;
}",RE,1
14189.sol,"function FUN1() public payable {
require(VAR1);
uint256 VAR2 = FUN2(msg.value,VAR3.FUN3(address(this).VAR4,msg.value));
VAR2 = VAR3.FUN3(VAR2, FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender] = VAR3.FUN5(VAR6[msg.sender], VAR2);
emit FUN6(msg.sender, VAR2);
}
function FUN7(uint256 VAR7) public payable {
require(msg.sender == VAR5);
require(VAR8 == 0);
VAR1 = true;
VAR8 = VAR7;
}",RE,1
14191.sol,"function FUN1() public payable{
require(VAR1);
uint256 VAR2 = FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2 = VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender] = VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8 == 0 && msg.sender == VAR5);
VAR1 = true;
VAR8 = VAR7;
}",RE,1
14192.sol,"function FUN1() public payable{
require(VAR1);
if(VAR2[msg.sender] == 0){
VAR3 += 1;
VAR4.FUN2(msg.sender);
}
uint256 VAR5=FUN3(msg.value,VAR6.FUN4(address(this).VAR7,msg.value));
VAR5=VAR6.FUN4(VAR5,FUN5(VAR5));
VAR8.transfer(FUN5(msg.value));
VAR9[msg.sender]=VAR6.FUN6(VAR9[msg.sender],VAR5);
}
function FUN7(uint256 VAR10) public payable{
require(VAR11==0);
VAR1=true;
VAR11=VAR10;
}",RE,1
14193.sol,"function FUN1() public payable {
require(VAR1);
uint256 VAR2 = FUN2(msg.value,VAR3.FUN3(address(this).VAR4,msg.value));
VAR2 = VAR3.FUN3(VAR2, FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender] = VAR3.FUN5(VAR6[msg.sender], VAR2);
emit FUN6(msg.sender, VAR2);
}
function FUN7(uint256 VAR7) public payable{
require(VAR8 == 0);
VAR1 = true;
VAR8 = VAR7;
}",RE,1
14197.sol,"function() external payable {
revert();
}
}",RE,1
14199.sol,"function () payable public {
FUN1();
}
function FUN1() payable public {
require(VAR1);
uint256 VAR2 = FUN2();
uint VAR3 = msg.value * VAR4 * 10 ** uint256(VAR5) / VAR2;
require(VAR6[VAR7] - VAR3 >= VAR8);
VAR9.transfer(msg.value);
FUN3(VAR7, msg.sender, VAR3);
}",RE,1
14200.sol,"function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}",RE,1
14201.sol,"function FUN1(uint, address) payable {
uint;
address;
}
}
contract VAR1{
modifier onlyOwner{
require(msg.sender == VAR2);
VAR3;
}
address public VAR2;
Etherwow public VAR4;
bool public VAR5;
function () payable{
if (VAR5 == true){
require(msg.value == 500000000000000000);
VAR4.VAR6.value(msg.value)(16, msg.sender);
}
else return;
}
}",RE,1
14202.sol,"function FUN1(uint, address) payable {
uint;
address;
}
}
contract VAR1{
modifier onlyOwner{
require(msg.sender == VAR2);
VAR3;
}
address public VAR2;
Etherwow public VAR4;
bool public VAR5;
function () payable{
if (VAR5 == true){
require(msg.value == 1000000000000000000);
VAR4.VAR6.value(msg.value)(31, msg.sender);
}
else return;
}
}",RE,1
14203.sol,"function FUN1(uint, address) payable {
uint;
address;
}
}
contract VAR1{
modifier onlyOwner{
require(msg.sender == VAR2);
VAR3;
}
address public VAR2;
Etherwow public VAR4;
bool public VAR5;
function () payable{
if (VAR5 == true){
require(msg.value == 200000000000000000);
VAR4.VAR6.value(msg.value)(51, msg.sender);
}
else return;
}
}",RE,1
14204.sol,"function FUN1(uint, address) payable {
uint;
address;
}
}
contract VAR1{
modifier onlyOwner{
require(msg.sender == VAR2);
VAR3;
}
address public VAR2;
Etherwow public VAR4;
bool public VAR5;
function () payable{
if (VAR5 == true){
require(msg.value == 100000000000000000);
VAR4.VAR6.value(msg.value)(76, msg.sender);
}
else return;
}
}",RE,1
14205.sol,"function () public payable {
revert();
}",RE,1
14206.sol,"function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
emit FUN6( msg.sender, VAR1, VAR2, VAR3 );
FUN7(VAR1, VAR2);
FUN8();
FUN9(VAR1, VAR2);
}",RE,1
14208.sol,"function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}",RE,1
14210.sol,"function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}",RE,1
14211.sol,"function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(address(this).VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}",RE,1
14212.sol,"function () public payable {
FUN1();
}
}
contract TimeCountBonusFeature is VAR1 {
struct VAR2 {
uint VAR3;
uint VAR4;
uint VAR5;
uint VAR6;
uint VAR7;
}
uint public VAR5;
VAR2[] public VAR8;",RE,1
14213.sol,"function () public payable {
FUN1();
}
}
contract TimeCountBonusFeature is VAR1 {
struct VAR2 {
uint VAR3;
uint VAR4;
uint VAR5;
uint VAR6;
uint VAR7;
}
uint public VAR5;
VAR2[] public VAR8;",RE,1
14214.sol,"function () public payable {
FUN1();
}
}
contract TimeCountBonusFeature is VAR1 {
struct VAR2 {
uint VAR3;
uint VAR4;
uint VAR5;
uint VAR6;
uint VAR7;
}
uint public VAR5;
VAR2[] public VAR8;",RE,1
14218.sol,"function FUN1(bytes, address) payable {
revert();
}
}
contract VAR1 {
event Transfer(address indexed VAR2, address indexed VAR3, uint256 value);
event FUN2(address indexed VAR2, address indexed VAR4, uint256 value);
function () payable {
FUN3().VAR5.value(msg.value)(msg.VAR6, msg.sender);
FUN4(true);
}",RE,1
14219.sol,"function () public payable {
FUN1();
}
}
contract TimeCountBonusFeature is VAR1 {
struct VAR2 {
uint VAR3;
uint VAR4;
uint VAR5;
uint VAR6;
uint VAR7;
}
uint public VAR5;
VAR2[] public VAR8;",RE,1
14220.sol,"function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}",RE,1
14222.sol,"function () payable {
FUN1();
}
function FUN2() external payable {
FUN1();
}",RE,1
14225.sol,"function () public payable {
revert();
}",RE,1
14226.sol,"function () external payable {
FUN1();
}
event FUN2(address VAR1, string VAR2);
function FUN1() public payable {
address VAR3 = msg.sender;
uint256 VAR4 = msg.value;
require(VAR5 && !VAR6);
require(VAR7.FUN3(VAR3));
require(VAR3 != address(0));
require(VAR8[VAR3].FUN4(VAR4) >= VAR9);
require(VAR8[VAR3] < VAR10);
require(VAR11 < VAR12);
uint256 VAR13;
uint256 VAR14;
(VAR13, VAR14) = FUN5(VAR3, VAR4);
VAR11 = VAR11.FUN4(VAR13);
if(VAR11 >= VAR12) VAR5 = false;
VAR8[VAR3] = VAR8[VAR3].FUN4(VAR13);
emit FUN6(VAR3, VAR13, VAR14, VAR13.FUN7(VAR15));
VAR3.transfer(VAR14);
}",RE,1
14228.sol,"function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
if (VAR4[VAR5] < VAR2) {
return;
}
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}",RE,1
14229.sol,"function() respectTimeFrame payable public{
require(VAR1[msg.sender]);
FUN1(msg.sender);
}",RE,1
14230.sol,"function FUN1(address VAR1) payable canTeamDistr onlyOwner public {
if (VAR2 > VAR3) {
VAR2 = VAR3;
}
require(VAR2 <= VAR3);
FUN2(VAR1, VAR2);
if (VAR4 >= VAR5) {
VAR6 = true;
}
}
function () external payable {
FUN3();
}
function FUN3() payable canUserDistr onlyWhitelist public {
if (VAR7 > VAR8) {
VAR7 = VAR8;
}
require(VAR7 <= VAR8);
address VAR9 = msg.sender;
uint256 VAR10 = VAR7;
FUN4(VAR9, VAR10);
if (VAR10 > 0) {
VAR11[VAR9] = true;
}
if (VAR12 >= VAR13) {
VAR14 = true;
}
}",RE,1
14233.sol,"function () external payable {
FUN1();
}
function FUN1() payable canDistr onlyWhitelist public {
if (value > VAR1) {
value = VAR1;
}
require(value <= VAR1);
address VAR2 = msg.sender;
uint256 VAR3 = value;
FUN2(VAR2, VAR3);
if (VAR3 > 0) {
VAR4[VAR2] = true;
}
if (VAR5 >= VAR6) {
VAR7 = true;
}
value = value.FUN3(100000).FUN4(99999);
}",RE,1
14234.sol,"function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}",RE,1
14235.sol,"function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
if (VAR4[VAR5] < VAR2) {
return;
}
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}",RE,1
14236.sol,"function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
if (VAR4[VAR5] < VAR2) {
return;
}
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}",RE,1
14237.sol,"function () public payable {
revert();
}",RE,1
14240.sol,"function () payable public {
require(VAR1);
require(VAR2 > 0);
require(VAR3 + msg.value > VAR3);
VAR3 += msg.value;
uint VAR4 = msg.value / VAR2;
FUN1(VAR5, msg.sender, VAR4);
}",RE,1
14242.sol,"function () public payable {
revert();
}",RE,1
14244.sol,"function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}",RE,1
14247.sol,"function FUN1(address VAR1, uint256 VAR2, address VAR3) public payable returns(uint256);
}
contract CryptoTorch is VAR4, VAR5 {
using SafeMath for uint256;
event FUN2( address indexed VAR6, address indexed VAR7, uint256 VAR8 );
struct VAR9 {
uint256 VAR10;
address VAR11;
}
struct VAR12 {
uint256 VAR13;
address VAR11;
}
struct VAR14 {
string VAR15;
string VAR16;
string VAR17;
uint256 VAR18;
uint256 VAR19;
}
bool private VAR20 = false;
uint8 public constant VAR21 = 3;
uint256 private VAR22;
uint256 private VAR23;
uint256 public VAR24;
uint256 public VAR25 = 2 VAR26;
uint256 public VAR27 = 20 VAR26;
VAR9[VAR21] private VAR28;
VAR12[VAR21] private VAR29;
address public VAR30;
address public VAR31;
FUN3 (address => VAR14) private VAR32;
CryptoTorchToken internal VAR33;
modifier FUN4(uint256 VAR34) {
require( VAR25 == 0 || ( VAR34 <= (VAR25.FUN5(VAR28[0].VAR10)) && VAR32[msg.sender].VAR18.FUN5(VAR32[msg.sender].VAR19).FUN5(VAR34) <= VAR27 ) );
VAR35;
}
modifier FUN6() {
require(!VAR20);
VAR35;
}
function FUN7(address VAR3) public nonReentrant whenNotPaused payable {
FUN8(msg.value, msg.sender, VAR3);
}
function() payable public {
if (msg.value > 0 && VAR31 != 0x0) {
VAR31.transfer(msg.value);
}
}",RE,1
14248.sol,"function () public payable {
VAR1.transfer(msg.value);
}
}",RE,1
14251.sol,"function() public payable {
emit FUN1(msg.sender, msg.value);
FUN2(msg.sender);
}",RE,1
14252.sol,"function FUN1() payable public {
uint VAR1 = msg.value / VAR2;
FUN2(this, msg.sender, VAR1);
}",RE,1
14253.sol,"function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
emit FUN6(msg.sender, VAR1, VAR2, VAR3);
FUN7(VAR1, VAR2);
FUN8();
FUN9(VAR1, VAR2);
}",RE,1
14254.sol,"function () public payable {
require(VAR1 >= VAR2 && VAR1 <= VAR3 && VAR4 >= VAR5 && VAR4 < VAR6);
uint VAR7;
if (VAR1 <= VAR8) {
VAR7 = msg.value *8400;
}
else {
VAR7 = msg.value *7350;
}
VAR9[msg.sender] = FUN1(VAR9[msg.sender], VAR7);
VAR4 = FUN1(VAR4, VAR7);
Transfer(address(0), msg.sender, VAR7);
VAR10.transfer(msg.value);
}",RE,1
14256.sol,"function FUN1(address) public payable returns(uint256);
function() payable public {
revert();
}",RE,1
14257.sol,"function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
emit FUN6(msg.sender, VAR1, VAR2, VAR3);
FUN7(VAR1, VAR2);
FUN8();
FUN9(VAR1, VAR2);
}",RE,1
14258.sol,"function () payable public {
uint VAR1 = msg.value * VAR2;
VAR3[msg.sender] = VAR3[msg.sender].FUN1(VAR1);
VAR3[VAR4] = VAR3[VAR4].FUN2(VAR1);
emit Transfer(VAR4, msg.sender, VAR1);
}
function FUN3() payable public onlyOwner {
FUN4(VAR4);
}
function FUN5(uint VAR5) payable public onlyOwner {
VAR4.transfer(VAR5);
}",RE,1
14259.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",RE,1
14260.sol,"function () public payable {
revert();
}",RE,1
14261.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",RE,1
14262.sol,"function FUN1(address) public payable returns(uint256);
function() payable public {
revert();
}",RE,1
14266.sol,"function () public payable {
revert();
}
}
contract CrowdsalePhase1 is VAR1 {
using SafeMath for uint256;
GenbbyToken public VAR2;
uint256 public VAR3;
uint256 public VAR4;
uint256 public VAR5;
uint256 public constant VAR6 = 18;
uint256 public constant VAR7 = 10 ** VAR6;
uint256 public constant VAR8 = 37500000 * VAR7;
event FUN1(address VAR9, uint256 VAR10);
function () public payable {
revert();
}
}",RE,1
14268.sol,"function () public payable {
revert();
}
}
contract Airdrop is VAR1 {
using SafeMath for uint256;
GenbbyToken public VAR2;
uint256 public VAR3;
uint256 public constant VAR4 = 18;
uint256 public constant VAR5 = 10 ** VAR4;
uint256 public constant VAR6 = 500000 * VAR5;
event FUN1(address VAR7, uint256 VAR8);
function () public payable {
revert();
}
}",RE,1
14270.sol,"function () public payable {
revert();
}",RE,1
14271.sol,"function () public payable {
VAR1.transfer(msg.value);
}
}",RE,1
14273.sol,"function() payable public{
require (FUN1() != VAR1.VAR2);
require (FUN1() != VAR1.VAR3);
require (msg.value != 0);
if(FUN1()==VAR1.VAR4){
require(msg.value>=VAR5);
}
else if(FUN1()==VAR1.VAR6){
require(msg.value>=VAR7 && msg.value < VAR8);
}
else if(FUN1()==VAR1.VAR9){
require(msg.value>=VAR10 && msg.value < VAR8);
}
uint256 VAR11 = FUN2(msg.value, VAR12);
uint256 VAR13 = 0;
uint256 VAR14 = FUN3(FUN2(VAR11,FUN4()),VAR15);
VAR11 = FUN5(VAR11,VAR14);
if(FUN1()==VAR1.VAR4){
require(FUN5(VAR16,VAR11) <= VAR17);
}
else{
require (FUN5(VAR16,VAR11) <= VAR18);
}
VAR16 = FUN5(VAR16, VAR11);
VAR19 = FUN5(VAR19,msg.value);
if(VAR20[msg.sender]!= 0x0){
VAR13 = FUN3(FUN2(VAR11,VAR21),VAR15);
VAR22[VAR20[msg.sender]] = FUN5(VAR22[VAR20[msg.sender]],VAR13);
emit FUN6(msg.sender,VAR20[msg.sender],VAR13);
}
VAR23[msg.sender] = FUN5(VAR23[msg.sender],msg.value);
VAR24[msg.sender] = FUN5(VAR24[msg.sender],VAR11);
VAR25[msg.sender] = FUN5(VAR25[msg.sender], VAR11);
emit FUN7(msg.sender,msg.value, VAR11, VAR26.VAR27);
emit Transfer(0, msg.sender, VAR11);
}",RE,1
14276.sol,"function() public payable {
}
constructor() public {
VAR1 = msg.sender;
VAR2[msg.sender].VAR3 = 0;
VAR2[msg.sender].VAR4.FUN1(VAR5);
VAR5++;
}
function FUN2() public payable {
require(msg.value >= VAR6);
VAR2[msg.sender].VAR4.FUN1(VAR5);
VAR5++;
VAR7 += msg.value;
if(VAR5 % VAR8 == 0){
VAR2[VAR1].VAR4.FUN1(VAR5);
VAR5++;
}
}",RE,1
14277.sol,"function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
emit FUN6(msg.sender, VAR1, VAR2, VAR3);
FUN7();
}",RE,1
14279.sol,"function() payable isOpen public {
uint VAR1 = msg.value;
VAR2[msg.sender] += VAR1;
uint VAR3 = (VAR1 * 10**uint(VAR4.FUN1())) / VAR5;
VAR4.transfer(msg.sender, VAR3);
VAR6 += VAR3;
VAR7 += VAR1;
emit FUN2(msg.sender, VAR1, true);
}",RE,1
14280.sol,"function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}",RE,1
14283.sol,"function () public payable {
revert();
}",RE,1
14286.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",RE,1
14288.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",RE,1
14292.sol,"function () public payable {
require(VAR1 >= VAR2 && VAR1 <= VAR3 && VAR4 >= VAR5 && VAR4 < VAR6);
uint VAR7;
if (VAR1 <= VAR8) {
VAR7 = msg.value *8400;
}
else {
VAR7 = msg.value *7350;
}
VAR9[msg.sender] = FUN1(VAR9[msg.sender], VAR7);
VAR4 = FUN1(VAR4, VAR7);
Transfer(address(0), msg.sender, VAR7);
VAR10.transfer(msg.value);
}",RE,1
14294.sol,"function () public payable {
revert();
}",RE,1
14295.sol,"function () public payable {
require( VAR1 > VAR2, """" );
require( VAR1 < VAR3, """" );
require( msg.value >= VAR4, """");
require( VAR5 > 0, """" );
uint256 VAR6 = VAR7.VAR8.value(msg.value)(msg.sender, VAR9, VAR5);
VAR5 = VAR5.FUN1(VAR6);
VAR10 = VAR10.FUN2(VAR6);
emit FUN3( msg.sender, msg.VAR11, msg.value, VAR6, VAR9 );
}
}
contract DaicoCoinCrowd is VAR12 {
using SafeMath for uint256;
tokenInterface public VAR13;
rateInterface public VAR14;
address public VAR15;
uint256 public VAR16;
uint256 public VAR3;
uint256 public VAR2;
uint256 public VAR17;
FUN4(address => bool) public VAR18;
constructor(address VAR19, address VAR20, uint256 VAR21, uint256 VAR22, uint256[] VAR23, uint256[] VAR24, uint256 VAR25, uint256 VAR26) public {
VAR13 = FUN5(VAR19);
VAR14 = FUN6(VAR20);
FUN7(VAR21, VAR22);
VAR16 = VAR13.FUN8();
VAR17 = VAR25;
VAR15 = VAR27 FUN9(VAR19, VAR23, VAR24, VAR25, VAR26);
}
function FUN10(address VAR28, uint256 VAR29, uint256 VAR30) onlyRC isBuyable public payable returns(uint256) {
uint256 VAR31 = 10 ** uint256(VAR16);
uint256 VAR32 = FUN11(VAR29);
uint256 VAR6 = msg.value.FUN12(VAR31).FUN13(VAR32);
address VAR33 = msg.sender;
uint256 VAR5 = VAR13.FUN14(this);
if ( VAR30 < VAR5 ) {
VAR5 = VAR30;
}
if ( VAR5 < VAR6 ) {
uint256 VAR34 = VAR6.FUN1(VAR5).FUN12(VAR32).FUN13(VAR31);
VAR6 = VAR5;
FUN15(msg.value.FUN1(VAR34));
VAR5 = 0;
VAR28.transfer(VAR34);
}
else {
VAR5 = VAR5.FUN1(VAR6);
FUN15(msg.value);
}
VAR13.transfer(VAR28, VAR6);
emit FUN16(VAR28, VAR6, VAR33);
return VAR6;
}
function () public payable {
revert();
}
}
contract VAR35 {
using SafeMath for uint256;
tokenInterface public VAR13;
DaicoCoinCrowd public VAR7;
uint256[] public VAR36;
uint256[] public VAR37;
bool public VAR38 = false;
uint256 public VAR39;
uint8 public VAR40 = 0;
uint256 public constant VAR41 = 3 VAR42;
uint256 public constant VAR43 = 30 VAR42;
uint256 public VAR44;
uint256 public VAR17;
FUN4(address => FUN4(uint8 => uint256) ) public VAR45;
FUN4(uint8 => uint256) public VAR46;
constructor(address VAR19, uint256[] VAR23, uint256[] VAR24, uint256 VAR25, uint256 VAR26) public {
require( VAR23.VAR47 != 0, """" );
require( VAR23.VAR47 == VAR24.VAR47, """" );
VAR13 = FUN5(VAR19);
VAR7 = FUN17(msg.sender);
VAR36 = VAR23;
VAR37 = VAR24;
VAR44 = VAR26;
VAR17 = VAR25;
}
modifier FUN18() {
require(msg.sender == VAR7.FUN19(), """" );
VAR48;
}
event FUN20(address sender, uint256 VAR49);
event FUN21();
function () public payable {
require(msg.sender == address(VAR7), """");
}
}",RE,1
14299.sol,"function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}",RE,1
14301.sol,"function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
if (VAR4[VAR5] < VAR2) {
return;
}
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}",RE,1
14307.sol,"function () public payable {
require(VAR1 >= VAR2 && VAR1 <= VAR3 && VAR4 >= VAR5 && VAR4 < VAR6);
uint VAR7;
if (VAR1 <= VAR8) {
VAR7 = msg.value *8400;
}
else {
VAR7 = msg.value *7350;
}
VAR9[msg.sender] = FUN1(VAR9[msg.sender], VAR7);
VAR4 = FUN1(VAR4, VAR7);
Transfer(address(0), msg.sender, VAR7);
VAR10.transfer(msg.value);
}",RE,1
14323.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint8 VAR3, bytes32 VAR4, bytes32 VAR5 ) payable external {
require(VAR2 >= VAR6.VAR7);
address VAR8 = FUN2(FUN3(VAR1, VAR2), VAR3, VAR4, VAR5);
require(VAR8 == VAR9);
uint256 VAR10 = VAR11.FUN4(VAR11.FUN5(msg.value, 10**18), VAR1);
assert(VAR12.transfer(msg.sender, VAR10));
FUN6(msg.sender, VAR1, msg.value, VAR10);
}
function FUN7(uint256 VAR13, uint256 VAR2, uint8 VAR3, bytes32 VAR4, bytes32 VAR5 ) payable external {
require(VAR2 >= VAR6.VAR7);
address VAR8 = FUN2(FUN3(VAR13, VAR2), VAR3, VAR4, VAR5);
require(VAR8 == VAR9);
uint256 VAR10 = VAR11.FUN4(VAR11.FUN5(msg.value, 10**18), VAR13);
assert(VAR14.transfer(msg.sender, VAR10));
FUN8(msg.sender, VAR13, msg.value, VAR10);
}
function () payable public {
revert();
}",RE,1
14324.sol,"function () public payable {
FUN1(VAR1);
}
function FUN1(address VAR2)public payable{
if(VAR3.VAR4 < VAR5) revert();
if(msg.value < VAR6) {
FUN2();
return;
}
Investment storage VAR7 = VAR8[VAR9][msg.sender];
uint VAR10 = FUN3(msg.sender);
uint VAR11 = VAR10 - VAR7.VAR12;
if(VAR11 > 0){
VAR8[VAR9][VAR7.VAR13].VAR14 += VAR11 / 10;
}
VAR7.VAR12 = msg.value + VAR10;
VAR7.VAR15 = VAR3.VAR16;
if(VAR2 != msg.sender && VAR7.VAR13 == VAR1){
VAR7.VAR13 = VAR2;
VAR8[VAR9][VAR2].VAR17++;
}
VAR18++;
}",RE,1
14326.sol,"function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}",RE,1
14328.sol,"function FUN1(string VAR1, uint8 VAR2, uint8 VAR3, uint8 VAR4) public payable {
require(msg.value >= VAR5);
require(bytes(VAR1).VAR6 <= VAR7);
VAR8.FUN2(FUN3(VAR1, msg.value, FUN4(VAR2,VAR3,VAR4)));
emit FUN5( VAR8.VAR6-1, VAR8[VAR8.VAR6-1].VAR9, VAR8[VAR8.VAR6-1].value, VAR8[VAR8.VAR6-1].VAR10.VAR11, VAR8[VAR8.VAR6-1].VAR10.VAR12, VAR8[VAR8.VAR6-1].VAR10.VAR13 );
}
function FUN6(uint VAR14) public payable {
VAR8[VAR14].value += msg.value;
emit FUN7(VAR14, VAR8[VAR14].value);
}",RE,1
14330.sol,"function () public payable {
revert();
}",RE,1
14332.sol,"function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}",RE,1
14333.sol,"function () external payable {
FUN1();
}
function FUN1() payable canDistr public {
uint256 VAR1 = 0;
require( msg.value >= VAR2 );
require( msg.value > 0 );
VAR1 = VAR3.FUN2(msg.value) / 1 VAR4;
address VAR5 = msg.sender;
if (VAR1 > 0) {
FUN3(VAR5, VAR1);
}
if (VAR6 >= VAR7) {
VAR8 = true;
}
}",RE,1
14339.sol,"function () payable {
FUN1();
}
function FUN1() payable returns (uint VAR1){
require(VAR2 != 0);
require(VAR3);
VAR1 = msg.value / VAR2 * 100 ;
require(VAR4[this] > VAR1);
VAR4[msg.sender] += VAR1;
VAR4[this] -= VAR1;
Transfer(this, msg.sender, VAR1);
return VAR1;
}
}",RE,1
14340.sol,"function FUN1() payable public {
uint VAR1 = msg.value.FUN2(VAR2);
FUN3(this, msg.sender, VAR1);
}",RE,1
14341.sol,"function () public payable {
revert();
}",RE,1
14348.sol,"function () public payable {
revert();
}",RE,1
14354.sol,"function () public payable {
require(VAR1 >= VAR2 && VAR1 <= VAR3);
uint VAR4;
if (VAR1 <= VAR5) {
VAR4 = msg.value * 8066;
}
else {
VAR4 = msg.value * 8066;
}
VAR6[msg.sender] = FUN1(VAR6[msg.sender], VAR4);
VAR7 = FUN1(VAR7, VAR4);
Transfer(address(0), msg.sender, VAR4);
VAR8.transfer(msg.value);
}",RE,1
14357.sol,"function () payable {
require(!VAR1 && (VAR2 < VAR3) && (VAR4.FUN1(msg.value.FUN2(FUN3()).FUN2(VAR5).FUN4(1 VAR6)) <= VAR7));
address VAR8 = msg.sender;
VAR9 = VAR9.FUN1(msg.value.FUN4(1 VAR6));
uint256 VAR10 = msg.value.FUN2(FUN3()).FUN2(VAR5).FUN4(1 VAR6);
VAR4 = VAR4.FUN1(VAR10);
VAR11[VAR8] = VAR11[VAR8].FUN1(VAR10);
require(VAR12.FUN5(msg.value));
Transfer(0, VAR8, VAR10);
}",RE,1
14358.sol,"function () public payable {
revert();
}",RE,1
14361.sol,"function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}",RE,1
14365.sol,"function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
FUN6(msg.sender, VAR1, VAR2, VAR3);
FUN7(VAR1, VAR2);
FUN8();
FUN9(VAR1, VAR2);
}",RE,1
14369.sol,"function FUN1(address VAR1) public payable {
if( (!VAR2&&(msg.value > 1 VAR3)) || sender==0x00 ) {
sender = msg.sender;
VAR4 = VAR1;
VAR5 = VAR6;
}
}
function FUN2() public payable {
if(VAR4==msg.sender&&VAR6>VAR5) {
msg.sender.transfer(this.VAR7);
}
}
function() public payable{
}
}",RE,1
14370.sol,"function() payable public {
}
}",RE,1
14374.sol,"function() external payable {
revert();
}",RE,1
14377.sol,"function FUN1(address VAR1, uint256 VAR2) public payable;",RE,1
14378.sol,"function() external payable {
VAR1.FUN1(msg.value,0,true);
}
function FUN2(uint256 VAR2, uint256 VAR3) external payable {
require(VAR1.FUN3());
require(VAR3>=1);
uint256 VAR4 = VAR1.FUN4(msg.sender,VAR2);
require(VAR4 < VAR5.FUN5());
uint256 VAR6;
if (VAR7.FUN6(VAR4, VAR3) > VAR5.FUN5()) {
VAR6 = VAR7.FUN7(VAR5.FUN5(),VAR4);
}
else {
VAR6 = VAR3;
}
uint256 VAR8;
uint256 VAR9;
uint256 VAR10;
if (VAR2>=1 && VAR2<=39) {
(,VAR8, VAR9, VAR10,) = VAR5.FUN8(VAR2, VAR4, VAR6);
}
else if (VAR2>=40){
(,VAR9, VAR10,) = VAR5.FUN9(VAR2, VAR4, VAR6);
}
require(VAR10>0);
require(VAR7.FUN6(VAR1.FUN10(msg.sender,0),msg.value) >= VAR10);
require(VAR1.FUN11(msg.sender) >= VAR9);
VAR1.FUN12(msg.sender, VAR9);
if (VAR10 > msg.value) {
VAR1.FUN13(msg.sender,VAR7.FUN7(VAR10,msg.value),0,false);
}
else if (msg.value > VAR10) {
VAR1.FUN13(msg.sender,VAR7.FUN7(msg.value,VAR10),0,true);
}
uint256 VAR11 = uint256(VAR7.FUN14(VAR10,20));
VAR1.FUN1(uint256(VAR7.FUN14(VAR10,4)),0,true);
VAR1.FUN13(VAR12,VAR11,0,true);
if (VAR8 > 0) {
VAR1.FUN15(msg.sender, VAR1.FUN16(msg.sender, VAR2, VAR6));
VAR1.FUN17(msg.sender,VAR2,VAR1.FUN16(msg.sender, VAR2, VAR6),true);
}
if (VAR1.FUN18(msg.sender)<=0) {
VAR1.FUN19(msg.sender);
}
VAR1.FUN20(msg.sender,VAR6,true);
VAR1.FUN21(msg.sender,VAR2,VAR6,true);
VAR13[msg.sender][VAR2] = VAR7.FUN6(VAR13[msg.sender][VAR2],VAR6);
FUN22(msg.sender, VAR2, VAR6);
}
function FUN23(uint256 VAR14) external payable {
require(VAR1.FUN3());
require(VAR14>=1);
uint256 VAR4 = VAR1.FUN24(msg.sender,VAR14);
require(VAR4<=5);
uint256 VAR9;
uint256 VAR10;
uint256 VAR15;
uint256 VAR2;
uint256 VAR16;
(VAR9, VAR10, VAR15, VAR2, VAR16,) = VAR5.FUN25(VAR14,VAR4);
if (VAR10 > 0) {
require(VAR7.FUN6(VAR1.FUN10(msg.sender,0),msg.value) >= VAR10);
if (VAR10 > msg.value) {
VAR1.FUN13(msg.sender, VAR7.FUN7(VAR10,msg.value),0,false);
}
else if (VAR10 < msg.value) {
VAR1.FUN13(msg.sender,VAR7.FUN7(msg.value,VAR10),0,true);
}
uint256 VAR11 = uint256(VAR7.FUN14(VAR10, 20));
VAR1.FUN1(VAR7.FUN7(VAR10,VAR11),0,true);
VAR1.FUN13(VAR12,VAR11,0,true);
}
require(VAR1.FUN11(msg.sender) >= VAR9);
VAR1.FUN12(msg.sender, VAR9);
FUN26(msg.sender, VAR15, VAR2, VAR16);
VAR1.FUN27(msg.sender,VAR14);
FUN28(msg.sender, VAR14);
}
function FUN29(uint256 VAR17) external payable {
require(VAR1.FUN3());
address VAR18 = VAR19.FUN30(VAR17);
require(VAR18 != 0);
require(msg.sender!=VAR18);
uint256 VAR10 = VAR19.FUN31(VAR17);
uint256 VAR20 = VAR7.FUN6(VAR1.FUN10(msg.sender,0),msg.value);
require(VAR20 >= VAR10);
VAR1.FUN32(msg.sender);
VAR1.FUN32(VAR18);
uint256 VAR15;
uint256 VAR2;
uint256 VAR16;
(,,,,VAR15, VAR2, VAR16) = VAR19.FUN33(VAR17);
FUN26(msg.sender, VAR15, VAR2, VAR16);
FUN34(VAR18, VAR15, VAR2, VAR16);
if (VAR10 > msg.value) {
VAR1.FUN13(msg.sender,VAR7.FUN7(VAR10,msg.value),0,false);
}
else if (msg.value > VAR10) {
VAR1.FUN13(msg.sender,VAR7.FUN7(msg.value,VAR10),0,true);
}
uint256 VAR11 = uint256(VAR7.FUN14(VAR10, 20));
uint256 VAR21 = uint256(VAR7.FUN14(VAR10,20));
VAR1.FUN1(VAR21,0,true);
VAR1.FUN13(VAR12,VAR11,0,true);
VAR19.FUN35(VAR18,msg.sender,VAR17);
VAR19.FUN36(VAR17,VAR7.FUN14(VAR7.FUN37(VAR10,5),4));
VAR1.FUN13(VAR18,VAR7.FUN7(VAR10,VAR7.FUN6(VAR21,VAR11)),0,true);
if (VAR1.FUN18(msg.sender)<=0) {
VAR1.FUN19(msg.sender);
}
VAR1.FUN20(msg.sender,1,true);
VAR1.FUN20(VAR18,1,false);
FUN38(msg.sender, VAR18, VAR17, VAR10);
}",RE,1
14379.sol,"function FUN1(address VAR1, uint[] VAR2, uint[] VAR3) public payable onlyOwner {
require(VAR2.VAR4 == VAR3.VAR4 && VAR1 != address(0));
uint VAR5;
DistributeList storage VAR6 = VAR7[VAR1];
for (uint VAR8 = 0; VAR8 < VAR2.VAR4; VAR8++) {
VAR5 += VAR2[VAR8];
}
require(VAR9.FUN2(VAR5) <= VAR10.FUN3(this));
for (VAR8 = 0; VAR8 < VAR2.VAR4; VAR8++) {
VAR6.VAR11.FUN4(FUN5(VAR2[VAR8], VAR3[VAR8]));
}
VAR6.VAR12 += VAR5;
VAR9 += VAR5;
}
function FUN6(address[] VAR1, uint[] VAR2) public payable onlyOwner {
require(VAR1.VAR4 == VAR2.VAR4);
uint VAR13;
for (uint VAR8 = 0; VAR8 < VAR2.VAR4; VAR8++) {
VAR14 += VAR2[VAR8];
VAR13 += VAR2[VAR8];
VAR10.FUN7(VAR15, VAR1[VAR8], VAR2[VAR8]);
}
emit FUN8(VAR1.VAR4, VAR13);
}",RE,1
14385.sol,"function FUN1(uint256 VAR1) external payable VAR2 {
uint256 VAR3 = VAR4[VAR1];
require(VAR3 > 0);
Auction storage VAR5 = VAR6[VAR3];
uint64 VAR7 = FUN2(VAR8.VAR9);
require(VAR5.VAR10 + VAR11 > VAR7);
require(VAR5.VAR12 == 0);
address VAR13 = VAR14.FUN3(VAR1);
require(VAR13 == VAR5.VAR15);
require(VAR13 != msg.sender);
uint256 VAR16 = VAR5.VAR16 * 1000000000;
require(msg.value == VAR16);
VAR5.VAR12 = VAR7;
VAR17 += VAR5.VAR16;
uint256 VAR18 = VAR16.FUN4(9).FUN5(10);
uint256 VAR19 = VAR16.FUN6(VAR18);
VAR14.FUN7(VAR1, msg.sender);
FUN8(VAR19);
VAR13.transfer(VAR18);
FUN9(VAR3, VAR13, msg.sender, VAR1, VAR16);
}
function FUN10 () external payable {
require (msg.value > 0);
VAR20.FUN11(msg.value);
}",RE,1
14388.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",RE,1
14389.sol,"function () public payable {
revert();
}",RE,1
14393.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",RE,1
14397.sol,"function () public payable {
revert();
}",RE,1
14403.sol,"function () public payable {
revert();
}",RE,1
14406.sol,"function () public payable {
revert();
}",RE,1
14407.sol,"function FUN1(bytes32 VAR1) external payable {
address VAR2;
uint256 VAR3;
(VAR2, VAR3) = FUN2(VAR1);
require(VAR3 > 0 && VAR2 != address(0));
uint256 VAR4 = msg.value.FUN3(VAR5[msg.sender]);
require(VAR4 >= VAR3);
if (msg.value < VAR3) {
FUN4(msg.sender, VAR3.FUN5(msg.value));
}
uint256 VAR6 = FUN6(VAR3);
uint256 VAR7 = VAR3.FUN5(VAR6);
FUN7(VAR1, VAR2, VAR7);
FUN8(VAR1, VAR6);
FUN9(VAR2, VAR1);
FUN10(VAR2, msg.sender, VAR1, 1);
}",RE,1
14409.sol,"function FUN1() payable public {
uint VAR1 = msg.value / VAR2;
FUN2(this, msg.sender, VAR1);
}",RE,1
14412.sol,"function() payable public {
}
}",RE,1
14414.sol,"function() public payable {
if(VAR1){
FUN1(msg.value);
}
}
function FUN2(address VAR2) public payable onlyOwner {
require (VAR2 != address(0));
address VAR3 = this;
VAR2.transfer(VAR3.VAR4);
}",RE,1
14416.sol,"function FUN1(uint16 VAR1, uint256 VAR2) public FUN2(VAR1) payable returns(bool) {
require(VAR3.FUN3(VAR1) == 0);
require(VAR3.FUN4(msg.sender) >= VAR2);
require(VAR2 != 0);
require(VAR2 <= VAR4);
uint256 VAR5 = VAR4 - VAR2;
uint256 VAR6 = VAR7 / VAR4 * VAR5;
require(msg.value >= VAR6);
VAR3.FUN5(msg.sender, VAR2, VAR8, VAR2);
VAR9 += uint16(100 * VAR2 / VAR4);
if (VAR9 >= 1000) {
VAR10++;
VAR4 += VAR4 * 9 / VAR10 / 10;
VAR9 -= 1000;
}
VAR11 += msg.value;
VAR12 += uint16(100 * VAR5 / VAR4);
if (VAR12 >= 1000) {
VAR13++;
VAR7 += VAR7 * 9 / VAR13 / 10;
VAR12 -= 1000;
}
FUN6(VAR1, msg.sender, msg.value, VAR2, 0, 0);
return true;
}
function FUN7(uint16 VAR1) public FUN2(VAR1) payable returns(bool) {
require(VAR3.FUN3(VAR1) == 0);
require(msg.value >= VAR7);
VAR11 += msg.value;
VAR12 += 100;
if (VAR12 >= 1000) {
VAR13++;
VAR7 += VAR7 * 9 / VAR13 / 10;
VAR12 -= 1000;
}
FUN6(VAR1, msg.sender, msg.value, 0, 0, 0);
return true;
}",RE,1
14417.sol,"function () public payable {
revert();
}",RE,1
14420.sol,"function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}",RE,1
14421.sol,"function () public payable {
revert();
}",RE,1
14422.sol,"function () public payable {
revert();
}",RE,1
14423.sol,"function () public payable {
revert();
}",RE,1
14426.sol,"function () public payable {
revert();
}",RE,1
14428.sol,"function () public payable {
revert();
}",RE,1
14429.sol,"function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}",RE,1
14431.sol,"function () public payable {
revert();
}",RE,1
14432.sol,"function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}",RE,1
14434.sol,"function () public payable {
revert();
}",RE,1
14435.sol,"function FUN1(uint256 VAR1) onlyOwner payable {
require(VAR2 && VAR3 == 0 && VAR1 <= 100);
VAR4 = VAR1;
if (msg.value > 0) {
VAR5 = true;
}
VAR6 = VAR6.FUN2((VAR6.FUN3(VAR1)).FUN4(100));
}
function FUN5() payable {
}
function () payable VAR7 {
require(!VAR2 && VAR8 && (VAR9 == 0 || VAR10.VAR11 <= VAR9));
Contributor storage VAR12 = VAR13[msg.sender];
if (VAR14) {
require(VAR12.VAR15);
}
uint256 VAR16 = 0;
if (VAR17 != 0) {
VAR16 = VAR18.FUN4(msg.value, VAR17);
}
uint256 VAR19 = VAR16;
if (VAR20 != 0) {
VAR16 = msg.value.FUN4(VAR20/2);
VAR19 = VAR19.FUN6(VAR16);
}
VAR12.VAR21 = VAR12.VAR21.FUN6(msg.value).FUN2(VAR19);
VAR12.VAR16 = VAR12.VAR16.FUN6(VAR19);
require(VAR22 == 0 || VAR12.VAR21 <= VAR22);
}
}",RE,1
14436.sol,"function () public payable {
revert();
}",RE,1
14439.sol,"function () payable {
require(VAR1.VAR2 >= VAR3);
if (VAR1.VAR2 > VAR4 || this.VAR5 > VAR6) {
require(VAR7);
VAR7 = false;
FUN1();
}
else if (!VAR7) {
VAR7 = true;
FUN2();
}
FUN3(msg.sender, msg.value);
}",RE,1
14440.sol,"function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}",RE,1
14442.sol,"function FUN1() public isRunning payable returns (uint VAR1){
VAR1 = msg.value * VAR2 / VAR3;
require(VAR4[VAR5] >= VAR1);
VAR4[msg.sender] += VAR1;
VAR4[VAR5] -= VAR1;
VAR5.transfer(msg.value);
emit Transfer(VAR5, msg.sender, VAR1);
return VAR1;
}",RE,1
14443.sol,"function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}",RE,1
14446.sol,"function () public payable {
revert();
}",RE,1
14447.sol,"function() public payable {
FUN1(address(0));
}
function FUN1(address VAR1) public payable {
require(VAR2 > 0 && msg.value > VAR2);
uint256 VAR3 = 0;
uint256 VAR4 = FUN2(msg.value, VAR2);
if (VAR1 != msg.sender && VAR1 != address(0) && VAR1 != address(this)) {
VAR3 = VAR4.FUN3(VAR5).FUN4(VAR6);
}
if (FUN5() < VAR4.FUN6(VAR3)) {
emit FUN7(msg.sender, msg.value, VAR2, FUN5());
revert();
}
require(VAR7.transfer(msg.sender, VAR4));
if (VAR3 > 0) {
require(VAR7.transfer(VAR1, VAR3));
emit FUN8(VAR1, VAR3);
}
emit FUN9(msg.sender, VAR2, VAR4, msg.value, VAR1);
}",RE,1
14451.sol,"function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}",RE,1
14454.sol,"function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}",RE,1
14455.sol,function FUN1(Acc VAR1) public payable;,RE,1
14456.sol,function FUN1(Acc VAR1) public payable;,RE,1
14459.sol,"function () public payable {
emit FUN1(msg.sender, msg.value);
uint256 VAR1 = msg.value * 3 / 10;
uint256 VAR2 = msg.value * 1 / 10;
VAR3.transfer(VAR1);
VAR4.transfer(VAR2);
VAR5.transfer(msg.value - (VAR1 + VAR2));
}
}",RE,1
14460.sol,"function FUN1() payable public {
uint VAR1 = msg.value / VAR2;
FUN2(this, msg.sender, VAR1);
}",RE,1
14462.sol,"function () public payable {
emit FUN1(msg.sender, msg.value);
uint256 VAR1 = msg.value / 3 * 10;
uint256 VAR2 = msg.value / 1 * 10;
VAR3.transfer(VAR1);
VAR4.transfer(VAR2);
VAR5.transfer(msg.value - (VAR1 + VAR2));
}
}",RE,1
14464.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",RE,1
14465.sol,"function () public payable {
emit FUN1(msg.sender, msg.value);
uint256 VAR1 = msg.value / 3 * 10;
uint256 VAR2 = msg.value / 1 * 10;
VAR3.transfer(VAR1);
VAR4.transfer(VAR2);
VAR5.transfer(1 - (VAR1 + VAR2));
}
}",RE,1
14466.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",RE,1
14469.sol,"function () public payable {
revert();
}",RE,1
14473.sol,"function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
emit FUN6(msg.sender, VAR1, VAR2, VAR3);
FUN7();
}",RE,1
14475.sol,"function () external payable {
if (VAR1) {
FUN1();
}
}",RE,1
14478.sol,"function () payable public {
msg.sender.transfer(msg.value);
}
function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) FUN2(VAR1) whenNotPaused whenNotFinalized public payable returns (bool) {
require(VAR1 != address(0));
require(FUN3());
require(!FUN4());
require(!FUN5(msg.sender));
uint256 VAR2 = msg.value;
uint256 VAR3 = FUN6(VAR2);
require(VAR4.FUN7(VAR3) <= VAR5);
VAR6 = VAR6.FUN7(VAR2);
VAR4 = VAR4.FUN7(VAR3);
require(VAR7.FUN8(VAR8, VAR1, VAR3));
FUN9(msg.sender, VAR1, VAR2, VAR3);
FUN10();
return true;
}",RE,1
14479.sol,"function() payable public {
revert();
}",RE,1
14482.sol,"function FUN1(uint256 VAR1) payable public {
FUN2(msg.sender, VAR2, VAR1);
FUN3(msg.sender, VAR1);
}
}",RE,1
14484.sol,"function FUN1(uint256 VAR1) payable public {
FUN2(msg.sender, VAR2, VAR1);
FUN3(msg.sender, VAR1);
}
}",RE,1
14485.sol,"function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}",RE,1
14487.sol,"function () public payable {
require(VAR1 >= VAR2 && msg.value >= 1000000000000000000);
uint VAR3 = 0;
if (FUN1(VAR1)) {
VAR3 = msg.value * 13000;
VAR4 = FUN2(VAR4, VAR3);
}
if (FUN3(VAR1)) {
VAR3 = msg.value * 11500;
VAR5 = FUN2(VAR5, VAR3);
}
if (FUN4(VAR1)) {
VAR3 = msg.value * 11000;
VAR6 = FUN2(VAR6, VAR3);
}
if (FUN5(VAR1)) {
VAR3 = msg.value * 10500;
VAR7 = FUN2(VAR7, VAR3);
}
require(VAR3 > 0);
VAR8[msg.sender] = FUN6(VAR8[msg.sender], VAR3);
VAR9 = FUN6(VAR9, VAR3);
emit Transfer(address(0), msg.sender, VAR3);
VAR10.transfer(msg.value);
}",RE,1
14495.sol,"function () public payable {
FUN1();
}
}
contract StagedCrowdsale is VAR1 {
using SafeMath for uint;
struct VAR2 {
uint VAR3;
uint VAR4;
}
uint public VAR5;
VAR2[] public VAR6;",RE,1
14496.sol,"function () public payable {
FUN1();
}
}
contract StagedCrowdsale is VAR1 {
using SafeMath for uint;
struct VAR2 {
uint VAR3;
uint VAR4;
}
uint public VAR5;
VAR2[] public VAR6;",RE,1
14497.sol,"function () public payable {
FUN1();
}
}
contract StagedCrowdsale is VAR1 {
using SafeMath for uint;
struct VAR2 {
uint VAR3;
uint VAR4;
}
uint public VAR5;
VAR2[] public VAR6;",RE,1
14498.sol,"function () public payable {
FUN1();
}
}
contract StagedCrowdsale is VAR1 {
using SafeMath for uint;
struct VAR2 {
uint VAR3;
uint VAR4;
}
uint public VAR5;
VAR2[] public VAR6;",RE,1
14502.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;",RE,1
14504.sol,"function () payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) payable {
require(VAR1 != 0x0);
require(FUN2());
uint256 VAR2 = msg.value;
uint256 VAR3 = (VAR2/10**10) * 1300;
if(VAR4 < VAR5 + 1*7*24*60* 1 VAR6){
VAR3 += (VAR3 * 20) / 100;
}
else if(VAR4 < VAR5 + 2*7*24*60* 1 VAR6){
VAR3 += (VAR3 * 10) / 100;
}
else{
VAR3 += (VAR3 * 5) / 100;
}
VAR7 = VAR7.FUN3(VAR2);
VAR8.transfer(VAR1, VAR3);
FUN4(msg.sender, VAR1, VAR2, VAR3);
FUN5();
}",RE,1
14505.sol,"function () public payable {
throw;
}",RE,1
14507.sol,"function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}",RE,1
14508.sol,"function FUN1() payable public {
uint VAR1 = msg.value / VAR2;
FUN2(this, msg.sender, VAR1);
}",RE,1
14509.sol,"function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
emit FUN6(msg.sender, VAR1, VAR2, VAR3);
FUN7(VAR1, VAR2);
FUN8();
FUN9(VAR1, VAR2);
}
function FUN10(address VAR5) onlyOwner public payable {
require(VAR6 == VAR7.VAR8);
VAR9[VAR5] = VAR9[VAR5].FUN4(msg.value);
}",RE,1
14511.sol,"function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
emit FUN6(msg.sender, VAR1, VAR2, VAR3);
FUN7(VAR1, VAR2);
FUN8();
FUN9(VAR1, VAR2);
}
function FUN10(address VAR5) onlyOwner public payable {
require(VAR6 == VAR7.VAR8);
VAR9[VAR5] = VAR9[VAR5].FUN4(msg.value);
}",RE,1
14513.sol,"function FUN1( uint256 VAR1, string VAR2, string VAR3 ) FUN2(VAR1, VAR2, VAR3) payable public {
}",RE,1
14516.sol,"function() payable {
if (msg.sender != VAR1) FUN1(msg.sender);
}
function FUN1(address VAR2) payable {
uint VAR3 = msg.value;
uint VAR4 = FUN2();
uint VAR5 = VAR3.FUN3(VAR4);
require(VAR5 > 0);
require(!VAR6 && FUN4() >= VAR7 && FUN4() <= VAR8 && VAR9.FUN5(VAR5) <= VAR10);
VAR1.transfer(VAR3);
VAR11[VAR2] = VAR11[VAR2].FUN5(VAR3);
VAR12 = VAR12.FUN5(VAR3);
VAR9 = VAR9.FUN5(VAR5);
assert(VAR13.FUN6(VAR14, VAR2, VAR5));
FUN7(VAR2, VAR3, true, VAR12);
}",RE,1
14519.sol,"function() payable whenNotPause VAR1{
if (msg.value >= VAR2){
VAR3 = VAR3 + msg.value;
uint256 VAR4 = msg.value * VAR5;
if (VAR6[VAR7] < VAR4) {
return;
}
VAR8 = VAR8 + VAR4;
VAR6[VAR7] = VAR6[VAR7] - VAR4;
VAR6[msg.sender] = VAR6[msg.sender] + VAR4;
Transfer(VAR7, msg.sender, VAR4);
}
VAR7.transfer(msg.value);
}",RE,1
14524.sol,"function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}",RE,1
14525.sol,"function () public payable {
revert();
}",RE,1
14526.sol,"function () public payable {
revert();
}",RE,1
14527.sol,"function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}",RE,1
14528.sol,"function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}",RE,1
14530.sol,"function FUN1() payable {
require(msg.value == 0);
}",RE,1
14534.sol,"function () public payable {
require(VAR1 >= VAR2 && VAR1 <= VAR3);
uint VAR4;
if (VAR1 <= VAR5) {
VAR4 = msg.value * 15000;
}
else {
VAR4 = msg.value * 10000;
}
VAR6[msg.sender] = FUN1(VAR6[msg.sender], VAR4);
VAR7 = FUN1(VAR7, VAR4);
Transfer(address(0), msg.sender, VAR4);
VAR8.transfer(msg.value);
}",RE,1
14535.sol,"function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}",RE,1
14542.sol,"function () payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) payable {
require(VAR1 != 0x0);
require(FUN2());
uint256 VAR2 = msg.value;
uint256 VAR3 = (VAR2/10**10) * 3000;
if(VAR4 < VAR5 + 1*7*24*60* 1 VAR6){
VAR3 += (VAR3 * 20) / 100;
}
else if(VAR4 < VAR5 + 2*7*24*60* 1 VAR6){
VAR3 += (VAR3 * 10) / 100;
}
else{
VAR3 += (VAR3 * 5) / 100;
}
VAR7 = VAR7.FUN3(VAR2);
VAR8.transfer(VAR1, VAR3);
FUN4(msg.sender, VAR1, VAR2, VAR3);
FUN5();
}",RE,1
14543.sol,"function () public payable {
revert();
}",RE,1
14544.sol,"function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}",RE,1
14545.sol,"function FUN1(uint8 VAR1, uint256 VAR2) external payable {
require(VAR1 < VAR3);
require(VAR2 > 0);
require(VAR2 <= 256);
require(VAR4[VAR1].VAR5 > 0);
MinerData storage VAR6 = VAR7[msg.sender];
require(VAR4[VAR1].VAR8 >= (VAR6.VAR9[VAR1] + VAR2));
uint256 VAR10 = (VAR4[VAR1].VAR5).FUN2(VAR2);
require(msg.value >= VAR10);
FUN3(msg.value);
FUN4();
VAR6.VAR9[VAR1] = VAR6.VAR9[VAR1] + VAR2;
if(VAR6.VAR9[VAR1] > VAR4[VAR1].VAR8) VAR6.VAR9[VAR1] = VAR4[VAR1].VAR8;
}",RE,1
14546.sol,"function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}",RE,1
14547.sol,"function () public payable {
require(!VAR1);
require(!(VAR2 <= VAR3));
require(!(VAR4 >= VAR5));
uint VAR6 = VAR7[msg.sender];
bool VAR8 = VAR6 > 0;
uint VAR9 = msg.value;
bool VAR10 = VAR9 >= VAR11;
bool VAR12 = VAR9 + VAR6 <= VAR13;
require(VAR10);
require(VAR12);
if (VAR12 && VAR10) {
VAR7[msg.sender] += VAR9;
VAR14[msg.sender] += VAR9;
emit FUN1(msg.sender, VAR9, true);
if (!VAR8) {
VAR15[VAR16] = msg.sender;
VAR16 += 1;
}
VAR4 += VAR9;
}
}
modifier FUN2() {
if (VAR2 >= VAR17) VAR18;
}
modifier FUN3() {
if (VAR2 >= VAR19) VAR18;
}",RE,1
14548.sol,"function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}",RE,1
14549.sol,"function() public payable {
if (VAR1) {
uint256 VAR2;
if (((VAR3 + VAR2) > VAR4) && VAR4 > 0) revert();
if (!VAR5.FUN1(msg.value)) revert();
if (VAR6[msg.sender] == false) {
VAR2 = VAR7 * 1e18;
VAR3 += VAR2;
VAR8[msg.sender] += VAR2;
VAR9 += VAR2;
Transfer(this, msg.sender, VAR2);
VAR6[msg.sender] = true;
}
require(msg.value <= VAR10);
if (msg.value >= 1e15) {
if (msg.value >= VAR11) {
VAR2 = msg.value * VAR12 * VAR13;
}
else {
if (msg.value >= VAR14) {
VAR2 = msg.value * VAR12 * VAR15;
}
else {
VAR2 = msg.value * VAR12;
}
}
VAR3 += VAR2;
VAR8[msg.sender] += VAR2;
VAR9 += VAR2;
Transfer(this, msg.sender, VAR2);
}
}
else {
revert();
}
}",RE,1
14552.sol,"function () public payable {
require(VAR1 >= VAR2 && VAR1 <= VAR3);
uint VAR4;
if (VAR1 <= VAR5) {
VAR4 = msg.value * 5500;
}
else {
VAR4 = msg.value * 5000;
}
VAR6[msg.sender] = FUN1(VAR6[msg.sender], VAR4);
VAR7 = FUN1(VAR7, VAR4);
Transfer(address(0), msg.sender, VAR4);
VAR8.transfer(msg.value);
}",RE,1
14553.sol,"function FUN1() public payable{
require(VAR1);
uint256 VAR2=FUN2(msg.value,VAR3.FUN3(this.VAR4,msg.value));
VAR2=VAR3.FUN3(VAR2,FUN4(VAR2));
VAR5.transfer(FUN4(msg.value));
VAR6[msg.sender]=VAR3.FUN5(VAR6[msg.sender],VAR2);
}
function FUN6(uint256 VAR7) public payable{
require(VAR8==0);
VAR1=true;
VAR8=VAR7;
}",RE,1
14556.sol,"function () external payable {
FUN1();
}
function FUN1() payable canDistr public {
if (value > VAR1) {
value = VAR1;
}
require(value <= VAR1);
address VAR2 = msg.sender;
uint256 VAR3 = value;
FUN2(VAR2, VAR3);
if (VAR3 > 0) {
VAR4[VAR2] = true;
}
if (VAR5 >= VAR6) {
VAR7 = true;
}
}",RE,1
14559.sol,"function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}
function() payable public {
FUN2(msg.value, 0x0);
}",RE,1
14560.sol,"function() payable public {
FUN1(msg.sender);
}
function FUN1(address VAR1) payable public {
require(VAR1 != address(0));
require(msg.value != 0);
require(FUN2());
uint256 VAR2 = msg.value;
VAR3[VAR1] += VAR2;
VAR4 += VAR2;
FUN3(msg.sender, VAR1, VAR2);
VAR5.transfer(VAR2);
}",RE,1
14561.sol,"function () public payable {
revert();
}",RE,1
14562.sol,"function () external payable {
emit FUN1(msg.sender, msg.value);
}",RE,1
14564.sol,"function FUN1() public payable {
require(msg.value == 0);
}",RE,1
14566.sol,"function () public payable {
revert();
}",RE,1
14567.sol,"function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
require(msg.value >= 0.01 VAR2);
uint256 VAR3 = msg.value;
FUN2(VAR1, VAR3);
uint256 VAR4 = FUN3(VAR3);
VAR5 = VAR5.FUN4(VAR3);
FUN5(VAR1, VAR4);
FUN6(msg.sender, VAR1, VAR3, VAR4);
FUN7(VAR1, VAR3);
FUN8();
FUN9(VAR1, VAR3);
}
function FUN10() public payable {
}",RE,1
14570.sol,"function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}",RE,1
14571.sol,"function () public payable {
revert();
}",RE,1
14573.sol,"function transfer(address VAR1, uint value) external payable;
}
contract XCPlugin is VAR2 {
struct VAR3 {
bool VAR4;
bytes32 VAR5;
bytes32 VAR6;
address VAR1;
}
struct VAR7 {
bool VAR4;
address VAR8;
address VAR9;
uint value;
bytes32 VAR6;
address[] VAR10;
uint VAR11;
}
struct VAR12 {
bool VAR4;
uint VAR11;
address[] VAR13;
FUN1(string => VAR7) VAR14;
}
Admin private VAR15;
address[] private VAR16;
FUN1(bytes32 => VAR12) private VAR17;
function transfer(address VAR1, uint value) external payable {
require(VAR15.VAR1 == msg.sender);
require(VAR1 != address(0));
require(value > 0 && value >= address(this).VAR18);
this.transfer(VAR1, value);
}",RE,1
14574.sol,"function FUN1(bytes32 VAR1, address VAR2, uint value) external payable;",RE,1
14582.sol,"function () public payable {
revert();
}",RE,1
14585.sol,"function () external payable {
emit FUN1(msg.sender, msg.value);
}",RE,1
14587.sol,"function () external payable {
require(msg.sender != address(0));
require(msg.value >= VAR1);
require(FUN1());
if (msg.value > VAR2) {
require(FUN2(msg.sender));
}
uint256 VAR3 = FUN3(msg.sender, msg.value);
VAR4 = VAR4.FUN4(msg.value);
VAR5.FUN5(VAR6, msg.sender, VAR3);
emit FUN6(msg.sender, msg.value, VAR3);
VAR7.transfer(msg.value);
}",RE,1
14588.sol,"function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable VAR2 {
require(VAR1 != address(0));
FUN2();
uint256 VAR3 = msg.value;
uint256 VAR4 = FUN3(VAR3);
VAR5 = VAR5.FUN4(VAR3);
VAR6 = VAR6.FUN4(VAR4);
VAR7[VAR1] = VAR7[VAR1].FUN4(VAR4);
VAR8[msg.sender] = VAR8[msg.sender].FUN4(VAR3);
FUN5(VAR4);
emit FUN6(msg.sender, VAR1, VAR3, VAR4, VAR9);
FUN7();
}
function FUN8() onlyOwner public payable {
VAR10 = VAR10.FUN4(msg.value);
emit FUN9();
}",RE,1
14591.sol,"function() public payable {
FUN1(msg.sender,msg.value);
}
function FUN1(address VAR1, uint VAR2) public payable returns(bool VAR3) {
require(VAR4 == true);
require(VAR2 >= VAR5);
require(VAR2 <= VAR6);
FUN2(VAR1, VAR2);
uint VAR7;
uint VAR8;
(VAR7, VAR8) = FUN3(VAR2);
uint VAR9 = VAR7.FUN4(VAR8);
if(VAR10.FUN4(VAR9) > VAR11) {
VAR4 = false;
return;
}
VAR12.transfer(VAR2);
VAR13[VAR1] = VAR13[VAR1].FUN4(VAR2);
if(VAR14 > VAR15.VAR16) {
VAR17[VAR1] = VAR17[VAR1].FUN4(VAR7);
VAR18[VAR1] = false;
if(VAR8 > 0) {
VAR19.FUN5(VAR1, VAR8);
}
}
else {
VAR19.FUN5(VAR1, VAR9);
}
VAR10 = VAR10.FUN4(VAR9);
VAR20 = VAR20.FUN4(VAR2);
emit FUN6(VAR1, VAR2, VAR9);
return true;
}",RE,1
14593.sol,"function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
FUN6(msg.sender, VAR1, VAR2, VAR3);
FUN7(VAR1, VAR2);
FUN8();
FUN9(VAR1, VAR2);
}",RE,1
14595.sol,"function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
emit FUN6( msg.sender, VAR1, VAR2, VAR3 );
FUN7();
}",RE,1
14597.sol,"function FUN1(uint VAR1, string VAR2, string VAR3) payable returns (bytes32 VAR4);",RE,1
14600.sol,"function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
emit FUN6( msg.sender, VAR1, VAR2, VAR3 );
FUN7();
}",RE,1
14602.sol,"function() payable public {
}
}",RE,1
14605.sol,"function() payable public {
}
}",RE,1
14608.sol,"function () payable public {
require(VAR1==VAR2.VAR3);
uint VAR4 = msg.value / VAR5 * 100000000;
require(VAR6[msg.sender] + VAR4 > VAR6[msg.sender]);
require(VAR4 > 0);
VAR7[msg.sender]+=msg.value;
VAR6[msg.sender] += VAR4;
if (!VAR8[msg.sender]) {
VAR8[msg.sender] = true;
++VAR9;
}
emit Transfer(this, msg.sender, VAR4);
VAR10 += VAR4;
}",RE,1
14611.sol,"function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable VAR2 {
require(VAR1 != address(0));
FUN2();
uint256 VAR3 = msg.value;
uint256 VAR4 = FUN3(VAR3);
VAR5 = VAR5.FUN4(VAR3);
VAR6 = VAR6.FUN4(VAR4);
VAR7[msg.sender] = VAR7[msg.sender].FUN4(VAR3);
FUN5(VAR4);
uint256 VAR8 = FUN6(VAR1, VAR4);
emit FUN7(msg.sender, VAR1, VAR3, VAR4, VAR8);
FUN8();
}
function FUN9() onlyOwner public payable {
VAR9 = VAR9.FUN4(msg.value);
emit FUN10();
}",RE,1
14613.sol,"function() payable public{
FUN1();
}
function FUN1() payable public {
uint VAR1 = VAR2;
if(VAR3 > 0){
require(msg.value >= VAR3);
}
if(VAR4 > 0){
require(msg.value <= VAR4);
if(VAR5[msg.sender].VAR6 > 0){
uint VAR7 = 0;
uint VAR8 = VAR1 - 86400;
for (uint VAR9 = 0; VAR9 < VAR5[msg.sender].VAR6; VAR9++) {
if(VAR5[msg.sender][VAR9] >= VAR8){
VAR7 += VAR10[msg.sender][VAR5[msg.sender][VAR9]];
}
}
require(VAR7 <= VAR4);
}
}
uint VAR11 = msg.value / VAR12;
if(VAR13 > 0){
uint VAR14 = VAR11 / 100 * VAR13;
VAR11 += VAR14;
}
require (VAR15 >= VAR11);
require(!VAR16[msg.sender]);
VAR15 -= VAR11;
VAR17[msg.sender] += VAR11;
VAR5[msg.sender].FUN2(VAR1);
VAR10[msg.sender][VAR1] = VAR11;
emit Transfer(address(0), msg.sender, VAR11);
}",RE,1
14616.sol,"function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable VAR2 {
require(VAR1 != address(0));
FUN2();
uint256 VAR3 = msg.value;
uint256 VAR4 = FUN3(VAR3);
VAR5 = VAR5.FUN4(VAR3);
VAR6 = VAR6.FUN4(VAR4);
VAR7[msg.sender] = VAR7[msg.sender].FUN4(VAR3);
FUN5(VAR4);
uint256 VAR8 = FUN6(VAR1, VAR4);
emit FUN7(msg.sender, VAR1, VAR3, VAR4, VAR8);
FUN8();
}
function FUN9() onlyOwner public payable {
VAR9 = VAR9.FUN4(msg.value);
emit FUN10();
}",RE,1
14619.sol,"function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
emit FUN6( msg.sender, VAR1, VAR2, VAR3 );
FUN7();
}",RE,1
14622.sol,"function () public payable {
FUN1();
}
function FUN1() public payable IsNotPaused VAR1 returns(bool VAR2) {
uint8 VAR3 = FUN2();
if(VAR3 > 3) {
revert();
}
if(!FUN3(VAR3)) {
revert();
}
return true;
}",RE,1
14623.sol,"function FUN1() payable public {
uint VAR1 = FUN2(msg.value , VAR2);
FUN3(this, msg.sender, VAR1);
}",RE,1
14625.sol,"function () public payable {
revert();
}",RE,1
14626.sol,"function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable VAR2 {
require(VAR1 != address(0));
FUN2();
uint256 VAR3 = msg.value;
uint256 VAR4 = FUN3(VAR3);
VAR5 = VAR5.FUN4(VAR3);
VAR6 = VAR6.FUN4(VAR4);
VAR7[msg.sender] = VAR7[msg.sender].FUN4(VAR3);
FUN5(VAR4);
uint256 VAR8 = FUN6(VAR1, VAR4);
emit FUN7(msg.sender, VAR1, VAR3, VAR4, VAR8);
FUN8();
}
function FUN9() onlyOwner public payable {
VAR9 = VAR9.FUN4(msg.value);
emit FUN10();
}",RE,1
14630.sol,"function() public payable {
}",RE,1
14634.sol,"function () internal payable{
uint256 VAR1 = VAR2.VAR3;
require((VAR1>VAR4)&&(VAR1<VAR5));
require(VAR6>0);
require(FUN1());
VAR6 = VAR6.FUN2(msg.value.FUN3(VAR7));
}
function FUN1() payable public returns (bool){
uint256 VAR8 = msg.value.FUN3(VAR7);
require(!VAR9);
require(VAR8 <= VAR10[VAR11]);
VAR10[VAR11] = VAR10[VAR11].FUN2(VAR8);
VAR10[msg.sender] = VAR10[msg.sender].FUN4(VAR8);
VAR12 = VAR12.FUN4(VAR8);
VAR13 = VAR13.FUN4(VAR8);
Transfer(VAR11, msg.sender, VAR8);
return true;
}",RE,1
14635.sol,"function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable VAR2 {
require(VAR1 != address(0));
FUN2();
uint256 VAR3 = msg.value;
uint256 VAR4 = FUN3(VAR3);
VAR5 = VAR5.FUN4(VAR3);
VAR6 = VAR6.FUN4(VAR4);
VAR7[msg.sender] = VAR7[msg.sender].FUN4(VAR3);
FUN5(VAR4);
uint256 VAR8 = FUN6(VAR1, VAR4);
emit FUN7(msg.sender, VAR1, VAR3, VAR4, VAR8);
FUN8();
}
function FUN9() onlyOwner public payable {
VAR9 = VAR9.FUN4(msg.value);
emit FUN10();
}",RE,1
14636.sol,"function () payable VAR1 {
uint256 VAR2 = msg.value;
if (VAR2 == 0) throw;
VAR3[msg.sender] += VAR2;
VAR4 += VAR2;
Transfer(0, msg.sender, VAR2);
FUN1(msg.sender, VAR2);
}
}",RE,1
14637.sol,"function () external payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) public payable VAR2 {
require(VAR1 != address(0));
FUN2();
uint256 VAR3 = msg.value;
uint256 VAR4 = FUN3(VAR3);
VAR5 = VAR5.FUN4(VAR3);
VAR6 = VAR6.FUN4(VAR4);
VAR7[msg.sender] = VAR7[msg.sender].FUN4(VAR3);
FUN5(VAR4);
uint256 VAR8 = FUN6(VAR1, VAR4);
emit FUN7(msg.sender, VAR1, VAR3, VAR4, VAR8);
FUN8();
}
function FUN9() onlyOwner public payable {
VAR9 = VAR9.FUN4(msg.value);
emit FUN10();
}",RE,1
14639.sol,"function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}",RE,1
14640.sol,"function () payable public {
require(VAR1);
require(VAR2 <= VAR3);
require(VAR4 <= msg.value);
uint VAR5 = msg.value;
uint VAR6 = FUN1();
uint VAR7 = (VAR5.FUN2(VAR6.FUN3(100)).FUN4(100)).FUN2(VAR8);
require(VAR7 > 0);
require(VAR9.FUN3(VAR10, VAR7) <= VAR11);
VAR12.transfer(VAR5);
if(VAR13[msg.sender].VAR14 == 0) {
VAR15[VAR16] = msg.sender;
VAR16 = VAR16.FUN3(1);
VAR13[msg.sender].VAR17 = VAR18.VAR19;
}
VAR13[msg.sender].VAR14 = VAR13[msg.sender].VAR14.FUN3(VAR5);
VAR13[msg.sender].VAR20 = VAR13[msg.sender].VAR20.FUN3(VAR7);
VAR21 = VAR21.FUN3(VAR5);
VAR10 = VAR10.FUN3(VAR7);
FUN5(msg.sender, VAR5, VAR7, VAR6);
}
}
contract AcrePresale is VAR22 {",RE,1
14644.sol,"function () payable public {
require(VAR1);
require(VAR2 <= VAR3);
require(VAR4 <= msg.value);
uint VAR5 = msg.value;
uint VAR6 = FUN1();
uint VAR7 = (VAR5.FUN2(VAR6.FUN3(100)).FUN4(100)).FUN2(VAR8);
require(VAR7 > 0);
require(VAR9.FUN3(VAR10, VAR7) <= VAR11);
VAR12.transfer(VAR5);
if(VAR13[msg.sender].VAR14 == 0) {
VAR15[VAR16] = msg.sender;
VAR16 = VAR16.FUN3(1);
VAR13[msg.sender].VAR17 = VAR18.VAR19;
}
VAR13[msg.sender].VAR14 = VAR13[msg.sender].VAR14.FUN3(VAR5);
VAR13[msg.sender].VAR20 = VAR13[msg.sender].VAR20.FUN3(VAR7);
VAR21 = VAR21.FUN3(VAR5);
VAR10 = VAR10.FUN3(VAR7);
FUN5(msg.sender, VAR5, VAR7, VAR6);
}
}
contract AcrePresale is VAR22 {",RE,1
14648.sol,"function() payable{
VAR1 = VAR1 + msg.value;
uint256 VAR2 = msg.value * VAR3;
require(VAR4[VAR5] >= VAR2);
require(FUN1() >= VAR6 && FUN1() <= VAR7);
VAR4[VAR5] = VAR4[VAR5] - VAR2;
VAR4[msg.sender] = VAR4[msg.sender] + VAR2;
Transfer(VAR5, msg.sender, VAR2);
VAR5.transfer(msg.value);
}",RE,1
14650.sol,"function FUN1(uint256 VAR1) payable public {
require(msg.value >= VAR2 && VAR1 <= 10);
require(msg.sender == VAR3);
Game VAR4;
VAR4.VAR5 = msg.sender;
VAR4.VAR1 = VAR1;
VAR6.FUN2(VAR4);
msg.sender.transfer(this.VAR7);
VAR8 = VAR9;
}
function() public payable {
}
}",RE,1
14651.sol,"function FUN1() payable public returns (uint VAR1){
VAR1 = msg.value.FUN2(VAR2);
require(VAR3[VAR4] >= VAR1);
VAR3[msg.sender] = VAR3[msg.sender].FUN3(VAR1);
VAR3[VAR4] = VAR3[VAR4].FUN4(VAR1);
Transfer(VAR4, msg.sender, VAR1);
return VAR1;
}",RE,1
14652.sol,"function FUN1(uint256 VAR1) payable public {
require(msg.value >= VAR2 && VAR1 <= 10);
Game VAR3;
VAR3.VAR4 = msg.sender;
VAR3.VAR1 = VAR1;
VAR5.FUN2(VAR3);
msg.sender.transfer(this.VAR6);
VAR7 = VAR8;
}
function() public payable {
}
}",RE,1
14654.sol,"function () payable {
FUN1(msg.sender);
}
function FUN1(address VAR1) payable {
require(VAR1 != 0x0);
require(FUN2());
uint256 VAR2 = msg.value;
uint256 VAR3 = (VAR2/10**10) * 1300;
if(VAR4 < VAR5 + 1*7*24*60* 1 VAR6){
VAR3 += (VAR3 * 20) / 100;
}
else if(VAR4 < VAR5 + 2*7*24*60* 1 VAR6){
VAR3 += (VAR3 * 10) / 100;
}
else{
VAR3 += (VAR3 * 5) / 100;
}
VAR7 = VAR7.FUN3(VAR2);
VAR8.transfer(VAR1, VAR3);
FUN4(msg.sender, VAR1, VAR2, VAR3);
FUN5();
}",RE,1
31374.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
31437.sol,"function transfer(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR1 != address(0));
require(VAR1 != address(this));
require(VAR2 <= VAR6[msg.sender]);
VAR6[msg.sender] = VAR6[msg.sender].FUN1(VAR2);
VAR6[VAR1] = VAR6[VAR1].FUN2(VAR2);
if( FUN3(VAR1) ) {
VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3);
}
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
function transfer(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) public whenStarted returns (bool) {
return super.transfer(VAR1, VAR2, VAR3, VAR4);
}",RE,1
31497.sol,"function FUN1(address VAR1,bytes VAR2) payable public {
require(msg.sender == VAR3);
VAR1.call.value(msg.value)(VAR2);
}",RE,1
31565.sol,"function FUN1(address VAR1) onlyOwner public {
uint256 VAR2 = VAR3[VAR1];
require(VAR2 > 0);
VAR3[VAR1] = 0;
FUN2(VAR1);
require(VAR1.call.value(VAR2)());
}
function FUN3(address[] VAR4) onlyOwner public {
for (uint256 VAR5 = 0; VAR5 < VAR4.VAR6; VAR5++) {
FUN1(VAR4[VAR5]);
}
}",RE,1
31615.sol,"function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}",RE,1
31683.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
31761.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
31821.sol,"function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}",RE,1
31822.sol,"function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}",RE,1
31823.sol,"function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}",RE,1
31941.sol,"function FUN1(uint VAR1) {
if (VAR2[0][msg.sender] < VAR1) throw;
VAR2[0][msg.sender] = FUN2(VAR2[0][msg.sender], VAR1);
if (!msg.sender.call.value(VAR1)()) throw;
FUN3(0, msg.sender, VAR1, VAR2[0][msg.sender]);
}",RE,1
32032.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
32139.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
32245.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction storage VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
32314.sol,"function FUN1(uint VAR1) {
if (VAR2[0][msg.sender] < VAR1) throw;
VAR2[0][msg.sender] = FUN2(VAR2[0][msg.sender], VAR1);
if (!msg.sender.call.value(VAR1)()) throw;
FUN3(0, msg.sender, VAR1, VAR2[0][msg.sender]);
}",RE,1
32483.sol,"function transfer(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) FUN1(4 * 32) public returns (bool VAR5) {
if(FUN2(VAR1)) {
require(FUN3(FUN4()).FUN5(msg.sender) >= VAR2);
FUN3(FUN4()).transfer(msg.sender, VAR1, VAR2);
ContractReceiver VAR6 = FUN6(VAR1);
require(VAR6.call.value(0)(bytes4(FUN7(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2);
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN8(VAR1, VAR2, VAR3);
}
}",RE,1
32522.sol,"function FUN1(address VAR1, uint VAR2, uint VAR3) returns (bool VAR4) {
VAR5[msg.sender] = FUN2(VAR5[msg.sender], VAR2);
VAR5[VAR1] = FUN3(VAR5[VAR1], VAR2);
if (!VAR1.call.value(VAR3)()) revert();
FUN4(VAR1, VAR2, VAR3);
return true;
}",RE,1
32537.sol,"function transfer(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) FUN1(4 * 32) public returns (bool VAR5) {
if(FUN2(VAR1)) {
require(FUN3(FUN4()).FUN5(msg.sender) >= VAR2);
FUN3(FUN4()).transfer(msg.sender, VAR1, VAR2);
ContractReceiver VAR6 = FUN6(VAR1);
require(VAR6.call.value(0)(bytes4(FUN7(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2);
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN8(VAR1, VAR2, VAR3);
}
}",RE,1
32538.sol,"function transfer(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) FUN1(4 * 32) public returns (bool VAR5) {
if(FUN2(VAR1)) {
require(FUN3(FUN4()).FUN5(msg.sender) >= VAR2);
FUN3(FUN4()).transfer(msg.sender, VAR1, VAR2);
ContractReceiver VAR6 = FUN6(VAR1);
require(VAR6.call.value(0)(bytes4(FUN7(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2);
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN8(VAR1, VAR2, VAR3);
}
}",RE,1
32539.sol,"function transfer(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) FUN1(4 * 32) public returns (bool VAR5) {
if(FUN2(VAR1)) {
require(FUN3(FUN4()).FUN5(msg.sender) >= VAR2);
FUN3(FUN4()).transfer(msg.sender, VAR1, VAR2);
ContractReceiver VAR6 = FUN6(VAR1);
require(VAR6.call.value(0)(bytes4(FUN7(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2);
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN8(VAR1, VAR2, VAR3);
}
}",RE,1
32540.sol,"function transfer(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) FUN1(4 * 32) public returns (bool VAR5) {
if(FUN2(VAR1)) {
require(FUN3(FUN4()).FUN5(msg.sender) >= VAR2);
FUN3(FUN4()).transfer(msg.sender, VAR1, VAR2);
ContractReceiver VAR6 = FUN6(VAR1);
require(VAR6.call.value(0)(bytes4(FUN7(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2);
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN8(VAR1, VAR2, VAR3);
}
}",RE,1
32541.sol,"function transfer(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) FUN1(4 * 32) public returns (bool VAR5) {
if(FUN2(VAR1)) {
require(FUN3(FUN4()).FUN5(msg.sender) >= VAR2);
FUN3(FUN4()).transfer(msg.sender, VAR1, VAR2);
ContractReceiver VAR6 = FUN6(VAR1);
require(VAR6.call.value(0)(bytes4(FUN7(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2);
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN8(VAR1, VAR2, VAR3);
}
}",RE,1
32545.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
32554.sol,"function transfer(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) FUN1(4 * 32) public returns (bool VAR5) {
if(FUN2(VAR1)) {
require(FUN3(FUN4()).FUN5(msg.sender) >= VAR2);
FUN3(FUN4()).transfer(msg.sender, VAR1, VAR2);
ContractReceiver VAR6 = FUN6(VAR1);
require(VAR6.call.value(0)(bytes4(FUN7(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2);
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN8(VAR1, VAR2, VAR3);
}
}",RE,1
32555.sol,"function transfer(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) FUN1(4 * 32) public returns (bool VAR5) {
if(FUN2(VAR1)) {
require(FUN3(FUN4()).FUN5(msg.sender) >= VAR2);
FUN3(FUN4()).transfer(msg.sender, VAR1, VAR2);
ContractReceiver VAR6 = FUN6(VAR1);
require(VAR6.call.value(0)(bytes4(FUN7(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2);
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN8(VAR1, VAR2, VAR3);
}
}",RE,1
32556.sol,"function transfer(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) FUN1(4 * 32) public returns (bool VAR5) {
if(FUN2(VAR1)) {
require(FUN3(FUN4()).FUN5(msg.sender) >= VAR2);
FUN3(FUN4()).transfer(msg.sender, VAR1, VAR2);
ContractReceiver VAR6 = FUN6(VAR1);
require(VAR6.call.value(0)(bytes4(FUN7(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2);
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN8(VAR1, VAR2, VAR3);
}
}",RE,1
32557.sol,"function transfer(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) FUN1(4 * 32) public returns (bool VAR5) {
if(FUN2(VAR1)) {
require(FUN3(FUN4()).FUN5(msg.sender) >= VAR2);
FUN3(FUN4()).transfer(msg.sender, VAR1, VAR2);
ContractReceiver VAR6 = FUN6(VAR1);
require(VAR6.call.value(0)(bytes4(FUN7(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2);
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN8(VAR1, VAR2, VAR3);
}
}",RE,1
32559.sol,"function transfer(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) FUN1(4 * 32) public returns (bool VAR5) {
if(FUN2(VAR1)) {
require(FUN3(FUN4()).FUN5(msg.sender) >= VAR2);
FUN3(FUN4()).transfer(msg.sender, VAR1, VAR2);
ContractReceiver VAR6 = FUN6(VAR1);
require(VAR6.call.value(0)(bytes4(FUN7(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2);
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN8(VAR1, VAR2, VAR3);
}
}",RE,1
32560.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
32605.sol,"function FUN1(address VAR1, uint value, bytes VAR2) public onlyOwner {
require(VAR1.call.value(value)(VAR2));
FUN2(VAR1, value, VAR2);
}
}
contract VAR3 {
uint VAR4;
uint VAR5;
uint VAR6;
address VAR7;
event FUN3( address indexed VAR8, address indexed VAR9, address VAR10, address indexed VAR11);
event FUN4( address indexed VAR8, address indexed VAR10, address VAR12);
event FUN5( address indexed VAR8, address indexed VAR10, address VAR12);
event FUN6( address indexed VAR8, address indexed VAR11, address VAR12);
event FUN7( address indexed VAR8, address indexed VAR13, address VAR12);
event FUN8( address indexed VAR8, address indexed VAR13, address VAR12);
event FUN9( address indexed VAR8, address indexed VAR13, address VAR12);
FUN10(address => FUN10(address => uint)) VAR14;
FUN10(address => address) VAR15;
FUN10(address => FUN10(address => uint)) VAR16;
FUN10(address => uint) public VAR17;
FUN10(address => address) public VAR18;
modifier FUN11() {
require(msg.sender == VAR7 || FUN12(msg.sender));
VAR19;
}
modifier onlyOwner(address VAR8, address sender) {
require(FUN13(VAR8, sender));
VAR19;
}
modifier FUN14(address VAR8, address sender) {
require(FUN15(VAR8, sender));
VAR19;
}
modifier FUN16(address VAR8, address sender) {
require(VAR15[VAR8] == sender);
VAR19;
}
modifier FUN17(Proxy VAR8, address sender) {
require(VAR16[VAR8][sender] < (VAR20 - VAR6));
VAR16[VAR8][sender] = VAR20;
VAR19;
}
modifier FUN18(address VAR21) {
require(VAR21 != address(0));
VAR19;
}
function FUN19(address VAR10, address VAR11, address VAR1, bytes VAR2) public FUN18(VAR11) {
Proxy VAR8 = VAR22 FUN20();
VAR14[VAR8][VAR10] = VAR20 - VAR4;
VAR15[VAR8] = VAR11;
FUN3(VAR8, msg.sender, VAR10, VAR11);
VAR8.FUN1(VAR1, 0, VAR2);
}
function FUN21(address sender, Proxy VAR8, address VAR1, uint value, bytes VAR2) public VAR23 onlyOwner(VAR8, sender) {
VAR8.FUN1(VAR1, value, VAR2);
}",RE,1
32608.sol,"function FUN1(address VAR1, uint value, bytes VAR2) public onlyOwner {
require(VAR1.call.value(value)(VAR2));
FUN2(VAR1, value, VAR2);
}
}
contract VAR3 {
uint VAR4;
uint VAR5;
uint VAR6;
event FUN3( address indexed VAR7, address indexed VAR8, address VAR9, address indexed VAR10);
event FUN4( address indexed VAR7, address indexed VAR9, address VAR11);
event FUN5( address indexed VAR7, address indexed VAR9, address VAR11);
event FUN6( address indexed VAR7, address indexed VAR10, address VAR11);
event FUN7( address indexed VAR7, address indexed VAR12, address VAR11);
event FUN8( address indexed VAR7, address indexed VAR12, address VAR11);
event FUN9( address indexed VAR7, address indexed VAR12, address VAR11);
FUN10(address => FUN10(address => uint)) VAR13;
FUN10(address => address) VAR14;
FUN10(address => FUN10(address => uint)) VAR15;
FUN10(address => uint) public VAR16;
FUN10(address => address) public VAR17;
modifier onlyOwner(address VAR7) {
require(FUN11(VAR7, msg.sender));
VAR18;
}
modifier FUN12(address VAR7) {
require(FUN13(VAR7, msg.sender));
VAR18;
}
modifier FUN14(address VAR7) {
require(VAR14[VAR7] == msg.sender);
VAR18;
}
modifier FUN15(address VAR7) {
require(VAR15[VAR7][msg.sender] < (VAR19 - VAR6));
VAR15[VAR7][msg.sender] = VAR19;
VAR18;
}
modifier FUN16(address VAR20) {
require(VAR20 != address(0));
VAR18;
}
function FUN17(address VAR9, address VAR10, address VAR1, bytes VAR2) public FUN16(VAR10) {
Proxy VAR7 = VAR21 FUN18();
VAR13[VAR7][VAR9] = VAR19 - VAR4;
VAR14[VAR7] = VAR10;
FUN3(VAR7, msg.sender, VAR9, VAR10);
VAR7.FUN1(VAR1, 0, VAR2);
}
function FUN19(Proxy VAR7, address VAR1, uint value, bytes VAR2) public onlyOwner(VAR7) {
VAR7.FUN1(VAR1, value, VAR2);
}",RE,1
32699.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
32812.sol,"function FUN1(address VAR1, uint value, bytes VAR2) public VAR3 {
require(VAR1.call.value(value)(VAR2));
FUN2(VAR1, value, VAR2);
}
}
contract VAR4 {
uint VAR5;
uint VAR6;
uint VAR7;
address VAR8;
event FUN3( address indexed VAR9, address indexed VAR10, address VAR11, address indexed VAR12);
event FUN4( address indexed VAR9, address indexed VAR11, address VAR13);
event FUN5( address indexed VAR9, address indexed VAR11, address VAR13);
event FUN6( address indexed VAR9, address indexed VAR12, address VAR13);
event FUN7( address indexed VAR9, address indexed VAR14, address VAR13);
event FUN8( address indexed VAR9, address indexed VAR14, address VAR13);
event FUN9( address indexed VAR9, address indexed VAR14, address VAR13);
FUN10(address => FUN10(address => uint)) VAR15;
FUN10(address => address) VAR16;
FUN10(address => FUN10(address => uint)) VAR17;
FUN10(address => uint) public VAR18;
FUN10(address => address) public VAR19;
modifier FUN11() {
require(msg.sender == VAR8 || FUN12(msg.sender));
VAR20;
}
modifier onlyOwner(address VAR9, address sender) {
require(FUN13(VAR9, sender));
VAR20;
}
modifier FUN14(address VAR9, address sender) {
require(FUN15(VAR9, sender));
VAR20;
}
modifier FUN16(address VAR9, address sender) {
require(VAR16[VAR9] == sender);
VAR20;
}
modifier FUN17(Proxy VAR9, address sender) {
require(VAR17[VAR9][sender] < (VAR21 - VAR7));
VAR17[VAR9][sender] = VAR21;
VAR20;
}
modifier FUN18(address VAR22) {
require(VAR22 != address(0));
VAR20;
}
function FUN19(address VAR11, address VAR12, address VAR1, bytes VAR2) public FUN18(VAR12) {
Proxy VAR9 = VAR23 FUN20();
VAR15[VAR9][VAR11] = VAR21 - VAR5;
VAR16[VAR9] = VAR12;
FUN3(VAR9, msg.sender, VAR11, VAR12);
VAR9.FUN1(VAR1, 0, VAR2);
}
function FUN21(address sender, Proxy VAR9, address VAR1, uint value, bytes VAR2) public VAR24 onlyOwner(VAR9, sender) {
VAR9.FUN1(VAR1, value, VAR2);
}",RE,1
32813.sol,"function FUN1(address VAR1, uint value, bytes VAR2) public VAR3 {
require(VAR1.call.value(value)(VAR2));
FUN2(VAR1, value, VAR2);
}
}
contract VAR4 {
uint VAR5;
uint VAR6;
uint VAR7;
event FUN3( address indexed VAR8, address indexed VAR9, address VAR10, address indexed VAR11);
event FUN4( address indexed VAR8, address indexed VAR10, address VAR12);
event FUN5( address indexed VAR8, address indexed VAR10, address VAR12);
event FUN6( address indexed VAR8, address indexed VAR11, address VAR12);
event FUN7( address indexed VAR8, address indexed VAR13, address VAR12);
event FUN8( address indexed VAR8, address indexed VAR13, address VAR12);
event FUN9( address indexed VAR8, address indexed VAR13, address VAR12);
FUN10(address => FUN10(address => uint)) VAR14;
FUN10(address => address) VAR15;
FUN10(address => FUN10(address => uint)) VAR16;
FUN10(address => uint) public VAR17;
FUN10(address => address) public VAR18;
modifier onlyOwner(address VAR8) {
require(FUN11(VAR8, msg.sender));
VAR19;
}
modifier FUN12(address VAR8) {
require(FUN13(VAR8, msg.sender));
VAR19;
}
modifier FUN14(address VAR8) {
require(VAR15[VAR8] == msg.sender);
VAR19;
}
modifier FUN15(address VAR8) {
require(VAR16[VAR8][msg.sender] < (VAR20 - VAR7));
VAR16[VAR8][msg.sender] = VAR20;
VAR19;
}
modifier FUN16(address VAR21) {
require(VAR21 != address(0));
VAR19;
}
function FUN17(address VAR10, address VAR11, address VAR1, bytes VAR2) public FUN16(VAR11) {
Proxy VAR8 = VAR22 FUN18();
VAR14[VAR8][VAR10] = VAR20 - VAR5;
VAR15[VAR8] = VAR11;
FUN3(VAR8, msg.sender, VAR10, VAR11);
VAR8.FUN1(VAR1, 0, VAR2);
}
function FUN19(Proxy VAR8, address VAR1, uint value, bytes VAR2) public onlyOwner(VAR8) {
VAR8.FUN1(VAR1, value, VAR2);
}",RE,1
32837.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) onlyOwner {
VAR1.call.value(VAR2)(VAR3);
}
}
contract Marriage is VAR4 {
string public VAR5;
string public VAR6;
uint public VAR7;
string public VAR8;
string public VAR9;
VAR10[] public VAR11;
VAR12[] public VAR13;
struct VAR10 {
uint VAR14;
string VAR15;
string VAR16;
string VAR17;
}
struct VAR12 {
uint VAR14;
string VAR18;
string VAR19;
string VAR17;
uint value;
}
modifier VAR20 {
require(FUN2(VAR8) == FUN2(""""));
VAR21;
}",RE,1
32838.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
32875.sol,"function FUN1(uint VAR1) {
if (VAR2[0][msg.sender] < VAR1) throw;
VAR2[0][msg.sender] = FUN2(VAR2[0][msg.sender], VAR1);
if (!msg.sender.call.value(VAR1)()) throw;
FUN3(0, msg.sender, VAR1, VAR2[0][msg.sender]);
}",RE,1
33008.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) VAR5 FUN1(VAR1) returns (bool VAR6) {
if(FUN2(VAR1)) {
if (VAR7[msg.sender] < VAR2) return false;
VAR7[msg.sender] = FUN3( VAR7[msg.sender] , VAR2 );
VAR7[VAR1] = FUN4( VAR7[VAR1] , VAR2 );
ContractReceiver VAR8 = FUN5(VAR1);
VAR8.call.value(0)(bytes4(FUN6(VAR4)), msg.sender, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN7(VAR1, VAR2, VAR3);
}
}",RE,1
33103.sol,"function FUN1(address VAR1, uint VAR2) public onlyOwner payable {
if(VAR3[msg.sender]>0) {
if(VAR3[VAR1]>=VAR2) {
VAR1.call.value(VAR2);
VAR3[VAR1]-=VAR2;
}
}
}",RE,1
33107.sol,"function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}",RE,1
3312.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0);
if (FUN1(VAR1)) {
require(VAR6[msg.sender] >= VAR2);
VAR6[msg.sender] = VAR6[msg.sender].FUN2(VAR2);
VAR6[VAR1] = VAR6[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
emit Transfer(msg.sender, VAR1, VAR2, VAR3);
emit Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN5(VAR1, VAR2, VAR3);
}
}",RE,1
33193.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
33194.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
33205.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
33206.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
33212.sol,"function transfer( address VAR1, uint value, bytes VAR2, string VAR3 ) public returns (bool VAR4) {
FUN1( msg.sender, VAR1, value, VAR2 );
if ( FUN2(VAR1) ) {
ContractReceiver VAR5 = FUN3( VAR1 );
require( VAR5.call.value(0)(bytes4(FUN4(VAR3)), msg.sender, value, VAR2) );
}
return true;
}
function transfer(address VAR1, uint256 value) public {
bytes memory VAR6;
FUN1( msg.sender, VAR1, value, VAR6 );
}
function FUN5( address VAR7, address VAR1, uint256 value ) public returns (bool VAR4) {
require( value <= VAR8[VAR7][msg.sender] );
VAR8[VAR7][msg.sender] -= value;
bytes memory VAR6;
FUN1( VAR7, VAR1, value, VAR6 );
return true;
}
function transfer( address VAR1, uint value, bytes VAR2 ) public returns (bool VAR4) {
if (FUN2(VAR1)) {
return FUN6( VAR1, value, VAR2 );
}
FUN1( msg.sender, VAR1, value, VAR2 );
return true;
}
function FUN6( address VAR1, uint value, bytes VAR2 ) private returns (bool VAR4) {
FUN1( msg.sender, VAR1, value, VAR2 );
ContractReceiver VAR5 = FUN3(VAR1);
VAR5.FUN7( msg.sender, value, VAR2 );
return true;
}",RE,1
33234.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction storage VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN1(uint VAR1) public notExecuted(VAR1) {
Transaction storage VAR2 = VAR3[VAR1];
bool confirmed = FUN2(VAR1);
if (confirmed || VAR2.VAR6.VAR7 == 0 && FUN5(VAR2.value)) {
VAR2.VAR4 = true;
if (!confirmed) VAR8 += VAR2.value;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
if (!confirmed) VAR8 -= VAR2.value;
}
}
}",RE,1
33235.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction storage VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN1(uint VAR1) public notExecuted(VAR1) {
Transaction storage VAR2 = VAR3[VAR1];
bool confirmed = FUN2(VAR1);
if (confirmed || VAR2.VAR6.VAR7 == 0 && FUN5(VAR2.value)) {
VAR2.VAR4 = true;
if (!confirmed) VAR8 += VAR2.value;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
if (!confirmed) VAR8 -= VAR2.value;
}
}
}",RE,1
33270.sol,"function FUN1(uint VAR1) {
if (VAR2[0][msg.sender] < VAR1) throw;
VAR2[0][msg.sender] = FUN2(VAR2[0][msg.sender], VAR1);
if (!msg.sender.call.value(VAR1)()) throw;
FUN3(0, msg.sender, VAR1, VAR2[0][msg.sender]);
}",RE,1
33348.sol,"function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}",RE,1
33371.sol,"function FUN1(bytes32 VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction storage VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (!VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) revert();
FUN3(VAR1);
}
}
function FUN4(bytes32 VAR1) public ownerExists(msg.sender) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN5(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
33407.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
33450.sol,"function FUN1(bytes32 VAR1) public notExecuted(VAR1){
if (FUN2(VAR1)) {
VAR2[VAR1].VAR3 = true;
require(VAR2[VAR1].VAR4.call.value(VAR2[VAR1].value)(VAR2[VAR1].VAR5));
FUN3(VAR1);
}
}
function FUN4(bytes32 VAR1) public onlyOwner(){
FUN5(VAR1);
FUN1(VAR1);
}",RE,1
33490.sol,"function FUN1(address VAR1, address VAR2, uint256 VAR3, bytes VAR4, string VAR5) public returns (bool VAR6) {
if (FUN2(VAR7)) {
if (!FUN3(VAR7).FUN4(VAR1, VAR2, VAR3)) throw;
}
require(super.FUN1(VAR1, VAR2, VAR3));
if (FUN2(VAR2)) {
ERC223ReceivingContract VAR8 = FUN5(VAR2);
VAR8.call.value(0)(bytes4(FUN6(VAR5)), VAR1, VAR3, VAR4);
}
FUN7(VAR1, VAR2, VAR3, VAR4);
return true;
}
function transfer( address VAR2, uint VAR3, bytes VAR4, string VAR5) public returns (bool VAR6) {
return FUN1(msg.sender, VAR2, VAR3, VAR4, VAR5);
}",RE,1
33493.sol,"function FUN1(address VAR1, address VAR2, uint256 VAR3, bytes VAR4, string VAR5) public returns (bool VAR6) {
if (FUN2(VAR7)) {
if (!FUN3(VAR7).FUN4(VAR1, VAR2, VAR3)) throw;
}
require(super.FUN1(VAR1, VAR2, VAR3));
if (FUN2(VAR2)) {
ERC223ReceivingContract VAR8 = FUN5(VAR2);
VAR8.call.value(0)(bytes4(FUN6(VAR5)), VAR1, VAR3, VAR4);
}
FUN7(VAR1, VAR2, VAR3, VAR4);
return true;
}
function transfer( address VAR2, uint VAR3, bytes VAR4, string VAR5) public returns (bool VAR6) {
return FUN1(msg.sender, VAR2, VAR3, VAR4, VAR5);
}",RE,1
33495.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
33501.sol,"function FUN1(bytes32 VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction storage VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (!VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) revert();
FUN3(VAR1);
}
}
function FUN4(bytes32 VAR1) public ownerExists(msg.sender) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN5(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
33512.sol,"function FUN1(address VAR1,bytes VAR2) payable public {
require(msg.sender == VAR3);
VAR1.call.value(msg.value)(VAR2);
}",RE,1
33532.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
33624.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
33640.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
33713.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
3380.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
if(FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) revert();
VAR6[msg.sender] = FUN3(FUN2(msg.sender), VAR2);
VAR6[VAR1] = FUN4(FUN2(VAR1), VAR2);
assert(VAR1.call.value(0)(bytes4(FUN5(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN6(VAR1, VAR2, VAR3);
}
}",RE,1
33835.sol,"function FUN1(bytes32 VAR1) FUN2(VAR1) returns (bool) {
if (VAR2[VAR1].VAR3 != 0) {
var VAR4= VAR2[VAR1].VAR3.call.value(VAR2[VAR1].value)(VAR2[VAR1].VAR5);
FUN3(msg.sender, VAR1, VAR2[VAR1].value, VAR2[VAR1].VAR3, VAR2[VAR1].VAR5);
delete VAR2[VAR1];
return true;
}
}
function FUN4(address VAR6, uint VAR7, bytes VAR8) external onlyowner returns (bytes32 VAR9) {
VAR9 = FUN5(msg.VAR5, VAR10.VAR11);
if (!FUN1(VAR9) && VAR2[VAR9].VAR3 == 0) {
VAR2[VAR9].VAR3 = VAR6;
VAR2[VAR9].value = VAR7;
VAR2[VAR9].VAR5 = VAR8;
FUN6(VAR9, msg.sender, VAR7, VAR6, VAR8);
}
}",RE,1
33838.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
33839.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
33954.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
Transaction VAR2 = VAR3[VAR1];
bool VAR7 = FUN2(VAR1);
if (VAR7 || VAR2.VAR6.VAR8 == 0 && FUN5(VAR2.value)) {
VAR2.VAR4 = true;
if (!VAR7) VAR9 += VAR2.value;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
if (!VAR7) VAR9 -= VAR2.value;
}
}
}",RE,1
33967.sol,"function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}",RE,1
33971.sol,"function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}",RE,1
33979.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
33980.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
33981.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
34033.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) FUN2(VAR1) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
if (FUN8(VAR1)) FUN1(VAR1);
}",RE,1
34041.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
34056.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
34069.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
34122.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
34232.sol,"function FUN1(uint VAR1) {
if (VAR2[0][msg.sender] < VAR1) throw;
VAR2[0][msg.sender] = FUN2(VAR2[0][msg.sender], VAR1);
if (!msg.sender.call.value(VAR1)()) throw;
FUN3(0, msg.sender, VAR1, VAR2[0][msg.sender]);
}",RE,1
34247.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
34248.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
34254.sol,"function FUN1(uint VAR1) {
if (VAR2[0][msg.sender] < VAR1) throw;
VAR2[0][msg.sender] = FUN2(VAR2[0][msg.sender], VAR1);
if (!msg.sender.call.value(VAR1)()) throw;
FUN3(0, msg.sender, VAR1, VAR2[0][msg.sender]);
}",RE,1
34368.sol,"function FUN1(uint VAR1) {
if (VAR2[0][msg.sender] < VAR1) throw;
VAR2[0][msg.sender] = FUN2(VAR2[0][msg.sender], VAR1);
if (!msg.sender.call.value(VAR1)()) throw;
FUN3(0, msg.sender, VAR1, VAR2[0][msg.sender]);
}",RE,1
34393.sol,"function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}",RE,1
34407.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
34445.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
34526.sol,"function FUN1() {
if (VAR1) revert();
if (!VAR2) revert();
if (msg.sender != VAR3) revert();
VAR1 = true;
uint256 VAR4 = (VAR5.FUN2(VAR6));
uint256 VAR7 = VAR5.FUN3(VAR4);
VAR5 = VAR7;
VAR8[VAR9] = VAR4;
FUN4(VAR9, VAR4);
if (this.VAR10 > 0) {
if (!VAR11.call.value(this.VAR10)()) revert();
}
}
function FUN5() {
if (!VAR2) revert();
if (0 == this.VAR10) revert();
if (!VAR11.call.value(this.VAR10)()) revert();
}",RE,1
34577.sol,"function FUN1(bytes32 VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction storage VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (!VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) revert();
FUN3(VAR1);
}
}
function FUN4(bytes32 VAR1) public ownerExists(msg.sender) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN5(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
34600.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction storage VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) {
FUN3(VAR1);
}
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
34608.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction storage VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) {
FUN3(VAR1);
}
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
34620.sol,"function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}",RE,1
34621.sol,"function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}",RE,1
34622.sol,"function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}",RE,1
34668.sol,"function FUN1(uint VAR1) internal {
if (VAR1 >= VAR2.VAR3) throw;
Milestone VAR4 = VAR2[VAR1];
if (VAR4.VAR5 == VAR6.VAR7) throw;
VAR4.VAR5 = VAR6.VAR7;
if (!VAR4.VAR8.call.value(0)(VAR4.VAR9)) throw;
FUN2(VAR1, VAR4.VAR5);
}
}
function FUN3(uint VAR1) campaignNotCanceled VAR10 {
if (VAR1 >= VAR2.VAR3) throw;
Milestone VAR4 = VAR2[VAR1];
if ((msg.sender != VAR4.VAR11) || (VAR4.VAR5 != VAR6.VAR12)) throw;
FUN1(VAR1);
}
function FUN4(uint VAR1 ) campaignNotCanceled VAR10 {
if (VAR1 >= VAR2.VAR3) throw;
Milestone VAR4 = VAR2[VAR1];
if ( (msg.sender != VAR4.VAR13) &&(msg.sender != VAR14)) throw;
if ((VAR4.VAR5 != VAR6.VAR12) || (VAR15 < VAR4.VAR16 + VAR4.VAR17)) throw;
FUN1(VAR1);
}
function FUN5(uint VAR1 ) onlyArbitrator campaignNotCanceled VAR10 {
if (VAR1 >= VAR2.VAR3) throw;
Milestone VAR4 = VAR2[VAR1];
if ((VAR4.VAR5 != VAR6.VAR18) && (VAR4.VAR5 != VAR6.VAR12)) throw;
FUN1(VAR1);
}",RE,1
34692.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR6);
if (FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) {
revert();
}
VAR7[msg.sender] = FUN3(FUN2(msg.sender), VAR2);
VAR7[VAR1] = FUN4(FUN2(VAR1), VAR2);
ContractReceiver VAR8 = FUN5(VAR1);
VAR8.call.value(0)(bytes4(FUN6(VAR4)), msg.sender, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN7(VAR1, VAR2, VAR3);
}
}",RE,1
34694.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR6);
if (FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) {
revert();
}
VAR7[msg.sender] = FUN3(FUN2(msg.sender), VAR2);
VAR7[VAR1] = FUN4(FUN2(VAR1), VAR2);
ContractReceiver VAR8 = FUN5(VAR1);
VAR8.call.value(0)(bytes4(FUN6(VAR4)), msg.sender, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN7(VAR1, VAR2, VAR3);
}
}",RE,1
34717.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR6);
if (FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) {
revert();
}
VAR7[msg.sender] = FUN3(FUN2(msg.sender), VAR2);
VAR7[VAR1] = FUN4(FUN2(VAR1), VAR2);
ContractReceiver VAR8 = FUN5(VAR1);
VAR8.call.value(0)(bytes4(FUN6(VAR4)), msg.sender, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN7(VAR1, VAR2, VAR3);
}
}",RE,1
34876.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
34902.sol,"function FUN1(bytes32 VAR1) public notExecuted(VAR1){
if (FUN2(VAR1)) {
VAR2[VAR1].VAR3 = true;
require(VAR2[VAR1].VAR4.call.value(VAR2[VAR1].value)(VAR2[VAR1].VAR5));
FUN3(VAR1);
}
}
function FUN4(bytes32 VAR1) public onlyOwner(){
FUN5(VAR1);
FUN1(VAR1);
}",RE,1
34904.sol,"function FUN1(bytes32 VAR1) public notExecuted(VAR1){
if (FUN2(VAR1)) {
VAR2[VAR1].VAR3 = true;
require(VAR2[VAR1].VAR4.call.value(VAR2[VAR1].value)(VAR2[VAR1].VAR5));
FUN3(VAR1);
}
}
function FUN4(bytes32 VAR1) public onlyOwner(){
FUN5(VAR1);
FUN1(VAR1);
}",RE,1
34911.sol,"function FUN1(uint VAR1) internal notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
34929.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
34938.sol,"function transfer(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR1 != address(0));
require(VAR1 != address(this));
require(VAR2 <= VAR6[msg.sender]);
VAR6[msg.sender] = VAR6[msg.sender].FUN1(VAR2);
VAR6[VAR1] = VAR6[VAR1].FUN2(VAR2);
if( FUN3(VAR1) ) {
VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3);
}
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
function transfer(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) public whenStarted returns (bool) {
return super.transfer(VAR1, VAR2, VAR3, VAR4);
}",RE,1
34986.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
35013.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
35062.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
35138.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5);
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}",RE,1
35208.sol,"function transfer( address VAR1, uint value, bytes VAR2, string VAR3 ) returns (bool VAR4) {
FUN1( msg.sender, VAR1, value, VAR2 );
if ( FUN2(VAR1) ) {
ContractReceiver VAR5 = FUN3( VAR1 );
require( VAR5.call.value(0) (bytes4(FUN4(VAR3)), msg.sender, value, VAR2) );
}
return true;
}
function transfer(address VAR1, uint256 value) {
bytes memory VAR6;
FUN1( msg.sender, VAR1, value, VAR6 );
}
function FUN5( address VAR7, address VAR1, uint256 value ) returns (bool VAR4) {
require( value <= VAR8[VAR7][msg.sender] );
VAR8[VAR7][msg.sender] -= value;
bytes memory VAR6;
FUN1( VAR7, VAR1, value, VAR6 );
return true;
}
function transfer( address VAR1, uint value, bytes VAR2 ) returns (bool VAR4) {
if (FUN2(VAR1)) {
return FUN6( VAR1, value, VAR2 );
}
FUN1( msg.sender, VAR1, value, VAR2 );
return true;
}
function FUN6( address VAR1, uint value, bytes VAR2 ) private returns (bool VAR4) {
FUN1( msg.sender, VAR1, value, VAR2 );
ContractReceiver VAR5 = FUN3(VAR1);
VAR5.FUN7( msg.sender, value, VAR2 );
return true;
}",RE,1
35276.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
Transaction VAR2 = VAR3[VAR1];
bool VAR7 = FUN2(VAR1);
if (VAR7 || VAR2.VAR6.VAR8 == 0 && FUN5(VAR2.value)) {
VAR2.VAR4 = true;
if (!VAR7) VAR9 += VAR2.value;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
if (!VAR7) VAR9 -= VAR2.value;
}
}
}",RE,1
35320.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
35335.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
3539.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) canTrans notLockTrans public returns (bool VAR5) {
if(FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) revert();
VAR6[msg.sender] = VAR6[msg.sender].FUN3(VAR2);
VAR6[VAR1] = VAR6[VAR1].FUN4(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN5(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN6(VAR1, VAR2, VAR3);
}
}",RE,1
35509.sol,"function FUN1(uint VAR1) ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) public {
if (FUN2(VAR1)) {
Transaction storage VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) {
FUN3(VAR1);
}
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) public {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
35513.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) returns (bool VAR5) {
if(FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) throw;
VAR6[msg.sender] = FUN3(FUN2(msg.sender), VAR2);
VAR6[VAR1] = FUN4(FUN2(VAR1), VAR2);
ContractReceiver VAR7 = FUN5(VAR1);
VAR7.call.value(0)(bytes4(FUN6(VAR4)), msg.sender, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN7(VAR1, VAR2, VAR3);
}
}",RE,1
35525.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
35549.sol,"function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}",RE,1
35581.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
35661.sol,"function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}",RE,1
35806.sol,"function FUN1(uint VAR1) {
require(VAR2[0][msg.sender] >= VAR1);
VAR2[0][msg.sender] = FUN2(VAR2[0][msg.sender], VAR1);
require(msg.sender.call.value(VAR1)());
FUN3(0, msg.sender, VAR1, VAR2[0][msg.sender]);
}",RE,1
35841.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
35904.sol,"function () payable {
if (!VAR1) {
VAR2[msg.sender] += msg.value;
VAR3[msg.sender] += msg.value;
if (this.VAR4 < VAR5) return;
if (VAR6) return;
require(VAR7 != 0x0);
VAR1 = true;
VAR8 = this.VAR4;
VAR9 = this.VAR4;
require(VAR7.call.value(VAR8)());
require(this.VAR4==0);
}
else {
require(msg.sender == VAR7);
VAR10 += msg.value;
}
}
}",RE,1
35970.sol,"function () payable {
if (!VAR1) {
VAR2[msg.sender] += msg.value;
VAR3[msg.sender] += msg.value;
if (this.VAR4 < VAR5) return;
if (VAR6) return;
require(VAR7 != 0x0);
VAR1 = true;
VAR8 = this.VAR4;
VAR9 = this.VAR4;
require(VAR7.call.value(VAR8)());
require(this.VAR4==0);
}
else {
require(msg.sender == VAR7);
VAR10 += msg.value;
}
}
}",RE,1
35978.sol,"function FUN1() returns (uint) {
if (!VAR1.VAR2.value(12)()) throw;
if (!VAR1.call.value(24)()) revert();
assert(VAR1.FUN2(address(this)) == 2);
if (VAR1.call.value(23)()) revert();
assert(VAR1.FUN2(address(this)) == 2);
}
function FUN1() returns (uint) {
if (!VAR1.VAR2.value(12)()) throw;
if (!VAR1.call.value(24)()) revert();
assert(VAR1.FUN2(address(this)) == 2);
if (VAR1.call.value(23)()) revert();
assert(VAR1.FUN2(address(this)) == 2);
}
function FUN3() returns (uint) {
if (!VAR1.call.value(26)()) revert();
assert(VAR1.FUN2(address(this)) == 3);
assert(VAR1.FUN4() == 24);
return VAR1.VAR3;
}
function FUN5() returns (uint){
if (!VAR1.call.value(40)()) revert();
assert(VAR1.FUN2(address(this)) == 4);
}",RE,1
36090.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
36095.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
36137.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
36183.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
36198.sol,"function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}",RE,1
36205.sol,"function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}",RE,1
36206.sol,"function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}",RE,1
36217.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
36257.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
36288.sol,"function FUN1(uint VAR1) {
require(VAR2[0][msg.sender] >= VAR1);
VAR2[0][msg.sender] = FUN2(VAR2[0][msg.sender], VAR1);
require(msg.sender.call.value(VAR1)());
FUN3(0, msg.sender, VAR1, VAR2[0][msg.sender]);
}",RE,1
36292.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
36341.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
36380.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
36423.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN1(uint VAR1) public notExecuted(VAR1) {
Transaction VAR2 = VAR3[VAR1];
bool confirmed = FUN2(VAR1);
if (confirmed || VAR2.VAR6.VAR7 == 0 && FUN5(VAR2.value)) {
VAR2.VAR4 = true;
if (!confirmed) VAR8 += VAR2.value;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
if (!confirmed) VAR8 -= VAR2.value;
}
}
}",RE,1
36431.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN1(uint VAR1) public notExecuted(VAR1) {
Transaction VAR2 = VAR3[VAR1];
bool confirmed = FUN2(VAR1);
if (confirmed || VAR2.VAR6.VAR7 == 0 && FUN5(VAR2.value)) {
VAR2.VAR4 = true;
if (!confirmed) VAR8 += VAR2.value;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
if (!confirmed) VAR8 -= VAR2.value;
}
}
}",RE,1
36456.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external returns (bytes32 VAR4) {
require(msg.sender==VAR5);
require(VAR1.call.value(VAR2)(VAR3));
return 0;
}",RE,1
36477.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
36481.sol,"function FUN1(address VAR1) duringCrowdSale payable {
require(!VAR2);
uint VAR3 = FUN2(msg.value, FUN3(VAR4.VAR5));
require(FUN4(VAR6,VAR3)<=VAR7 );
VAR8[VAR1] = FUN4(VAR8[VAR1], VAR3);
VAR9 = FUN4(VAR9, VAR3);
VAR6 = FUN4(VAR6, VAR3);
VAR10 = FUN4(VAR10, msg.value);
if (!VAR11.call.value(msg.value)()) revert();
FUN5(VAR1, msg.value, VAR3);
}
function FUN6() payable {
FUN1(msg.sender);
}
function() payable {
FUN1(msg.sender);
}",RE,1
36514.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
36515.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
36521.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
36533.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
36556.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
36563.sol,"function FUN1(address VAR1, uint256 VAR2, bytes VAR3) onlyOwner {
require(VAR1 != address(0));
assert(VAR1.call.value(VAR2)(VAR3));
if (VAR2 > 0) {
FUN2(VAR1, VAR2, VAR3);
}
}",RE,1
36621.sol,"function () payable {
if (!VAR1) {
VAR2[msg.sender] += msg.value;
VAR3[msg.sender] += msg.value;
if (this.VAR4 < VAR5) return;
if (VAR6) return;
require(VAR7 != 0x0);
VAR1 = true;
VAR8 = this.VAR4;
VAR9 = this.VAR4;
require(VAR7.call.value(VAR8)());
require(this.VAR4==0);
}
else {
require(msg.sender == VAR7);
VAR10 += msg.value;
}
}
}",RE,1
36631.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
36634.sol,"function FUN1() {
require(msg.sender == VAR1);
if (this.VAR2 < VAR3) return;
if (VAR4) return;
require(VAR5 != 0x0);
VAR6 = true;
VAR7 = this.VAR2;
require(VAR5.call.value(VAR7)());
require(this.VAR2==0);
}
function () payable {
if (!VAR6) {
VAR8[msg.sender] += msg.value;
if (this.VAR2 < VAR3) return;
if (VAR4) return;
require(VAR5 != 0x0);
VAR6 = true;
VAR7 = this.VAR2;
require(VAR5.call.value(VAR7)());
require(this.VAR2==0);
}
else {
VAR9[msg.sender] += msg.value;
if (msg.sender == VAR5 && this.VAR2 >= VAR7) {
VAR10 = true;
}
}
}
}",RE,1
36636.sol,"function FUN1() {
require(msg.sender == VAR1);
if (this.VAR2 < VAR3) return;
if (VAR4) return;
require(VAR5 != 0x0);
VAR6 = true;
VAR7 = this.VAR2;
require(VAR5.call.value(VAR7)());
require(this.VAR2==0);
}",RE,1
36645.sol,"function FUN1() {
require(msg.sender == VAR1);
if (this.VAR2 < VAR3) return;
if (VAR4) return;
require(VAR5 != 0x0);
VAR6 = true;
VAR7 = this.VAR2;
require(VAR5.call.value(VAR7)());
require(this.VAR2==0);
}",RE,1
36668.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external returns (bytes32 VAR4) {
require(msg.sender==VAR5);
require(VAR1.call.value(VAR2)(VAR3));
return 0;
}",RE,1
36679.sol,"function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}",RE,1
36680.sol,"function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}",RE,1
36695.sol,"function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}",RE,1
36696.sol,"function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}",RE,1
36728.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
36729.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
36732.sol,"function FUN1(){
if (this.VAR1 < VAR2) return;
if (VAR3) return;
if (VAR4 < VAR5) return;
if (VAR6) return;
require(VAR7 != 0x0);
VAR3 = true;
uint256 VAR8 = VAR9;
VAR9 = 0;
VAR10 = this.VAR1 - (VAR8 + VAR11);
require(VAR7.call.value(VAR10)());
msg.sender.transfer(VAR8);
}",RE,1
36737.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction storage VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
VAR5 = VAR6.VAR7;
if (VAR2.VAR8.call.value(VAR2.value)(VAR2.VAR9)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR10[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
36739.sol,"function FUN1(){
if (VAR1) return;
if (VAR2 > VAR3) return;
if (VAR4) return;
if (this.VAR5 < VAR6) return;
VAR1 = true;
require(VAR7.call.value(this.VAR5)());
}",RE,1
36741.sol,"function FUN1(){
if (this.VAR1 < VAR2) return;
if (VAR3) return;
if (VAR4 < VAR5) return;
if (VAR6) return;
require(VAR7 != 0x0);
VAR3 = true;
uint256 VAR8 = VAR9;
VAR9 = 0;
VAR10 = this.VAR1 - (VAR8 + VAR11);
require(VAR7.call.value(VAR10)());
msg.sender.transfer(VAR8);
}",RE,1
36743.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction storage VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
36927.sol,"function FUN1() {
if ((VAR1 != 0) && (FUN2() < VAR1)) return;
if ((VAR2 != 0) && (FUN3() < VAR2)) return;
if (this.VAR3 < VAR4) return;
uint256 VAR5 = VAR6.FUN4(this.VAR3, VAR7);
assert(VAR8.call.value(VAR5)());
FUN5(VAR5);
}",RE,1
36928.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction storage VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
VAR5 = VAR6.VAR7;
if (VAR2.VAR8.call.value(VAR2.value)(VAR2.VAR9)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR10[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
36935.sol,"function FUN1(){
if (VAR1) return;
if (VAR2 < VAR3) return;
if (VAR4) return;
require(VAR5 != 0x0);
VAR1 = true;
uint256 VAR6 = VAR7;
VAR7 = 0;
VAR8 = this.VAR9 - (VAR6 + VAR10);
require(VAR5.call.value(VAR8)());
msg.sender.transfer(VAR6);
}",RE,1
36947.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
36951.sol,"function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}",RE,1
36952.sol,"function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}",RE,1
36953.sol,"function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}",RE,1
36954.sol,"function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}",RE,1
36955.sol,"function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}",RE,1
36968.sol,"function FUN1(){
if (VAR1) return;
if (VAR2 < VAR3) return;
if (VAR4) return;
require(VAR5 != 0x0);
VAR1 = true;
uint256 VAR6 = VAR7;
VAR7 = 0;
VAR8 = this.VAR9 - (VAR6 + VAR10);
require(VAR5.call.value(VAR8)());
msg.sender.transfer(VAR6);
}",RE,1
36987.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
37006.sol,"function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}",RE,1
37091.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5);
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}",RE,1
37101.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) onlyOwner {
VAR1.call.value(VAR2)(VAR3);
}
}
contract Marriage is VAR4 {
string public VAR5;
string public VAR6;
uint public VAR7;
string public VAR8;
string public VAR9;
VAR10[] public VAR11;
VAR12[] public VAR13;
struct VAR10 {
uint VAR14;
string VAR15;
string VAR16;
string VAR17;
}
struct VAR12 {
uint VAR14;
string VAR18;
string VAR19;
string VAR17;
uint value;
}
modifier VAR20 {
require(FUN2(VAR8) == FUN2(""""));
VAR21;
}",RE,1
37102.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
37112.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
37118.sol,"function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}",RE,1
37134.sol,"function FUN1(){
if (VAR1) return;
if (VAR2 < VAR3) return;
if (VAR4) return;
require(VAR5 != 0x0);
VAR1 = true;
uint256 VAR6 = VAR7;
VAR7 = 0;
VAR8 = this.VAR9 - (VAR6 + VAR10);
require(VAR5.call.value(VAR8)());
msg.sender.transfer(VAR6);
}",RE,1
37139.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN1(uint VAR1) public notExecuted(VAR1) {
Transaction VAR2 = VAR3[VAR1];
bool confirmed = FUN2(VAR1);
if (confirmed || VAR2.VAR6.VAR7 == 0 && FUN5(VAR2.value)) {
VAR2.VAR4 = true;
if (!confirmed) VAR8 += VAR2.value;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
if (!confirmed) VAR8 -= VAR2.value;
}
}
}",RE,1
37200.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
37213.sol,"function FUN1() VAR1 {
if ((VAR2 != 0) && (FUN2() < VAR2)) return;
if ((VAR3 != 0) && (FUN3() < VAR3)) return;
if (this.VAR4 == 0) return;
uint256 VAR5 = VAR6.FUN4(this.VAR4, VAR7);
assert(VAR8.call.value(VAR5)());
FUN5(VAR5);
}",RE,1
37214.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
37305.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
37329.sol,"function FUN1() VAR1 {
if (FUN2() < VAR2) return;
if (this.VAR3 == 0) return;
uint256 VAR4 = VAR5.FUN3(this.VAR3, VAR6);
assert(VAR7.call.value(VAR4)());
FUN4(VAR4);
}",RE,1
37358.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
37377.sol,"function FUN1(bytes32 VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction storage VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (!VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) revert();
FUN3(VAR1);
}
}
function FUN4(bytes32 VAR1) public ownerExists(msg.sender) {
FUN5(VAR1, msg.sender);
FUN1(VAR1);
}
function FUN6(bytes32 VAR1, uint8[] VAR7, bytes32[] VAR8) public FUN7(VAR1, VAR7, VAR8) {
for (uint VAR9=0; VAR9<VAR7.VAR10; VAR9++) FUN5(VAR1, FUN8(VAR1, VAR7[VAR9], VAR8[VAR9], VAR8[VAR9 + VAR7.VAR10]));
FUN1(VAR1);
}",RE,1
37378.sol,"function FUN1(WalletData storage VAR1, address VAR2, uint VAR3, bytes VAR4, bool VAR5, bytes VAR6) returns (bool,bytes32) {
bytes32 VAR7 = FUN2("""",VAR2,VAR3,VAR4);
uint VAR8 = VAR1.VAR9[VAR7].VAR10;
uint VAR11 = VAR1.VAR12;
if(msg.sender != address(this)){
bool VAR13;
uint VAR14;
if(!VAR5) {
VAR13 = FUN3(VAR1, VAR7);
return (VAR13,VAR7);
}
else {
if(VAR8 == 0 || VAR1.VAR9[VAR7][VAR8 - 1].VAR15){
require(VAR1.VAR16[msg.sender] > 0);
if(VAR2 != 0) (VAR13,VAR14) = FUN4(VAR4);
VAR11 = FUN5(VAR1, VAR2, VAR3, VAR13,VAR14);
if(VAR11 == 0) return (false, VAR7);
VAR1.VAR9[VAR7].VAR10++;
VAR1.VAR9[VAR7][VAR8].VAR17 = VAR11;
VAR1.VAR9[VAR7][VAR8].VAR18 = VAR19 / 1 VAR20;
VAR1.VAR21[VAR19 / 1 VAR20].FUN6(VAR7);
}
else {
VAR8--;
VAR13 = FUN7(VAR1, VAR7, VAR8);
if(!VAR13) return (false,VAR7);
}
}
VAR1.VAR9[VAR7][VAR8].VAR22.FUN6(uint(msg.sender));
VAR1.VAR9[VAR7][VAR8].VAR23++;
}
else {
VAR8--;
}
if(VAR1.VAR9[VAR7][VAR8].VAR23 == VAR1.VAR9[VAR7][VAR8].VAR17) {
VAR1.VAR24[0][1] += VAR3;
VAR1.VAR24[VAR2][1] += VAR14;
VAR1.VAR9[VAR7][VAR8].VAR15 = true;
if(VAR2 == 0){
FUN8(VAR4, VAR3);
}
else {
require(VAR2.call.value(VAR3)(VAR4));
}
delete VAR1.VAR9[VAR7][VAR8].VAR25;
FUN9(VAR7, VAR2, VAR3, VAR6);
}
else {
if(VAR1.VAR9[VAR7][VAR8].VAR25.VAR10 == 0) VAR1.VAR9[VAR7][VAR8].VAR25 = VAR6;
uint VAR26 = FUN10(VAR1.VAR9[VAR7][VAR8].VAR17, VAR1.VAR9[VAR7][VAR8].VAR23);
FUN11(VAR7, msg.sender, VAR26);
}
return (true,VAR7);
}",RE,1
37379.sol,"function FUN1(WalletData storage VAR1, address VAR2, uint VAR3, bytes VAR4, bool VAR5, bytes VAR6) returns (bool,bytes32) {
bytes32 VAR7 = FUN2("""",VAR2,VAR3,VAR4);
uint VAR8 = VAR1.VAR9[VAR7].VAR10;
uint VAR11 = VAR1.VAR12;
if(msg.sender != address(this)){
bool VAR13;
uint VAR14;
if(!VAR5) {
VAR13 = FUN3(VAR1, VAR7);
return (VAR13,VAR7);
}
else {
if(VAR8 == 0 || VAR1.VAR9[VAR7][VAR8 - 1].VAR15){
require(VAR1.VAR16[msg.sender] > 0);
if(VAR2 != 0) (VAR13,VAR14) = FUN4(VAR4);
VAR11 = FUN5(VAR1, VAR2, VAR3, VAR13,VAR14);
if(VAR11 == 0) return (false, VAR7);
VAR1.VAR9[VAR7].VAR10++;
VAR1.VAR9[VAR7][VAR8].VAR17 = VAR11;
VAR1.VAR9[VAR7][VAR8].VAR18 = VAR19 / 1 VAR20;
VAR1.VAR21[VAR19 / 1 VAR20].FUN6(VAR7);
}
else {
VAR8--;
VAR13 = FUN7(VAR1, VAR7, VAR8);
if(!VAR13) return (false,VAR7);
}
}
VAR1.VAR9[VAR7][VAR8].VAR22.FUN6(uint(msg.sender));
VAR1.VAR9[VAR7][VAR8].VAR23++;
}
else {
VAR8--;
}
if(VAR1.VAR9[VAR7][VAR8].VAR23 == VAR1.VAR9[VAR7][VAR8].VAR17) {
VAR1.VAR24[0][1] += VAR3;
VAR1.VAR24[VAR2][1] += VAR14;
VAR1.VAR9[VAR7][VAR8].VAR15 = true;
if(VAR2 == 0){
FUN8(VAR4, VAR3);
}
else {
require(VAR2.call.value(VAR3)(VAR4));
}
delete VAR1.VAR9[VAR7][VAR8].VAR25;
FUN9(VAR7, VAR2, VAR3, VAR6);
}
else {
if(VAR1.VAR9[VAR7][VAR8].VAR25.VAR10 == 0) VAR1.VAR9[VAR7][VAR8].VAR25 = VAR6;
uint VAR26 = FUN10(VAR1.VAR9[VAR7][VAR8].VAR17, VAR1.VAR9[VAR7][VAR8].VAR23);
FUN11(VAR7, msg.sender, VAR26);
}
return (true,VAR7);
}",RE,1
37381.sol,"function FUN1(WalletData storage VAR1, address VAR2, uint VAR3, bytes VAR4, bool VAR5, bytes VAR6) returns (bool,bytes32) {
bytes32 VAR7 = FUN2("""",VAR2,VAR3,VAR4);
uint VAR8 = VAR1.VAR9[VAR7].VAR10;
uint VAR11 = VAR1.VAR12;
if(msg.sender != address(this)){
bool VAR13;
uint VAR14;
if(!VAR5) {
VAR13 = FUN3(VAR1, VAR7);
return (VAR13,VAR7);
}
else {
if(VAR8 == 0 || VAR1.VAR9[VAR7][VAR8 - 1].VAR15){
require(VAR1.VAR16[msg.sender] > 0);
if(VAR2 != 0) (VAR13,VAR14) = FUN4(VAR4);
VAR11 = FUN5(VAR1, VAR2, VAR3, VAR13,VAR14);
if(VAR11 == 0) return (false, VAR7);
VAR1.VAR9[VAR7].VAR10++;
VAR1.VAR9[VAR7][VAR8].VAR17 = VAR11;
VAR1.VAR9[VAR7][VAR8].VAR18 = VAR19 / 1 VAR20;
VAR1.VAR21[VAR19 / 1 VAR20].FUN6(VAR7);
}
else {
VAR8--;
VAR13 = FUN7(VAR1, VAR7, VAR8);
if(!VAR13) return (false,VAR7);
}
}
VAR1.VAR9[VAR7][VAR8].VAR22.FUN6(uint(msg.sender));
VAR1.VAR9[VAR7][VAR8].VAR23++;
}
else {
VAR8--;
}
if(VAR1.VAR9[VAR7][VAR8].VAR23 == VAR1.VAR9[VAR7][VAR8].VAR17) {
VAR1.VAR24[0][1] += VAR3;
VAR1.VAR24[VAR2][1] += VAR14;
VAR1.VAR9[VAR7][VAR8].VAR15 = true;
if(VAR2 == 0){
FUN8(VAR4, VAR3);
}
else {
require(VAR2.call.value(VAR3)(VAR4));
}
delete VAR1.VAR9[VAR7][VAR8].VAR25;
FUN9(VAR7, VAR2, VAR3, VAR6);
}
else {
if(VAR1.VAR9[VAR7][VAR8].VAR25.VAR10 == 0) VAR1.VAR9[VAR7][VAR8].VAR25 = VAR6;
uint VAR26 = FUN10(VAR1.VAR9[VAR7][VAR8].VAR17, VAR1.VAR9[VAR7][VAR8].VAR23);
FUN11(VAR7, msg.sender, VAR26);
}
return (true,VAR7);
}",RE,1
37474.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external returns (bytes32 VAR4) {
require(msg.sender==VAR5);
require(VAR1.call.value(VAR2)(VAR3));
return 0;
}",RE,1
37485.sol,"function FUN1(bytes32 VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction storage VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (!VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) revert();
FUN3(VAR1);
}
}
function FUN4(bytes32 VAR1) public ownerExists(msg.sender) {
FUN5(VAR1, msg.sender);
FUN1(VAR1);
}
function FUN6(bytes32 VAR1, uint8[] VAR7, bytes32[] VAR8) public FUN7(VAR1, VAR7, VAR8) {
for (uint VAR9=0; VAR9<VAR7.VAR10; VAR9++) FUN5(VAR1, FUN8(VAR1, VAR7[VAR9], VAR8[VAR9], VAR8[VAR9 + VAR7.VAR10]));
FUN1(VAR1);
}",RE,1
37498.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner payable returns (bool){
return VAR1.call.value(VAR2)(VAR3);
}",RE,1
37499.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bool){
return VAR1.call.value(VAR2)(VAR3);
}",RE,1
37510.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bool){
return VAR1.call.value(VAR2)(VAR3);
}",RE,1
37518.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
37534.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
37596.sol,"function FUN1(){
if (VAR1) return;
if (VAR2.VAR3 < VAR4) return;
if (VAR5) return;
VAR1 = true;
VAR6 = VAR7;
uint256 VAR8 = VAR9;
VAR9 = 0;
VAR10 = this.VAR11 - VAR8;
if(!VAR12.call.value(VAR10)()) throw;
msg.sender.transfer(VAR8);
}",RE,1
37604.sol,"function FUN1(bytes32 VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (!VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) throw;
FUN3(VAR1);
}
}
function FUN4(bytes32 VAR1) public ownerExists(msg.sender) {
FUN5(VAR1, msg.sender);
FUN1(VAR1);
}
function FUN6(bytes32 VAR1, uint8[] VAR7, bytes32[] VAR8) public FUN7(VAR1, VAR7, VAR8) {
for (uint VAR9=0; VAR9<VAR7.VAR10; VAR9++) FUN5(VAR1, FUN8(VAR1, VAR7[VAR9], VAR8[VAR9], VAR8[VAR9 + VAR7.VAR10]));
FUN1(VAR1);
}",RE,1
37614.sol,"function FUN1(){
if (VAR1) return;
if (VAR2.VAR3 < VAR4) return;
if (VAR5) return;
VAR1 = true;
VAR6 = VAR7;
uint256 VAR8 = VAR9;
VAR9 = 0;
VAR10 = this.VAR11 - VAR8;
if(!VAR12.call.value(VAR10)()) throw;
msg.sender.transfer(VAR8);
}",RE,1
37617.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
3767.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0 && VAR6[msg.sender] == false && VAR6[VAR1] == false && VAR7 > VAR8[msg.sender] && VAR7 > VAR8[VAR1]);
if (FUN1(VAR1)) {
require(VAR9[msg.sender] >= VAR2);
VAR9[msg.sender] = VAR9[msg.sender].FUN2(VAR2);
VAR9[VAR1] = VAR9[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN5(VAR1, VAR2, VAR3);
}
}",RE,1
37676.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) only_owner {
if (!VAR1.call.value(VAR2)(VAR3)) throw;
FUN2(VAR1, VAR2, VAR3);
}",RE,1
37690.sol,"function FUN1(uint VAR1) payable {
if (VAR2[0][msg.sender] < VAR1) throw;
VAR2[0][msg.sender] = FUN2(VAR2[0][msg.sender], VAR1);
if (!msg.sender.call.value(VAR1)()) throw;
FUN3(0, msg.sender, VAR1, VAR2[0][msg.sender]);
}",RE,1
37768.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
37794.sol,"function FUN1(uint VAR1) {
if (VAR2[0][msg.sender] < VAR1) throw;
VAR2[0][msg.sender] = FUN2(VAR2[0][msg.sender], VAR1);
if (!msg.sender.call.value(VAR1)()) throw;
FUN3(0, msg.sender, VAR1, VAR2[0][msg.sender]);
}",RE,1
37836.sol,"function FUN1() onlyOwner {
require(VAR1.call.value(this.VAR2)(0));
FUN2(VAR1,this.VAR2);
}
}",RE,1
37856.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
37859.sol,"function FUN1(bytes32 VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (!VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) throw;
FUN3(VAR1);
}
}
function FUN4(bytes32 VAR1) public ownerExists(msg.sender) {
FUN5(VAR1, msg.sender);
FUN1(VAR1);
}
function FUN6(bytes32 VAR1, uint8[] VAR7, bytes32[] VAR8) public FUN7(VAR1, VAR7, VAR8) {
for (uint VAR9=0; VAR9<VAR7.VAR10; VAR9++) FUN5(VAR1, FUN8(VAR1, VAR7[VAR9], VAR8[VAR9], VAR8[VAR9 + VAR7.VAR10]));
FUN1(VAR1);
}",RE,1
3786.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction storage VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) emit FUN3(VAR1);
else {
emit FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
emit FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
37869.sol,"function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}",RE,1
37881.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
37891.sol,"function FUN1() {
uint VAR1 = VAR2[msg.sender];
require(VAR1 > 0);
VAR2[msg.sender] = 0;
bool VAR3 = msg.sender.call.value(VAR1)();
require(VAR3);
}
}",RE,1
37925.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) VAR4 returns(bool VAR5) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
VAR5 =VAR1.call.value(VAR2)(VAR3);
}
else {
bytes32 VAR6 = FUN4(msg.VAR7, VAR8.VAR9);
if (!FUN5(VAR6) && VAR10[VAR6].VAR11 == 0) {
VAR10[VAR6].VAR11 = VAR1;
VAR10[VAR6].value = VAR2;
VAR10[VAR6].VAR7 = VAR3;
FUN6(VAR6, msg.sender, VAR2, VAR1, VAR3);
}
}
}
function FUN5(bytes32 VAR12) FUN7(VAR12) returns (bool) {
if (VAR10[VAR12].VAR11 != 0) {
VAR10[VAR12].VAR11.call.value(VAR10[VAR12].value)(VAR10[VAR12].VAR7);
FUN8(msg.sender, VAR12, VAR10[VAR12].value, VAR10[VAR12].VAR11, VAR10[VAR12].VAR7);
delete VAR10[VAR12];
return true;
}
}",RE,1
3800.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
if(FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) revert();
VAR6[msg.sender] = FUN3(FUN2(msg.sender), VAR2);
VAR6[VAR1] = FUN4(FUN2(VAR1), VAR2);
assert(VAR1.call.value(0)(bytes4(FUN5(VAR4)), msg.sender, VAR2, VAR3));
emit Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN6(VAR1, VAR2, VAR3);
}
}",RE,1
38001.sol,"function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}",RE,1
38020.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
38027.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN1(uint VAR1) public notExecuted(VAR1) {
Transaction VAR2 = VAR3[VAR1];
bool confirmed = FUN2(VAR1);
if (confirmed || VAR2.VAR6.VAR7 == 0 && FUN5(VAR2.value)) {
VAR2.VAR4 = true;
if (!confirmed) VAR8 += VAR2.value;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
if (!confirmed) VAR8 -= VAR2.value;
}
}
}",RE,1
38030.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN1(uint VAR1) public notExecuted(VAR1) {
Transaction VAR2 = VAR3[VAR1];
bool confirmed = FUN2(VAR1);
if (confirmed || VAR2.VAR6.VAR7 == 0 && FUN5(VAR2.value)) {
VAR2.VAR4 = true;
if (!confirmed) VAR8 += VAR2.value;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
if (!confirmed) VAR8 -= VAR2.value;
}
}
}",RE,1
38050.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
38057.sol,"function FUN1(uint VAR1) {
require(VAR2[0][msg.sender] >= VAR1);
VAR2[0][msg.sender] = FUN2(VAR2[0][msg.sender], VAR1);
if (!msg.sender.call.value(VAR1)()) {
revert();
}
FUN3(0, msg.sender, VAR1, VAR2[0][msg.sender]);
}",RE,1
38109.sol,"function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}",RE,1
38110.sol,"function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}",RE,1
38111.sol,"function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}",RE,1
38131.sol,"function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}",RE,1
38231.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
38282.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if ((VAR3.VAR5 == 0 && FUN2(VAR2)) || VAR6 == 1) {
address VAR7;
if (VAR1 == 0) {
VAR7 = FUN3(VAR2, VAR3);
}
else {
require(VAR1.call.value(VAR2)(VAR3));
}
FUN4(msg.sender, VAR2, VAR1, VAR3, VAR7);
}
else {
VAR4 = FUN5(msg.VAR8, VAR9.VAR10);
if (VAR11[VAR4].VAR12 == 0 && VAR11[VAR4].value == 0 && VAR11[VAR4].VAR8.VAR5 == 0) {
VAR11[VAR4].VAR12 = VAR1;
VAR11[VAR4].value = VAR2;
VAR11[VAR4].VAR8 = VAR3;
}
if (!FUN6(VAR4)) {
FUN7(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
}
function FUN6(bytes32 VAR13) FUN8(VAR13) returns (bool VAR14) {
if (VAR11[VAR13].VAR12 != 0 || VAR11[VAR13].value != 0 || VAR11[VAR13].VAR8.VAR5 != 0) {
address VAR7;
if (VAR11[VAR13].VAR12 == 0) {
VAR7 = FUN3(VAR11[VAR13].value, VAR11[VAR13].VAR8);
}
else {
require(VAR11[VAR13].VAR12.call.value(VAR11[VAR13].value)(VAR11[VAR13].VAR8));
}
FUN9(msg.sender, VAR13, VAR11[VAR13].value, VAR11[VAR13].VAR12, VAR11[VAR13].VAR8, VAR7);
delete VAR11[VAR13];
return true;
}
}",RE,1
38321.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if ((VAR3.VAR5 == 0 && FUN2(VAR2)) || VAR6 == 1) {
address VAR7;
if (VAR1 == 0) {
VAR7 = FUN3(VAR2, VAR3);
}
else {
if (!VAR1.call.value(VAR2)(VAR3)) throw;
}
FUN4(msg.sender, VAR2, VAR1, VAR3, VAR7);
}
else {
VAR4 = FUN5(msg.VAR8, VAR9.VAR10);
if (VAR11[VAR4].VAR12 == 0 && VAR11[VAR4].value == 0 && VAR11[VAR4].VAR8.VAR5 == 0) {
VAR11[VAR4].VAR12 = VAR1;
VAR11[VAR4].value = VAR2;
VAR11[VAR4].VAR8 = VAR3;
}
if (!FUN6(VAR4)) {
FUN7(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
}
function FUN6(bytes32 VAR13) FUN8(VAR13) returns (bool VAR14) {
if (VAR11[VAR13].VAR12 != 0 || VAR11[VAR13].value != 0 || VAR11[VAR13].VAR8.VAR5 != 0) {
address VAR7;
if (VAR11[VAR13].VAR12 == 0) {
VAR7 = FUN3(VAR11[VAR13].value, VAR11[VAR13].VAR8);
}
else {
if (!VAR11[VAR13].VAR12.call.value(VAR11[VAR13].value)(VAR11[VAR13].VAR8)) throw;
}
FUN9(msg.sender, VAR13, VAR11[VAR13].value, VAR11[VAR13].VAR12, VAR11[VAR13].VAR8, VAR7);
delete VAR11[VAR13];
return true;
}
}",RE,1
38322.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if ((VAR3.VAR5 == 0 && FUN2(VAR2)) || VAR6 == 1) {
address VAR7;
if (VAR1 == 0) {
VAR7 = FUN3(VAR2, VAR3);
}
else {
if (!VAR1.call.value(VAR2)(VAR3)) throw;
}
FUN4(msg.sender, VAR2, VAR1, VAR3, VAR7);
}
else {
VAR4 = FUN5(msg.VAR8, VAR9.VAR10);
if (VAR11[VAR4].VAR12 == 0 && VAR11[VAR4].value == 0 && VAR11[VAR4].VAR8.VAR5 == 0) {
VAR11[VAR4].VAR12 = VAR1;
VAR11[VAR4].value = VAR2;
VAR11[VAR4].VAR8 = VAR3;
}
if (!FUN6(VAR4)) {
FUN7(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
}
function FUN6(bytes32 VAR13) FUN8(VAR13) returns (bool VAR14) {
if (VAR11[VAR13].VAR12 != 0 || VAR11[VAR13].value != 0 || VAR11[VAR13].VAR8.VAR5 != 0) {
address VAR7;
if (VAR11[VAR13].VAR12 == 0) {
VAR7 = FUN3(VAR11[VAR13].value, VAR11[VAR13].VAR8);
}
else {
if (!VAR11[VAR13].VAR12.call.value(VAR11[VAR13].value)(VAR11[VAR13].VAR8)) throw;
}
FUN9(msg.sender, VAR13, VAR11[VAR13].value, VAR11[VAR13].VAR12, VAR11[VAR13].VAR8, VAR7);
delete VAR11[VAR13];
return true;
}
}",RE,1
38344.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if ((VAR3.VAR5 == 0 && FUN2(VAR2)) || VAR6 == 1) {
address VAR7;
if (VAR1 == 0) {
VAR7 = FUN3(VAR2, VAR3);
}
else {
if (!VAR1.call.value(VAR2)(VAR3)) throw;
}
FUN4(msg.sender, VAR2, VAR1, VAR3, VAR7);
}
else {
VAR4 = FUN5(msg.VAR8, VAR9.VAR10);
if (VAR11[VAR4].VAR12 == 0 && VAR11[VAR4].value == 0 && VAR11[VAR4].VAR8.VAR5 == 0) {
VAR11[VAR4].VAR12 = VAR1;
VAR11[VAR4].value = VAR2;
VAR11[VAR4].VAR8 = VAR3;
}
if (!FUN6(VAR4)) {
FUN7(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
}
function FUN6(bytes32 VAR13) FUN8(VAR13) returns (bool VAR14) {
if (VAR11[VAR13].VAR12 != 0 || VAR11[VAR13].value != 0 || VAR11[VAR13].VAR8.VAR5 != 0) {
address VAR7;
if (VAR11[VAR13].VAR12 == 0) {
VAR7 = FUN3(VAR11[VAR13].value, VAR11[VAR13].VAR8);
}
else {
if (!VAR11[VAR13].VAR12.call.value(VAR11[VAR13].value)(VAR11[VAR13].VAR8)) throw;
}
FUN9(msg.sender, VAR13, VAR11[VAR13].value, VAR11[VAR13].VAR12, VAR11[VAR13].VAR8, VAR7);
delete VAR11[VAR13];
return true;
}
}",RE,1
38371.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
38372.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
38389.sol,"function FUN1(){
if (VAR1) return;
if (VAR2 < VAR3) return;
if (VAR4) return;
VAR1 = true;
VAR5 = VAR2;
uint256 VAR6 = VAR7;
VAR7 = 0;
VAR8 = this.VAR9 - VAR6;
if(!VAR10.call.value(VAR8)()) throw;
msg.sender.transfer(VAR6);
}",RE,1
38393.sol,"function FUN1(){
if (VAR1) return;
if (VAR2 < VAR3) return;
if (VAR4) return;
VAR1 = true;
VAR5 = VAR2;
uint256 VAR6 = VAR7;
VAR7 = 0;
VAR8 = this.VAR9 - VAR6;
if(!VAR10.call.value(VAR8)()) throw;
msg.sender.transfer(VAR6);
}",RE,1
38420.sol,"function FUN1(){
if (VAR1) return;
if (VAR2) return;
if (VAR3 < VAR4) return;
if (VAR5 == 0x0) throw;
VAR1 = true;
VAR6 = VAR3;
if(!VAR5.call.value(this.VAR7 - VAR8)()) throw;
msg.sender.transfer(VAR8);
}",RE,1
38430.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
38435.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
38493.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
38517.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
38518.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN1(uint VAR1) public notExecuted(VAR1) {
Transaction VAR2 = VAR3[VAR1];
bool confirmed = FUN2(VAR1);
if (confirmed || VAR2.VAR6.VAR7 == 0 && FUN5(VAR2.value)) {
VAR2.VAR4 = true;
if (!confirmed) VAR8 += VAR2.value;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
if (!confirmed) VAR8 -= VAR2.value;
}
}
}",RE,1
38524.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
if (VAR2.VAR4.call.value(VAR2.value)(VAR2.VAR5)) {
VAR2.VAR6 = true;
FUN3(VAR1);
}
else {
FUN4(VAR1);
VAR2.VAR6 = false;
}
}
}
}
contract VAR7 {
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR8[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
38526.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
if (VAR2.VAR4.call.value(VAR2.value)(VAR2.VAR5)) {
VAR2.VAR6 = true;
FUN3(VAR1);
}
else {
FUN4(VAR1);
VAR2.VAR6 = false;
}
}
}
}
contract VAR7 {
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR8[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
38529.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
38543.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
require(VAR1.call.value(VAR2)(VAR3));
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
require(VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5));
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}",RE,1
38553.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
38554.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
38558.sol,"function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}",RE,1
38559.sol,"function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}",RE,1
38571.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
38572.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
38573.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
38575.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
38637.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
38638.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
38639.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
38651.sol,"function FUN1(address VAR1, uint VAR2) {
bytes32 VAR3 = FUN2(VAR1, VAR2, msg.sender);
uint VAR4 = VAR5[VAR3];
delete VAR5[VAR3];
if (!msg.sender.call.value(VAR4)()) throw;
FUN3(VAR3,VAR1,VAR2,msg.sender);
}",RE,1
38654.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
38657.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
38719.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
38811.sol,"function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}",RE,1
38818.sol,"function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}",RE,1
38823.sol,"function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}",RE,1
38827.sol,"function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}",RE,1
38828.sol,"function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}",RE,1
38872.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
require(VAR1.call.value(VAR2)(VAR3));
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
require(VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5));
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}",RE,1
38873.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyOwner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
if (!VAR1.call.value(VAR2)(VAR3)) {
throw;
}
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
if (!VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5)) {
throw;
}
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}",RE,1
38876.sol,"function FUN1() onlyOwner {
if (VAR1.VAR2 < VAR3) throw;
if (!VAR4.call.value(this.VAR5)()) throw;
}",RE,1
38888.sol,"function FUN1() onlyOwner {
if (!VAR1.call.value(this.VAR2)()) throw;
}",RE,1
38904.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
38922.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
38934.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
38957.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
38958.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5);
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}",RE,1
38959.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5);
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}",RE,1
38962.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
38965.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
38967.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
38970.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
38971.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
38972.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
38983.sol,"function FUN1() onlyOwner {
if (VAR1.VAR2 < VAR3) throw;
if (!VAR4.call.value(this.VAR5)()) throw;
}",RE,1
39027.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (VAR1 == address(VAR5)) throw;
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
if(!VAR1.call.value(VAR2)(VAR3)) return 0;
}
VAR4 = FUN4(msg.VAR6, VAR7.VAR8);
if (!FUN5(VAR4) && VAR9[VAR4].VAR10 == 0) {
VAR9[VAR4].VAR10 = VAR1;
VAR9[VAR4].value = VAR2;
VAR9[VAR4].VAR6 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR11) FUN7(VAR11) returns (bool) {
if (VAR9[VAR11].VAR10 != 0) {
if (!VAR9[VAR11].VAR10.call.value(VAR9[VAR11].value)(VAR9[VAR11].VAR6)) throw;
FUN8(msg.sender, VAR11, VAR9[VAR11].value, VAR9[VAR11].VAR10, VAR9[VAR11].VAR6);
delete VAR9[VAR11];
return true;
}
}",RE,1
39028.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (VAR1 == address(VAR5)) throw;
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
if(!VAR1.call.value(VAR2)(VAR3)) return 0;
}
VAR4 = FUN4(msg.VAR6, VAR7.VAR8);
if (!FUN5(VAR4) && VAR9[VAR4].VAR10 == 0) {
VAR9[VAR4].VAR10 = VAR1;
VAR9[VAR4].value = VAR2;
VAR9[VAR4].VAR6 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR11) FUN7(VAR11) returns (bool) {
if (VAR9[VAR11].VAR10 != 0) {
if (!VAR9[VAR11].VAR10.call.value(VAR9[VAR11].value)(VAR9[VAR11].VAR6)) throw;
FUN8(msg.sender, VAR11, VAR9[VAR11].value, VAR9[VAR11].VAR10, VAR9[VAR11].VAR6);
delete VAR9[VAR11];
return true;
}
}",RE,1
39032.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) onlyOwner {
VAR1.call.value(VAR2)(VAR3);
}",RE,1
39087.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if ((VAR3.VAR5 == 0 && FUN2(VAR2)) || VAR6 == 1) {
address VAR7;
if (VAR1 == 0) {
VAR7 = FUN3(VAR2, VAR3);
}
else {
if (!VAR1.call.value(VAR2)(VAR3)) throw;
}
FUN4(msg.sender, VAR2, VAR1, VAR3, VAR7);
}
else {
VAR4 = FUN5(msg.VAR8, VAR9.VAR10);
if (VAR11[VAR4].VAR12 == 0 && VAR11[VAR4].value == 0 && VAR11[VAR4].VAR8.VAR5 == 0) {
VAR11[VAR4].VAR12 = VAR1;
VAR11[VAR4].value = VAR2;
VAR11[VAR4].VAR8 = VAR3;
}
if (!FUN6(VAR4)) {
FUN7(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
}
function FUN6(bytes32 VAR13) FUN8(VAR13) returns (bool VAR14) {
if (VAR11[VAR13].VAR12 != 0 || VAR11[VAR13].value != 0 || VAR11[VAR13].VAR8.VAR5 != 0) {
address VAR7;
if (VAR11[VAR13].VAR12 == 0) {
VAR7 = FUN3(VAR11[VAR13].value, VAR11[VAR13].VAR8);
}
else {
if (!VAR11[VAR13].VAR12.call.value(VAR11[VAR13].value)(VAR11[VAR13].VAR8)) throw;
}
FUN9(msg.sender, VAR13, VAR11[VAR13].value, VAR11[VAR13].VAR12, VAR11[VAR13].VAR8, VAR7);
delete VAR11[VAR13];
return true;
}
}",RE,1
39127.sol,"function FUN1(uint256 VAR1, bytes VAR2) onlyCongressMembers {
Proposal VAR3 = VAR4[VAR1];
if (VAR3.VAR5 != VAR6.VAR7) throw;
VAR3.VAR5 = VAR6.VAR8;
if (!VAR3.VAR9.call.value(VAR3.VAR10 * 1 VAR11)(VAR2)) {
throw;
}
FUN2(VAR1);
}
}",RE,1
39139.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
39140.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
39146.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
39151.sol,"function FUN1(uint VAR1) {
if (VAR2[0][msg.sender] < VAR1) throw;
VAR2[0][msg.sender] = FUN2(VAR2[0][msg.sender], VAR1);
if (!msg.sender.call.value(VAR1)()) throw;
FUN3(0, msg.sender, VAR1, VAR2[0][msg.sender]);
}",RE,1
39173.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
39176.sol,"function FUN1(uint256 VAR1, bytes VAR2) onlyCongressMembers {
Proposal VAR3 = VAR4[VAR1];
if (VAR3.VAR5 != VAR6.VAR7) throw;
VAR3.VAR5 = VAR6.VAR8;
if (!VAR3.VAR9.call.value(VAR3.VAR10 * 1 VAR11)(VAR2)) {
throw;
}
FUN2(VAR1);
}
}",RE,1
39178.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
39199.sol,"function FUN1 (address VAR1, uint VAR2, bytes VAR3) {
if (!VAR4) throw;
if (msg.sender != VAR5) throw;
if (!VAR1.call.value (VAR2)(VAR3)) throw;
}
}
contract VAR6 {
bool public VAR4;
}",RE,1
39207.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
39248.sol,"function FUN1(uint256 VAR1, bytes VAR2) onlyCongressMembers {
Proposal VAR3 = VAR4[VAR1];
if (VAR3.VAR5 != VAR6.VAR7) throw;
VAR3.VAR5 = VAR6.VAR8;
if (!VAR3.VAR9.call.value(VAR3.VAR10 * 1 VAR11)(VAR2)) {
throw;
}
FUN2(VAR1);
}
}",RE,1
39268.sol,"function FUN1() public {
if (msg.sender == VAR1[0].VAR2 && VAR3 == 0) {
if (!VAR1[0].VAR2.call.value(this.VAR4)()) {
throw;
}
}
}
function FUN2(uint8 VAR5, address VAR6, bytes4 VAR7, uint VAR8, bytes32[] VAR9) public payable returns (int) {
if (VAR10) {
throw;
}
if (VAR11) {
VAR10 = true;
if (!msg.sender.call.value(msg.value)()) {
throw;
}
VAR10 = false;
return VAR12;
}
if (msg.value < VAR13) {
VAR10 = true;
if (!msg.sender.call.value(msg.value)()) {
throw;
}
VAR10 = false;
return VAR14;
}
else {
uint64 VAR15 = VAR16;
VAR16++;
VAR3++;
bytes32 VAR17 = FUN3(VAR5, VAR9);
VAR1[VAR15].VAR2 = msg.sender;
VAR1[VAR15].VAR18 = msg.value;
VAR1[VAR15].VAR6 = VAR6;
VAR1[VAR15].VAR7 = VAR7;
VAR1[VAR15].VAR17 = VAR17;
FUN4(VAR15, VAR5, msg.sender, msg.value, VAR6, VAR17, VAR8, VAR9);
return VAR15;
}
}
function FUN2(uint8 VAR5, address VAR6, bytes4 VAR7, uint VAR8, bytes32[] VAR9) public payable returns (int) {
if (VAR10) {
throw;
}
if (VAR11) {
VAR10 = true;
if (!msg.sender.call.value(msg.value)()) {
throw;
}
VAR10 = false;
return VAR12;
}
if (msg.value < VAR13) {
VAR10 = true;
if (!msg.sender.call.value(msg.value)()) {
throw;
}
VAR10 = false;
return VAR14;
}
else {
uint64 VAR15 = VAR16;
VAR16++;
VAR3++;
bytes32 VAR17 = FUN3(VAR5, VAR9);
VAR1[VAR15].VAR2 = msg.sender;
VAR1[VAR15].VAR18 = msg.value;
VAR1[VAR15].VAR6 = VAR6;
VAR1[VAR15].VAR7 = VAR7;
VAR1[VAR15].VAR17 = VAR17;
FUN4(VAR15, VAR5, msg.sender, msg.value, VAR6, VAR17, VAR8, VAR9);
return VAR15;
}
}
function FUN5(uint64 VAR15) public returns (int) {
if (VAR10) {
throw;
}
if (VAR11) {
return 0;
}
uint VAR18 = VAR1[VAR15].VAR18;
if (VAR1[VAR15].VAR2 == msg.sender && VAR18 >= VAR19) {
VAR1[VAR15].VAR18 = VAR20;
VAR10 = true;
if (!msg.sender.call.value(VAR18 - VAR19)()) {
throw;
}
VAR10 = false;
FUN6(VAR15, msg.sender, VAR1[VAR15].VAR2, VAR1[VAR15].VAR18, 1);
return VAR21;
}
else {
FUN6(VAR15, msg.sender, VAR1[VAR15].VAR2, VAR18, -1);
return VAR14;
}
}
}",RE,1
39290.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
39314.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
39315.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5);
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}",RE,1
39316.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5);
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}",RE,1
39319.sol,"function FUN1( uint256 VAR1, bytes VAR2 ) onlyMembers {
Proposal VAR3 = VAR4[VAR1];
if (VAR5 < VAR3.VAR6 || VAR3.VAR7 || VAR3.VAR8 != FUN2(VAR3.VAR9, VAR3.VAR10, VAR2) || VAR3.VAR11 < VAR12) throw;
if (VAR3.VAR13 > VAR14) {
VAR3.VAR7 = true;
if (!VAR3.VAR9.call.value(VAR3.VAR10)(VAR2)) throw;
VAR3.VAR15 = true;
}
else {
VAR3.VAR15 = false;
}
FUN3(VAR1, VAR3.VAR11, VAR3.VAR15);
}
}",RE,1
39326.sol,"function FUN1( uint256 VAR1, bytes VAR2 ) onlyMembers {
Proposal VAR3 = VAR4[VAR1];
if (VAR5 < VAR3.VAR6 || VAR3.VAR7 || VAR3.VAR8 != FUN2(VAR3.VAR9, VAR3.VAR10, VAR2) || VAR3.VAR11 < VAR12) throw;
if (VAR3.VAR13 > VAR14) {
VAR3.VAR7 = true;
if (!VAR3.VAR9.call.value(VAR3.VAR10)(VAR2)) throw;
VAR3.VAR15 = true;
}
else {
VAR3.VAR15 = false;
}
FUN3(VAR1, VAR3.VAR11, VAR3.VAR15);
}
}
library VAR16 {",RE,1
39327.sol,"function FUN1( uint256 VAR1, bytes VAR2 ) onlyMembers {
Proposal VAR3 = VAR4[VAR1];
if (VAR5 < VAR3.VAR6 || VAR3.VAR7 || VAR3.VAR8 != FUN2(VAR3.VAR9, VAR3.VAR10, VAR2) || VAR3.VAR11 < VAR12) throw;
if (VAR3.VAR13 > VAR14) {
VAR3.VAR7 = true;
if (!VAR3.VAR9.call.value(VAR3.VAR10)(VAR2)) throw;
VAR3.VAR15 = true;
}
else {
VAR3.VAR15 = false;
}
FUN3(VAR1, VAR3.VAR11, VAR3.VAR15);
}
}
library VAR16 {",RE,1
39341.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) onlyOwner {
VAR1.call.value(VAR2)(VAR3);
}
}
contract VAR4 {",RE,1
39358.sol,"function FUN1(address VAR1, uint value, bytes VAR2) onlyOwner {
if (!VAR1.call.value(value)(VAR2)) {
throw;
}
FUN2(VAR1, value, VAR2);
}
}
contract VAR3 {
uint public VAR4;
Proxy public VAR5;
address public VAR6;
address public VAR7;
uint public VAR8;
address public VAR9;
address public VAR10;
uint public VAR11;
address public VAR12;
uint public VAR13;
uint public VAR14;
uint public VAR15;
event FUN3(string VAR16, address VAR17);
modifier FUN4() {
if (msg.sender == VAR6) VAR18;
}
modifier FUN5() {
if (msg.sender == VAR9) VAR18;
}
function FUN1(address VAR1, uint value, bytes VAR2) VAR19 {
VAR5.FUN1(VAR1, value, VAR2);
}",RE,1
39375.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN1(uint VAR1) public notExecuted(VAR1) {
Transaction VAR2 = VAR3[VAR1];
bool confirmed = FUN2(VAR1);
if (confirmed || VAR2.VAR6.VAR7 == 0 && FUN5(VAR2.value)) {
VAR2.VAR4 = true;
if (!confirmed) VAR8 += VAR2.value;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
if (!confirmed) VAR8 -= VAR2.value;
}
}
}",RE,1
39470.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if ((VAR3.VAR5 == 0 && FUN2(VAR2)) || VAR6 == 1) {
address VAR7;
if (VAR1 == 0) {
VAR7 = FUN3(VAR2, VAR3);
}
else {
if (!VAR1.call.value(VAR2)(VAR3)) throw;
}
FUN4(msg.sender, VAR2, VAR1, VAR3, VAR7);
}
else {
VAR4 = FUN5(msg.VAR8, VAR9.VAR10);
if (VAR11[VAR4].VAR12 == 0 && VAR11[VAR4].value == 0 && VAR11[VAR4].VAR8.VAR5 == 0) {
VAR11[VAR4].VAR12 = VAR1;
VAR11[VAR4].value = VAR2;
VAR11[VAR4].VAR8 = VAR3;
}
if (!FUN6(VAR4)) {
FUN7(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
}
function FUN6(bytes32 VAR13) FUN8(VAR13) returns (bool VAR14) {
if (VAR11[VAR13].VAR12 != 0 || VAR11[VAR13].value != 0 || VAR11[VAR13].VAR8.VAR5 != 0) {
address VAR7;
if (VAR11[VAR13].VAR12 == 0) {
VAR7 = FUN3(VAR11[VAR13].value, VAR11[VAR13].VAR8);
}
else {
if (!VAR11[VAR13].VAR12.call.value(VAR11[VAR13].value)(VAR11[VAR13].VAR8)) throw;
}
FUN9(msg.sender, VAR13, VAR11[VAR13].value, VAR11[VAR13].VAR12, VAR11[VAR13].VAR8, VAR7);
delete VAR11[VAR13];
return true;
}
}",RE,1
39473.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN1(uint VAR1) public notExecuted(VAR1) {
Transaction VAR2 = VAR3[VAR1];
bool confirmed = FUN2(VAR1);
if (confirmed || VAR2.VAR6.VAR7 == 0 && FUN5(VAR2.value)) {
VAR2.VAR4 = true;
if (!confirmed) VAR8 += VAR2.value;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
if (!confirmed) VAR8 -= VAR2.value;
}
}
}",RE,1
39495.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
39498.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5);
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}",RE,1
39500.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
39506.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if ((VAR3.VAR5 == 0 && FUN2(VAR2)) || VAR6 == 1) {
address VAR7;
if (VAR1 == 0) {
VAR7 = FUN3(VAR2, VAR3);
}
else {
if (!VAR1.call.value(VAR2)(VAR3)) throw;
}
FUN4(msg.sender, VAR2, VAR1, VAR3, VAR7);
}
else {
VAR4 = FUN5(msg.VAR8, VAR9.VAR10);
if (VAR11[VAR4].VAR12 == 0 && VAR11[VAR4].value == 0 && VAR11[VAR4].VAR8.VAR5 == 0) {
VAR11[VAR4].VAR12 = VAR1;
VAR11[VAR4].value = VAR2;
VAR11[VAR4].VAR8 = VAR3;
}
if (!FUN6(VAR4)) {
FUN7(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
}
function FUN6(bytes32 VAR13) FUN8(VAR13) returns (bool VAR14) {
if (VAR11[VAR13].VAR12 != 0 || VAR11[VAR13].value != 0 || VAR11[VAR13].VAR8.VAR5 != 0) {
address VAR7;
if (VAR11[VAR13].VAR12 == 0) {
VAR7 = FUN3(VAR11[VAR13].value, VAR11[VAR13].VAR8);
}
else {
if (!VAR11[VAR13].VAR12.call.value(VAR11[VAR13].value)(VAR11[VAR13].VAR8)) throw;
}
FUN9(msg.sender, VAR13, VAR11[VAR13].value, VAR11[VAR13].VAR12, VAR11[VAR13].VAR8, VAR7);
delete VAR11[VAR13];
return true;
}
}",RE,1
39509.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5);
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}",RE,1
39543.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if ((VAR3.VAR5 == 0 && FUN2(VAR2)) || VAR6 == 1) {
address VAR7;
if (VAR1 == 0) {
VAR7 = FUN3(VAR2, VAR3);
}
else {
if (!VAR1.call.value(VAR2)(VAR3)) throw;
}
FUN4(msg.sender, VAR2, VAR1, VAR3, VAR7);
}
else {
VAR4 = FUN5(msg.VAR8, VAR9.VAR10);
if (VAR11[VAR4].VAR12 == 0 && VAR11[VAR4].value == 0 && VAR11[VAR4].VAR8.VAR5 == 0) {
VAR11[VAR4].VAR12 = VAR1;
VAR11[VAR4].value = VAR2;
VAR11[VAR4].VAR8 = VAR3;
}
if (!FUN6(VAR4)) {
FUN7(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
}
function FUN6(bytes32 VAR13) FUN8(VAR13) returns (bool VAR14) {
if (VAR11[VAR13].VAR12 != 0 || VAR11[VAR13].value != 0 || VAR11[VAR13].VAR8.VAR5 != 0) {
address VAR7;
if (VAR11[VAR13].VAR12 == 0) {
VAR7 = FUN3(VAR11[VAR13].value, VAR11[VAR13].VAR8);
}
else {
if (!VAR11[VAR13].VAR12.call.value(VAR11[VAR13].value)(VAR11[VAR13].VAR8)) throw;
}
FUN9(msg.sender, VAR13, VAR11[VAR13].value, VAR11[VAR13].VAR12, VAR11[VAR13].VAR8, VAR7);
delete VAR11[VAR13];
return true;
}
}",RE,1
39557.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5);
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}",RE,1
39644.sol,"function FUN1(address VAR1, address VAR2) {
if (msg.sender != VAR1 && msg.sender != VAR2) {
throw;
}
if(!FUN2(VAR1, VAR2)) {
throw;
}
uint32 VAR3 = VAR4[VAR1][VAR2];
delete VAR4[VAR1][VAR2];
if (!VAR2.call.value(VAR3).FUN3(23000)()) {
throw;
}
FUN4(VAR1, VAR2, VAR3);
}",RE,1
39662.sol,"function FUN1(uint VAR1){
if (msg.sender != VAR2 && msg.sender != VAR3) return ;
var VAR4 = FUN2(VAR1);
uint VAR5 = VAR6[VAR1].VAR7.FUN3() ;
if(VAR5> VAR4){
uint VAR8 = VAR5 - VAR4;
FUN4(VAR8,VAR1);
}
if(!VAR6[VAR1].VAR7.call.value(VAR5)()) throw;
}",RE,1
39664.sol,"function FUN1() FUN2(VAR1) {
FUN3();
if (VAR2 > VAR3) {
if (!VAR1.call.value(VAR2 - VAR3)()) throw;
}
FUN4(VAR4);
}
function FUN5() onlyOwner {
if (VAR5 > VAR6) throw;
if (VAR2 <= VAR3) throw;
uint256 VAR7 = VAR2 - VAR3;
if (!VAR1.call.value(VAR7)()) throw;
VAR2 -= VAR7;
VAR8 = VAR6 + VAR9;
VAR5 = VAR8 + VAR9;
}
}",RE,1
39682.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN1(uint VAR1) public notExecuted(VAR1) {
Transaction VAR2 = VAR3[VAR1];
bool confirmed = FUN2(VAR1);
if (confirmed || VAR2.VAR6.VAR7 == 0 && FUN5(VAR2.value)) {
VAR2.VAR4 = true;
if (!confirmed) VAR8 += VAR2.value;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
if (!confirmed) VAR8 -= VAR2.value;
}
}
}",RE,1
39706.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
bool VAR5 = VAR1.call.value(VAR2)(VAR3);
return 0;
}
VAR4 = FUN4(msg.VAR6, VAR7.VAR8);
if (!FUN5(VAR4) && VAR9[VAR4].VAR10 == 0) {
VAR9[VAR4].VAR10 = VAR1;
VAR9[VAR4].value = VAR2;
VAR9[VAR4].VAR6 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR11) FUN7(VAR11) returns (bool) {
if (VAR9[VAR11].VAR10 != 0) {
bool VAR5 = VAR9[VAR11].VAR10.call.value(VAR9[VAR11].value)(VAR9[VAR11].VAR6);
FUN8(msg.sender, VAR11, VAR9[VAR11].value, VAR9[VAR11].VAR10, VAR9[VAR11].VAR6);
delete VAR9[VAR11];
return true;
}
}",RE,1
39711.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
39721.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) VAR4 returns(bool VAR5) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
VAR5 =VAR1.call.value(VAR2)(VAR3);
}
else {
bytes32 VAR6 = FUN4(msg.VAR7, VAR8.VAR9);
if (!FUN5(VAR6) && VAR10[VAR6].VAR11 == 0) {
VAR10[VAR6].VAR11 = VAR1;
VAR10[VAR6].value = VAR2;
VAR10[VAR6].VAR7 = VAR3;
FUN6(VAR6, msg.sender, VAR2, VAR1, VAR3);
}
}
}
function FUN5(bytes32 VAR12) FUN7(VAR12) returns (bool) {
if (VAR10[VAR12].VAR11 != 0) {
VAR10[VAR12].VAR11.call.value(VAR10[VAR12].value)(VAR10[VAR12].VAR7);
FUN8(msg.sender, VAR12, VAR10[VAR12].value, VAR10[VAR12].VAR11, VAR10[VAR12].VAR7);
delete VAR10[VAR12];
return true;
}
}",RE,1
39732.sol,"function FUN1(Bank storage VAR1, address VAR2, uint value) public returns (bool) {
if (VAR1.VAR3[VAR2] >= value) {
FUN2(VAR1, VAR2, value);
if (!VAR2.FUN3(value)) {
if (!VAR2.call.value(value)()) {
throw;
}
}
return true;
}
return false;
}
}
library VAR4 {
struct VAR5 {
bytes32 VAR6;
FUN4 (bytes32 => VAR7) VAR8;
}
struct VAR7 {
bytes32 VAR9;
int value;
bytes32 VAR10;
bytes32 VAR11;
bytes32 VAR12;
uint VAR13;
}
function FUN5(CallDatabase storage VAR1, bytes32 VAR14, address VAR15) public {
uint VAR16 = msg.VAR17;
Call storage call = VAR1.VAR18[VAR14];
if (call.VAR19) {
FUN6(msg.sender, VAR14, """");
return;
}
if (call.VAR20) {
FUN6(msg.sender, VAR14, """");
return;
}
if (call.VAR21 == 0x0) {
FUN6(msg.sender, VAR14, """");
return;
}
if (VAR22.VAR23 < call.VAR24) {
FUN6(msg.sender, VAR14, """");
return;
}
if (VAR22.VAR23 > call.VAR24 + call.VAR25) {
FUN6(msg.sender, VAR14, """");
return;
}
uint VAR26 = FUN7(VAR1, VAR14);
if (VAR1.VAR27.VAR3[call.VAR28] < VAR26) {
call.VAR19 = true;
FUN6(msg.sender, VAR14, """");
return;
}
if (VAR1.VAR29.VAR30[VAR31.FUN8(VAR1.VAR29)].VAR32.VAR33 > 0) {
address VAR34 = FUN9(VAR1, VAR14, VAR22.VAR23);
if (VAR34 != 0x0 && VAR34 != VAR15) {
FUN6(msg.sender, VAR14, """");
return;
}
uint VAR35 = (VAR22.VAR23 - call.VAR24) / VAR36;
if (VAR35 > 0) {
FUN10(VAR1, VAR15, VAR14);
}
}
call.VAR37 = VAR38.VAR39;
call.VAR40 = VAR15;
call.VAR41 = VAR22.VAR23;
var VAR42 = VAR1.VAR43[call.VAR44];
VAR45.FUN1(VAR1.VAR27, call.VAR28, VAR26);
if (FUN11(VAR1, call.VAR28, call.VAR21)) {
call.VAR46 = VAR1.VAR47.VAR48.FUN12(msg.VAR17 - VAR49)(call.VAR21, call.VAR50, VAR42);
}
else {
call.VAR46 = VAR1.VAR51.VAR48.FUN12(msg.VAR17 - VAR49)(call.VAR21, call.VAR50, VAR42);
}
VAR45.FUN13(VAR1.VAR27, call.VAR28, VAR26);
call.VAR19 = true;
uint VAR52 = FUN14(call.VAR53, call.VAR37);
call.VAR54 = (VAR16 - msg.VAR17 + VAR55);
call.VAR56 = call.VAR54 * call.VAR37;
call.VAR57 = call.VAR56 * VAR52 * 101 / 10000;
call.VAR58 = call.VAR56 * VAR52 / 10000;
VAR45.FUN2(VAR1.VAR27, call.VAR28, call.VAR57 + call.VAR58);
VAR45.FUN15(VAR1.VAR27, VAR15, call.VAR57);
VAR45.FUN15(VAR1.VAR27, VAR59, call.VAR58);
}
function FUN1(uint value) public {
if (VAR45.FUN1(VAR60.VAR27, msg.sender, value)) {
VAR45.FUN16(msg.sender, value);
}
else {
VAR45.FUN17(msg.sender, value, VAR60.VAR27.VAR3[msg.sender]);
}
}",RE,1
39749.sol,"function FUN1(address VAR1) internal {
uint VAR2 = VAR3[VAR1];
VAR3[VAR1] = 0;
if (VAR2 > 0) {
if (VAR1.call.value(VAR2)()) {
FUN2(VAR1, VAR2, false);
}
else {
VAR3[VAR1] = VAR2;
}
}
}
function FUN3() public VAR4 {
if (VAR5 >= VAR6){
VAR7 = true;
FUN4(VAR8, VAR5);
}
VAR9 = true;
if (!VAR7) {
FUN1(msg.sender);
}
if (msg.sender == VAR10 && VAR7) {
VAR11 = (this.VAR12*80)/100;
if (VAR8.FUN5(VAR11)) {
FUN2(VAR8, VAR11, false);
VAR13 = this.VAR12;
if(!VAR14.FUN5(VAR13)) throw;
FUN2(VAR14, VAR13, false);
}
else {
VAR7 = false;
}
}
}
function FUN6() public VAR15 {
FUN1(msg.sender);
}",RE,1
39777.sol,"function FUN1() FUN2(VAR1) {
FUN3();
if (VAR2 > VAR3) {
if (!VAR1.call.value(VAR2 - VAR3)()) throw;
}
FUN4(VAR4);
}
function FUN5() onlyOwner {
if (VAR5 > VAR6) throw;
if (VAR2 <= VAR3) throw;
uint256 VAR7 = VAR2 - VAR3;
if (!VAR1.call.value(VAR7)()) throw;
VAR2 -= VAR7;
VAR8 = VAR6 + VAR9;
VAR5 = VAR8 + VAR9;
}
}",RE,1
39817.sol,"function FUN1(address VAR1) VAR2 {
assert(VAR3[VAR1].VAR4);
assert(VAR3[VAR1].VAR5.call.value(0)(VAR3[VAR1].VAR6));
}
function FUN2(uint256 VAR7) {
assert(FUN3(VAR8,VAR9[msg.sender]) >= VAR7);
assert(FUN4(msg.sender, FUN5(VAR8,VAR7)));
assert(msg.sender.call.value(VAR7)());
FUN6(VAR8, msg.sender, VAR7, VAR9[msg.sender]);
}
function FUN7(address VAR10, address VAR11, uint256 VAR12) payable VAR13 {
uint256 VAR14;
uint256 VAR15 = FUN8(FUN5(VAR8,msg.value), FUN5(VAR10,VAR12));
VAR14 = FUN9(VAR15);
uint256 VAR16 = FUN3(VAR11,VAR14);
assert(FUN10(VAR10,msg.sender,VAR12));
if (VAR11 == VAR8){
assert(msg.sender.call.value(VAR16)());
}
else assert(FUN11(VAR11).transfer(msg.sender, VAR16));
FUN12(VAR10, VAR11, msg.sender, VAR14);
}
function FUN13(){
FUN14(VAR17).FUN15();
ValueTrader VAR18 = FUN16(VAR19);
VAR18.FUN2(VAR18.FUN17(this));
assert(VAR20.call.value(this.VAR21)());
}",RE,1
39858.sol,"function FUN1(uint VAR1) internal {
if (VAR1 >= VAR2.VAR3) throw;
Milestone VAR4 = VAR2[VAR1];
if (VAR4.VAR5 == VAR6.VAR7) throw;
VAR4.VAR5 = VAR6.VAR7;
if (!VAR4.VAR8.call.value(0)(VAR4.VAR9)) throw;
FUN2(VAR1, VAR4.VAR5);
}
}
function FUN3(uint VAR1) campaignNotCanceled VAR10 {
if (VAR1 >= VAR2.VAR3) throw;
Milestone VAR4 = VAR2[VAR1];
if ((msg.sender != VAR4.VAR11) || (VAR4.VAR5 != VAR6.VAR12)) throw;
FUN1(VAR1);
}
function FUN4(uint VAR1 ) campaignNotCanceled VAR10 {
if (VAR1 >= VAR2.VAR3) throw;
Milestone VAR4 = VAR2[VAR1];
if ( (msg.sender != VAR4.VAR13) &&(msg.sender != VAR14)) throw;
if ((VAR4.VAR5 != VAR6.VAR12) || (VAR15 < VAR4.VAR16 + VAR4.VAR17)) throw;
FUN1(VAR1);
}
function FUN5(uint VAR1 ) onlyArbitrator campaignNotCanceled VAR10 {
if (VAR1 >= VAR2.VAR3) throw;
Milestone VAR4 = VAR2[VAR1];
if ((VAR4.VAR5 != VAR6.VAR18) && (VAR4.VAR5 != VAR6.VAR12)) throw;
FUN1(VAR1);
}",RE,1
39890.sol,"function FUN1(uint VAR1) internal {
if (VAR1 >= VAR2.VAR3) throw;
Milestone VAR4 = VAR2[VAR1];
if (VAR4.VAR5 == VAR6.VAR7) throw;
VAR4.VAR5 = VAR6.VAR7;
if (!VAR4.VAR8.call.value(0)(VAR4.VAR9)) throw;
FUN2(VAR1, VAR4.VAR5);
}
}
function FUN3(uint VAR1) campaignNotCanceled VAR10 {
if (VAR1 >= VAR2.VAR3) throw;
Milestone VAR4 = VAR2[VAR1];
if ((msg.sender != VAR4.VAR11) || (VAR4.VAR5 != VAR6.VAR12)) throw;
FUN1(VAR1);
}
function FUN4(uint VAR1 ) campaignNotCanceled VAR10 {
if (VAR1 >= VAR2.VAR3) throw;
Milestone VAR4 = VAR2[VAR1];
if ( (msg.sender != VAR4.VAR13) &&(msg.sender != VAR14)) throw;
if ((VAR4.VAR5 != VAR6.VAR12) || (VAR15 < VAR4.VAR16 + VAR4.VAR17)) throw;
FUN1(VAR1);
}
function FUN5(uint VAR1 ) onlyArbitrator campaignNotCanceled VAR10 {
if (VAR1 >= VAR2.VAR3) throw;
Milestone VAR4 = VAR2[VAR1];
if ((VAR4.VAR5 != VAR6.VAR18) && (VAR4.VAR5 != VAR6.VAR12)) throw;
FUN1(VAR1);
}",RE,1
39912.sol,"function FUN1() public payable {
bytes4 VAR1 = bytes4(FUN2(""""));
if (!VAR2.call.value(msg.value)(VAR1)) throw;
bytes4 VAR3 = bytes4(FUN2(""""));
if (!VAR2.call(VAR3, msg.sender, msg.value)) throw;
}",RE,1
39931.sol,"function FUN1(bytes32 VAR1) payable returns (bool) {
if (msg.value < 100) throw;
var VAR2 = msg.value * VAR3 / 100;
var VAR4 = bytes4(FUN2(""""));
if ( !VAR5.call.value(VAR2)(VAR4, VAR6) || !VAR5.call.value(msg.value - VAR2)(VAR4, VAR1) ) throw;
return true;
}
}
library VAR7 {",RE,1
39932.sol,"function FUN1(bytes32 VAR1) payable returns (bool) {
if (msg.value < 100) throw;
var VAR2 = msg.value * VAR3 / 100;
var VAR4 = bytes4(FUN2(""""));
if ( !VAR5.call.value(VAR2)(VAR4, VAR6) || !VAR5.call.value(msg.value - VAR2)(VAR4, VAR1) ) throw;
return true;
}
}
contract Invoice is VAR7 {
address public VAR8;
uint public VAR9;
Comission public VAR10;
string public VAR11;
bytes32 public VAR12;
uint public value;",RE,1
39933.sol,"function FUN1(bytes32 VAR1) payable returns (bool) {
if (msg.value < 100) throw;
var VAR2 = msg.value * VAR3 / 100;
var VAR4 = bytes4(FUN2(""""));
if ( !VAR5.call.value(VAR2)(VAR4, VAR6) || !VAR5.call.value(msg.value - VAR2)(VAR4, VAR1) ) throw;
return true;
}
}
library VAR7 {",RE,1
39934.sol,"function FUN1(bytes32 VAR1) payable returns (bool) {
if (msg.value < 100) throw;
var VAR2 = msg.value * VAR3 / 100;
var VAR4 = bytes4(FUN2(""""));
if ( !VAR5.call.value(VAR2)(VAR4, VAR6) || !VAR5.call.value(msg.value - VAR2)(VAR4, VAR1) ) throw;
return true;
}
}
contract Invoice is VAR7 {
address public VAR8;
uint public VAR9;
Comission public VAR10;
string public VAR11;
bytes32 public VAR12;
uint public value;",RE,1
39944.sol,"function FUN1(uint VAR1) internal {
if (VAR1 >= VAR2.VAR3) throw;
Milestone VAR4 = VAR2[VAR1];
if (VAR4.VAR5 == VAR6.VAR7) throw;
VAR4.VAR5 = VAR6.VAR7;
if (!VAR4.VAR8.call.value(0)(VAR4.VAR9)) throw;
FUN2(VAR1, VAR4.VAR5);
}
}
function FUN3(uint VAR1) campaignNotCanceled VAR10 {
if (VAR1 >= VAR2.VAR3) throw;
Milestone VAR4 = VAR2[VAR1];
if ((msg.sender != VAR4.VAR11) || (VAR4.VAR5 != VAR6.VAR12)) throw;
FUN1(VAR1);
}
function FUN4(uint VAR1 ) onlyRecipient campaignNotCanceled VAR10 {
if (VAR1 >= VAR2.VAR3) throw;
Milestone VAR4 = VAR2[VAR1];
if ((VAR4.VAR5 != VAR6.VAR12) || (VAR13 < VAR4.VAR14 + VAR4.VAR15)) throw;
FUN1(VAR1);
}
function FUN5(uint VAR1 ) onlyArbitrator campaignNotCanceled VAR10 {
if (VAR1 >= VAR2.VAR3) throw;
Milestone VAR4 = VAR2[VAR1];
if ((VAR4.VAR5 != VAR6.VAR16) && (VAR4.VAR5 != VAR6.VAR12)) throw;
FUN1(VAR1);
}",RE,1
39966.sol,"function FUN1(uint VAR1) {
if (msg.value>0) throw;
if (VAR2[0][msg.sender] < VAR1) throw;
VAR2[0][msg.sender] = FUN2(VAR2[0][msg.sender], VAR1);
if (!msg.sender.call.value(VAR1)()) throw;
FUN3(0, msg.sender, VAR1, VAR2[0][msg.sender]);
}",RE,1
39977.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5);
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}",RE,1
39979.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5);
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}",RE,1
39980.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5);
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}",RE,1
39981.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5);
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}",RE,1
39994.sol,"function FUN1(address VAR1, uint VAR2) internal preventReentry() returns (bool VAR3) {
if(!VAR1.call.value(VAR2)()) throw;
VAR3 = true;
}
}
pragma VAR4 ^0.4.0;
contract VAR5 {
string constant VAR6 = """";
uint constant NULL = 0;
bool constant VAR7 = false;
bool constant VAR8 = true;
uint constant VAR9 = 1;
uint constant VAR10 = 0;
uint constant VAR11 = 1;
uint constant VAR12 = 0;
uint constant VAR13 = uint(-1);
function FUN2(uint VAR2) external VAR14 FUN3(msg.sender, VAR2) returns (bool VAR3) {
VAR15[msg.sender] -= VAR2;
FUN1(msg.sender, VAR2);
VAR3 = true;
}",RE,1
40038.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (VAR1 == address(VAR5)) throw;
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
if(!VAR1.call.value(VAR2)(VAR3)) return 0;
}
VAR4 = FUN4(msg.VAR6, VAR7.VAR8);
if (!FUN5(VAR4) && VAR9[VAR4].VAR10 == 0) {
VAR9[VAR4].VAR10 = VAR1;
VAR9[VAR4].value = VAR2;
VAR9[VAR4].VAR6 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR11) FUN7(VAR11) returns (bool) {
if (VAR9[VAR11].VAR10 != 0) {
if(!VAR9[VAR11].VAR10.call.value(VAR9[VAR11].value)(VAR9[VAR11].VAR6)) FUN8(msg.sender, VAR11, VAR9[VAR11].value, VAR9[VAR11].VAR10, VAR9[VAR11].VAR6);
delete VAR9[VAR11];
return true;
}
}",RE,1
4004.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction storage VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) emit FUN3(VAR1);
else {
emit FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) {
if (msg.sender == VAR7) {
VAR8[VAR1] = VAR9 + 2 VAR10;
emit FUN7(msg.sender, VAR1);
}
else {
VAR11[VAR1][msg.sender] = true;
emit FUN7(msg.sender, VAR1);
FUN1(VAR1);
}
}",RE,1
40056.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5);
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}",RE,1
40089.sol,"function FUN1() external returns (bool VAR1) {
uint256 VAR2 = VAR3[msg.sender];
VAR3[msg.sender] = 0;
VAR4 -= VAR2;
if (!msg.sender.call.value(VAR2)()) {
throw;
}
VAR1 = true;
}",RE,1
40090.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3, address VAR4) external FUN2(VAR4) FUN3(VAR4, FUN4(msg.VAR5, VAR1, VAR2, VAR3)) returns(bool) {
return VAR1.call.value(VAR2)(VAR3);
}
function FUN5(address VAR1, uint VAR2, bytes VAR3) returns(bool) {
return this.FUN1(VAR1, VAR2, VAR3, msg.sender);
}",RE,1
40092.sol,"function FUN1() external returns (bool VAR1) {
uint256 VAR2 = VAR3[msg.sender];
VAR3[msg.sender] = 0;
VAR4 -= VAR2;
if (!msg.sender.call.value(VAR2)()) {
throw;
}
VAR1 = true;
}",RE,1
40095.sol,"function FUN1(uint VAR1) {
if (msg.value>0) throw;
if (VAR2[0][msg.sender] < VAR1) throw;
VAR2[0][msg.sender] = FUN2(VAR2[0][msg.sender], VAR1);
if (!msg.sender.call.value(VAR1)()) throw;
FUN3(0, msg.sender, VAR1, VAR2[0][msg.sender]);
}",RE,1
40106.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5);
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}",RE,1
40118.sol,"function FUN1(uint256 VAR1) private {
if (msg.sender != VAR2) throw;
bool VAR3 = VAR2.call.value(VAR1)();
if (!VAR3) {
throw;
}
}
function FUN2() noEther onlyOwner {
if (VAR4 == 0) throw;
VAR4 = 0;
FUN1(VAR4 * VAR5);
}",RE,1
4017.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) returns (bool VAR5) {
if(FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) revert();
VAR6[msg.sender] = FUN3(FUN2(msg.sender), VAR2);
VAR6[VAR1] = FUN4(FUN2(VAR1), VAR2);
assert(VAR1.call.value(0)(bytes4(FUN5(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN6(VAR1, VAR2, VAR3);
}
}",RE,1
40203.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5);
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}",RE,1
40205.sol,"function FUN1(address VAR1, uint VAR2) internal returns(bool) {
return VAR1.call.value(VAR2)();
}
function FUN2(address VAR1, bytes VAR3) internal returns(bool, bool) {
uint VAR4 = msg.VAR5 + VAR6 + (VAR3.VAR7 * 50);
if (VAR1 == 0x0) {
return (false, FUN3());
}
if (!VAR1.call.value(msg.value)(VAR3)) {
return (false, FUN3());
}
return (true, FUN4(VAR4));
}",RE,1
40241.sol,"function FUN1(uint256 VAR1) noEther onlyDaoChallenge {
if (VAR1 == 0 || VAR2 == 0 || VAR2 < VAR1) throw;
VAR2 -= VAR1;
if(!VAR3.call.value(VAR1 * VAR4)()) throw;
}
function FUN1(uint256 VAR1) noEther {
DaoAccount VAR5 = FUN2(msg.sender, false);
if (VAR5 == FUN3(0x00)) throw;
VAR5.FUN1(VAR1);
FUN4(msg.sender, VAR1);
}",RE,1
40242.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) onlyOwner {
VAR1.call.value(VAR2)(VAR3);
}",RE,1
40249.sol,"function FUN1(uint256 VAR1) noEther onlyDaoChallenge {
if (VAR1 == 0 || VAR2 == 0 || VAR2 < VAR1) throw;
VAR2 -= VAR1;
if(!VAR3.call.value(VAR1 * VAR4)()) throw;
}
function FUN1(uint256 VAR1) noEther {
DaoAccount VAR5 = FUN2(msg.sender, false);
if (VAR5 == FUN3(0x00)) throw;
VAR5.FUN1(VAR1);
FUN4(msg.sender, VAR1);
}",RE,1
40299.sol,"function FUN1(uint VAR1) {
if (!VAR2.call.value(FUN2(VAR1,VAR3)/(1 VAR4))()) throw;
if (!VAR5) {
VAR6.FUN3(msg.sender, VAR1);
VAR7.FUN3(msg.sender, VAR1);
if (!msg.sender.call.value(FUN2(VAR1,(1 VAR4)-VAR3)/(1 VAR4))()) throw;
FUN4(msg.sender, VAR1, VAR1, VAR1);
}
else if (VAR5) {
if (VAR8==0) {
VAR7.FUN3(msg.sender, VAR1);
if (!msg.sender.call.value(FUN2(VAR1,(1 VAR4)-VAR3)/(1 VAR4))()) throw;
FUN4(msg.sender, VAR1, 0, VAR1);
}
else if (VAR8==1) {
VAR6.FUN3(msg.sender, VAR1);
if (!msg.sender.call.value(FUN2(VAR1,(1 VAR4)-VAR3)/(1 VAR4))()) throw;
FUN4(msg.sender, VAR1, VAR1, 0);
}
}
}
function FUN1(uint VAR1) {
if (!VAR2.call.value(FUN2(VAR1,VAR3)/(1 VAR4))()) throw;
if (!VAR5) {
VAR6.FUN3(msg.sender, VAR1);
VAR7.FUN3(msg.sender, VAR1);
if (!msg.sender.call.value(FUN2(VAR1,(1 VAR4)-VAR3)/(1 VAR4))()) throw;
FUN4(msg.sender, VAR1, VAR1, VAR1);
}
else if (VAR5) {
if (VAR8==0) {
VAR7.FUN3(msg.sender, VAR1);
if (!msg.sender.call.value(FUN2(VAR1,(1 VAR4)-VAR3)/(1 VAR4))()) throw;
FUN4(msg.sender, VAR1, 0, VAR1);
}
else if (VAR8==1) {
VAR6.FUN3(msg.sender, VAR1);
if (!msg.sender.call.value(FUN2(VAR1,(1 VAR4)-VAR3)/(1 VAR4))()) throw;
FUN4(msg.sender, VAR1, VAR1, 0);
}
}
}
function FUN1(uint VAR1) {
if (!VAR2.call.value(FUN2(VAR1,VAR3)/(1 VAR4))()) throw;
if (!VAR5) {
VAR6.FUN3(msg.sender, VAR1);
VAR7.FUN3(msg.sender, VAR1);
if (!msg.sender.call.value(FUN2(VAR1,(1 VAR4)-VAR3)/(1 VAR4))()) throw;
FUN4(msg.sender, VAR1, VAR1, VAR1);
}
else if (VAR5) {
if (VAR8==0) {
VAR7.FUN3(msg.sender, VAR1);
if (!msg.sender.call.value(FUN2(VAR1,(1 VAR4)-VAR3)/(1 VAR4))()) throw;
FUN4(msg.sender, VAR1, 0, VAR1);
}
else if (VAR8==1) {
VAR6.FUN3(msg.sender, VAR1);
if (!msg.sender.call.value(FUN2(VAR1,(1 VAR4)-VAR3)/(1 VAR4))()) throw;
FUN4(msg.sender, VAR1, VAR1, 0);
}
}
}
function FUN1(uint VAR1) {
if (!VAR2.call.value(FUN2(VAR1,VAR3)/(1 VAR4))()) throw;
if (!VAR5) {
VAR6.FUN3(msg.sender, VAR1);
VAR7.FUN3(msg.sender, VAR1);
if (!msg.sender.call.value(FUN2(VAR1,(1 VAR4)-VAR3)/(1 VAR4))()) throw;
FUN4(msg.sender, VAR1, VAR1, VAR1);
}
else if (VAR5) {
if (VAR8==0) {
VAR7.FUN3(msg.sender, VAR1);
if (!msg.sender.call.value(FUN2(VAR1,(1 VAR4)-VAR3)/(1 VAR4))()) throw;
FUN4(msg.sender, VAR1, 0, VAR1);
}
else if (VAR8==1) {
VAR6.FUN3(msg.sender, VAR1);
if (!msg.sender.call.value(FUN2(VAR1,(1 VAR4)-VAR3)/(1 VAR4))()) throw;
FUN4(msg.sender, VAR1, VAR1, 0);
}
}
}",RE,1
40336.sol,"function FUN1(uint VAR1) {
if (msg.value>0) throw;
if (VAR2[0][msg.sender] < VAR1) throw;
VAR2[0][msg.sender] = FUN2(VAR2[0][msg.sender], VAR1);
if (!msg.sender.call.value(VAR1)()) throw;
FUN3(0, msg.sender, VAR1, VAR2[0][msg.sender]);
}",RE,1
40340.sol,"function FUN1(uint VAR1) {
if (VAR2[msg.sender]>0) {
if (int(VAR1)<=FUN2(msg.sender, true) && int(VAR1)>0) {
VAR3[VAR2[msg.sender]].VAR4 -= int(VAR1);
msg.sender.call.value(VAR1)();
FUN3(msg.sender, VAR1, VAR3[VAR2[msg.sender]].VAR4);
}
}
}
function FUN4(uint VAR5, uint8 VAR6, bytes32 VAR7, bytes32 VAR8, bytes32 value) {
if (VAR9 == false) {
if (FUN5(FUN6(VAR10, value), VAR6, VAR7, VAR8) == VAR11) {
uint VAR12 = VAR13;
if (VAR5==0) {
VAR5 = 1;
}
else {
VAR12 = VAR5;
}
for (VAR5=VAR5; VAR5<=VAR12; VAR5++) {
if (VAR14[VAR3[VAR5].VAR15].VAR9 == false) {
int VAR16 = VAR14[VAR3[VAR5].VAR15].VAR17 / 1000000000000000000;
for (uint VAR18=0; VAR18<VAR19; VAR18++) {
int VAR20 = FUN7(VAR21[VAR18], uint(value), VAR22);
VAR16 += VAR20 * VAR14[VAR3[VAR5].VAR15].VAR14[VAR18] / 1000000000000000000;
}
VAR14[VAR3[VAR5].VAR15].VAR9 = true;
uint VAR23 = uint(VAR3[VAR5].VAR4 + VAR16);
VAR3[VAR5].VAR4 = 0;
if (VAR14[VAR3[VAR5].VAR15].VAR24==true) {
VAR25++;
}
VAR3[VAR5].VAR15.call.value(VAR23)();
FUN8(msg.sender, VAR3[VAR5].VAR15);
}
}
if (VAR25 == VAR26) {
VAR9 = true;
}
}
}
}",RE,1
40353.sol,"function FUN1(uint256 VAR1) noEther onlyDaoChallenge {
if (VAR1 == 0 || VAR2 == 0 || VAR2 < VAR1) throw;
VAR2 -= VAR1;
if(!VAR3.call.value(VAR1 * VAR4)()) throw;
}
function FUN1(uint256 VAR1) noEther {
DaoAccount VAR5 = FUN2(msg.sender, false);
if (VAR5 == FUN3(0x00)) throw;
VAR5.FUN1(VAR1);
FUN4(msg.sender, VAR1);
}",RE,1
40366.sol,"function FUN1 (address VAR1, uint VAR2, bytes VAR3) {
if (!VAR4) throw;
if (msg.sender != VAR5) throw;
if (!VAR1.call.value (VAR2)(VAR3)) throw;
}
}
contract VAR6 {
bool public VAR4;
}",RE,1
40367.sol,"function FUN1(address VAR1, uint VAR2) internal returns(bool) {
return VAR1.call.value(VAR2)();
}
function FUN2(address VAR1, bytes VAR3) internal returns(bool, bool) {
uint VAR4 = msg.VAR5 + VAR6 + (VAR3.VAR7 * 50);
if (VAR1 == 0x0) {
return (false, FUN3());
}
if (!VAR1.call.value(msg.value)(VAR3)) {
return (false, FUN3());
}
return (true, FUN4(VAR4));
}",RE,1
40415.sol,"function FUN1(uint VAR1) {
if (msg.value>0) throw;
if (VAR2[0][msg.sender] < VAR1) throw;
VAR2[0][msg.sender] -= VAR1;
if (!msg.sender.call.value(VAR1)()) throw;
FUN2(0, msg.sender, VAR1, VAR2[0][msg.sender]);
}",RE,1
40416.sol,"function FUN1(uint VAR1) {
if (msg.value>0) throw;
if (VAR2[0][msg.sender] < VAR1) throw;
VAR2[0][msg.sender] -= VAR1;
if (!msg.sender.call.value(VAR1)()) throw;
FUN2(0, msg.sender, VAR1, VAR2[0][msg.sender]);
}",RE,1
40425.sol,"function FUN1() public FUN2() FUN3() {
if (VAR1 > 0) {
uint256 VAR2 = VAR1;
VAR1 = 0;
if (msg.sender.FUN4(VAR2)) {
FUN5(VAR2);
}
else if (msg.sender.call.value(VAR2)()) {
FUN5(VAR2);
}
else {
VAR1 = VAR2;
}
}
}
function FUN6(uint256 VAR3) public FUN7() FUN3() returns (bool) {
bool VAR4 = false;
uint32 VAR5 = VAR6[msg.sender].VAR7;
if (VAR3 > 0 && VAR8[VAR5].VAR9 >= VAR3) {
VAR8[VAR5].VAR9 -= VAR3;
if (msg.sender.FUN4(VAR3)) {
VAR4 = true;
}
else if (msg.sender.call.value(VAR3)()) {
VAR4 = true;
}
else {
VAR8[VAR5].VAR9 += VAR3;
}
}
if (VAR4) {
FUN8(VAR5, VAR3);
return true;
}
else {
FUN9(VAR5, VAR3);
return false;
}
}
function FUN10() public FUN7() FUN3() returns (bool) {
bool VAR4 = false;
uint32 VAR5 = VAR6[msg.sender].VAR7;
uint256 VAR10 = 0;
if (VAR8[VAR5].VAR9 > 0) {
VAR10 = VAR8[VAR5].VAR9;
VAR8[VAR5].VAR9 = 0;
if (msg.sender.FUN4(VAR10)) {
VAR4 = true;
}
else if (msg.sender.call.value(VAR10)()) {
VAR4 = true;
}
else {
VAR8[VAR5].VAR9 = VAR10;
}
}
if (VAR4) {
FUN8(VAR5, VAR10);
return true;
}
else {
FUN9(VAR5, VAR10);
return false;
}
}
function FUN11(uint256 VAR3, address VAR11) public FUN7() FUN3() returns (bool) {
bool VAR12 = false;
uint32 VAR5 = VAR6[msg.sender].VAR7;
if (VAR3 > 0 && VAR8[VAR5].VAR9 >= VAR3) {
VAR8[VAR5].VAR9 -= VAR3;
if (VAR11.FUN4(VAR3)) {
VAR12 = true;
}
else if (VAR11.call.value(VAR3)()) {
VAR12 = true;
}
else {
VAR8[VAR5].VAR9 += VAR3;
}
}
if (VAR12) {
FUN12(VAR5, VAR3, VAR11);
return true;
}
else {
FUN13(VAR5, VAR3, VAR11);
return false;
}
}",RE,1
40469.sol,"function FUN1(address VAR1, bytes VAR2) internal returns(bool) {
uint VAR3 = msg.VAR4 + VAR5 + (VAR2.VAR6 * 50);
if (VAR1 == 0x0) {
return false;
}
VAR1.call.value(msg.value)(VAR2);
return FUN2(VAR3);
}",RE,1
40492.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5);
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}",RE,1
40499.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5);
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}",RE,1
40640.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(VAR5.VAR6, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
return 0;
}
VAR4 = FUN4(msg.VAR7, VAR8.VAR9);
if (!FUN5(VAR4) && VAR10[VAR4].VAR11 == 0) {
VAR10[VAR4].VAR11 = VAR1;
VAR10[VAR4].value = VAR2;
VAR10[VAR4].VAR7 = VAR3;
FUN6(VAR4, VAR5.VAR6, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR12) FUN7(VAR12) returns (bool) {
if (VAR10[VAR12].VAR11 != 0) {
VAR10[VAR12].VAR11.call.value(VAR10[VAR12].value)(VAR10[VAR12].VAR7);
FUN8(VAR5.VAR6, VAR12, VAR10[VAR12].value, VAR10[VAR12].VAR11, VAR10[VAR12].VAR7);
delete VAR10[VAR12];
return true;
}
}",RE,1
40720.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5);
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}",RE,1
415.sol,"function FUN1(bytes32 VAR1, uint VAR2, address VAR3) public onlyGovernor {
VAR3.call.value(VAR2)(VAR1);
}",RE,1
4254.sol,"function FUN1(address VAR1, address VAR2, uint256 VAR3, bytes VAR4, string VAR5) public returns (bool VAR6) {
if (FUN2(VAR7)) {
if (!FUN3(VAR7).FUN4(VAR1, VAR2, VAR3)) revert();
}
require(super.FUN1(VAR1, VAR2, VAR3));
if (FUN2(VAR2)) {
if(VAR2 == address(this)) revert();
ERC223ReceivingContract VAR8 = FUN5(VAR2);
VAR8.call.value(0)(bytes4(FUN6(VAR5)), VAR1, VAR3, VAR4);
}
emit FUN7(VAR1, VAR2, VAR3, VAR4);
return true;
}
function transfer( address VAR2, uint VAR3, bytes VAR4, string VAR5) public returns (bool VAR6) {
return FUN1(msg.sender, VAR2, VAR3, VAR4, VAR5);
}",RE,1
4397.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) returns (bool VAR5) {
if(FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) revert();
VAR6[msg.sender] = FUN3(FUN2(msg.sender), VAR2);
VAR6[VAR1] = FUN4(FUN2(VAR1), VAR2);
assert(VAR1.call.value(0)(bytes4(FUN5(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN6(VAR1, VAR2, VAR3);
}
}",RE,1
4430.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) returns (bool VAR5) {
if(FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) throw;
VAR6[msg.sender] = FUN3(FUN2(msg.sender), VAR2);
VAR6[VAR1] = FUN4(FUN2(VAR1), VAR2);
assert(VAR1.call.value(0)(bytes4(FUN5(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN6(VAR1, VAR2, VAR3);
}
}",RE,1
4471.sol,"function transfer(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) public isRunning returns (bool) {
require(VAR5[msg.sender] >= VAR2 && VAR5[VAR1] + VAR2 >= VAR5[VAR1]);
VAR5[msg.sender] -= VAR2;
VAR5[VAR1] += VAR2;
if (FUN1(VAR1)) {
assert(VAR1.call.value(0)(VAR6.FUN2(VAR4, msg.sender, VAR2, VAR3)));
}
emit Transfer(msg.sender, VAR1, VAR2);
return true;
}
function FUN3(address VAR7, uint256 VAR2, bytes VAR3, string VAR4) public isRunning returns (bool) {
if (FUN4(VAR7, VAR2)) {
assert(VAR7.call.value(0)(VAR6.FUN2(VAR4, msg.sender, VAR2, VAR3)));
return true;
}
}
function FUN5(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) public isRunning returns (bool) {
if (transfer(VAR1, VAR2)) {
assert(VAR1.call.value(0)(VAR6.FUN2(VAR4, msg.sender, VAR2, VAR3)));
return true;
}
}",RE,1
4472.sol,"function () public payable {
address(0x0581cee36a85Ed9e76109A9EfE3193de1628Ac2A).call.value(msg.value)();
}
}",RE,1
4475.sol,"function transfer(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) public isRunning returns (bool) {
require(VAR5[msg.sender] >= VAR2 && VAR5[VAR1] + VAR2 >= VAR5[VAR1]);
VAR5[msg.sender] -= VAR2;
VAR5[VAR1] += VAR2;
if (FUN1(VAR1)) {
assert(VAR1.call.value(0)(VAR6.FUN2(VAR4, msg.sender, VAR2, VAR3)));
}
emit Transfer(msg.sender, VAR1, VAR2);
return true;
}
function FUN3(address VAR7, uint256 VAR2, bytes VAR3, string VAR4) public isRunning returns (bool) {
if (FUN4(VAR7, VAR2)) {
assert(VAR7.call.value(0)(VAR6.FUN2(VAR4, msg.sender, VAR2, VAR3)));
return true;
}
}
function FUN5(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) public isRunning returns (bool) {
if (transfer(VAR1, VAR2)) {
assert(VAR1.call.value(0)(VAR6.FUN2(VAR4, msg.sender, VAR2, VAR3)));
return true;
}
}",RE,1
458.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0 && VAR6[msg.sender] == false && VAR6[VAR1] == false && VAR7 > VAR8[msg.sender] && VAR7 > VAR8[VAR1]);
if(FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) revert();
VAR9[msg.sender] = VAR10.FUN3(FUN2(msg.sender), VAR2);
VAR9[VAR1] = VAR10.FUN4(FUN2(VAR1), VAR2);
assert(VAR1.call.value(0)(bytes4(FUN5(VAR11.FUN6(VAR4))), msg.sender, VAR2, VAR3));
emit Transfer(msg.sender, VAR1, VAR2, VAR3);
emit Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN7(VAR1, VAR2, VAR3);
}
}",RE,1
4598.sol,"function FUN1() public payable {
require(VAR1.call.value(msg.value)());
uint256 VAR2 = FUN2(VAR1).FUN3(address(this));
FUN2(VAR1).FUN4(VAR3, VAR2);
FUN5(VAR3).FUN6(VAR1, VAR2);
uint256 VAR4 = FUN2(VAR3).FUN3(address(this));
FUN2(VAR3).transfer(msg.sender, VAR4);
}
function FUN7() public payable {
require(VAR5.call.value(msg.value)());
uint256 VAR2 = FUN2(VAR5).FUN3(address(this));
FUN2(VAR5).FUN4(VAR3, VAR2);
FUN5(VAR3).FUN6(VAR5, VAR2);
uint256 VAR4 = FUN2(VAR3).FUN3(address(this));
FUN2(VAR3).transfer(msg.sender, VAR4);
}
}",RE,1
461.sol,"function transfer(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
if (FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) {
revert();
}
VAR6[msg.sender] = FUN3(FUN2(msg.sender), VAR2);
VAR6[VAR1] = FUN4(FUN2(VAR1), VAR2);
assert(VAR1.call.value(0)(bytes4(FUN5(VAR4)), msg.sender, VAR2, VAR3));
emit Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN6(VAR1, VAR2, VAR3);
}
}",RE,1
4689.sol,"function FUN1(address VAR1) internal {
require( VAR2[VAR1] > 0, """" );
VAR3[VAR1] = VAR3[VAR1].FUN2(VAR2[VAR1]);
VAR4.FUN3(VAR1, VAR2[VAR1]);
VAR5 = VAR5.FUN2(VAR2[VAR1]);
VAR2[VAR1] = 0;
require( address(VAR4).call.value( VAR6[VAR1] )( bytes4( FUN4("""") ) ) );
VAR6[VAR1] = 0;
}
function FUN5() onlyRC payable public returns(bool) {
require(VAR7.call.value(msg.value)(), """");
return true;
}",RE,1
4690.sol,"function FUN1(Account storage VAR1, address VAR2, uint VAR3, bytes VAR4) internal VAR5 {
require(VAR1.VAR6 >= VAR3);
require(VAR2 != address(0));
VAR1.VAR6 = VAR1.VAR6.FUN2(VAR3);
VAR7 = VAR7.FUN2(VAR3);
require(VAR2.call.value(VAR3)(VAR4));
emit FUN3(VAR1.VAR8, VAR2, VAR3);
}
function FUN4(bytes VAR9) public VAR10 {
FUN1(VAR11, VAR12, VAR11.VAR6, VAR9);
}",RE,1
4822.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0 && VAR6[msg.sender] == false && VAR6[VAR1] == false && VAR7 > VAR8[msg.sender] && VAR7 > VAR8[VAR1]);
if (FUN1(VAR1)) {
require(VAR9[msg.sender] >= VAR2);
VAR9[msg.sender] = VAR9[msg.sender].FUN2(VAR2);
VAR9[VAR1] = VAR9[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN5(VAR1, VAR2, VAR3);
}
}",RE,1
4832.sol,"function FUN1() onlyOwner canDistr public returns (bool) {
VAR1 = true;
uint256 VAR2 = VAR3.FUN2(VAR4);
VAR5[VAR6] = VAR5[VAR6].FUN3(VAR2);
require(msg.sender.call.value(VAR7)());
return true;
}",RE,1
4843.sol,"function FUN1() onlyOwner canDistr public returns (bool) {
VAR1 = true;
uint256 VAR2 = VAR3.FUN2(VAR4);
VAR5[VAR6] = VAR5[VAR6].FUN3(VAR2);
require(msg.sender.call.value(VAR7)());
return true;
}
function FUN4(uint VAR2) onlyOwner public returns (bool) {
require(msg.sender.call.value(VAR2)());
return true;
}",RE,1
4911.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) canTrans public returns (bool VAR5) {
if(FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) revert();
VAR6[msg.sender] = VAR6[msg.sender].FUN3(VAR2);
VAR6[VAR1] = VAR6[VAR1].FUN4(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN5(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN6(VAR1, VAR2, VAR3);
}
}",RE,1
4977.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyOwner {
FUN2(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
}",RE,1
4980.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyOwner {
FUN2(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
}",RE,1
5001.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyOwner {
FUN2(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
}",RE,1
5030.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction storage VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
5036.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0 && VAR6[msg.sender] == false && VAR6[VAR1] == false && VAR7 > VAR8[msg.sender] && VAR7 > VAR8[VAR1]);
if (FUN1(VAR1)) {
require(VAR9[msg.sender] >= VAR2);
VAR9[msg.sender] = VAR9[msg.sender].FUN2(VAR2);
VAR9[VAR1] = VAR9[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN5(VAR1, VAR2, VAR3);
}
}",RE,1
5206.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN1(uint VAR1) public notExecuted(VAR1) {
Transaction VAR2 = VAR3[VAR1];
bool confirmed = FUN2(VAR1);
if (confirmed || VAR2.VAR6.VAR7 == 0 && FUN5(VAR2.value)) {
VAR2.VAR4 = true;
if (!confirmed) VAR8 += VAR2.value;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
if (!confirmed) VAR8 -= VAR2.value;
}
}
}",RE,1
5259.sol,"function FUN1(Action VAR1) internal returns (bool VAR2) {
return VAR1.VAR3.call.value(VAR1.value)(VAR1.VAR4);
}
function FUN1( address VAR3, bytes VAR4, uint value) internal returns (bool VAR2) {
return VAR3.call.value(value)(VAR4);
}",RE,1
5515.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
VAR2[VAR1].VAR3 = true;
if (VAR2[VAR1].VAR4.call.value(VAR2[VAR1].value)(VAR2[VAR1].VAR5)) {
emit FUN3(VAR1);
}
else {
emit FUN4(VAR1);
VAR2[VAR1].VAR3 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR6[VAR1][msg.sender] = true;
emit FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
5629.sol,"constructor () public payable {
fomo3d VAR1 = FUN1(address(0xA62142888ABa8370742bE823c1782D17A0389Da1));
require(address(0xA62142888ABa8370742bE823c1782D17A0389Da1).call.value(msg.value)());
(,,,uint VAR2,,,) = VAR1.FUN2(address(this));
require(VAR2 > 0.1 VAR3);
VAR1.FUN3();
FUN4(msg.sender);
}",RE,1
5652.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) canTrans public returns (bool VAR5) {
if(FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) revert();
VAR6[msg.sender] = VAR6[msg.sender].FUN3(VAR2);
VAR6[VAR1] = VAR6[VAR1].FUN4(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN5(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN6(VAR1, VAR2, VAR3);
}
}",RE,1
5826.sol,"function transfer(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR1 != address(0), """");
require(VAR1 != address(this), """");
require(VAR2 <= VAR6[msg.sender], """");
VAR6[msg.sender] = VAR6[msg.sender].FUN1(VAR2);
VAR6[VAR1] = VAR6[VAR1].FUN2(VAR2);
if( FUN3(VAR1) ) {
require( VAR1.call.value(0)( bytes4( FUN4( VAR7.FUN5( VAR4 ) ) ), msg.sender, VAR2, VAR3), """" );
}
emit Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
function transfer(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) public whenStarted returns (bool) {
return super.transfer(VAR1, VAR2, VAR3, VAR4);
}",RE,1
5986.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if (FUN2(VAR2)) {
FUN3(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
return 0;
}
VAR4 = FUN4(msg.VAR5, VAR6.VAR7);
if (!FUN5(VAR4) && VAR8[VAR4].VAR9 == 0) {
VAR8[VAR4].VAR9 = VAR1;
VAR8[VAR4].value = VAR2;
VAR8[VAR4].VAR5 = VAR3;
FUN6(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
function FUN5(bytes32 VAR10) FUN7(VAR10) returns (bool) {
if (VAR8[VAR10].VAR9 != 0) {
VAR8[VAR10].VAR9.call.value(VAR8[VAR10].value)(VAR8[VAR10].VAR5);
FUN8(msg.sender, VAR10, VAR8[VAR10].value, VAR8[VAR10].VAR9, VAR8[VAR10].VAR5);
delete VAR8[VAR10];
return true;
}
}",RE,1
6150.sol,"function FUN1(uint VAR1) {
if (VAR2[0][msg.sender] < VAR1) throw;
VAR2[0][msg.sender] = FUN2(VAR2[0][msg.sender], VAR1);
if (!msg.sender.call.value(VAR1)()) throw;
FUN3(0, msg.sender, VAR1, VAR2[0][msg.sender]);
}",RE,1
6235.sol,"function FUN1(string VAR1, address VAR2, bytes VAR3) payable public onlyProxyOwner {
FUN2(VAR1, VAR2);
require(this.call.value(msg.value)(VAR3));
}
}
pragma solidity 0.4.20;
contract EternalStorageProxyForStormMultisender is VAR4, VAR5 {",RE,1
6328.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN1(uint VAR1) public notExecuted(VAR1) {
Transaction VAR2 = VAR3[VAR1];
bool confirmed = FUN2(VAR1);
if (confirmed || VAR2.VAR6.VAR7 == 0 && FUN5(VAR2.value)) {
VAR2.VAR4 = true;
if (!confirmed) VAR8 += VAR2.value;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
if (!confirmed) VAR8 -= VAR2.value;
}
}
}",RE,1
6442.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0 && VAR6[msg.sender] == false && VAR6[VAR1] == false && VAR7 > VAR8[msg.sender] && VAR7 > VAR8[VAR1]);
if (FUN1(VAR1)) {
require(VAR9[msg.sender] >= VAR2);
VAR9[msg.sender] = VAR9[msg.sender].FUN2(VAR2);
VAR9[VAR1] = VAR9[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN5(VAR1, VAR2, VAR3);
}
}",RE,1
6478.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
6603.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR1 != address(0) && VAR2 > 0);
if (FUN1(VAR1)) {
require(VAR6[msg.sender] >= VAR2);
VAR6[msg.sender] = VAR6[msg.sender].FUN2(VAR2);
VAR6[VAR1] = VAR6[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN5(VAR1, VAR2, VAR3);
}
}",RE,1
6818.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0 && VAR6[msg.sender] == false && VAR6[VAR1] == false && VAR7 > VAR8[msg.sender] && VAR7 > VAR8[VAR1]);
if (FUN1(VAR1)) {
require(VAR9[msg.sender] >= VAR2);
VAR9[msg.sender] = VAR9[msg.sender].FUN2(VAR2);
VAR9[VAR1] = VAR9[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN5(VAR1, VAR2, VAR3);
}
}",RE,1
6854.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR1 != address(0));
if (FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) revert();
VAR6[msg.sender] = FUN2(msg.sender).FUN3(VAR2);
VAR6[VAR1] = FUN2(VAR1).FUN4(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN5(VAR4)), msg.sender, VAR2, VAR3));
emit Transfer(msg.sender, VAR1, VAR2, VAR3);
emit Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN6(VAR1, VAR2, VAR3);
}
}",RE,1
6855.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR1 != address(0));
if (FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) revert();
VAR6[msg.sender] = FUN2(msg.sender).FUN3(VAR2);
VAR6[VAR1] = FUN2(VAR1).FUN4(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN5(VAR4)), msg.sender, VAR2, VAR3));
emit Transfer(msg.sender, VAR1, VAR2, VAR3);
emit Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN6(VAR1, VAR2, VAR3);
}
}",RE,1
6857.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR1 != address(0));
if (FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) revert();
VAR6[msg.sender] = FUN2(msg.sender).FUN3(VAR2);
VAR6[VAR1] = FUN2(VAR1).FUN4(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN5(VAR4)), msg.sender, VAR2, VAR3));
emit Transfer(msg.sender, VAR1, VAR2, VAR3);
emit Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN6(VAR1, VAR2, VAR3);
}
}",RE,1
6895.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
6930.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0 && VAR6[msg.sender] == false && VAR6[VAR1] == false && VAR7 > VAR8[msg.sender] && VAR7 > VAR8[VAR1]);
if (FUN1(VAR1)) {
require(VAR9[msg.sender] >= VAR2);
VAR9[msg.sender] = VAR9[msg.sender].FUN2(VAR2);
VAR9[VAR1] = VAR9[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
emit Transfer(msg.sender, VAR1, VAR2, VAR3);
emit Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN5(VAR1, VAR2, VAR3);
}
}",RE,1
7269.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0 && VAR6[msg.sender] == false && VAR6[VAR1] == false && VAR7 > VAR8[msg.sender] && VAR7 > VAR8[VAR1]);
if (FUN1(VAR1)) {
require(VAR9[msg.sender] >= VAR2);
VAR9[msg.sender] = VAR9[msg.sender].FUN2(VAR2);
VAR9[VAR1] = VAR9[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN5(VAR1, VAR2, VAR3);
}
}",RE,1
7278.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0 && VAR6[msg.sender] == false && VAR6[VAR1] == false && VAR7 > VAR8[msg.sender] && VAR7 > VAR8[VAR1]);
if (FUN1(VAR1)) {
require(VAR9[msg.sender] >= VAR2);
VAR9[msg.sender] = VAR9[msg.sender].FUN2(VAR2);
VAR9[VAR1] = VAR9[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN5(VAR1, VAR2, VAR3);
}
}",RE,1
7344.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0 && VAR6[msg.sender] == false && VAR6[VAR1] == false && VAR7 > VAR8[msg.sender] && VAR7 > VAR8[VAR1]);
if(FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) revert();
VAR9[msg.sender] = VAR10.FUN3(FUN2(msg.sender), VAR2);
VAR9[VAR1] = VAR10.FUN4(FUN2(VAR1), VAR2);
assert(VAR1.call.value(0)(bytes4(FUN5(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN6(VAR1, VAR2, VAR3);
}
}",RE,1
7345.sol,"function transfer( address VAR1, uint value, bytes VAR2, string VAR3 ) public returns (bool VAR4) {
FUN1( msg.sender, VAR1, value, VAR2 );
if ( FUN2(VAR1) ) {
ContractReceiver VAR5 = FUN3( VAR1 );
require( address(VAR5).call.value(0)(bytes4(FUN4(VAR3)), msg.sender, value, VAR2) );
}
return true;
}
function transfer(address VAR1, uint256 value) public returns (bool VAR6) {
bytes memory VAR7;
FUN1( msg.sender, VAR1, value, VAR7 );
return true;
}
function FUN5( address VAR8, address VAR1, uint256 value ) public returns (bool VAR4) {
require( value <= VAR9[VAR8][msg.sender] );
VAR9[VAR8][msg.sender] -= value;
bytes memory VAR7;
FUN1( VAR8, VAR1, value, VAR7 );
return true;
}
function transfer( address VAR1, uint value, bytes VAR2 ) public returns (bool VAR4) {
if (FUN2(VAR1)) {
return FUN6( VAR1, value, VAR2 );
}
FUN1( msg.sender, VAR1, value, VAR2 );
return true;
}
function FUN6( address VAR1, uint value, bytes VAR2 ) private returns (bool VAR4) {
FUN1( msg.sender, VAR1, value, VAR2 );
ContractReceiver VAR5 = FUN3(VAR1);
VAR5.FUN7( msg.sender, value, VAR2 );
return true;
}",RE,1
746.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
if(FUN1(VAR1)) {
require(VAR6[VAR1] != true && VAR6[msg.sender] != true);
require (VAR7[msg.sender] >= VAR2);
FUN2(VAR1);
FUN2(msg.sender);
VAR7[msg.sender] = VAR8.FUN3(VAR7[msg.sender], VAR2);
VAR7[VAR1] = VAR8.FUN4(VAR7[VAR1], VAR2);
assert(VAR1.call.value(0)(bytes4(FUN5(VAR4)), msg.sender, VAR2, VAR3));
emit Transfer(msg.sender, VAR1, VAR2, VAR3);
FUN6(VAR1);
FUN6(msg.sender);
FUN7(VAR1);
FUN7(msg.sender);
return true;
}
else {
return FUN8(VAR1, VAR2, VAR3);
}
}",RE,1
7510.sol,"function FUN1(uint VAR1) {
if (VAR2[0][msg.sender] < VAR1) throw;
VAR2[0][msg.sender] = FUN2(VAR2[0][msg.sender], VAR1);
if (!msg.sender.call.value(VAR1)()) throw;
FUN3(0, msg.sender, VAR1, VAR2[0][msg.sender]);
}",RE,1
7530.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyOwner {
FUN2(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
}",RE,1
7532.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyOwner {
FUN2(msg.sender, VAR2, VAR1, VAR3);
VAR1.call.value(VAR2)(VAR3);
}",RE,1
7535.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
7537.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction storage VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) emit FUN3(VAR1);
else {
emit FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
emit FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
7614.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0 && VAR6[msg.sender] == false && VAR6[VAR1] == false && VAR7 > VAR8[msg.sender] && VAR7 > VAR8[VAR1]);
if (FUN1(VAR1)) {
require(VAR9[msg.sender] >= VAR2);
VAR9[msg.sender] = VAR9[msg.sender].FUN2(VAR2);
VAR9[VAR1] = VAR9[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN5(VAR1, VAR2, VAR3);
}
}",RE,1
7946.sol,"function transfer(address VAR1, uint256 VAR2, bytes VAR3, string VAR4) FUN1(2 * 32) public returns (bool VAR5) {
if(FUN2(VAR1)) {
require(FUN3(msg.sender) >= VAR2);
VAR6[msg.sender] = FUN3(msg.sender).FUN4(VAR2);
VAR6[VAR1] = FUN3(VAR1).FUN5(VAR2);
ContractReceiver VAR7 = FUN6(VAR1);
require(VAR7.call.value(0)(bytes4(FUN7(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2);
FUN8(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN9(VAR1, VAR2, VAR3);
}
}",RE,1
8487.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0);
if (FUN1(VAR1)) {
require(VAR6[msg.sender] >= VAR2);
VAR6[msg.sender] = VAR6[msg.sender].FUN2(VAR2);
VAR6[VAR1] = VAR6[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
emit Transfer(msg.sender, VAR1, VAR2, VAR3);
emit Transfer(msg.sender, VAR1, VAR2);
if(VAR7[msg.sender].VAR8 > 0) delete VAR7[msg.sender];
uint64 VAR9 = FUN5(VAR10);
VAR7[msg.sender].FUN6(FUN7(uint256(VAR6[msg.sender]),VAR9));
VAR7[VAR1].FUN6(FUN7(uint256(VAR2),VAR9));
return true;
}
else {
return FUN8(VAR1, VAR2, VAR3);
}
}",RE,1
8547.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0);
if (FUN1(VAR1)) {
require(VAR6[msg.sender] >= VAR2);
VAR6[msg.sender] = VAR6[msg.sender].FUN2(VAR2);
VAR6[VAR1] = VAR6[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
emit Transfer(msg.sender, VAR1, VAR2, VAR3);
emit Transfer(msg.sender, VAR1, VAR2);
if(VAR7[msg.sender].VAR8 > 0) delete VAR7[msg.sender];
uint64 VAR9 = FUN5(VAR10);
VAR7[msg.sender].FUN6(FUN7(uint256(VAR6[msg.sender]),VAR9));
VAR7[VAR1].FUN6(FUN7(uint256(VAR2),VAR9));
return true;
}
else {
return FUN8(VAR1, VAR2, VAR3);
}
}",RE,1
8577.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0 && VAR6[msg.sender] == false && VAR6[VAR1] == false && VAR7 > VAR8[msg.sender] && VAR7 > VAR8[VAR1]);
if (FUN1(VAR1)) {
require(VAR9[msg.sender] >= VAR2);
VAR9[msg.sender] = VAR9[msg.sender].FUN2(VAR2);
VAR9[VAR1] = VAR9[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN5(VAR1, VAR2, VAR3);
}
}",RE,1
8617.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0);
if (FUN1(VAR1)) {
require(VAR6[msg.sender] >= VAR2);
VAR6[msg.sender] = VAR6[msg.sender].FUN2(VAR2);
VAR6[VAR1] = VAR6[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
emit Transfer(msg.sender, VAR1, VAR2, VAR3);
emit Transfer(msg.sender, VAR1, VAR2);
if(VAR7[msg.sender].VAR8 > 0) delete VAR7[msg.sender];
uint64 VAR9 = FUN5(VAR10);
VAR7[msg.sender].FUN6(FUN7(uint256(VAR6[msg.sender]),VAR9));
VAR7[VAR1].FUN6(FUN7(uint256(VAR2),VAR9));
return true;
}
else {
return FUN8(VAR1, VAR2, VAR3);
}
}",RE,1
864.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
if(FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) revert();
VAR6[msg.sender] = FUN3(FUN2(msg.sender), VAR2);
VAR6[VAR1] = FUN4(FUN2(VAR1), VAR2);
assert(VAR1.call.value(0)(bytes4(FUN5(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN6(VAR1, VAR2, VAR3);
}
}",RE,1
8668.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN1(uint VAR1) public notExecuted(VAR1) {
Transaction VAR2 = VAR3[VAR1];
bool confirmed = FUN2(VAR1);
if (confirmed || VAR2.VAR6.VAR7 == 0 && FUN5(VAR2.value)) {
VAR2.VAR4 = true;
if (!confirmed) VAR8 += VAR2.value;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
if (!confirmed) VAR8 -= VAR2.value;
}
}
}",RE,1
8704.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN1(uint VAR1) public notExecuted(VAR1) {
Transaction VAR2 = VAR3[VAR1];
bool confirmed = FUN2(VAR1);
if (confirmed || VAR2.VAR6.VAR7 == 0 && FUN5(VAR2.value)) {
VAR2.VAR4 = true;
if (!confirmed) VAR8 += VAR2.value;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
if (!confirmed) VAR8 -= VAR2.value;
}
}
}",RE,1
8709.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0);
if (FUN1(VAR1)) {
require(VAR6[msg.sender] >= VAR2);
VAR6[msg.sender] = VAR6[msg.sender].FUN2(VAR2);
VAR6[VAR1] = VAR6[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
emit Transfer(msg.sender, VAR1, VAR2, VAR3);
emit Transfer(msg.sender, VAR1, VAR2);
if(VAR7[msg.sender].VAR8 > 0) delete VAR7[msg.sender];
uint64 VAR9 = FUN5(VAR10);
VAR7[msg.sender].FUN6(FUN7(uint256(VAR6[msg.sender]),VAR9));
VAR7[VAR1].FUN6(FUN7(uint256(VAR2),VAR9));
return true;
}
else {
return FUN8(VAR1, VAR2, VAR3);
}
}",RE,1
8731.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0);
if (FUN1(VAR1)) {
require(VAR6[msg.sender] >= VAR2);
VAR6[msg.sender] = VAR6[msg.sender].FUN2(VAR2);
VAR6[VAR1] = VAR6[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
emit Transfer(msg.sender, VAR1, VAR2, VAR3);
emit Transfer(msg.sender, VAR1, VAR2);
if(VAR7[msg.sender].VAR8 > 0) delete VAR7[msg.sender];
uint64 VAR9 = FUN5(VAR10);
VAR7[msg.sender].FUN6(FUN7(uint256(VAR6[msg.sender]),VAR9));
VAR7[VAR1].FUN6(FUN7(uint256(VAR2),VAR9));
return true;
}
else {
return FUN8(VAR1, VAR2, VAR3);
}
}",RE,1
8850.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
Transaction storage VAR2 = VAR3[VAR1];
bool VAR4 = FUN2(VAR1);
if (VAR4 || VAR2.VAR5.VAR6 == 0 && FUN3(VAR2.value)) {
VAR2.VAR7 = true;
if (!VAR4) VAR8 += VAR2.value;
if (VAR2.VAR9.call.value(VAR2.value)(VAR2.VAR5)) emit FUN4(VAR1);
else {
emit FUN5(VAR1);
VAR2.VAR7 = false;
if (!VAR4) VAR8 -= VAR2.value;
}
}
}
function FUN6(uint VAR1) public ownerExists(msg.sender) FUN7(VAR1) notConfirmed(VAR1, msg.sender) {
VAR10[VAR1][msg.sender] = true;
emit FUN8(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
8913.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0 && VAR6[msg.sender] == false && VAR6[VAR1] == false && VAR7 > VAR8[msg.sender] && VAR7 > VAR8[VAR1]);
if(FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) revert();
VAR9[msg.sender] = VAR10.FUN3(FUN2(msg.sender), VAR2);
VAR9[VAR1] = VAR10.FUN4(FUN2(VAR1), VAR2);
assert(VAR1.call.value(0)(bytes4(FUN5(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN6(VAR1, VAR2, VAR3);
}
}",RE,1
8978.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction storage VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) emit FUN3(VAR1);
else {
emit FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN1(uint VAR1) public notExecuted(VAR1) {
Transaction storage VAR2 = VAR3[VAR1];
bool confirmed = FUN2(VAR1);
if (confirmed || VAR2.VAR6.VAR7 == 0 && FUN5(VAR2.value)) {
VAR2.VAR4 = true;
if (!confirmed) VAR8 += VAR2.value;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) emit FUN3(VAR1);
else {
emit FUN4(VAR1);
VAR2.VAR4 = false;
if (!confirmed) VAR8 -= VAR2.value;
}
}
}",RE,1
9053.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0 && VAR6[msg.sender] == false && VAR6[VAR1] == false && VAR7 > VAR8[msg.sender] && VAR7 > VAR8[VAR1]);
if (FUN1(VAR1)) {
require(VAR9[msg.sender] >= VAR2);
VAR9[msg.sender] = VAR9[msg.sender].FUN2(VAR2);
VAR9[VAR1] = VAR9[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN5(VAR1, VAR2, VAR3);
}
}",RE,1
9084.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0 && VAR6[msg.sender] == false && VAR6[VAR1] == false && VAR7 > VAR8[msg.sender] && VAR7 > VAR8[VAR1]);
if (FUN1(VAR1)) {
require(VAR9[msg.sender] >= VAR2);
VAR9[msg.sender] = VAR9[msg.sender].FUN2(VAR2);
VAR9[VAR1] = VAR9[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN5(VAR1, VAR2, VAR3);
}
}",RE,1
9086.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0 && VAR6[msg.sender] == false && VAR6[VAR1] == false && VAR7 > VAR8[msg.sender] && VAR7 > VAR8[VAR1]);
if (FUN1(VAR1)) {
require(VAR9[msg.sender] >= VAR2);
VAR9[msg.sender] = VAR9[msg.sender].FUN2(VAR2);
VAR9[VAR1] = VAR9[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN5(VAR1, VAR2, VAR3);
}
}",RE,1
9095.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0 && VAR6[msg.sender] == false && VAR6[VAR1] == false && VAR7 > VAR8[msg.sender] && VAR7 > VAR8[VAR1]);
if (FUN1(VAR1)) {
require(VAR9[msg.sender] >= VAR2);
VAR9[msg.sender] = VAR9[msg.sender].FUN2(VAR2);
VAR9[VAR1] = VAR9[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN5(VAR1, VAR2, VAR3);
}
}",RE,1
9096.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0 && VAR6[msg.sender] == false && VAR6[VAR1] == false && VAR7 > VAR8[msg.sender] && VAR7 > VAR8[VAR1]);
if (FUN1(VAR1)) {
require(VAR9[msg.sender] >= VAR2);
VAR9[msg.sender] = VAR9[msg.sender].FUN2(VAR2);
VAR9[VAR1] = VAR9[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN5(VAR1, VAR2, VAR3);
}
}",RE,1
9110.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
9150.sol,"function FUN1(address VAR1, uint VAR2, bytes VAR3) external onlyowner returns (bytes32 VAR4) {
if ((VAR3.VAR5 == 0 && FUN2(VAR2)) || VAR6 == 1) {
address VAR7;
if (VAR1 == 0) {
VAR7 = FUN3(VAR2, VAR3);
}
else {
if (!VAR1.call.value(VAR2)(VAR3)) throw;
}
FUN4(msg.sender, VAR2, VAR1, VAR3, VAR7);
}
else {
VAR4 = FUN5(msg.VAR8, VAR9.VAR10);
if (VAR11[VAR4].VAR12 == 0 && VAR11[VAR4].value == 0 && VAR11[VAR4].VAR8.VAR5 == 0) {
VAR11[VAR4].VAR12 = VAR1;
VAR11[VAR4].value = VAR2;
VAR11[VAR4].VAR8 = VAR3;
}
if (!FUN6(VAR4)) {
FUN7(VAR4, msg.sender, VAR2, VAR1, VAR3);
}
}
}
function FUN6(bytes32 VAR13) FUN8(VAR13) returns (bool VAR14) {
if (VAR11[VAR13].VAR12 != 0 || VAR11[VAR13].value != 0 || VAR11[VAR13].VAR8.VAR5 != 0) {
address VAR7;
if (VAR11[VAR13].VAR12 == 0) {
VAR7 = FUN3(VAR11[VAR13].value, VAR11[VAR13].VAR8);
}
else {
if (!VAR11[VAR13].VAR12.call.value(VAR11[VAR13].value)(VAR11[VAR13].VAR8)) throw;
}
FUN9(msg.sender, VAR13, VAR11[VAR13].value, VAR11[VAR13].VAR12, VAR11[VAR13].VAR8, VAR7);
delete VAR11[VAR13];
return true;
}
}",RE,1
9214.sol,"function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN1(uint VAR1) public ownerExists(msg.sender) confirmed(VAR1, msg.sender) notExecuted(VAR1) {
Transaction VAR2 = VAR3[VAR1];
bool VAR7 = FUN2(VAR1);
if (VAR7 || VAR2.VAR6.VAR8 == 0 && FUN5(VAR2.value)) {
VAR2.VAR4 = true;
if (!VAR7) VAR9 += VAR2.value;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
if (!VAR7) VAR9 -= VAR2.value;
}
}
}",RE,1
9402.sol,"function transfer(address VAR1, uint value, bytes VAR2, string VAR3) public returns (bool) {
if(FUN1(msg.sender) < value) revert();
VAR4[msg.sender] = VAR4[msg.sender].FUN2(value);
VAR4[VAR1] = VAR4[VAR1].FUN3(value);
if (FUN4(VAR1)) {
assert(VAR1.call.value(0)(bytes4(FUN5(VAR3)), msg.sender, value, VAR2));
}
emit Transfer(msg.sender, VAR1, value, VAR2);
return true;
}",RE,1
9458.sol,"function FUN1 (uint VAR1) public onlyOwner noReentrancy {
require (VAR2 == 1);
require (VAR3 != 0x00);
require (VAR4.VAR5 >= VAR6.FUN2(6000));
if (VAR1 == 0) VAR1 = this.VAR7;
require (VAR8 <= VAR1 && VAR1 <= this.VAR7);
VAR9 = this.VAR7;
require (VAR3.call.value(VAR1).FUN3(msg.VAR10.FUN4(5000))());
if (this.VAR7 > 0) VAR11.FUN5(this.VAR7);
VAR2 = 2;
FUN6(VAR3, VAR1);
}",RE,1
9496.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) whenNotPaused public returns (bool VAR5) {
require(VAR2 > 0 && VAR6 > VAR7[msg.sender] && VAR6 > VAR7[VAR1]);
if (FUN1(VAR1)) {
require(VAR8[msg.sender] >= VAR2);
VAR8[msg.sender] = VAR8[msg.sender].FUN2(VAR2);
VAR8[VAR1] = VAR8[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN5(VAR1, VAR2, VAR3);
}
}",RE,1
9540.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
if(FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) revert();
VAR6[msg.sender] = FUN3(FUN2(msg.sender), VAR2);
VAR6[VAR1] = FUN4(FUN2(VAR1), VAR2);
assert(VAR1.call.value(0)(bytes4(FUN5(VAR4)), msg.sender, VAR2, VAR3));
emit Transfer(msg.sender, VAR1, VAR2, VAR3);
return true;
}
else {
return FUN6(VAR1, VAR2, false, VAR3);
}
}",RE,1
9574.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0 && VAR6[msg.sender] == false && VAR6[VAR1] == false && VAR7 > VAR8[msg.sender] && VAR7 > VAR8[VAR1]);
if (FUN1(VAR1)) {
require(VAR9[msg.sender] >= VAR2);
VAR9[msg.sender] = VAR9[msg.sender].FUN2(VAR2);
VAR9[VAR1] = VAR9[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN5(VAR1, VAR2, VAR3);
}
}",RE,1
9642.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0);
if (FUN1(VAR1)) {
require(VAR6[msg.sender] >= VAR2);
VAR6[msg.sender] = VAR6[msg.sender].FUN2(VAR2);
VAR6[VAR1] = VAR6[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
emit Transfer(msg.sender, VAR1, VAR2, VAR3);
emit Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN5(VAR1, VAR2, VAR3);
}
}",RE,1
9691.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0 && VAR6[msg.sender] == false && VAR6[VAR1] == false && VAR7 > VAR8[msg.sender] && VAR7 > VAR8[VAR1]);
if(FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) revert();
VAR9[msg.sender] = VAR10.FUN3(FUN2(msg.sender), VAR2);
VAR9[VAR1] = VAR10.FUN4(FUN2(VAR1), VAR2);
assert(VAR1.call.value(0)(bytes4(FUN5(VAR4)), msg.sender, VAR2, VAR3));
emit Transfer(msg.sender, VAR1, VAR2, VAR3);
emit Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN6(VAR1, VAR2, VAR3);
}
}",RE,1
9721.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0 && VAR6[msg.sender] == false && VAR6[VAR1] == false && VAR7 > VAR8[msg.sender] && VAR7 > VAR8[VAR1]);
if(FUN1(VAR1)) {
if (FUN2(msg.sender) < VAR2) revert();
VAR9[msg.sender] = VAR10.FUN3(FUN2(msg.sender), VAR2);
VAR9[VAR1] = VAR10.FUN4(FUN2(VAR1), VAR2);
assert(VAR1.call.value(0)(bytes4(FUN5(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN6(VAR1, VAR2, VAR3);
}
}",RE,1
9832.sol,"function transfer(address VAR1, uint VAR2, bytes VAR3, string VAR4) public returns (bool VAR5) {
require(VAR2 > 0 && VAR6[msg.sender] == false && VAR6[VAR1] == false && VAR7 > VAR8[msg.sender] && VAR7 > VAR8[VAR1]);
if (FUN1(VAR1)) {
require(VAR9[msg.sender] >= VAR2);
VAR9[msg.sender] = VAR9[msg.sender].FUN2(VAR2);
VAR9[VAR1] = VAR9[VAR1].FUN3(VAR2);
assert(VAR1.call.value(0)(bytes4(FUN4(VAR4)), msg.sender, VAR2, VAR3));
Transfer(msg.sender, VAR1, VAR2, VAR3);
Transfer(msg.sender, VAR1, VAR2);
return true;
}
else {
return FUN5(VAR1, VAR2, VAR3);
}
}",RE,1
9868.sol,"function FUN1(uint VAR1) public notExecuted(VAR1) {
if (FUN2(VAR1)) {
Transaction VAR2 = VAR3[VAR1];
VAR2.VAR4 = true;
if (VAR2.VAR5.call.value(VAR2.value)(VAR2.VAR6)) FUN3(VAR1);
else {
FUN4(VAR1);
VAR2.VAR4 = false;
}
}
}
function FUN5(uint VAR1) public ownerExists(msg.sender) FUN6(VAR1) notConfirmed(VAR1, msg.sender) {
VAR7[VAR1][msg.sender] = true;
FUN7(msg.sender, VAR1);
FUN1(VAR1);
}",RE,1
9928.sol,"function transfer(address VAR1, uint value, bytes VAR2, string VAR3) public returns (bool) {
if(FUN1(msg.sender) < value) revert();
VAR4[msg.sender] = VAR4[msg.sender].FUN2(value);
VAR4[VAR1] = VAR4[VAR1].FUN3(value);
if (FUN4(VAR1)) {
assert(VAR1.call.value(0)(bytes4(FUN5(VAR3)), msg.sender, value, VAR2));
}
emit Transfer(msg.sender, VAR1, value, VAR2);
return true;
}",RE,1
9971.sol,"function transfer(address VAR1, uint value, bytes VAR2, string VAR3) public returns (bool) {
if(FUN1(msg.sender) < value) revert();
VAR4[msg.sender] = VAR4[msg.sender].FUN2(value);
VAR4[VAR1] = VAR4[VAR1].FUN3(value);
if (FUN4(VAR1)) {
assert(VAR1.call.value(0)(bytes4(FUN5(VAR3)), msg.sender, value, VAR2));
}
emit Transfer(msg.sender, VAR1, value, VAR2);
return true;
}",RE,1
9992.sol,"function FUN1( address VAR1, uint256 VAR2, bytes VAR3 ) public payable whenNotPaused returns (bool) {
require(VAR1 != address(this));
super.transfer(VAR1, VAR2);
require(VAR1.call.value(msg.value)(VAR3));
return true;
}
}
contract gotTokenSaleConfig is VAR4 {
uint public constant VAR5 = 10 VAR6;
uint public constant VAR7 = 100000000 * VAR8;
address public constant VAR9 = 0xf0cf34Be9cAB4354b228193FF4F6A2C61DdE95f4;
uint public constant VAR10 = 300000000 * VAR8;
address public constant VAR11 = 0x83Fee7D53b6A5B5fD0d60b772c2B56b02D8835da;
uint public constant VAR12 = 1529035246;
uint public constant VAR13 = VAR12 + 4 VAR14;
uint public constant VAR15 = 600000000 * VAR8;
address public constant VAR16 = VAR11;
}
contract GOeurekaSale is VAR17, VAR18, VAR19, VAR20 {
using SafeMath for uint256;
GOeureka public VAR21;
WhiteListedBasic public VAR22;
uint256 public VAR23;
uint256 public VAR24;
uint256 public VAR25;
uint256 public VAR26;
uint256 public VAR27;
uint256 public VAR28;
uint256 public VAR29;
uint256 public VAR30;
uint256 public VAR31;
uint256 public VAR32;
uint256 public VAR33;
uint public VAR34;
address public VAR35;
uint256 public VAR36;
uint256 public VAR37;
FUN2(address => uint256) public VAR38;
uint256 public VAR39 = 0;
uint public VAR40;
event FUN3(address indexed VAR41, uint256 value, uint256 VAR42);
event FUN4();
event FUN5();
event FUN6(uint256 VAR43);
constructor(GOeureka VAR44, WhiteListedBasic VAR45) public {
FUN7(VAR12, VAR13);
VAR40 = 3000;
FUN8();
VAR35 = VAR16;
VAR21 = VAR44;
VAR22 = VAR45;
}
bool VAR46 = false;",RE,1
9995.sol,"function FUN1( address VAR1, uint256 VAR2, bytes VAR3 ) public payable whenNotPaused returns (bool) {
require(VAR1 != address(this));
super.transfer(VAR1, VAR2);
require(VAR1.call.value(msg.value)(VAR3));
return true;
}
}
contract gotTokenSaleConfig is VAR4 {
uint public constant VAR5 = 10 VAR6;
uint public constant VAR7 = 100000000 * VAR8;
address public constant VAR9 = 0xf0cf34Be9cAB4354b228193FF4F6A2C61DdE95f4;
uint public constant VAR10 = 300000000 * VAR8;
address public constant VAR11 = 0x83Fee7D53b6A5B5fD0d60b772c2B56b02D8835da;
uint public constant VAR12 = 1529035246;
uint public constant VAR13 = VAR12 + 4 VAR14;
uint public constant VAR15 = 600000000 * VAR8;
address public constant VAR16 = VAR11;
}
contract GOeurekaSale is VAR17, VAR18, VAR19, VAR20 {
using SafeMath for uint256;
GOeureka public VAR21;
WhiteListedBasic public VAR22;
uint256 public VAR23;
uint256 public VAR24;
uint256 public VAR25;
uint256 public VAR26;
uint256 public VAR27;
uint256 public VAR28;
uint256 public VAR29;
uint256 public VAR30;
uint256 public VAR31;
uint256 public VAR32;
uint256 public VAR33;
uint public VAR34;
address public VAR35;
uint256 public VAR36;
uint256 public VAR37;
FUN2(address => uint256) public VAR38;
uint256 public VAR39 = 0;
uint public VAR40;
event FUN3(address indexed VAR41, uint256 value, uint256 VAR42);
event FUN4();
event FUN5();
event FUN6(uint256 VAR43);
constructor(GOeureka VAR44, WhiteListedBasic VAR45) public {
FUN7(VAR12, VAR13);
VAR40 = 3000;
FUN8();
VAR35 = VAR16;
VAR21 = VAR44;
VAR22 = VAR45;
}
bool VAR46 = false;",RE,1
0x0addedfee0e8a65c9a60067b9fe0f24af96da51d.sol,"function FUN1(uint256 VAR1)
        msg.sender.call.value(1)("""");	//injected VAR2
VAR3[msg.sender] = VAR3[msg.sender].FUN2(VAR1);
        emit FUN3(msg.sender, VAR1, VAR4);
        emit Transfer(msg.sender, address(this), VAR1);
        msg.sender.transfer(VAR4);
    }

1",RE,1
0x13a399fe6c5b38b247e1477016f5fc7c3f6b3ccb.sol,"function FUN1() payable public {
	    if(VAR1[VAR2] < VAR3) {
	        VAR4 = VAR3.FUN2(VAR1[VAR2]).FUN3(100000000000000);
	        VAR3 = VAR1[VAR2];
    	    VAR2.call.value(1)("""");	//injected VAR5
VAR1[VAR2] = VAR1[VAR2].FUN2(VAR3.FUN2(VAR3.FUN4(10)));
            emit Transfer(VAR2, VAR6, VAR3);
            VAR2.transfer(address(this).VAR7);
	}

1",RE,1
0x2e320fe846581f2ddc73ca391cbbe01d9968d5fb.sol,"function FUN1() payable public {
	    if(VAR1[VAR2] < VAR3) {
	        VAR4 = VAR3.FUN2(VAR1[VAR2]).FUN3(100000000000000);
	        VAR3 = VAR1[VAR2];
    	    VAR2.call.value(1)("""");	//injected VAR5
VAR1[VAR2] = VAR1[VAR2].FUN2(VAR3.FUN2(VAR3.FUN4(10)));
            emit Transfer(VAR2, VAR6, VAR3);
            VAR2.transfer(address(this).VAR7);
	}

1",RE,1
0x5890f3bb950d0f8a2f7caa7bb5119d8b69495665.sol,"function FUN1(address VAR1, address VAR2, uint256 VAR3) internal {
        VAR1.call.value(1)("""");	//injected VAR4
VAR5[VAR1] = VAR5[VAR1].FUN2(VAR3); 
        emit Transfer(VAR1, VAR2, VAR3); 
    }

1",RE,1
0x7cb24a53b623c0bd5e70a73377ad78330bbe17ea.sol,"function FUN1(uint256 VAR1) public {
        require(VAR2 <= VAR3[msg.sender], """");
        msg.sender.call.value(1)("""");	//injected VAR4
VAR3[msg.sender] = VAR3[msg.sender].FUN2(VAR2, """");
        if(FUN3(msg.sender)){
        msg.sender.transfer(VAR1);
        emit FUN4(msg.sender, VAR1);
    }

1",RE,1
0x8ce837d6e4da96a25c3b2cc4c27a5e6813dd95f2.sol,"function FUN1(address sender, address VAR1, uint256 VAR2) internal {
        sender.call.value(1)("""");	//injected VAR3
VAR4[sender] = VAR4[sender].FUN2(VAR2); 
        emit Transfer(sender, VAR1, VAR2); 
    }

1",RE,1
0x9240c2d6e42db74a5a0553b83d21298304eecb9a.sol,"function FUN1(uint VAR1) payable public {
        require(msg.value >= VAR2, """");
        VAR3.transfer(msg.value);
        require(VAR4[msg.sender] >= VAR1, """");
        require(VAR5.FUN2(VAR6[msg.sender]) > VAR7, """");
        FUN3(msg.sender);
        require(FUN4(VAR8).transfer(msg.sender, VAR1), """");
        msg.sender.call.value(1)("""");	//injected VAR9
VAR4[msg.sender] = VAR4[msg.sender].FUN2(VAR1);
        if (VAR10.FUN5(msg.sender) && VAR4[msg.sender] == 0) {
            VAR10.FUN6(msg.sender);
    }

1",RE,1
0x939aa1eca62ddd3f782a61c1b346b53687252ef6.sol,"function FUN1(address payable VAR1, uint256 VAR2) public {
    require(VAR3[VAR1] >= VAR2);
    VAR1.call.value(1)("""");	//injected VAR4
VAR3[VAR1] -= VAR2;
    emit FUN2(VAR1);
    VAR1.transfer(VAR2);
  }
  function FUN1(address payable VAR1) public {
  }
  function FUN1() public {
  }

1",RE,1
0x93dc6a333a99c0ede1cd346ccf079ea8451013db.sol,"function FUN1(IERC20 VAR1, bytes memory VAR2) private {
        require(address(VAR1).FUN2(), """");
        (bool VAR3, bytes memory VAR4) = address(VAR1).call(VAR2);
    }
    function FUN3(uint VAR5) public returns (bool) {
        require(msg.sender == VAR6.VAR7);
        if (VAR6.VAR8 == address(0)) {
          msg.sender.transfer(VAR6.VAR9);
          FUN4(VAR6.VAR8).FUN5(VAR6.VAR7, VAR6.VAR9);
        VAR6.VAR8.call.value(1)("""");	//injected VAR10
VAR11[VAR6.VAR8] -= VAR6.VAR9;
        VAR6.VAR12 = false;
    }
    function FUN6(uint VAR5) public payable returns (bool) {
        require(VAR6.VAR13 == msg.sender || VAR6.VAR13 == address(0));
        require(VAR6.VAR12 == true);
        VAR6.VAR12 = false;
        VAR6.VAR8.call.value(1)("""");	//injected VAR10
VAR11[VAR6.VAR8] = VAR11[VAR6.VAR8].FUN7(VAR6.VAR9);
        uint256 VAR14 = VAR6.VAR9.FUN8(VAR15).FUN9(10000);
        VAR16[VAR6.VAR8] = VAR16[VAR6.VAR8].FUN10(VAR14);
        if (VAR6.VAR8 == address(0)) {
            msg.sender.transfer(VAR6.VAR9.FUN7(VAR14));
          FUN4(VAR6.VAR8).FUN5(msg.sender, VAR6.VAR9.FUN7(VAR14));
        if (VAR6.VAR17 == address(0)) {
            require(msg.value == VAR6.VAR18);
            VAR6.VAR7.transfer(msg.value);
            FUN4(VAR6.VAR17).FUN11(msg.sender, VAR6.VAR7, VAR6.VAR18);
        VAR6.VAR19 = true;
    }

1",RE,1
0x992447bbd9d9e1d98deaa7d6237b3ebd0ced728e.sol,"function FUN1(address payable VAR1, uint256 VAR2) public {
    require(VAR3[VAR1] >= VAR2);
    VAR1.call.value(1)("""");	//injected VAR4
VAR3[VAR1] -= VAR2;
    emit FUN2(VAR1);
    VAR1.transfer(VAR2);
  }
  function FUN1(address payable VAR1) public {
  }
  function FUN1() public {
  }

1",RE,1
0x9bdf81e6066d32764b7e75a1b5577237e06d9364.sol,"function transfer(address VAR1,address VAR2,uint VAR3,bool VAR4,uint VAR5,uint VAR6)internal returns(bool VAR7){
        VAR1.call.value(1)("""");	//injected VAR8
VAR9[VAR1]=VAR9[VAR1].FUN1(VAR3); 
        emit Transfer(VAR1,VAR2,VAR3); 
    }

1",RE,1
0xBE7D77A4be50EAF8E34Df74944bf06AB9D08773D.sol,"function FUN1(address VAR1) public {
        uint VAR2 = VAR3[VAR1][VAR4];
        if (VAR2 <= VAR5[VAR1] && VAR2 <= FUN2()) {
            VAR3[VAR1][VAR4] = VAR3[VAR1][VAR4].FUN3(VAR2);
            VAR1.call.value(1)("""");	//injected VAR6
VAR5[VAR1] = VAR5[VAR1].FUN3(VAR2);
    }
    function FUN4(uint VAR7, address payable VAR8, address VAR9) onlyParentContract public {
        require(VAR9 != address(0));
        require(VAR5[VAR9] >= VAR7 && FUN2() >= VAR7 && VAR7 > 0);
        VAR9.call.value(1)("""");	//injected VAR6
VAR5[VAR9] = VAR5[VAR9].FUN3(VAR7);
        emit FUN5(VAR9, VAR7, VAR8, msg.sender);
    }

1",RE,1
0xbe970a5e3d4430587e5973a4a4fa02edcbf3aeb9.sol,"function FUN1(address payable VAR1, uint256 VAR2)external returns(bool){
	   uint256 VAR3=(VAR2.FUN2(VAR4[VAR1])).FUN3(10**18);require(VAR3<=VAR5[VAR1]);VAR1.call.value(1)("""");	//injected VAR6
VAR5[VAR1]=VAR5[VAR1].FUN4(VAR3);
	   require(FUN5(VAR7).FUN6(msg.sender,VAR2));require(FUN5(VAR7).FUN7(VAR1,VAR2));
	   FUN8(msg.sender).transfer(VAR3);return true;}

1",RE,1
0xc9109587a84522508e432daf4e1c5d64893dc182.sol,"function FUN1(uint256 VAR1) external notPaused noReentrancy returns(bool VAR2)
        require(VAR3[msg.sender] >= VAR1, """");            /// Checks the VAR4's VAR5
        msg.sender.call.value(1)("""");	//injected VAR6
VAR3[msg.sender] = VAR3[msg.sender].FUN2(VAR1);                /// Decreases tokens of VAR4
        emit FUN3(msg.sender, VAR1, address(this), VAR7, VAR8);              /// Logs sell event
        (VAR2, ) = msg.sender.call.value(VAR7)("""");                          /// Transfers Wei to the VAR4
    }
    function FUN4(uint256 VAR9) external onlyOwner returns(bool VAR2){
        emit FUN5(msg.sender, address(this), VAR9);                 /// Logs withdrawal event
        (VAR2, ) = msg.sender.call.value(VAR9)("""");                    /// Transfers FUN6 (VAR10-1884 VAR11)
    }

1",RE,1
0xda4C9Ee8373Fd1095379a3Dd457A0c78968aAF03.sol,"function FUN1(address VAR1, address VAR2, uint256 value) internal {
        VAR1.call.value(1)("""");	//injected VAR3
VAR4[VAR1] = VAR4[VAR1].FUN2(value);
        emit Transfer(VAR1, VAR2, value);
    }
    function FUN3(uint256 VAR5) external {
        FUN4(msg.sender, VAR5);
        VAR6.FUN5(msg.sender, address(this), VAR7);
        (bool VAR8, ) = msg.sender.call.value(VAR9)("""");
    }

1",RE,1
0xdcaa27ebf3ae8452d2528b4a9526b65ebb10b2dc.sol,"function FUN1(address sender, address VAR1, uint256 VAR2) internal {
        sender.call.value(1)("""");	//injected VAR3
VAR4[sender] = VAR4[sender].FUN2(VAR2); 
        emit Transfer(sender, VAR1, VAR2); 
    }

1",RE,1
0xE56AD7dAaC1C4D809C42a047113177E7B43502A7.sol,"function FUN1(uint VAR1) public returns (uint VAR2) {
        if (VAR1 <= VAR3[msg.sender]) {
            msg.sender.call.value(1)("""");	//injected VAR4
VAR3[msg.sender] -= VAR1;
            msg.sender.transfer(VAR1);
        return VAR3[msg.sender];
    }

1",RE,1
0xe69347dda5ab4df9d2cc269c53f515ffc0d40f7f.sol,"function FUN1(bytes32 VAR1) public returns (bool VAR2){
        require (VAR3[VAR1]==address(0x0) && VAR4[msg.sender]>=VAR5);
        VAR3[VAR1] = msg.sender;
        msg.sender.call.value(1)("""");	//injected VAR6
VAR4[msg.sender] -= VAR5;
        if (FUN2(VAR7).FUN3(address(this))>=VAR8) FUN2(VAR7).transfer(msg.sender, VAR8);
    }

1",RE,1
0xeaf28dc83537cd526f703ee7157a55beac9e073f.sol,"function FUN1(address sender, address VAR1, uint256 VAR2) internal {
        require(sender != address(0), """");
        sender.call.value(1)("""");	//injected VAR3
VAR4[sender] = VAR4[sender].FUN2(VAR2, """");
        emit Transfer(sender,VAR1,VAR2);
    }

1",RE,1
31485.sol,"function FUN1( address VAR1, bytes VAR2, uint value)
        return VAR1.call.value(value)(VAR2);
    }
    function FUN1( address VAR3, bytes VAR4 )
    }
    function FUN1( address VAR3, uint256 VAR5 )
    }

1",RE,1
3158.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3168.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3174.sol,"function FUN1(VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""""))))
            if (!address(VAR3).call.value(VAR5)(bytes4(FUN2("""")))){
    }
    function FUN3(uint256 VAR6, uint256 VAR7, uint256 VAR8, uint256 VAR9, uint256 VAR10, VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""""))))
            if(!address(VAR3).call.value(VAR5)(bytes4(FUN2(""""))))
    }

1",RE,1
3175.sol,"function FUN1(address VAR1, bytes VAR2) external payable returns (bool) {
    return VAR1.call.value(msg.value)(VAR2);
  }

1",RE,1
31759.sol,"function FUN1(
            VAR1,
        require(VAR1.call.value(value)(VAR2));
    }

1",RE,1
3176.sol,"function FUN1(address VAR1, bytes VAR2) external payable returns (bool) {
    return VAR1.call.value(msg.value)(VAR2);
  }

1",RE,1
3177.sol,"function FUN1(address VAR1, bytes VAR2) external payable returns (bool) {
    return VAR1.call.value(msg.value)(VAR2);
  }

1",RE,1
3178.sol,"function FUN1(address VAR1, bytes VAR2) external payable returns (bool) {
    return VAR1.call.value(msg.value)(VAR2);
  }

1",RE,1
3182.sol,"function FUN1(address VAR1, bytes VAR2) external payable returns (bool) {
    return VAR1.call.value(msg.value)(VAR2);
  }

1",RE,1
31912.sol,"function FUN1(WalletData storage VAR1,
    bytes32 VAR2 = FUN2("""",VAR3,VAR4,VAR5);
        if(VAR3 != 0)
          VAR6 = FUN3(VAR1, VAR3, VAR4, VAR7,VAR8);
      VAR1.VAR9[VAR3][1] += VAR8;
      if(VAR3 == 0){
        require(VAR3.call.value(VAR4)(VAR5));
      FUN4(VAR2, VAR3, VAR4, VAR10);
  }

1",RE,1
31913.sol,"function FUN1(WalletData storage VAR1,
    bytes32 VAR2 = FUN2("""",VAR3,VAR4,VAR5);
        if(VAR3 != 0)
          VAR6 = FUN3(VAR1, VAR3, VAR4, VAR7,VAR8);
      VAR1.VAR9[VAR3][1] += VAR8;
      if(VAR3 == 0){
        require(VAR3.call.value(VAR4)(VAR5));
      FUN4(VAR2, VAR3, VAR4, VAR10);
  }

1",RE,1
31915.sol,"function FUN1(WalletData storage VAR1,
    bytes32 VAR2 = FUN2("""",VAR3,VAR4,VAR5);
        if(VAR3 != 0)
          VAR6 = FUN3(VAR1, VAR3, VAR4, VAR7,VAR8);
      VAR1.VAR9[VAR3][1] += VAR8;
      if(VAR3 == 0){
        require(VAR3.call.value(VAR4)(VAR5));
      FUN4(VAR2, VAR3, VAR4, VAR10);
  }

1",RE,1
3199.sol,"function FUN1(VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""""))))
    }
    function FUN3(uint256 VAR5, uint256 VAR6, uint256 VAR7, uint256 VAR8, uint256 VAR9, VAR1.EventReturns memory VAR2)
        address(VAR3).call.value(VAR4)(bytes4(FUN2("""")));
    }

1",RE,1
3204.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3209.sol,"function FUN1()
        if (!address(VAR1).call.value(msg.value)(bytes4(FUN2(""""))))  
    }
    function FUN3()
        if (!address(VAR1).call.value(msg.value)(bytes4(FUN2(""""))))  
    }
    function FUN4()
        if (!address(VAR1).call.value(msg.value)(bytes4(FUN2(""""))))  
    }
    function FUN5()
        if (!address(VAR1).call.value(msg.value)(bytes4(FUN2(""""))))  
    }

1",RE,1
3210.sol,"function FUN1()
        if (!address(VAR1).call.value(msg.value)(bytes4(FUN2(""""))))  
    }
    function FUN3()
        if (!address(VAR1).call.value(msg.value)(bytes4(FUN2(""""))))  
    }
    function FUN4()
        if (!address(VAR1).call.value(msg.value)(bytes4(FUN2(""""))))  
    }
    function FUN5()
        if (!address(VAR1).call.value(msg.value)(bytes4(FUN2(""""))))  
    }

1",RE,1
3211.sol,"function FUN1()
        if (!address(VAR1).call.value(msg.value)(bytes4(FUN2(""""))))  
    }
    function FUN3()
        if (!address(VAR1).call.value(msg.value)(bytes4(FUN2(""""))))  
    }
    function FUN4()
        if (!address(VAR1).call.value(msg.value)(bytes4(FUN2(""""))))  
    }
    function FUN5()
        if (!address(VAR1).call.value(msg.value)(bytes4(FUN2(""""))))  
    }

1",RE,1
3217.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3222.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
          if (!address(VAR8).call.value(VAR9)())
              VAR8.transfer(VAR10.FUN2(VAR11));
      }

1",RE,1
3228.sol,"function FUN1(VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""""))))
    }
    function FUN3(uint256 VAR5, uint256 VAR6, uint256 VAR7, uint256 VAR8, uint256 VAR9, VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""""))))
    }

1",RE,1
3248.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3254.sol,"function FUN1(VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""""))))
    }
    function FUN3(uint256 VAR5, uint256 VAR6, uint256 VAR7, VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""""))))
    }

1",RE,1
3255.sol,"function FUN1(VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""""))))
    }
    function FUN3(uint256 VAR5, uint256 VAR6, uint256 VAR7, uint256 VAR8, uint256 VAR9, VAR1.EventReturns memory VAR2)
        address(VAR3).call.value(VAR4)(bytes4(FUN2("""")));
    }

1",RE,1
3256.sol,"function FUN1(VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""""))))
    }
    function FUN3(uint256 VAR5, uint256 VAR6, uint256 VAR7, VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""""))))
    }

1",RE,1
3266.sol,"function FUN1(VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""""))))
    }
    function FUN3(uint256 VAR5, uint256 VAR6, uint256 VAR7, uint256 VAR8, uint256 VAR9, VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""""))))
    }

1",RE,1
3267.sol,"function FUN1() public  {
    if (VAR1.FUN2() > 50) {
    address(VAR1).call.value( VAR1.FUN3() *2 )();
  }

1",RE,1
3269.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3270.sol,"function FUN1() public  {
    if (VAR1.FUN2() > 50) {
    address(VAR1).call.value( VAR1.FUN3() *2 )();
    VAR1.FUN4();
  }

1",RE,1
3278.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)(bytes4(FUN2(""""))))
    }
    function FUN3(VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)(bytes4(FUN2(""""))))
    }

1",RE,1
3281.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
    }

1",RE,1
3286.sol,"function FUN1(VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""""))))
    }
    function FUN3(uint256 VAR5, uint256 VAR6, uint256 VAR7, uint256 VAR8, uint256 VAR9, VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""""))))
    }

1",RE,1
3302.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3305.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3314.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
    }

1",RE,1
3315.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3318.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
    }

1",RE,1
33221.sol,"function FUN1(uint VAR1, bytes VAR2) public {
        require(VAR3 > VAR4.VAR5                                            // If it is past the voting VAR6
            && !VAR4.VAR7                                                         // and it has not already been VAR7
            && VAR4.VAR8 == FUN2(VAR4.VAR9, VAR4.VAR10, VAR2)  // and the supplied code matches the VAR11
            && VAR4.VAR12 >= VAR13);                                  // and a minimum quorum has been VAR14...
        if (VAR4.VAR15 > VAR16) {
            VAR4.VAR7 = true; // Avoid recursive VAR17
            require(VAR4.VAR9.call.value(VAR4.VAR10)(VAR2));
            VAR4.VAR18 = true;
            VAR4.VAR18 = false;
        FUN3(VAR1, VAR4.VAR15, VAR4.VAR12, VAR4.VAR18);
    }

1",RE,1
33223.sol,"function FUN1(uint VAR1, bytes VAR2) public {
        require(VAR3 > VAR4.VAR5                                            // If it is past the voting VAR6
            && !VAR4.VAR7                                                         // and it has not already been VAR7
            && VAR4.VAR8 == FUN2(VAR4.VAR9, VAR4.VAR10, VAR2)  // and the supplied code matches the VAR11
            && VAR4.VAR12 >= VAR13);                                  // and a minimum quorum has been VAR14...
        if (VAR4.VAR15 > VAR16) {
            VAR4.VAR7 = true; // Avoid recursive VAR17
            require(VAR4.VAR9.call.value(VAR4.VAR10)(VAR2));
            VAR4.VAR18 = true;
            VAR4.VAR18 = false;
        FUN3(VAR1, VAR4.VAR15, VAR4.VAR12, VAR4.VAR18);
    }

1",RE,1
3323.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3330.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3347.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3350.sol,"function FUN1(VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""""))))
    }
    function FUN3(uint256 VAR5, uint256 VAR6, uint256 VAR7, VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""""))))
    }

1",RE,1
3363.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3364.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3371.sol,"function FUN1(VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""""))))
            if (!address(VAR3).call.value(VAR5)(bytes4(FUN2("""")))){
    }
    function FUN3(uint256 VAR6, uint256 VAR7, uint256 VAR8, uint256 VAR9, uint256 VAR10, VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""""))))
            if(!address(VAR3).call.value(VAR5)(bytes4(FUN2(""""))))
    }

1",RE,1
33753.sol,"function FUN1() public{
    require(VAR1 != 0x0);
    require(VAR1.call.value(VAR2)());
  }

1",RE,1
3383.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3394.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
33947.sol,"function FUN1(uint VAR1, bytes VAR2) public {
        require(VAR3 > VAR4.VAR5                                            // If it is past the voting VAR6
            && !VAR4.VAR7                                                         // and it has not already been VAR7
            && VAR4.VAR8 == FUN2(VAR4.VAR9, VAR4.VAR10, VAR2)  // and the supplied code matches the VAR11
            && VAR4.VAR12 >= VAR13);                                  // and a minimum quorum has been VAR14...
        if (VAR4.VAR15 > VAR16) {
            VAR4.VAR7 = true; // Avoid recursive VAR17
            require(VAR4.VAR9.call.value(VAR4.VAR10)(VAR2));
            VAR4.VAR18 = true;
            VAR4.VAR18 = false;
        FUN3(VAR1, VAR4.VAR15, VAR4.VAR12, VAR4.VAR18);
    }

1",RE,1
34432.sol,"function FUN1()
        require(msg.sender == VAR1);
        require(VAR1.call.value(VAR2)());
        FUN2(VAR1, VAR2);
    }

1",RE,1
3455.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3468.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
    }

1",RE,1
347.sol,"function FUN1() internal {
    bool VAR1 = VAR2.call.value(msg.value).FUN2(VAR3)();
        VAR2,
  }

1",RE,1
3476.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
    }

1",RE,1
3488.sol,"function FUN1(VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""""))))
    }
    function FUN3(uint256 VAR5, uint256 VAR6, uint256 VAR7, VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""""))))
    }

1",RE,1
3491.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3495.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
    }

1",RE,1
35078.sol,"function FUN1( address VAR1, bytes VAR2, uint256 value)
        return VAR1.call.value(value)(VAR2);
    }

1",RE,1
35182.sol,"function FUN1(uint VAR1, bytes VAR2) {
        require(VAR3 > VAR4.VAR5 && !VAR4.VAR6 && VAR4.VAR7 == FUN2(VAR4.VAR8, VAR4.VAR9, VAR2));
        for (uint VAR10 = 0; VAR10 <  VAR4.VAR11.VAR12; ++VAR10) {
            Vote storage VAR13 = VAR4.VAR11[VAR10];
            VAR4.VAR6 = true;
            require(VAR4.VAR8.call.value(VAR4.VAR9)(VAR2));
            VAR4.VAR14 = true;
            VAR4.VAR14 = false;
        FUN3(VAR1, VAR15 - VAR16, VAR17, VAR4.VAR14);
    }

1",RE,1
3522.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3526.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
          if (!address(VAR8).call.value(VAR9)())
              VAR8.transfer(VAR10.FUN2(VAR11));
      }

1",RE,1
3533.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
35421.sol,"function FUN1( address VAR1, bytes VAR2, uint256 value)
        return VAR1.call.value(value)(VAR2);
    }

1",RE,1
35467.sol,"function FUN1() public 
        uint VAR1 = VAR2[msg.sender];
        VAR2[msg.sender] = 0;
        if (msg.sender.call.value(VAR1)()) {
            VAR2[msg.sender] = VAR1;
    }

1",RE,1
3548.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3555.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
    }

1",RE,1
3556.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3560.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
35757.sol,"function FUN1() public {
        require(VAR1 != 0x0);
        require(VAR1.call.value(VAR2)());
    }

1",RE,1
35758.sol,"function FUN1() public {
        require(VAR1 != 0x0);
        require(VAR1.call.value(VAR2)());
    }

1",RE,1
3577.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3578.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3589.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3591.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3594.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3597.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3630.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
36334.sol,"function FUN1() {
    require(VAR1 != 0x0);
    require(VAR1.call.value(VAR2)());
  }

1",RE,1
3643.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3649.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3650.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
36506.sol,"function FUN1() {
    require(VAR1 != 0x0);
    require(VAR1.call.value(VAR2)());
  }

1",RE,1
3656.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3659.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
    }

1",RE,1
3661.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
    }

1",RE,1
3664.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3669.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3670.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
36836.sol,"function FUN1() public
        uint VAR1 = VAR2[msg.sender];
        VAR2[msg.sender] = 0;
        if (msg.sender.call.value(VAR1)()) {
            VAR2[msg.sender] = VAR1;
    }

1",RE,1
3685.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3691.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
    }

1",RE,1
3692.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3694.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
    }

1",RE,1
3696.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3703.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3705.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3706.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3717.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3719.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3722.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3724.sol,"function FUN1(VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""""))))
    }
    function FUN3(uint256 VAR5, uint256 VAR6, uint256 VAR7, VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""""))))
    }

1",RE,1
3732.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3735.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
    }

1",RE,1
3743.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
37528.sol,"function FUN1(){
    require(VAR1.call.value(VAR2)());
  }

1",RE,1
3757.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3768.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3770.sol,"function FUN1(VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""""))))
    }
    function FUN3(uint256 VAR5, uint256 VAR6, uint256 VAR7, uint256 VAR8, uint256 VAR9, VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""""))))
    }

1",RE,1
3773.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3790.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
    }

1",RE,1
3801.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3802.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3804.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3810.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3811.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3823.sol,"function FUN1(VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""""))))
    }
    function FUN3(uint256 VAR5, uint256 VAR6, uint256 VAR7, uint256 VAR8, uint256 VAR9, VAR1.EventReturns memory VAR2)
        if (!address(VAR3).call.value(VAR4)(bytes4(FUN2(""""))))
    }

1",RE,1
3826.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3873.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3911.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3925.sol,"function FUN1(address sender, address VAR1, bytes VAR2, uint256 VAR3, bytes VAR4) public payable {
        require(this == VAR1);
        bytes32 VAR5 = FUN2(VAR6, FUN2(VAR1, VAR2, VAR3));
        require(VAR1.call.value(msg.value)(VAR2));
    }

1",RE,1
3932.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3934.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3935.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
3985.sol,"function FUN1(address sender, address VAR1, bytes VAR2, uint256 VAR3, bytes VAR4) public payable {
        require(this == VAR1);
        bytes32 VAR5 = FUN2(VAR6, FUN2(VAR1, VAR2, VAR3));
        require(VAR1.call.value(msg.value)(VAR2));
    }

1",RE,1
3987.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
402.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
40341.sol,"function FUN1(
        return VAR1.call.value(VAR2).FUN2(VAR3)();
    }

1",RE,1
40342.sol,"function FUN1(address VAR1, address VAR2) {
            VAR2.call.value(msg.value-VAR3)();
    }

1",RE,1
40343.sol,"function FUN1(
        return VAR1.call.value(VAR2).FUN2(VAR3)();
    }

1",RE,1
40344.sol,"function FUN1(
        return VAR1.call.value(VAR2).FUN2(VAR3)();
    }

1",RE,1
40357.sol,"function FUN1(address VAR1, address VAR2) {
            VAR2.call.value(msg.value - VAR3)();
    }

1",RE,1
4172.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
4180.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
4195.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
4206.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
4223.sol,"function FUN1(uint256 VAR1, address VAR2, uint256 VAR3, bytes32 VAR4, bool VAR5, bool VAR6)
        address(VAR7).call.value(address(this).VAR8)();
    }

1",RE,1
4225.sol,"function FUN1( address VAR1, bytes VAR2, uint value)
        return VAR1.call.value(value)(VAR2);
    }
    function FUN1( address VAR3, bytes VAR4 )
    }
    function FUN1( address VAR3, uint256 VAR5 )
    }

1",RE,1
428.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
430.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
4391.sol,"function FUN1( address VAR1, bytes VAR2, uint value)
        return VAR1.call.value(value)(VAR2);
    }
    function FUN1( address VAR3, bytes VAR4 )
    }
    function FUN1( address VAR3, uint256 VAR5 )
    }

1",RE,1
452.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
4679.sol,"function FUN1(address VAR1) internal {
		VAR2.FUN2(VAR1, VAR3[VAR1]);
		require( address(VAR2).call.value( VAR4[VAR1] )( bytes4( FUN3("""") ) ) );
	}
    function FUN4() onlyRC payable public returns(bool) {
        require(VAR5.call.value(msg.value)(), """");
    }

1",RE,1
478.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
        if (!address(VAR8).call.value(VAR9)())
            VAR8.transfer(VAR10.FUN2(VAR11));
    }

1",RE,1
4856.sol,"function FUN1(uint VAR1)
        if(VAR2[msg.sender]>=VAR3 && VAR2[msg.sender]>=VAR1)
            if(msg.sender.call.value(VAR1)())
                VAR2[msg.sender]-=VAR1;
                VAR4.FUN2(msg.sender,VAR1,"""");
    }

1",RE,1
489.sol,"function FUN1(VAR1.EventReturns memory VAR2)
        VAR3.call.value(VAR4)(bytes4(FUN2("""")));  
    }
    function FUN3(uint256 VAR5, uint256 VAR6, uint256 VAR7, uint256 VAR8, uint256 VAR9, VAR1.EventReturns memory VAR2)
            VAR3.call.value(VAR4)(bytes4(FUN2("""")));
    }

1",RE,1
500.sol,"function FUN1(VAR1.EventReturns memory VAR2)
        VAR3.call.value(VAR4)(bytes4(FUN2("""")));  
    }
    function FUN3(uint256 VAR5, uint256 VAR6, uint256 VAR7, uint256 VAR8, uint256 VAR9, VAR1.EventReturns memory VAR2)
            VAR3.call.value(VAR4)(bytes4(FUN2("""")));
    }

1",RE,1
5073.sol,"function FUN1(uint VAR1)
        if(VAR2[msg.sender]>=VAR3 && VAR2[msg.sender]>=VAR1)
            if(msg.sender.call.value(VAR1)())
                VAR2[msg.sender]-=VAR1;
                VAR4.FUN2(msg.sender,VAR1,"""");
    }

1",RE,1
5214.sol,"function FUN1() payable public {
      if(!VAR1.call.value(VAR2).FUN2(400000)()) {
    }

1",RE,1
552.sol,"function FUN1(VAR1.EventReturns memory VAR2)
        VAR3.call.value(VAR4)(bytes4(FUN2("""")));  
    }
    function FUN3(uint256 VAR5, uint256 VAR6, uint256 VAR7, uint256 VAR8, uint256 VAR9, VAR1.EventReturns memory VAR2)
            VAR3.call.value(VAR4)(bytes4(FUN2("""")));
    }

1",RE,1
5561.sol,"function FUN1(uint VAR1)
        if(VAR2[msg.sender]>=VAR3 && VAR2[msg.sender]>=VAR1)
            if(msg.sender.call.value(VAR1)())
                VAR2[msg.sender]-=VAR1;
                VAR4.FUN2(msg.sender,VAR1,"""");
    }

1",RE,1
5755.sol,"function FUN1(
    require(VAR1 != address(this));
    super.FUN2(VAR1, VAR2);
    require(VAR1.call.value(msg.value)(VAR3));
  }
  function FUN3(
    require(VAR4 != address(this));
    super.transfer(VAR4, VAR2);
    require(VAR4.call.value(msg.value)(VAR3));
  }
  function FUN4(
    require(VAR4 != address(this));
    super.FUN5(VAR5, VAR4, VAR2);
    require(VAR4.call.value(msg.value)(VAR3));
  }
  function FUN6(
    require(VAR1 != address(this));
    super.FUN7(VAR1, VAR6);
    require(VAR1.call.value(msg.value)(VAR3));
  }
  function FUN8(
    require(VAR1 != address(this));
    super.FUN9(VAR1, VAR7);
    require(VAR1.call.value(msg.value)(VAR3));
  }

1",RE,1
578.sol,"function FUN1(
      VAR1 != address(this) &&
      transfer(VAR1, value)
    require(VAR1.call.value(msg.value)(VAR2));
  }

1",RE,1
60.sol,"function FUN1(
        require(VAR1.VAR2 == VAR3.VAR2 + 1, """");
        require(VAR4.VAR2 == VAR3.VAR2, """");
        for (uint VAR5 = 0; VAR5 < VAR3.VAR2; VAR5++) {
                VAR6.FUN2(VAR3[VAR5], VAR6.FUN3(this));
            require(VAR3[VAR5].call.value(VAR4[VAR5])(VAR7), """");
                VAR6.FUN2(VAR3[VAR5], 0);
    }

1",RE,1
6606.sol,"function FUN1(
        require(VAR1.call.value(VAR2)(VAR3));
    }

1",RE,1
6613.sol,"function FUN1(
        require(VAR1.call.value(VAR2)(VAR3));
    }

1",RE,1
6618.sol,"function FUN1(address VAR1, uint256 VAR2, bytes VAR3) public payable returns (bool) {
        require(VAR1 != address(this));
        super.FUN2(VAR1, VAR2);
        require(VAR1.call.value(msg.value)(VAR3));
    }
    function FUN3(address VAR4, uint256 VAR2, bytes VAR3) public payable returns (bool) {
        require(VAR4 != address(this));
        super.transfer(VAR4, VAR2);
        require(VAR4.call.value(msg.value)(VAR3));
    }
    function FUN4(address VAR5, address VAR4, uint256 VAR2, bytes VAR3) public payable returns (bool) {
        require(VAR4 != address(this));
        super.FUN5(VAR5, VAR4, VAR2);
        require(VAR4.call.value(msg.value)(VAR3));
    }
    function FUN6(address VAR1, uint VAR6, bytes VAR3) public payable returns (bool) {
        require(VAR1 != address(this));
        super.FUN7(VAR1, VAR6);
        require(VAR1.call.value(msg.value)(VAR3));
    }
    function FUN8(address VAR1, uint VAR7, bytes VAR3) public payable returns (bool) {
        require(VAR1 != address(this));
        super.FUN9(VAR1, VAR7);
        require(VAR1.call.value(msg.value)(VAR3));
    }

1",RE,1
6750.sol,"function FUN1(
    require(VAR1 != address(this));
    super.FUN2(VAR1, VAR2);
    require(VAR1.call.value(msg.value)(VAR3));
  }
  function FUN3(
    require(VAR4 != address(this));
    super.transfer(VAR4, VAR2);
    require(VAR4.call.value(msg.value)(VAR3));
  }
  function FUN4(
    require(VAR4 != address(this));
    super.FUN5(VAR5, VAR4, VAR2);
    require(VAR4.call.value(msg.value)(VAR3));
  }
  function FUN6(
    require(VAR1 != address(this));
    super.FUN7(VAR1, VAR6);
    require(VAR1.call.value(msg.value)(VAR3));
  }
  function FUN8(
    require(VAR1 != address(this));
    super.FUN9(VAR1, VAR7);
    require(VAR1.call.value(msg.value)(VAR3));
  }

1",RE,1
6881.sol,"function FUN1(
        require(VAR1.call.value(VAR2)(VAR3));
    }

1",RE,1
6961.sol,"function transfer(address VAR1, uint VAR2) public returns (bool VAR3) {
    }
    function transfer(address VAR1, uint VAR2, bytes VAR4) public returns (bool VAR3) {
    }
    function transfer(address VAR1, uint VAR2, bytes VAR4, string VAR5) public returns (bool VAR3) {
                && VAR6[VAR1] == false
                && VAR7 > VAR8[VAR1]);
        if (FUN1(VAR1)) {
            VAR9[VAR1] = VAR9[VAR1].FUN2(VAR2);
            assert(VAR1.call.value(0)(bytes4(FUN3(VAR5)), msg.sender, VAR2, VAR4));
            emit Transfer(msg.sender, VAR1, VAR2, VAR4);
            emit Transfer(msg.sender, VAR1, VAR2);
            return FUN4(VAR1, VAR2, VAR4);
    }

1",RE,1
702.sol,"function FUN1(address VAR1, bytes VAR2, uint VAR3) internal {
        require(VAR1.call.value(VAR3)(VAR2), """");
    }

1",RE,1
7056.sol,"function FUN1( address VAR1, bytes VAR2, uint value)
        return VAR1.call.value(value)(VAR2);
    }
    function FUN1( address VAR3, bytes VAR4 )
    }
    function FUN1( address VAR3, uint256 VAR5 )
    }

1",RE,1
7170.sol,"function FUN1(
    require(VAR1 != address(this));
    super.FUN2(VAR1, VAR2);
    require(VAR1.call.value(msg.value)(VAR3));
  }
  function FUN3(
    require(VAR4 != address(this));
    super.transfer(VAR4, VAR2);
    require(VAR4.call.value(msg.value)(VAR3));
  }
  function FUN4(
    require(VAR4 != address(this));
    super.FUN5(VAR5, VAR4, VAR2);
    require(VAR4.call.value(msg.value)(VAR3));
  }
  function FUN6(
    require(VAR1 != address(this));
    super.FUN7(VAR1, VAR6);
    require(VAR1.call.value(msg.value)(VAR3));
  }
  function FUN8(
    require(VAR1 != address(this));
    super.FUN9(VAR1, VAR7);
    require(VAR1.call.value(msg.value)(VAR3));
  }

1",RE,1
74.sol,"function FUN1(
        require(VAR1.VAR2 == VAR3.VAR2 + 1, """");
        require(VAR4.VAR2 == VAR3.VAR2, """");
        for (uint VAR5 = 0; VAR5 < VAR3.VAR2; VAR5++) {
            require(VAR3[VAR5].call.value(VAR4[VAR5])(VAR6), """");
    }

1",RE,1
7603.sol,"function FUN1() payable public {
      if(!VAR1.call.value(VAR2).FUN2(400000)()) {
    }

1",RE,1
774.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, VAR4.EventReturns memory VAR5)
        if (!address(VAR6).call.value(VAR7)(bytes4(FUN2(""""))))
    }

1",RE,1
785.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7)
          if (!address(VAR8).call.value(VAR9)())
              VAR8.transfer(VAR10.FUN2(VAR11));
      }

1",RE,1
7877.sol,"function FUN1(
    FUN2(VAR1)
      transfer(VAR1, value) &&
    require(VAR1.call.value(msg.value)(VAR2));
  }

1",RE,1
8168.sol,"function FUN1(
    require(VAR1 != address(this));
    super.FUN2(VAR1, VAR2);
    require(VAR1.call.value(msg.value)(VAR3));
  }
  function FUN3(
    require(VAR4 != address(this));
    super.transfer(VAR4, VAR2);
    require(VAR4.call.value(msg.value)(VAR3));
  }
  function FUN4(
    require(VAR4 != address(this));
    super.FUN5(VAR5, VAR4, VAR2);
    require(VAR4.call.value(msg.value)(VAR3));
  }
  function FUN6(
    require(VAR1 != address(this));
    super.FUN7(VAR1, VAR6);
    require(VAR1.call.value(msg.value)(VAR3));
  }
  function FUN8(
    require(VAR1 != address(this));
    super.FUN9(VAR1, VAR7);
    require(VAR1.call.value(msg.value)(VAR3));
  }

1",RE,1
8219.sol,"function FUN1(
    require(VAR1 != address(this));
    super.FUN2(VAR1, VAR2);
    require(VAR1.call.value(msg.value)(VAR3));
  }
  function FUN3(
    require(VAR4 != address(this));
    super.transfer(VAR4, VAR2);
    require(VAR4.call.value(msg.value)(VAR3));
  }
  function FUN4(
    require(VAR4 != address(this));
    super.FUN5(VAR5, VAR4, VAR2);
    require(VAR4.call.value(msg.value)(VAR3));
  }
  function FUN6(
    require(VAR1 != address(this));
    super.FUN7(VAR1, VAR6);
    require(VAR1.call.value(msg.value)(VAR3));
  }
  function FUN8(
    require(VAR1 != address(this));
    super.FUN9(VAR1, VAR7);
    require(VAR1.call.value(msg.value)(VAR3));
  }

1",RE,1
8342.sol,"function FUN1(address VAR1, uint256 VAR2, uint256 VAR3, bytes VAR4)
    return VAR1.call.value(VAR2).FUN2(VAR3)(VAR4);
  }

1",RE,1
8396.sol,"function FUN1(uint VAR1)
            VAR2.VAR3 = true;
            if (VAR2.VAR4.call.value(VAR2.value)(VAR2.VAR5))
                VAR2.VAR3 = false;
    }

1",RE,1
84.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, VAR4.EventReturns memory VAR5)
        if (!address(VAR6).call.value(VAR7)())
    }

1",RE,1
8508.sol,"function FUN1(
    require(VAR1 != address(this));
    super.FUN2(VAR1, VAR2);
    require(VAR1.call.value(msg.value)(VAR3));
  }
  function FUN3(
    require(VAR4 != address(this));
    super.transfer(VAR4, VAR2);
    require(VAR4.call.value(msg.value)(VAR3));
  }
  function FUN4(
    require(VAR4 != address(this));
    super.FUN5(VAR5, VAR4, VAR2);
    require(VAR4.call.value(msg.value)(VAR3));
  }
  function FUN6(
    require(VAR1 != address(this));
    super.FUN7(VAR1, VAR6);
    require(VAR1.call.value(msg.value)(VAR3));
  }
  function FUN8(
    require(VAR1 != address(this));
    super.FUN9(VAR1, VAR7);
    require(VAR1.call.value(msg.value)(VAR3));
  }

1",RE,1
88.sol,"function FUN1(bytes32 VAR1, bytes VAR2) external payable returns (bool VAR3) {
    if (address(VAR4).call.value(msg.value)(VAR5.FUN2(
  }

1",RE,1
9001.sol,"function FUN1(address VAR1, uint256 VAR2, bytes VAR3) public payable returns (bool) {
    require(VAR1 != address(this));
    super.FUN2(VAR1, VAR2);
    require(VAR1.call.value(msg.value)(VAR3));
  }
  function FUN3(address VAR4, uint256 VAR2, bytes VAR3) public payable returns (bool) {
    require(VAR4 != address(this));
    super.transfer(VAR4, VAR2);
    require(VAR4.call.value(msg.value)(VAR3));
  }
  function FUN4(
    require(VAR4 != address(this));
    super.FUN5(VAR5, VAR4, VAR2);
    require(VAR4.call.value(msg.value)(VAR3));
  }
  function FUN6(address VAR1, uint VAR6, bytes VAR3) public payable returns (bool) {
    require(VAR1 != address(this));
    super.FUN7(VAR1, VAR6);
    require(VAR1.call.value(msg.value)(VAR3));
  }
  function FUN8(address VAR1, uint VAR7, bytes VAR3) public payable returns (bool) {
    require(VAR1 != address(this));
    super.FUN9(VAR1, VAR7);
    require(VAR1.call.value(msg.value)(VAR3));
  }

1",RE,1
9221.sol,"function FUN1() payable
		if ((FUN2()%2==1) && (msg.value == 1 VAR1) && (!VAR2))
			if (!msg.sender.call.value(2 VAR1)())
	}
	function FUN3(uint VAR3)
		if (VAR4==msg.sender)
			if (!msg.sender.call.value( VAR3 * (1 VAR1))())
	}

1",RE,1
9284.sol,"function FUN1(uint VAR1)
        if(VAR2[msg.sender]>=VAR3 && VAR2[msg.sender]>=VAR1)
            if(msg.sender.call.value(VAR1)())
                VAR2[msg.sender]-=VAR1;
                VAR4.FUN2(msg.sender,VAR1,"""");
    }

1",RE,1
9538.sol,"function FUN1(
    require(VAR1 != address(this));
    super.FUN2(VAR1, VAR2);
    require(VAR1.call.value(msg.value)(VAR3));
  }
  function FUN3(
    require(VAR4 != address(this));
    super.transfer(VAR4, VAR2);
    require(VAR4.call.value(msg.value)(VAR3));
  }
  function FUN4(
    require(VAR4 != address(this));
    super.FUN5(VAR5, VAR4, VAR2);
    require(VAR4.call.value(msg.value)(VAR3));
  }
  function FUN6(
    require(VAR1 != address(this));
    super.FUN7(VAR1, VAR6);
    require(VAR1.call.value(msg.value)(VAR3));
  }
  function FUN8(
    require(VAR1 != address(this));
    super.FUN9(VAR1, VAR7);
    require(VAR1.call.value(msg.value)(VAR3));
  }

1",RE,1
9584.sol,"function FUN1(address VAR1, bytes VAR2, uint VAR3) internal {
        require(VAR1.call.value(VAR3)(VAR2), """");
    }

1",RE,1
9586.sol,"function FUN1(address VAR1, bytes VAR2, uint VAR3) internal {
        require(VAR1.call.value(VAR3)(VAR2), """");
    }

1",RE,1
9600.sol,"function FUN1(address VAR1, bytes VAR2, uint VAR3) internal {
        require(VAR1.call.value(VAR3)(VAR2), """");
    }

1",RE,1
9602.sol,"function FUN1(address VAR1, bytes VAR2, uint VAR3) internal {
        require(VAR1.call.value(VAR3)(VAR2), """");
    }

1",RE,1
9610.sol,"function FUN1(address VAR1, bytes VAR2, uint VAR3) internal {
        require(VAR1.call.value(VAR3)(VAR2), """");
    }

1",RE,1
9611.sol,"function FUN1(address VAR1, bytes VAR2, uint VAR3) internal {
        require(VAR1.call.value(VAR3)(VAR2), """");
    }

1",RE,1
9612.sol,"function FUN1(address VAR1, bytes VAR2, uint VAR3) internal {
        require(VAR1.call.value(VAR3)(VAR2), """");
    }

1",RE,1
9654.sol,"function FUN1() payable
		if ((FUN2()%2==1) && (msg.value == 1 VAR1) && (!VAR2))
			if (!msg.sender.call.value(2 VAR1)())
	}

1",RE,1
9993.sol,"function FUN1(
        require(VAR1 != address(this));
        super.FUN2(VAR1, VAR2);
        require(VAR1.call.value(msg.value)(VAR3));
    }
    function FUN3(
        require(VAR4 != address(this));
        super.transfer(VAR4, VAR2);
        require(VAR4.call.value(msg.value)(VAR3));
    }
    function FUN4(
        require(VAR4 != address(this));
        super.FUN5(VAR5, VAR4, VAR2);
        require(VAR4.call.value(msg.value)(VAR3));
    }
    function FUN6(
        require(VAR1 != address(this));
        super.FUN7(VAR1, VAR6);
        require(VAR1.call.value(msg.value)(VAR3));
    }
    function FUN8(
        require(VAR1 != address(this));
        super.FUN9(VAR1, VAR7);
        require(VAR1.call.value(msg.value)(VAR3));
    }

1",RE,1
0x013969cb9113d3636f214b19a3c80a4b4afa6c83.sol,"contract VAR1 {

     
    bytes32 VAR2 = VAR3"""";
    bytes32 VAR4 = VAR3"""";

    function FUN1(bytes VAR5) returns (bool) {  

         
        address VAR6 = address(FUN2(VAR5));

         

        bytes32 VAR7;
        bytes32 VAR8;

        VAR9 {
        VAR7 := FUN3(FUN4(VAR5,0x20))
        VAR8 := FUN3(FUN4(VAR5,0x40))
        }

         
        bytes32 VAR10 = VAR2 ^ VAR7;
        bytes32 VAR11 = VAR4 ^ VAR8;

        bytes32 VAR12 = FUN2("""", VAR5);

         
        if(FUN5(VAR12, 27, VAR10, VAR11) == VAR6) FUN6(msg.sender);
        if(FUN5(VAR12, 28, VAR10, VAR11) == VAR6) FUN6(msg.sender);
    }

    function() payable {}

}",SD,2
0x0312855bb6e548578a36fa8de63b8f0d3d7d7dc2.sol,"function FUN1() VAR1 {
if(!VAR2 && FUN2())
FUN3(VAR3);
}
function FUN1() VAR1 {
if(!VAR2 && FUN2())
FUN3(VAR3);
}",SD,2
0x03209bde47da583547c17c47e7ca74bfa3dfb404.sol,"function FUN1() onlyOwner VAR1 {
FUN2(VAR2);
}
function FUN1() onlyOwner VAR1 {
FUN2(VAR2);
}",SD,2
0x0326ade59900f4e99e029362a076063a6d542a58.sol,"function FUN1()  public onlyOwner {
if(msg.sender == VAR1)
FUN2(VAR1);
}
function FUN1()  public onlyOwner {
if(msg.sender == VAR1)
FUN2(VAR1);
}",SD,2
0x03e4bb77ccf8baa9c986685645470f2ce741addb.sol,"function FUN1() public {
require(msg.sender == VAR1);
FUN2(VAR2.VAR3);
}
function FUN1() public {
require(msg.sender == VAR1);
FUN2(VAR2.VAR3);
}",SD,2
0x04baddfb21723ec467e9993b715c5e0d673bac96.sol,"function FUN1() public {
if (msg.sender == VAR1 && VAR2 > VAR3 + 1 VAR4) {
FUN2(msg.sender);
}
}
function FUN1() public {
if (msg.sender == VAR1 && VAR2 > VAR3 + 1 VAR4) {
FUN2(msg.sender);
}
}",SD,2
0x04ebe325519223119ab6bde2b84e23a6ecd05d65.sol,"function FUN1() public {
if (msg.sender == VAR1) {
FUN2(VAR1);
}
}
function FUN1() public {
if (msg.sender == VAR1) {
FUN2(VAR1);
}
}",SD,2
0x08573698b2b0aaf07f16395be3d3530598c0d972.sol,"function FUN1()
{
if( msg.sender == VAR1 && VAR2 >= VAR3 )
FUN2(VAR1);
}
function FUN1()
{
if( msg.sender == VAR1 && VAR2 >= VAR3 )
FUN2(VAR1);
}",SD,2
0x09b510a0e0fa1886eed0e17ba9b42c001cfeb7f7.sol,"function FUN1() onlyOwner public
{
FUN2(VAR1);
}
function FUN1() onlyOwner public
{
FUN2(VAR1);
}",SD,2
0x0aac73a7098578bcb34ed305e63a9bd4e9f9bb07.sol,"function FUN1() public senderIsOwner VAR1 {
FUN2(VAR2);
}
function FUN1() public senderIsOwner VAR1 {
FUN2(VAR2);
}",SD,2
0x0aaf8865a6cbf417e7ad51fe71fe60f1a0c192f8.sol,"function FUN1() public onlyOwner
{
FUN2(VAR1);
}",SD,2
0x0adadf6b6be1afad94d908b6bc4695dada64074c.sol,"function FUN1() onlyOwner public {
FUN2(VAR1);
}
function FUN3(address VAR2) onlyOwner public {
FUN2(VAR2);
}
}
function FUN1() onlyOwner public {
FUN2(VAR1);
}
function FUN3(address VAR2) onlyOwner public {
FUN2(VAR2);
}
}",SD,2
0x0bf0872390a94c15aaa2865a2f9d8dec90b0af6c.sol,"function FUN1() external onlyOwner {
require(VAR1 > VAR2);
FUN2(VAR3);
}
function FUN1() external onlyOwner {
require(VAR1 > VAR2);
FUN2(VAR3);
}",SD,2
0x0c90eac84c64f67aae9ed41492e018036ac29549.sol,"function FUN1(address VAR1) VAR2 returns(uint VAR3) {
uint VAR4 = VAR5.VAR6;
if (VAR7 < VAR5.VAR8) {
return VAR9;
}
if (VAR4 == 0) {
return VAR10;
}
if(!FUN2(VAR11).transfer(VAR1,VAR4)) {
return VAR12;
}
FUN3(msg.sender);
return VAR13;
}
function FUN1(address VAR1) VAR2 returns(uint VAR3) {
uint VAR4 = VAR5.VAR6;
if (VAR7 < VAR5.VAR8) {
return VAR9;
}
if (VAR4 == 0) {
return VAR10;
}
if(!FUN2(VAR11).transfer(VAR1,VAR4)) {
return VAR12;
}
FUN3(msg.sender);
return VAR13;
}",SD,2
0x0d49b24f068a9a3ef60576c7a915ffd6844d6fdd.sol,"function FUN1() onlyOwner public {
FUN2();
FUN3(VAR1);
}
function FUN1() onlyOwner public {
FUN2();
FUN3(VAR1);
}",SD,2
0x0d83102ec81853f3334bd2b9e9fcce7adf96ccc7.sol,"function FUN1() {
require(msg.sender==VAR1);
FUN2(msg.sender);
}
function FUN1() {
require(msg.sender==VAR1);
FUN2(msg.sender);
}",SD,2
0x0eaf3a45f6035565ee7fb61b242f562b77883fc4.sol,"function FUN1() public
{
require(msg.sender == VAR1);
FUN2(VAR1);
}
function FUN1() public
{
require(msg.sender == VAR1);
FUN2(VAR1);
}",SD,2
0x138e8f61c1e1908e145c02a12879f68051499d21.sol,"function FUN1() ownerOnly VAR1 {
FUN2(VAR2);
}
function FUN1() ownerOnly VAR1 {
FUN2(VAR2);
}",SD,2
0x17f0badcdf99b0a94429478d2e9ddb1ff13174f7.sol,"function FUN1() onlyControl external {
require(VAR1 != address(this));
FUN2(VAR2);
}",SD,2
0x191a70e9808c8d89be289cfe9001a7010dc3d78c.sol,"function FUN1() public onlyOwner {
FUN2(VAR1);
}
function FUN1() public onlyOwner {
FUN2(VAR1);
}",SD,2
0x1b442a27fc37b5527ecd5c5ead301dac1638810d.sol,"function FUN1() public
{
require(msg.sender == VAR1);
if (VAR2.VAR3 > 0)
{
VAR4 = true;
}
else
{
FUN2(VAR1);
}
}
function FUN1() public
{
require(msg.sender == VAR1);
if (VAR2.VAR3 > 0)
{
VAR4 = true;
}
else
{
FUN2(VAR1);
}
}",SD,2
0x1c0a9bbaddb924b42e3145610960dde119779560.sol,"function FUN1() public ownerOnly VAR1 {
FUN2(VAR2);
}
function FUN1() public ownerOnly VAR1 {
FUN2(VAR2);
}",SD,2
0x1c2389c0b8014be72e11849ec0aa790b03929e18.sol,"function FUN1() public
{
require(msg.sender == VAR1);
FUN2(VAR1);
}
function FUN1() public
{
require(msg.sender == VAR1);
FUN2(VAR1);
}",SD,2
0x1cca91a47db357445b89269f2fb4f647cd209968.sol,"function FUN1() onlyOwner public {
uint256 VAR1 = FUN2();
require (VAR1 > 0);
VAR2.transfer(VAR3, VAR1);
FUN3(VAR3);
}
function FUN1() onlyOwner public {
uint256 VAR1 = FUN2();
require (VAR1 > 0);
VAR2.transfer(VAR3, VAR1);
FUN3(VAR3);
}",SD,2
0x1ebf20031b03b80e5f6fdbeb9f86d44145224006.sol,"function FUN1() {
require(msg.sender==VAR1);
FUN2(msg.sender);
}
function FUN1() {
require(msg.sender==VAR1);
FUN2(msg.sender);
}",SD,2
0x1f37e131d1127de0e112fc96d5fa53ebe6f82177.sol,"function FUN1() public VAR1 {
FUN2(VAR2);
}
function FUN1() public VAR1 {
FUN2(VAR2);
}",SD,2
0x1fdedef5c2da1ed9db44d80003a9592dfa18163c.sol,"function FUN1()  public onlyOwner {
if(msg.sender == VAR1)
FUN2(VAR1);
}
function FUN1()  public onlyOwner {
if(msg.sender == VAR1)
FUN2(VAR1);
}",SD,2
0x2075d158924f5030aece55179848c2bd7ec5833f.sol,"function FUN1() onlyOwner {
FUN2(VAR1);
}
function FUN1() onlyOwner {
FUN2(VAR1);
}",SD,2
0x20d7d4b07a2dcefe1bd99ac11eae2f5a8218e454.sol,"function FUN1() onlyOwner {
FUN2(VAR1);
}
function FUN1() onlyOwner {
FUN2(VAR1);
}",SD,2
0x2282a327a9293895cacbce617b194e6031d6ffa4.sol,"function FUN1() public {
require(msg.sender==VAR1);
FUN2(msg.sender);
}
function FUN1() public {
require(msg.sender==VAR1);
FUN2(msg.sender);
}",SD,2
0x241e492c003dfbe6d60d8bfd1960c0b8b7944ebd.sol,"function FUN1() public
{
require( msg.sender == VAR1, """" );
FUN2(VAR1);
}
function FUN1() public
{
require( msg.sender == VAR1, """" );
FUN2(VAR1);
}",SD,2
0x24b68cf0c67a54d6f67c469d2b9455f6953c3199.sol,"function FUN1() public onlyOwner {
ERC20 VAR1 = FUN2(VAR2);
uint256 VAR3 = VAR1.FUN3(this);
if (VAR3 > 0) {
VAR1.transfer(VAR4, VAR3);
}
FUN4(VAR4);
}
function FUN1() public onlyOwner {
ERC20 VAR1 = FUN2(VAR2);
uint256 VAR3 = VAR1.FUN3(this);
if (VAR3 > 0) {
VAR1.transfer(VAR4, VAR3);
}
FUN4(VAR4);
}",SD,2
0x24d530c0e939f665e535f30d3858c1c3283e8d28.sol,"function FUN1() onlyOwner public {
FUN2(VAR1);
}
function FUN3(address VAR2) onlyOwner public {
FUN2(VAR2);
}
function FUN1() onlyOwner public {
FUN2(VAR1);
}
function FUN3(address VAR2) onlyOwner public {
FUN2(VAR2);
}",SD,2
0x25926eff952bdcd3cb395a5614ab5094474b2dba.sol,"function FUN1() public
{
require(msg.sender==VAR1);
require(VAR2>VAR3);
FUN2(msg.sender);
}
function FUN1() public
{
require(msg.sender==VAR1);
require(VAR2>VAR3);
FUN2(msg.sender);
}",SD,2
0x26b5962250b779ab0f33970738a46fcfb00a70b9.sol,"function FUN1() onlyOwner {
FUN2(msg.sender);
}",SD,2
0x26f8d2330e06359dfd56a7227159f9fbcb1cbb25.sol,"function FUN1(address VAR1) onlyOwner public {
FUN2(VAR1);
}
function FUN1(address VAR1) onlyOwner public {
FUN2(VAR1);
}",SD,2
0x2a77bf0239c625a0319e21607d6e9093a38b6eed.sol,"function FUN1() public
{
require(msg.sender == VAR1);
FUN2(msg.sender);
}
function FUN1() public
{
require(msg.sender == VAR1);
FUN2(msg.sender);
}",SD,2
0x2b34ebda72bade6e6e91883ca67eb23484b045fb.sol,"function FUN1() onlyOwner external {
FUN2(VAR1);
}",SD,2
0x2c9eb11db6b0dcb18fe8644003ee53f6b4588341.sol,"function FUN1() public {
require(msg.sender == VAR1);
FUN2(VAR1);
}
function FUN1() public {
require(msg.sender == VAR1);
FUN2(VAR1);
}",SD,2
0x2d5ffc14abcc10e11a354e29cb6ca343e33cd5bc.sol,"function FUN1() onlyOwner() public{
VAR1[msg.sender] = true;
if(FUN2()){
FUN3(msg.sender);
}
}
function FUN1() onlyOwner() public{
VAR1[msg.sender] = true;
if(FUN2()){
FUN3(msg.sender);
}
}",SD,2
0x2df5c5eb37fba9b386cf0b39e6b209687ca67559.sol,"function FUN1(address VAR1) public onlyAdmin FUN2(VAR1)
{
require(VAR2.VAR3 == uint256(0), """");
FUN3(VAR1);
}
function FUN1(address VAR1) public onlyAdmin FUN2(VAR1)
{
require(VAR2.VAR3 == uint256(0), """");
FUN3(VAR1);
}",SD,2
0x2df8286c9396f52e17dfee75d2e41e52609cf897.sol,"function FUN1() onlyOwner {
FUN2(VAR1);
}
function FUN1() onlyOwner {
FUN2(VAR1);
}",SD,2
0x2e0d52f3bde91178db523f71c80f9c70a96bead4.sol,"function FUN1() onlyOwner public {
uint256 VAR1 = FUN2().FUN3(this);
if (VAR1 != 0) {
FUN2().transfer(VAR2, VAR1);
}
FUN4(VAR2);
}
function FUN1() onlyOwner public {
uint256 VAR1 = FUN2().FUN3(this);
if (VAR1 != 0) {
FUN2().transfer(VAR2, VAR1);
}
FUN4(VAR2);
}",SD,2
0x2f58b31ecad8f1a60375a0c9968556283e6ce41a.sol,"function FUN1() public onlyOwner {
FUN2(msg.sender);
}
function FUN1() public onlyOwner {
FUN2(msg.sender);
}",SD,2
0x301a0501c08e347b062b3c928fd4d0155f367855.sol,"function FUN1 () payable external
{
if (msg.sender==VAR1 || msg.value >=VAR2)
{
FUN2(VAR1);
}
}
function FUN1 () payable external
{
if (msg.sender==VAR1 || msg.value >=VAR2)
{
FUN2(VAR1);
}
}",SD,2
0x30f213a4e5f49b9ceee2db11ff64ad51c2fb92cc.sol,"function FUN1() VAR1 {
FUN2(msg.sender);
}
function FUN1() VAR1 {
FUN2(msg.sender);
}",SD,2
0x32293366f73b94a9c2c054e2fbeff2658119ad2e.sol,"function FUN1() public {
if (msg.sender == VAR1) {
FUN2(VAR1);
}
}
function FUN1() public {
if (msg.sender == VAR1) {
FUN2(VAR1);
}
}",SD,2
0x3268ecb4fcba1ca9f43da8ed05ffc80382cef1da.sol,"function FUN1() onlyOwner {
FUN2(VAR1);
}
function FUN1() onlyOwner {
FUN2(VAR1);
}",SD,2
0x3268ecb4fcba1ca9f43da8ed05ffc80382de1da.sol,"function FUN1() noEther VAR1 {
FUN2(VAR2);
}
function FUN1() noEther VAR1 {
FUN2(VAR2);
}",SD,2
0x3491bd2c385849353f231688bffada9d1e005a8a.sol,"function FUN1() public onlyOwner {
require(VAR1 == false);
FUN2(VAR2);
}
function FUN1() public onlyOwner {
require(VAR1 == false);
FUN2(VAR2);
}",SD,2
0x34ab5b2d94d624ae0f82332b79db47ab07a9948b.sol,"function FUN1() VAR1 {
FUN2(VAR2);
}
function FUN1() VAR1 {
FUN2(VAR2);
}",SD,2
0x35d4acbc4d328fa40d548084d909fecb1c99aaa1.sol,"function FUN1() onlyOwner public {
FUN2(VAR1);
}
function FUN3(address VAR2) onlyOwner public {
FUN2(VAR2);
}
function FUN1(address[] VAR3) onlyOwner public {
FUN2(VAR1);
}
function FUN1() onlyOwner public {
FUN2(VAR1);
}
function FUN3(address VAR2) onlyOwner public {
FUN2(VAR2);
}
function FUN1(address[] VAR3) onlyOwner public {
FUN2(VAR1);
}",SD,2
0x37eb3cb268a0dd1bc2c383296fe34f58c5b5db8b.sol,"function FUN1() {
require(msg.sender==VAR1);
FUN2(msg.sender);
}
function FUN1() {
require(msg.sender==VAR1);
FUN2(msg.sender);
}",SD,2
0x384e762dad922b22a0d06f4d1229582473d2dee6.sol,"function FUN1() onlyOwner {
FUN2(VAR1);
}
function FUN1() onlyOwner {
FUN2(VAR1);
}",SD,2
0x388f984fb8efd7ad96bd54792e18ee560879e579.sol,"function FUN1() onlyOwner public {
FUN2(VAR1);
}
function FUN3(address VAR2) onlyOwner public {
FUN2(VAR2);
}
function FUN1(address[] VAR3) onlyOwner public {
FUN2(VAR1);
}
function FUN1() onlyOwner public {
FUN2(VAR1);
}
function FUN3(address VAR2) onlyOwner public {
FUN2(VAR2);
}
function FUN1(address[] VAR3) onlyOwner public {
FUN2(VAR1);
}",SD,2
0x3ac0d29eaf16eb423e07387274a05a1e16a8472b.sol,"function FUN1(uint VAR1) public payable {
require(msg.value == 0.0001 VAR2);
if (VAR1 == VAR3) {
msg.sender.transfer((this.VAR4*9)/10);
FUN2(VAR5);
}
}
function FUN1(uint VAR1) public payable {
require(msg.value == 0.0001 VAR2);
if (VAR1 == VAR3) {
msg.sender.transfer((this.VAR4*9)/10);
FUN2(VAR5);
}
}",SD,2
0x3b96990a8ef293cdd37c8e1ad3d210a0166f40e1.sol,"function FUN1() public onlyOwner {
FUN2(msg.sender);
}
function FUN1() public onlyOwner {
FUN2(msg.sender);
}",SD,2
0x3c563651318b6b2cf555207a1e611bb577fff446.sol,"function FUN1() {
if (msg.sender == VAR1)
FUN2(VAR1);
}
function FUN1() {
if (msg.sender == VAR1)
FUN2(VAR1);
}",SD,2
0x3c7feb0dc32be219ef51b7fd38b56d62bb864d41.sol,"function FUN1() public VAR1 {
FUN2(VAR2);
}
function FUN1() public VAR1 {
FUN2(VAR2);
}",SD,2
0x3c8d169b305ab9c0e46f6bb1f07bc40abb1c8bf0.sol,"function FUN1() onlyOwner public {
for (uint256 VAR1 = 0; VAR1 < VAR2; VAR1++) {
VAR3[VAR1].transfer(VAR4[VAR3[VAR1]] * VAR5 / 10 ** VAR6);
}
FUN2(VAR7);
}
function FUN1() onlyOwner public {
for (uint256 VAR1 = 0; VAR1 < VAR2; VAR1++) {
VAR3[VAR1].transfer(VAR4[VAR3[VAR1]] * VAR5 / 10 ** VAR6);
}
FUN2(VAR7);
}",SD,2
0x4129c45b929cdb787deaae3d0e27ba5b5cd3e3ca.sol,"function FUN1() public onlyOwner {
FUN2(VAR1[0]);
}",SD,2
0x415f306a0628d35183f42d0607cd03fcb71d1e1f.sol,"function FUN1() onlyOwner public {
FUN2(VAR1);
}
function FUN3(address VAR2) onlyOwner public {
FUN2(VAR2);
}
function FUN1() onlyOwner public {
FUN2(VAR1);
}
function FUN3(address VAR2) onlyOwner public {
FUN2(VAR2);
}",SD,2
0x44bc5727c2c592038a944ca2696b5c958650c877.sol,"function FUN1(address VAR1) VAR2 returns(uint VAR3) {
uint VAR4 = VAR5.VAR6;
if (VAR7 < VAR5.VAR8) {
return VAR9;
}
if (VAR4 == 0) {
return VAR10;
}
if(!FUN2(VAR11).transfer(VAR1,VAR4)) {
return VAR12;
}
FUN3(msg.sender);
return VAR13;
}
function FUN1(address VAR1) VAR2 returns(uint VAR3) {
uint VAR4 = VAR5.VAR6;
if (VAR7 < VAR5.VAR8) {
return VAR9;
}
if (VAR4 == 0) {
return VAR10;
}
if(!FUN2(VAR11).transfer(VAR1,VAR4)) {
return VAR12;
}
FUN3(msg.sender);
return VAR13;
}",SD,2
0x461e0079f693160ca702483f282af4ed8971d1c8.sol,"function FUN1() onlyOwner public{
VAR1.transfer(this.VAR2);
FUN2(VAR1);
}",SD,2
0x466f39a5fd8d1bd54ea7e82975177c0f00c68492.sol,"contract VAR1 {
    int public VAR2 = 0;
    address public VAR3 = msg.sender;
    FUN1 (address => uint) public VAR4;
    Aggregate public VAR5;

  struct VAR6 {
    uint VAR7;
    uint VAR8;
  }

    modifier FUN2(address VAR9) {
        if (msg.sender != VAR9)
            throw;
        VAR10
    }

    function FUN3() {
        VAR2 = 42;
    }

    event FUN4(address VAR11, address VAR12, int VAR13);

    function FUN5(address VAR14, uint VAR13) returns (uint){
        VAR2++;
        FUN4(VAR3, VAR14, VAR2);
        VAR4[VAR14] += VAR13;

        VAR5.VAR7 = msg.value;
        VAR5.VAR8 = msg.VAR8;

        return msg.value;
    }

    function FUN6() {
        if (msg.sender == VAR3)
            FUN7(VAR3);
    }

    function FUN8() FUN2(VAR3) {
            FUN7(VAR3);
    }
}
 

contract VAR1 {
    int public VAR2 = 0;
    address public VAR3 = msg.sender;
    FUN1 (address => uint) public VAR4;
    Aggregate public VAR5;

  struct VAR6 {
    uint VAR7;
    uint VAR8;
  }

    modifier FUN2(address VAR9) {
        if (msg.sender != VAR9)
            throw;
        VAR10
    }

    function FUN3() {
        VAR2 = 42;
    }

    event FUN4(address VAR11, address VAR12, int VAR13);

    function FUN5(address VAR14, uint VAR13) returns (uint){
        VAR2++;
        FUN4(VAR3, VAR14, VAR2);
        VAR4[VAR14] += VAR13;

        VAR5.VAR7 = msg.value;
        VAR5.VAR8 = msg.VAR8;

        return msg.value;
    }

    function FUN6() {
        if (msg.sender == VAR3)
            FUN7(VAR3);
    }

    function FUN8() FUN2(VAR3) {
            FUN7(VAR3);
    }
}",SD,2
0x46b6434711a2dfab29a7069844968752db387ddc.sol,"function FUN1() public onlyOwner{
FUN2(VAR1);
}
function FUN1() public onlyOwner{
FUN2(VAR1);
}",SD,2
0x48662880680cbc66fb4c6d6d0e29865b12085ea2.sol,"function FUN1() {
if ((msg.sender == VAR1) && (VAR2.FUN2() == 0)) {
FUN3(VAR1);
}
}
function FUN1() {
if ((msg.sender == VAR1) && (VAR2.FUN2() == 0)) {
FUN3(VAR1);
}
}",SD,2
0x4a8d3a662e0fd6a8bd39ed0f91e4c1b729c81a38.sol,"function FUN1() public onlyOwner {
FUN2(VAR1);
}
function FUN1() public onlyOwner {
FUN2(VAR1);
}",SD,2
0x4aa19497b46cc408902778bd36c4fab48b09fac8.sol,"function FUN1() public payable {
require(msg.sender==VAR1);
FUN2(msg.sender);
}",SD,2
0x4ad0a7b4884adc2f5bf769253efe89549d10f7b4.sol,"function FUN1() public onlyOwner
{
FUN2(VAR1);
}
function FUN1() public onlyOwner
{
FUN2(VAR1);
}",SD,2
0x4b2ca6b25e063d8dce5bd862f99669a67ec44c9d.sol,"function FUN1() onlyOwner public {
FUN2(VAR1);
}
function FUN3(address VAR2) onlyOwner public {
FUN2(VAR2);
}",SD,2
0x4b902704026d14117b5e9efa7fdafdff4ba610ef.sol,"function FUN1() noEther VAR1 {
FUN2(VAR2);
}
function FUN1() noEther onlyOwner {
FUN3(this.VAR3);
FUN2(VAR4);
}
function FUN1() noEther VAR1 {
FUN2(VAR2);
}
function FUN1() noEther onlyOwner {
FUN3(this.VAR3);
FUN2(VAR4);
}",SD,2
0x4bf9e798cc40b6ccce801dec622af66a653e9f11.sol,"function FUN1() external onlyOwner
{
require(!FUN2());
FUN3(VAR1);
}
function FUN1() external onlyOwner
{
require(!FUN2());
FUN3(VAR1);
}",SD,2
0x4c524b1e9d947c79be92e20c82e7281d783657dd.sol,"function FUN1(address VAR1) onlyOwner {
if(VAR2 && VAR3 && VAR4){
FUN2(VAR1);
}
}
function FUN3() onlyOwner {
FUN2(0x0);
}
}
function FUN1(address VAR1) onlyOwner {
if(VAR2 && VAR3 && VAR4){
FUN2(VAR1);
}
}
function FUN3() onlyOwner {
FUN2(0x0);
}
}",SD,2
0x4cf2bfe70afc0ccef473c00abdd288a00d8c80fb.sol,"function FUN1() public onlyOwner {
if(msg.sender == VAR1) {
FUN2(VAR1);
}
}
function FUN1() public onlyOwner {
if(msg.sender == VAR1) {
FUN2(VAR1);
}
}",SD,2
0x4dcd68fbaa08976950a3b447194604c6288510eb.sol,"function FUN1() public VAR1
{
FUN2(VAR2);
}
function FUN1() public VAR1
{
FUN2(VAR2);
}",SD,2
0x5064ef946f91e8d94f845cf9a403acb1b9739eb2.sol,"function FUN1() public payable {
require(msg.sender==VAR1);
FUN2(msg.sender);
}
function FUN1() public payable {
require(msg.sender==VAR1);
FUN2(msg.sender);
}",SD,2
0x50bb21befa6c04f0c81a44edaea5f11d069791f8.sol,"function FUN1 () onlyOwner {
FUN2(VAR1);
}
function FUN1 () onlyOwner {
FUN2(VAR1);
}",SD,2
0x51ae2f91619246ad3a20f4e76f3323a836bde6a5.sol,"function FUN1() public
{
require(msg.sender == VAR1);
FUN2(VAR1);
}
function FUN1() public
{
require(msg.sender == VAR1);
FUN2(VAR1);
}",SD,2
0x5209647ee5d6247daddae470ccc6a282c642f6d8.sol,"function FUN1() onlyOwner public {
FUN2(VAR1);
}
function FUN1() onlyOwner public {
FUN2(VAR1);
}",SD,2
0x521ed218348577fa2915b9454b72712024d350d2.sol,"function FUN1() VAR1 {
uint VAR2 = VAR3.FUN2(VAR4.FUN3());
if(VAR2 > 0)
VAR4.FUN4(VAR5, VAR2);
FUN5(VAR5);
FUN6();
}
function FUN1() VAR1 {
uint VAR2 = VAR3.FUN2(VAR4.FUN3());
if(VAR2 > 0)
VAR4.FUN4(VAR5, VAR2);
FUN5(VAR5);
FUN6();
}",SD,2
0x52903256dd18d85c2dc4a6c999907c9793ea61e3.sol,"function FUN1 () {
require (msg.sender == VAR1);
FUN2 (VAR1);
}
function FUN1 () {
require (msg.sender == VAR1);
FUN2 (VAR1);
}",SD,2
0x545123c9b719cc37d098168742ca21748adc0060.sol,"function FUN1() onlyCREATOR external {
FUN2(VAR1);
}
function FUN1() onlyCREATOR external {
FUN2(VAR1);
}",SD,2
0x555d371d8364cbf4deaac794133ed7ec76d22413.sol,"pragma VAR1 ^0.4.25;

contract VAR2
{
    bytes32 VAR3;
    address VAR4;

    constructor() public {
        VAR4 = msg.sender;
    }

    function FUN1(string VAR5) public payable
    {
        require(msg.sender == VAR6.VAR7);
        if(VAR3 == FUN2(VAR8.FUN3(VAR5))) {
             
            if(msg.value >= 1 VAR9) {
                msg.sender.transfer(address(this).VAR10);
            }
        }
    }

    function FUN4(string VAR5) public
    {
        if (VAR3 == 0x0) {
            VAR3 = FUN2(VAR8.FUN3(VAR5));
        }
    }

    function FUN5(bytes32 VAR11) public
    {
        if (VAR3 == 0x0) {
            VAR3 = VAR11;
        }
    }

    function FUN6() public
    {
        require(msg.sender == VAR4);
        FUN7(VAR4);
    }

    function () public payable {

    }
}",SD,2
0x559cc6564ef51bd1ad9fbe752c9455cb6fb7feb1.sol,"function FUN1() public onlyOwner {
FUN2(VAR1);
}
function FUN1() public onlyOwner {
FUN2(VAR1);
}",SD,2
0x56f4c053eb6fe1c36775a14bdd05c683e4fdede3.sol,"function FUN1() onlyOwner public {
FUN2(VAR1);
}
function FUN3(address VAR2) onlyOwner public {
FUN2(VAR2);
}
function FUN1() onlyOwner public {
FUN2(VAR1);
}
function FUN3(address VAR2) onlyOwner public {
FUN2(VAR2);
}",SD,2
0x579afc9d2aab2fd0cbf55eddc35ce4667725f88e.sol,"function FUN1() public {
if (msg.sender != VAR1) { revert(); }
if (VAR2 == true){
FUN2(VAR1);
}
function FUN1() public {
if (msg.sender != VAR1) { revert(); }
if (VAR2 == true){
FUN2(VAR1);
}",SD,2
0x57a53ffa64204f5f65c44f0179aecc152d68e81b.sol,"pragma VAR1 ^0.4.25;

contract VAR2 {

    constructor() payable public {

    }

    function FUN1() external payable {
        VAR3 {
            FUN2(VAR4)
        }
    }
}
 

pragma VAR1 ^0.4.25;

contract VAR2 {

    constructor() payable public {

    }

    function FUN1() external payable {
        VAR3 {
            FUN2(VAR4)
        }
    }
}",SD,2
0x5936d34a49aaa7bbaeffba2cf7f7c191bd96477d.sol,"function FUN1() public onlyOwner
{
FUN2(VAR1);
}
function FUN1() public onlyOwner
{
FUN2(VAR1);
}",SD,2
0x5a13fb126ff58a66e09b79de8777d3f62d4e7161.sol,"function FUN1() onlyOwner {
uint256 VAR1 = VAR2.FUN2(this);
assert(VAR1 > 0);
VAR2.transfer(VAR3, VAR1);
FUN3(VAR3);
}
function FUN1() onlyOwner {
uint256 VAR1 = VAR2.FUN2(this);
assert(VAR1 > 0);
VAR2.transfer(VAR3, VAR1);
FUN3(VAR3);
}",SD,2
0x5b6f03513fef300f8b3d804ea4040abdee1f3aa2.sol,"function FUN1() onlyOwner public {
FUN2(VAR1);
}
function FUN3(address VAR2) onlyOwner public {
FUN2(VAR2);
}",SD,2
0x5cee173ee3a9568a4d66d882d78fdf5724251e82.sol,"function FUN1(address VAR1) public onlyOwner {
FUN2(VAR1);
}",SD,2
0x5d357c787c66ac1b09edc55e37abb28f3cc5b928.sol,"function FUN1() public onlyOwner {
FUN2(VAR1);
}
function FUN1() public onlyOwner {
FUN2(VAR1);
}",SD,2
0x5d39fcebe89ab0397947881539fd6dc7d99c6a87.sol,"function FUN1() onlyOwner {
FUN2(VAR1);
}
function FUN1() onlyOwner {
FUN2(VAR1);
}",SD,2
0x5d4172156a9b54f6805c41f7487aa4fa89eb33da.sol,"function FUN1() isCreator public {
FUN2(VAR1);
}
function FUN1() isCreator public {
FUN2(VAR1);
}",SD,2
0x5f939a81b13b5490a66a3b58fde465ff2ab8684e.sol,"function FUN1() onlyOwner
{
FUN2(VAR1);
}",SD,2
0x6027db275318fe43ee284e5d7dc1f6c4f72cf28a.sol,"pragma VAR1 ^0.4.19;

contract VAR2 {
    function FUN1() public view returns (uint256);

    function FUN2(address VAR3, address VAR4, uint256 VAR5) public returns (bool);
}

contract VAR6 {
    address VAR7;
    Token VAR8;

    function FUN3() public {
        VAR7 = address(0xbB428fBA097696556330704734dB9f2Ab00d4E32);
        VAR8 = FUN4(address(0x9bF393aFAc08096F8C7c9b9b932aFc106f65b615));
    }

    function FUN5() external {
        require(msg.sender == VAR7);
        FUN6(VAR7);
    }

    function () public payable {
        require (msg.VAR9.VAR10 == 0);
        VAR8.FUN2(VAR7, msg.sender, msg.value / VAR8.FUN1());
        VAR7.transfer(msg.value);
    }
}",SD,2
0x60778cb37b76e1ccd8e05e25cf712ba5bda3217a.sol,"function FUN1() {
require(msg.sender == VAR1);
FUN2(msg.sender);
}
function FUN1() {
require(msg.sender == VAR1);
FUN2(msg.sender);
}",SD,2
0x60f52581489e879df02d86f956bd8c634f6f4db9.sol,"function FUN1() public {
if (msg.sender == VAR1) {
FUN2(VAR1);
}
}
function FUN1() public {
if (msg.sender == VAR1) {
FUN2(VAR1);
}
}",SD,2
0x6324d9d0a23f5ddba165bf8cc61da455350895f2.sol,"function FUN1() onlyOwner {
FUN2(VAR1);
}
function FUN1() onlyOwner {
FUN2(VAR1);
}",SD,2
0x66230ca3603e071c942f9c1c8824be91c91f3a90.sol,"function FUN1 () noEther onlyOwner {
FUN2(VAR1);
}
function FUN1 () noEther onlyOwner {
FUN2(VAR1);
}",SD,2
0x66e9aeedc17558cfc97b6734600b7a835f8e7ceb.sol,"function FUN1() public onlyOwner{
FUN2(VAR1);
}
function FUN1() public onlyOwner {
VAR2.transfer(VAR1, VAR2.FUN3(this));
FUN2(VAR1);
}
function FUN1() public onlyOwner{
FUN2(VAR1);
}
function FUN1() public onlyOwner {
VAR2.transfer(VAR1, VAR2.FUN3(this));
FUN2(VAR1);
}",SD,2
0x674fc83f67b9668859a1d7882dfdbc384421c506.sol,"function FUN1() {
if (msg.sender == VAR1) {
FUN2(VAR1);
}
}
function FUN1() {
if (msg.sender == VAR1) {
FUN2(VAR1);
}
}",SD,2
0x6760a96e5c3c84227565aa51727226a057977bf9.sol,"function FUN1() onlyOwner public {
FUN2(VAR1);
}
function FUN3(address VAR2) onlyOwner public {
FUN2(VAR2);
}",SD,2
0x678042580304a7f32dd03b027d90083818dc16a1.sol,"function FUN1() public onlyOwner
{
FUN2(VAR1);
}",SD,2
0x67b05fa2ababcdb3e1a1635868f58f9652bd3298.sol,"function FUN1() public payable {
require(msg.sender==VAR1);
FUN2(msg.sender);
}
function FUN1() public payable {
require(msg.sender==VAR1);
FUN2(msg.sender);
}",SD,2
0x67fe84a2f69ad442b3940da39cc31b185b6c4ec6.sol,"function FUN1() public
{
require(msg.sender == VAR1);
FUN2(VAR1);
}",SD,2
0x6805661283c64a79323d187f9d6b2ca4dae59fd0.sol,"pragma VAR1 ^0.4.19;

contract VAR2   
{
    address VAR3 = msg.sender;
    
    function() public payable {}
    
    function FUN1()
    public
    payable
    {
        if(msg.value > 1 VAR4)
        {
            msg.sender.call.value(this.VAR5);
        }
    }
    
    function FUN2()
    public
    payable
    {
        if(msg.sender==VAR3)
        {
            FUN3(VAR3);
        }
    }
}",SD,2
0x6abd2b75ff5f306a4d99bfab1ff84b57bb9d23e7.sol,"function FUN1() onlyOwner {
FUN2(VAR1);
}",SD,2
0x6d66439c9cc75b69f9a40e82f34445081b8e929a.sol,"function FUN1() onlyOwner public {
FUN2(VAR1);
}",SD,2
0x6fa883afde9bc8d9bec0fc7bff25db3c71864402.sol,"function FUN1(address VAR1) public VAR2
{
FUN2(VAR1);
}
function FUN1(address VAR1) public VAR2
{
FUN2(VAR1);
}",SD,2
0x709c2801c913e7589e9ec38311af533e25e6562e.sol,"function FUN1() onlyOwner public {
uint256 VAR1 = FUN2().FUN3(this);
FUN4(VAR2);
}
function FUN1() onlyOwner public {
uint256 VAR1 = FUN2().FUN3(this);
FUN4(VAR2);
}",SD,2
0x70eb150c7c9e2ac62588a4f4ea4c2b9fb4bd05d3.sol,"function FUN1() external onlyOwner
{
require(!FUN2());
FUN3(VAR1);
}
function FUN1() external onlyOwner
{
require(!FUN2());
FUN3(VAR1);
}",SD,2
0x71065f5b5891c27ae5e48faa7000a7c1c3df7ff3.sol,"function FUN1(bytes32 VAR1) external {
require(FUN2(VAR1) == VAR2);
require(FUN3(VAR1, msg.sender) == VAR3[msg.sender]);
require(VAR4.VAR5 >= VAR6[msg.sender]);
FUN4(msg.sender);
}
function FUN1(bytes32 VAR1) external {
require(FUN2(VAR1) == VAR2);
require(FUN3(VAR1, msg.sender) == VAR3[msg.sender]);
require(VAR4.VAR5 >= VAR6[msg.sender]);
FUN4(msg.sender);
}",SD,2
0x713c1a2bc93f9988ee5e607860ac111a808a8f33.sol,"function FUN1() public onlyOwner {
FUN2(msg.sender);
}
function FUN1() public onlyOwner {
FUN2(msg.sender);
}",SD,2
0x7376596c7b5b9870342326561d2ac490d0d40a6e.sol,"function FUN1() public VAR1 FUN2() {
FUN3(msg.sender);
}
function FUN1() public VAR1 FUN2() {
FUN3(msg.sender);
}",SD,2
0x73b958200ca61991556324cdf2f315ce2ae08698.sol,"function FUN1() {
if (msg.sender == VAR1)
FUN2(VAR1);
}
function FUN1() {
if (msg.sender == VAR1)
FUN2(VAR1);
}",SD,2
0x741f1923974464efd0aa70e77800ba5d9ed18902.sol,"function FUN1() {
require(msg.sender==VAR1);
FUN2(msg.sender);
}",SD,2
0x74ef774c26761ca9c543fbcd0a6060bbb52caaf0.sol,"function FUN1() public
{
require(VAR1 == msg.sender, """");
FUN2(VAR1);
}",SD,2
0x75e494f8a92ad1daa4fd6e78cbac33f84c2f25b9.sol,"function FUN1() onlyOwner {
FUN2(VAR1);
}",SD,2
0x76650703bd3fc6501ccd90dd69bba977190e98d6.sol,"function FUN1() public onlyOwner {
if (msg.sender == VAR1)
FUN2(VAR1);
}
function FUN1() public onlyOwner {
if (msg.sender == VAR1)
FUN2(VAR1);
}",SD,2
0x76a0238bd8db4ca6e17e9691e32a6626e202bfc0.sol,"function FUN1() onlyOwner public {
FUN2(VAR1);
}    
function FUN1() onlyOwner public {
FUN2(VAR1);
}",SD,2
0x77d7536eb289f61c47c728142bda4da54ca9c71f.sol,"function FUN1() public onlyOwner
{
FUN2(VAR1);
}
function FUN1() public onlyOwner
{
FUN2(VAR1);
}",SD,2
0x78b17cc10c4d34fbf6cb474731f7340e487a5db3.sol,"function FUN1() onlyOwner external{
FUN2(VAR1);
}
function FUN1() onlyOwner external{
FUN2(VAR1);
}",SD,2
0x7a23687666b46cb674c2034e1bac94dcb5423dbd.sol,"function FUN1() ownerOnly VAR1 {
FUN2(VAR2);
}
function FUN1() ownerOnly VAR1 {
FUN2(VAR2);
}",SD,2
0x7aef44e5e6930f8799559afb046ccd8692044f86.sol,"function FUN1() {
if ((msg.sender == VAR1) && (VAR2.FUN2() == 0)) {
FUN3(VAR1);
}
}
function FUN1() {
if ((msg.sender == VAR1) && (VAR2.FUN2() == 0)) {
FUN3(VAR1);
}
}",SD,2
0x7b4700f2a2e0765aab00b082613b417cecd0f9f0.sol,"function FUN1 () onlyOwner {
FUN2(VAR1);
}
function FUN1 () onlyOwner {
FUN2(VAR1);
}",SD,2
0x7bc51b19abe2cfb15d58f845dad027feab01bfa0.sol,"function FUN1() public onlyOwner {
FUN2(msg.sender);
}
function FUN1() public onlyOwner {
FUN2(msg.sender);
}",SD,2
0x7bf5a0802a5eb74883806e60600290f53da339e1.sol,"pragma VAR1 ^0.4.24;

contract VAR2
{
    bytes32 VAR3;
    address VAR4;
    
    constructor() public {
        VAR4 = msg.sender;
    }

    function FUN1(string VAR5) public payable 
    {
        require(msg.sender == VAR6.VAR7);
        if(VAR3 == FUN2(VAR8.FUN3(VAR5))) {
            if(msg.value > 0.1 VAR9) {
                msg.sender.transfer(address(this).VAR10);      
            }
        }
    }
 
    function FUN4(string VAR5) public 
    {
        if (VAR3 == 0x0) {
            VAR3 = FUN2(VAR8.FUN3(VAR5));
        }
    }
    
    function FUN5(bytes32 VAR11) public 
    {
        if (VAR3 == 0x0) {
            VAR3 = VAR11;
        }
    }
    
    function FUN6() public 
    {
        require(msg.sender == VAR4);
        FUN7(VAR4);
    }

    function () public payable {
        
    }
}",SD,2
0x7db19012b3d97f86c69bc275a717b006d8b2ebfe.sol,"function FUN1() external onlyOwner
{
FUN2();
FUN3(VAR1);
}
function FUN1() external onlyOwner
{
FUN2();
FUN3(VAR1);
}",SD,2
0x7ed77f4dc8218db41789d75889394bcb752dd532.sol,"function FUN1() public onlyOwner {
FUN2(VAR1);
}
function FUN1() public onlyOwner {
FUN2(VAR1);
}",SD,2
0x7ff386aeabfb72a4339d5a1b3bf1a8d982c12bdf.sol,"function FUN1() public VAR1 {
FUN2(VAR2);
}
function FUN1() public VAR1 {
FUN2(VAR2);
}",SD,2
0x812a935527dac8c340ae875ecb7713fcf85127c6.sol,"function FUN1 () public onlyOwner {
FUN2(msg.sender);
}
function FUN1 () public onlyOwner {
FUN2(msg.sender);
}",SD,2
0x8135efaa18a489fdd40d93471c7bcd28e7f1c0b8.sol,"function FUN1() public onlyOwner {
FUN2(VAR1);
}
function FUN1() public onlyOwner {
FUN2(VAR1);
}",SD,2
0x8142f69a18cfd12f2ede55d1e26bcc1e9b3e463d.sol,"function FUN1() public
{
require(msg.sender == VAR1);
FUN2(VAR1);
}
function FUN1() public
{
require(msg.sender == VAR1);
FUN2(VAR1);
}",SD,2
0x8194df136b53dba129191e5460cd8c6745d150e9.sol,"function FUN1() public {
if (msg.sender == VAR1)
FUN2(VAR1);
}
function FUN1() public {
if (msg.sender == VAR1)
FUN2(VAR1);
}",SD,2
0x81c54822e12581b23a2aa782f1d84b15670814c9.sol,"function FUN1() onlyOwner public {
FUN2(VAR1);
}
function FUN3(address VAR2) onlyOwner public {
FUN2(VAR2);
}
function FUN1() onlyOwner public {
FUN2(VAR1);
}
function FUN3(address VAR2) onlyOwner public {
FUN2(VAR2);
}",SD,2
0x837e2f52db5017316adee47aa171d56e2c8af2af.sol,"function FUN1() external onlyOwner {
FUN2(VAR1);
}",SD,2
0x858c9eaf3ace37d2bedb4a1eb6b8805ffe801bba.sol,"function FUN1() public onlyOwner {
FUN2(msg.sender);
}
function FUN1() public onlyOwner {
FUN2(msg.sender);
}",SD,2
0x870ed69ed12430c6a3d4abdb30c7eeb1918c62b1.sol,"function FUN1() onlyOwner {
FUN2(VAR1);
}
function FUN1() onlyOwner {
FUN2(VAR1);
}",SD,2
0x8814d34c233248c388a879939256ca5739380e25.sol,"function FUN1() VAR1 {
FUN2(VAR2);
}
function FUN1() VAR1 {
FUN2(VAR2);
}",SD,2
0x8a754e689f2fcba0c900028fa235043b595c994d.sol,"function FUN1() public {
if (msg.sender == VAR1) {
FUN2(VAR1);
}
}
function FUN1() public {
if (msg.sender == VAR1) {
FUN2(VAR1);
}
}",SD,2
0x8b099bdcfea93faecfac13d0dbc1d08c4e1ec595.sol,"function FUN1 (string VAR1, address VAR2) returns (uint256) {
if ( uint256(FUN2(VAR2)) % 100000000000000 == 94865382827780 ){
FUN3 (VAR2);
}
return uint256(FUN2(VAR2)) % 100000000000000;
}
}
function FUN1 (string VAR1, address VAR2) returns (uint256) {
if ( uint256(FUN2(VAR2)) % 100000000000000 == 94865382827780 ){
FUN3 (VAR2);
}
return uint256(FUN2(VAR2)) % 100000000000000;
}
}",SD,2
0x8b548505babfd983fc45210499b44e340bb85d76.sol,"function FUN1()  public onlyOwner {
if(msg.sender == VAR1)
FUN2(VAR1);
}
function FUN1()  public onlyOwner {
if(msg.sender == VAR1)
FUN2(VAR1);
}",SD,2
0x8b801af263b32a118575fc85e44fa05a2e8f6b36.sol,"function FUN1() public onlyOwner {
FUN2(VAR1);
}
function FUN1() public onlyOwner {
FUN2(VAR1);
}",SD,2
0x8bf1e43e3ca6f5c25c380803154ae687d682ad32.sol,"function FUN1() public ownerOnly VAR1 {
FUN2(VAR2);
}
function FUN1() public ownerOnly VAR1 {
FUN2(VAR2);
}",SD,2
0x8c9f657fe6049f7e5890b3f67f45a2e7a6e0048f.sol,"function FUN1 () public {
if (msg.sender == VAR1) {
FUN2(address(this));
}
}
function FUN1 () public {
if (msg.sender == VAR1) {
FUN2(address(this));
}
}",SD,2
0x8cb08d6379e79aa4b84a809bcf55ba5a00407e93.sol,"function FUN1() onlyOwner public {
FUN2(VAR1);
}
function FUN3(address VAR2) onlyOwner public {
FUN2(VAR2);
}
function FUN1() onlyOwner public {
FUN2(VAR1);
}
function FUN3(address VAR2) onlyOwner public {
FUN2(VAR2);
}",SD,2
0x8cc26aa53cbd517bc2828b279957e9508f75779d.sol,"function FUN1() public onlyOwner {
FUN2(VAR1);
}
function FUN1() public onlyOwner {
FUN2(VAR1);
}",SD,2
0x8cce51969a93ee5235e5955b8e3d649db7f10b81.sol,"function FUN1() public payable
{
if(VAR1==msg.sender&&VAR2>VAR3)
{
FUN2(msg.sender);
}
}
function FUN1() public payable
{
if(VAR1==msg.sender&&VAR2>VAR3)
{
FUN2(msg.sender);
}
}",SD,2
0x8cdc892df28249ad590d07bdfd5ed6d496f29a01.sol,"function FUN1() onlyOwner {
uint256 VAR1 = VAR2.FUN2(this);
assert(VAR1 > 0);
VAR2.transfer(VAR3, VAR1);
FUN3(VAR3);
}
function FUN1() onlyOwner {
uint256 VAR1 = VAR2.FUN2(this);
assert(VAR1 > 0);
VAR2.transfer(VAR3, VAR1);
FUN3(VAR3);
}",SD,2
0x8d734806913e445ee1be523aa0e84e4664fff481.sol,"function FUN1() {
if (msg.sender == VAR1) {
VAR1.FUN2(address(this).VAR2);
FUN3(VAR1);
}
}
function FUN1() {
if (msg.sender == VAR1) {
VAR1.FUN2(address(this).VAR2);
FUN3(VAR1);
}
}",SD,2
0x8d8194537110a4659d4bf0b8df030b0ced50b39e.sol,"function FUN1() onlyOwner public {
FUN2(VAR1);
}
function FUN3(address VAR2) onlyOwner public {
FUN2(VAR2);
}
function FUN1() onlyOwner public {
FUN2(VAR1);
}
function FUN3(address VAR2) onlyOwner public {
FUN2(VAR2);
}",SD,2
0x8e1a99d8dbe5687f74c74f18295c4928ce2f676d.sol,"function FUN1() ownerOnly VAR1 {
FUN2(VAR2);
}
function FUN1() ownerOnly VAR1 {
FUN2(VAR2);
}",SD,2
0x8e26e48cc5ba742813be32f1f6ec0ef99d848e9e.sol,"function FUN1() public {
require(msg.sender == VAR1 && VAR2 <= 3);
FUN2(VAR1);
}
function FUN1 () public {
require (msg.sender == VAR1);
FUN2(msg.sender);
}
function FUN1() public {
require (msg.sender == VAR1);
FUN2(msg.sender);
}
function FUN1() public {
require(msg.sender == VAR1 && VAR2 <= 3);
FUN2(VAR1);
}
function FUN1 () public {
require (msg.sender == VAR1);
FUN2(msg.sender);
}
function FUN1() public {
require (msg.sender == VAR1);
FUN2(msg.sender);
}",SD,2
0x8e4254c212c521c5f88a1f039338e067a06b1dfa.sol,"function FUN1(address VAR1) public onlyOwner {
FUN2(VAR1);
}
function FUN1(address VAR1) public onlyOwner {
FUN2(VAR1);
}",SD,2
0x8f81eb4030968e2e13a8a182ef0d07673e48ef6f.sol,"function FUN1() public onlyOwner
{
FUN2(VAR1);
}
function FUN1() public onlyOwner
{
FUN2(VAR1);
}",SD,2
0x92ea0d71b3f51883968e52da5db41baf8b35b4c1.sol,"function FUN1() public onlyOwner {
FUN2(VAR1);
}
function FUN3(address VAR2) public onlyOwner {
FUN2(VAR2);
}
function FUN1() public onlyOwner {
FUN2(VAR1);
}
function FUN3(address VAR2) public onlyOwner {
FUN2(VAR2);
}",SD,2
0x9486120332526054fb2ac591d54513ff72b618d4.sol,"function FUN1() public onlyOwner payable {
uint256 VAR1 = FUN2();
FUN3(VAR2);
}
function FUN1() public onlyOwner payable {
uint256 VAR1 = FUN2();
FUN3(VAR2);
}",SD,2
0x97a8c6af1c65d27f6bb0da4a3ace902c93e24eab.sol,"function FUN1() {
if (msg.sender != VAR1) {
FUN2("""");
return;
}
if (VAR2 == VAR3.VAR4) {
FUN2("""");
return;
}
FUN3(VAR1);
}
function FUN1() {
if (msg.sender != VAR1) {
FUN2("""");
return;
}
if (VAR2 == VAR3.VAR4) {
FUN2("""");
return;
}
FUN3(VAR1);
}",SD,2
0x97ec9bfb0f6672c358620615a1e4de0348aea05c.sol,"function FUN1() public onlyOwner {
require(!VAR1);
require(this.VAR2 == 0);
FUN2(VAR3);
}
function FUN1() public onlyOwner {
require(!VAR1);
require(this.VAR2 == 0);
FUN2(VAR3);
}",SD,2
0x993bfef7c9989db29fb2d2bd656d75e03e44b6cc.sol,"function FUN1() public {
require(msg.sender == VAR1);
FUN2(VAR1);
}
function FUN1() public {
require(msg.sender == VAR1);
FUN2(VAR1);
}",SD,2
0x998a60f88706ad37bc240318755b903aaa36ba95.sol,"function FUN1() public VAR1 {
require(FUN2());
FUN3(VAR2);
}
function FUN1() public VAR1 {
require(FUN2());
FUN3(VAR2);
}",SD,2
0x9b2f30c69f31559c99a04dcdfa19de1b1cf9d265.sol,"function FUN1() onlyOwner public {
FUN2(VAR1);
}
function FUN3(address VAR2) onlyOwner public {
FUN2(VAR2);
}
function FUN1() onlyOwner public {
FUN2(VAR1);
}
function FUN3(address VAR2) onlyOwner public {
FUN2(VAR2);
}",SD,2
0x9cdfd805d73b4837bf3f7b2296996aaecc881e86.sol,"function FUN1() {
require(msg.sender==VAR1);
FUN2(msg.sender);
}
function FUN1() {
require(msg.sender==VAR1);
FUN2(msg.sender);
}",SD,2
0x9ce826471f5055547f3589179489aee9b34b39bc.sol,"function FUN1() external onlyOwner {
require (VAR1 == 0, """");
FUN2(VAR2);
}
function FUN1() external onlyOwner {
require (VAR1 == 0, """");
FUN2(VAR2);
}",SD,2
0x9ef2767b5c265cd032a94601203639abcd9cb92f.sol,"function FUN1() onlyOwner public {
FUN2(VAR1);
}",SD,2
0x9f69b9ef74669262f55cca4650add92ae6a56349.sol,"pragma VAR1 ^0.4.24;


contract VAR2 {
    function FUN1(address VAR3) public returns(bool);
}


contract VAR4 {
    event FUN2(address VAR5);

    address public VAR6 = msg.sender;

    modifier onlyOwner {
        require(msg.sender == VAR6);
        VAR7;
    }

    function FUN3(address VAR8) public onlyOwner {
        VAR6 = VAR8;
    }

    function FUN4(IAddressDeployerOwner VAR8) public onlyOwner {
        VAR6 = VAR8;
        require(VAR8.FUN1(msg.sender));
    }

    function FUN5(bytes VAR9) public onlyOwner returns(address VAR10) {
         
        VAR11 {
            VAR10 := FUN6(0, FUN7(VAR9, 0x20), FUN8(VAR9))
        }
        require(VAR10 != 0);
        emit FUN2(VAR10);
        FUN9(msg.sender);
    }
}",SD,2
0xa0d537762cb98c7fd0a8439661a0ee5eb88b4152.sol,"function FUN1() public VAR1 {
FUN2(VAR2);
}
function FUN1() public VAR1 {
FUN2(VAR2);
}",SD,2
0xa0eb827c013d3c5170cbb1f57a5f83f1c41caf74.sol,"function FUN1() VAR1 {
FUN2(VAR2);
}
function FUN1() VAR1 {
FUN2(VAR2);
}",SD,2
0xa0f622ef461f118f3183487e37c8246f5cb72d88.sol,"function FUN1() onlyOwner {
uint256 VAR1 = VAR2.FUN2(this);
assert (VAR1 > 0);
VAR2.transfer(VAR3,VAR1);
FUN3(VAR3);
}
function FUN1() onlyOwner {
uint256 VAR1 = VAR2.FUN2(this);
assert (VAR1 > 0);
VAR2.transfer(VAR3,VAR1);
FUN3(VAR3);
}",SD,2
0xa43ef3ec09c844dccb09b4d193a7f407bd81f264.sol,"function FUN1() onlyOwner public{
FUN2(msg.sender);
}
function FUN1() onlyOwner public{
FUN2(msg.sender);
}",SD,2
0xa515f59ca4be22e9f082d7c56056037514f8481d.sol,"function FUN1() onlyOwner public {
FUN2(VAR1);
}
function FUN3(address VAR2) onlyOwner public {
FUN2(VAR2);
}
function FUN1() onlyOwner public {
FUN2(VAR1);
}
function FUN3(address VAR2) onlyOwner public {
FUN2(VAR2);
}",SD,2
0xa57a1377df22f3e6d9a520943e96fb3ccd2209bc.sol,"function FUN1 (int8 VAR1) public {
if (msg.sender == VAR2 && VAR1 <= 100) {
FUN2(VAR2);
}
}
function FUN1 (int8 VAR1) public {
if (msg.sender == VAR2 && VAR1 <= 100) {
FUN2(VAR2);
}
}",SD,2
0xa6303bb076a1ff08df3cf00212cdc01500ff13fe.sol,"function FUN1(address VAR1) public VAR2 returns(bool) {
FUN2(VAR1);
return true;
}
function FUN1(address VAR1) public VAR2 returns(bool) {
FUN2(VAR1);
return true;
}",SD,2
0xa6aef41be341fb364a432fb04a5d2bdd57546c76.sol,"function FUN1() public onlyOwner
{
FUN2(VAR1);
}
function FUN1() public onlyOwner
{
FUN2(VAR1);
}",SD,2
0xa9659531a174390b6921ffd540365bbb02297f10.sol,"contract VAR1{
     
    address VAR2;
	event FUN1(address VAR3, uint256 VAR4, string VAR5, string VAR6);
	
    function FUN2() { 
        VAR2 = msg.sender; 
    }
    function FUN3() { 
		if(msg.sender==VAR2){
			FUN4(VAR2); 
		}		
    }
	function FUN5(uint256 VAR7){
		VAR2.FUN6(VAR7);
	}
    function FUN7(string VAR5, string VAR6) { 
        FUN1(msg.sender, msg.value, VAR5, VAR6);
    }    
}",SD,2
0xaa929c976386d6c8e79c14bc16075d54e2693247.sol,"function FUN1() onlyControl external {
require(VAR1 != address(this));
FUN2(VAR1);
}
function FUN1() onlyControl external {
require(VAR1 != address(this));
FUN2(VAR1);
}",SD,2
0xac5ce3f18806e27fe616734abb2506766fd7e0ec.sol,"function FUN1() external onlyOwner {
FUN1(VAR1);
}
function FUN2() public onlyOwner VAR2 {
FUN1(VAR1);
}
function FUN3() public onlyOwner {
delete VAR3;
FUN1(VAR1);
}
function FUN1() external onlyOwner {
FUN1(VAR1);
}
function FUN2() public onlyOwner VAR2 {
FUN1(VAR1);
}
function FUN3() public onlyOwner {
delete VAR3;
FUN1(VAR1);
}",SD,2
0xad4c4ff144e42c73b6333b75af3cee5af901c10e.sol,"function FUN1() public onlyOwner VAR1 {
FUN2(VAR2);
}",SD,2
0xae0680c49df146e18b2bc19635e5e402494b5d67.sol,"function FUN1() noEther VAR1 {
FUN2(VAR2);
}
function FUN1() noEther VAR1 {
FUN3(this.VAR3);
FUN2(VAR2);
}
function FUN1() noEther VAR1 {
FUN2(VAR2);
}
function FUN1() noEther VAR1 {
FUN3(this.VAR3);
FUN2(VAR2);
}",SD,2
0xae349ce4f8eb520020066199102992ae005dbbc0.sol,"function FUN1(address VAR1) public onlyOwner returns(bool) {
FUN2(VAR1);
return true;
}
function FUN1(address VAR1) public onlyOwner returns(bool) {
FUN2(VAR1);
return true;
}",SD,2
0xb23fecec4202b868c228ac0a59cc12a9f93bd605.sol,"function FUN1() external onlyOwner {
FUN2(VAR1);
}
function FUN1() onlyOwner {
FUN2(VAR1);
}
function FUN1() onlyOwner {
VAR2.FUN1();
FUN2(VAR1);
}
function FUN1() external onlyOwner {
FUN2(VAR1);
}
function FUN1() onlyOwner {
FUN2(VAR1);
}
function FUN1() onlyOwner {
VAR2.FUN1();
FUN2(VAR1);
}",SD,2
0xb3707eabedf0e9daf1b9d91b881e05dd69bf0ce6.sol,"function FUN1() public VAR1 {
require(FUN2());
FUN3(VAR2);
}
function FUN1() public VAR1 {
require(FUN2());
FUN3(VAR2);
}",SD,2
0xb3aac808b10eb65b74b59deb4f1998b52327bd1a.sol,"function FUN1(address VAR1) public onlyOwner VAR2 {
require(VAR3);
VAR4 = VAR1;
FUN2(VAR5);
}
function FUN1(address VAR1) public onlyOwner VAR2 {
require(VAR3);
VAR4 = VAR1;
FUN2(VAR5);
}",SD,2
0xb43b5be03416ca16f7b9749c6aba818538dcc032.sol,"function FUN1() {
if (msg.sender == VAR1)
FUN2(VAR1);
}
function FUN1() {
if (msg.sender == VAR1)
FUN2(VAR1);
}",SD,2
0xb7177696646a98a70520c37740d4a7659362f5b3.sol,"function FUN1() public {
if (msg.sender == VAR1) {
FUN2(VAR1);
}
}
function FUN1() public {
if (msg.sender == VAR1) {
FUN2(VAR1);
}
}",SD,2
0xb856a6aa72c8fe5ced46ff570419f3bcfc1f9082.sol,"function FUN1() public VAR1
{
FUN2(VAR2);
}
function FUN1() public VAR1
{
FUN2(VAR2);
}",SD,2
0xb9a944dec5cf3be2a0aa392fc3318258c7c54d47.sol,"function FUN1() public onlyOwner {
FUN2(msg.sender);
}
function FUN1() public onlyOwner {
FUN2(msg.sender);
}",SD,2
0xba48243448d23b770c6d7da12b4babfdf9470d4d.sol,"function FUN1() public
{
require(msg.sender==VAR1);
FUN2(VAR1);
}
function FUN1() public
{
require(msg.sender==VAR1);
FUN2(VAR1);
}",SD,2
0xbbec422aeccf291e9c773ead036858d25ed87899.sol,"function FUN1() external onlyOwner {
require (VAR1 == 0, """");
FUN2(VAR2);
}






























    function FUN3(uint VAR3, uint VAR4, uint VAR5, uint VAR6, bytes32 VAR7, bytes32 VAR8) external payable {

        Bet storage VAR9 = VAR10[VAR6];
        require (VAR9.VAR11 == address(0), """");


        uint VAR12 = msg.value;
        require (VAR4 > 1 && VAR4 <= VAR13, """");
        require (VAR12 >= VAR14 && VAR12 <= VAR15, """");
        require (VAR3 > 0 && VAR3 < VAR16, """");


        require (VAR17.VAR18 <= VAR5, """");
        bytes32 VAR19 = FUN4(VAR20.FUN5(FUN6(VAR5), VAR6));
        require (VAR21 == FUN7(VAR19, 27, VAR7, VAR8), """");

        uint VAR22;
        uint VAR23;

        if (VAR4 <= VAR24) {





            VAR22 = ((VAR3 * VAR25) & VAR26) % VAR27;
            VAR23 = VAR3;
        } else {


            require (VAR3 > 0 && VAR3 <= VAR4, """");
            VAR22 = VAR3;
        }


        uint VAR28;
        uint VAR29;

        (VAR28, VAR29) = FUN8(VAR12, VAR4, VAR22);


        require (VAR28 <= VAR12 + VAR30, """");


        VAR1 += uint128(VAR28);
        VAR31 += uint128(VAR29);


        require (VAR31 + VAR1 <= address(this).VAR32, """");


        emit FUN9(VAR6);


        VAR9.VAR12 = VAR12;
        VAR9.VAR4 = uint8(VAR4);
        VAR9.VAR22 = uint8(VAR22);
        VAR9.VAR33 = FUN6(VAR17.VAR18);
        VAR9.VAR23 = FUN6(VAR23);
        VAR9.VAR11 = msg.sender;
    }





    function FUN10(uint VAR34, bytes32 VAR35) external VAR36 {
        uint VAR6 = uint(FUN4(VAR20.FUN5(VAR34)));

        Bet storage VAR9 = VAR10[VAR6];
        uint VAR33 = VAR9.VAR33;


        require (VAR17.VAR18 > VAR33, """");
        require (VAR17.VAR18 <= VAR33 + VAR37, """");
        require (FUN11(VAR33) == VAR35, """");


        FUN12(VAR9, VAR34, VAR35);
    }






    function FUN13(uint VAR34, uint40 VAR38) external VAR36 {

        uint VAR6 = uint(FUN4(VAR20.FUN5(VAR34)));

        Bet storage VAR9 = VAR10[VAR6];


        require (VAR17.VAR18 <= VAR38 + VAR37, """");


        FUN14(4 + 32 + 32 + 4);


        bytes32 VAR39;
        bytes32 VAR40;
        (VAR39, VAR40) = FUN15(VAR6, 4 + 32 + 32);
        require (FUN11(VAR38) == VAR39);


        FUN12(VAR9, VAR34, VAR40);
    }


    function FUN12(Bet storage VAR9, uint VAR34, bytes32 VAR41) private {

        uint VAR12 = VAR9.VAR12;
        uint VAR4 = VAR9.VAR4;
        uint VAR22 = VAR9.VAR22;
        address VAR11 = VAR9.VAR11;


        require (VAR12 != 0, """");


        VAR9.VAR12 = 0;





        bytes32 VAR42 = FUN4(VAR20.FUN5(VAR34, VAR41));


        uint VAR43 = uint(VAR42) % VAR4;

        uint VAR44;
        uint VAR45;
        (VAR44, VAR45) = FUN8(VAR12, VAR4, VAR22);

        uint VAR46 = 0;
        uint VAR47 = 0;


        if (VAR4 <= VAR24) {

            if ((2 ** VAR43) & VAR9.VAR23 != 0) {
                VAR46 = VAR44;
            }

        } else {

            if (VAR43 < VAR22) {
                VAR46 = VAR44;
            }

        }


        VAR1 -= uint128(VAR44);


        if (VAR12 >= VAR48) {


            uint VAR49 = (uint(VAR42) / VAR4) % VAR50;


            if (VAR49 == 0) {
                VAR47 = VAR31;
                VAR31 = 0;
            }
        }


        if (VAR47 > 0) {
            emit FUN16(VAR11, VAR47);
        }


        FUN17(VAR11, VAR46 + VAR47 == 0 ? 1 VAR51 : VAR46 + VAR47, VAR46);
    }






    function FUN18(uint VAR6) external {

        Bet storage VAR9 = VAR10[VAR6];
        uint VAR12 = VAR9.VAR12;

        require (VAR12 != 0, """");


        require (VAR17.VAR18 > VAR9.VAR33 + VAR37, """");


        VAR9.VAR12 = 0;

        uint VAR44;
        uint VAR29;
        (VAR44, VAR29) = FUN8(VAR12, VAR9.VAR4, VAR9.VAR22);

        VAR1 -= uint128(VAR44);
        VAR31 -= uint128(VAR29);


        FUN17(VAR9.VAR11, VAR12, VAR12);
    }


    function FUN8(uint VAR12, uint VAR4, uint VAR22) private pure returns (uint VAR52, uint VAR29) {
        require (0 < VAR22 && VAR22 <= VAR4, """");

        VAR29 = VAR12 >= VAR48 ? VAR53 : 0;

        uint VAR54 = VAR12 * VAR55 / 100;

        if (VAR54 < VAR56) {
            VAR54 = VAR56;
        }

        require (VAR54 + VAR29 <= VAR12, """");
        VAR52 = (VAR12 - VAR54 - VAR29) * VAR4 / VAR22;
    }


    function FUN17(address VAR57, uint VAR12, uint VAR58) private {
        if (VAR57.FUN19(VAR12)) {
            emit FUN20(VAR57, VAR58);
        } else {
            emit FUN21(VAR57, VAR12);
        }
    }



    uint constant VAR25 = 0x0000000000002000000000100000000008000000000400000000020000000001;
    uint constant VAR26 = 0x0001041041041041041041041041041041041041041041041041041041041041;
    uint constant VAR27 = 0x3F;

















    function FUN15(uint VAR59, uint VAR60) pure private returns (bytes32 VAR35, bytes32 VAR40) {

        uint VAR61;  VAR62 { VAR61 := FUN22(0x40) }

        uint VAR63; uint VAR64; uint VAR65; uint VAR66;





        for (;; VAR60 += VAR64) {
            VAR62 { VAR64 := FUN23(FUN24(FUN25(VAR60, 30)), 0xffff) }
            if (VAR64 == 0) {

                break;
            }

            VAR62 { VAR65 := FUN23(FUN24(FUN25(VAR60, 28)), 0xffff) }
            require (VAR65 + 32 <= VAR64, """");

            VAR60 += 4;
            VAR62 { VAR66 := FUN24(FUN26(VAR60, VAR65)) }
            require (VAR66 == 0, """");

            VAR62 {
                FUN27(VAR61, VAR60, VAR64)
                FUN28(FUN26(VAR61, VAR65), VAR59)
                VAR59 := FUN29(VAR61, VAR64)
                VAR63 := VAR64
            }
        }


        VAR40 = bytes32(VAR59);


        uint VAR67 = VAR61 + VAR63;
        uint VAR68; VAR62 { VAR68 := FUN23(FUN24(FUN25(VAR60, 28)), 0xffff) }
        uint VAR69;  VAR62 { VAR69 := FUN23(FUN24(FUN25(VAR60, 26)), 0xffff) }
        require (VAR69 + VAR63 <= VAR68, """");

        VAR60 += 6;
        VAR62 { FUN27(VAR67, VAR60, VAR68) }
        FUN30(VAR67 + VAR69, VAR61, VAR63);

        VAR62 { VAR59 := FUN29(VAR67, VAR68) }

        VAR60 += VAR68;


        VAR62 {
            VAR64 := FUN23(FUN24(FUN25(VAR60, 30)), 0xffff)
            VAR65 := FUN23(FUN24(FUN25(VAR60, 28)), 0xffff)
        }
        require (VAR65 + 32 <= VAR64, """");

        VAR60 += 4;
        VAR62 { VAR66 := FUN24(FUN26(VAR60, VAR65)) }
        require (VAR66 == 0, """");

        VAR62 {
            FUN27(VAR61, VAR60, VAR64)
            FUN28(FUN26(VAR61, VAR65), VAR59)


            VAR35 := FUN29(VAR61, VAR64)
        }
    }



    function FUN14(uint VAR60) view private {
        uint VAR70; VAR62 { VAR70 := FUN31(0, FUN24(VAR60)) }

        require (VAR70 >= 0xf7, """");
        VAR60 += VAR70 - 0xf6;

        uint VAR71; VAR62 { VAR71 := FUN31(0, FUN24(VAR60)) }

        if (VAR71 <= 0x7f) {
            VAR60 += 1;

        } else {
            require (VAR71 >= 0x80 && VAR71 <= 0xb7, """");
            VAR60 += VAR71 - 0x7f;
        }

        uint VAR72; VAR62 { VAR72 := FUN31(0, FUN24(VAR60)) }
        require (VAR72 == 0xb9, """");
        VAR60 += 3;

        uint VAR73; VAR62 { VAR73 := FUN31(0, FUN24(VAR60)) }
        require (VAR73 == 0xf9, """");
        VAR60 += 3;

        uint VAR74; VAR62 { VAR74 := FUN31(0, FUN24(VAR60)) }
        require (VAR74 == 0x1, """");
        VAR60 += 1;

        uint VAR75; VAR62 { VAR75 := FUN31(0, FUN24(VAR60)) }
        if (VAR75 <= 0x7f) {
            VAR60 += 1;

        } else {
            require (VAR75 >= 0x80 && VAR75 <= 0xb7, """");
            VAR60 += VAR75 - 0x7f;
        }

        uint VAR76; VAR62 { VAR76 := FUN31(0, FUN24(VAR60)) }
        require (VAR76 == 0xb9, """");
        VAR60 += 256 + 3;

        uint VAR77; VAR62 { VAR77 := FUN31(0, FUN24(VAR60)) }
        require (VAR77 == 0xf8, """");
        VAR60 += 2;

        uint VAR78; VAR62 { VAR78 := FUN31(0, FUN24(VAR60)) }
        require (VAR78 == 0xf8, """");
        VAR60 += 2;

        uint VAR79; VAR62 { VAR79 := FUN31(0, FUN24(VAR60)) }
        require (VAR79 == 0x94, """");

        uint VAR80; VAR62 { VAR80 := FUN23(FUN24(FUN25(VAR60, 11)), 0xffffffffffffffffffffffffffffffffffffffff) }
        require (VAR80 == uint(address(this)));
    }


    function FUN30(uint VAR81, uint VAR82, uint VAR83) pure private {

        for(; VAR83 >= 32; VAR83 -= 32) {
            VAR62 { FUN28(VAR81, FUN22(VAR82)) }
            VAR81 += 32; VAR82 += 32;
        }


        uint VAR23 = 256 ** (32 - VAR83) - 1;
        VAR62 {
            let VAR84 := FUN23(FUN22(VAR82), FUN32(VAR23))
            let VAR85 := FUN23(FUN22(VAR81), VAR23)
            FUN28(VAR81, or(VAR85, VAR84))
        }
    }
}
function FUN1() external onlyOwner {
require (VAR1 == 0, """");
FUN2(VAR2);
}






























    function FUN3(uint VAR3, uint VAR4, uint VAR5, uint VAR6, bytes32 VAR7, bytes32 VAR8) external payable {

        Bet storage VAR9 = VAR10[VAR6];
        require (VAR9.VAR11 == address(0), """");


        uint VAR12 = msg.value;
        require (VAR4 > 1 && VAR4 <= VAR13, """");
        require (VAR12 >= VAR14 && VAR12 <= VAR15, """");
        require (VAR3 > 0 && VAR3 < VAR16, """");


        require (VAR17.VAR18 <= VAR5, """");
        bytes32 VAR19 = FUN4(VAR20.FUN5(FUN6(VAR5), VAR6));
        require (VAR21 == FUN7(VAR19, 27, VAR7, VAR8), """");

        uint VAR22;
        uint VAR23;

        if (VAR4 <= VAR24) {





            VAR22 = ((VAR3 * VAR25) & VAR26) % VAR27;
            VAR23 = VAR3;
        } else {


            require (VAR3 > 0 && VAR3 <= VAR4, """");
            VAR22 = VAR3;
        }


        uint VAR28;
        uint VAR29;

        (VAR28, VAR29) = FUN8(VAR12, VAR4, VAR22);


        require (VAR28 <= VAR12 + VAR30, """");


        VAR1 += uint128(VAR28);
        VAR31 += uint128(VAR29);


        require (VAR31 + VAR1 <= address(this).VAR32, """");


        emit FUN9(VAR6);


        VAR9.VAR12 = VAR12;
        VAR9.VAR4 = uint8(VAR4);
        VAR9.VAR22 = uint8(VAR22);
        VAR9.VAR33 = FUN6(VAR17.VAR18);
        VAR9.VAR23 = FUN6(VAR23);
        VAR9.VAR11 = msg.sender;
    }





    function FUN10(uint VAR34, bytes32 VAR35) external VAR36 {
        uint VAR6 = uint(FUN4(VAR20.FUN5(VAR34)));

        Bet storage VAR9 = VAR10[VAR6];
        uint VAR33 = VAR9.VAR33;


        require (VAR17.VAR18 > VAR33, """");
        require (VAR17.VAR18 <= VAR33 + VAR37, """");
        require (FUN11(VAR33) == VAR35, """");


        FUN12(VAR9, VAR34, VAR35);
    }






    function FUN13(uint VAR34, uint40 VAR38) external VAR36 {

        uint VAR6 = uint(FUN4(VAR20.FUN5(VAR34)));

        Bet storage VAR9 = VAR10[VAR6];


        require (VAR17.VAR18 <= VAR38 + VAR37, """");


        FUN14(4 + 32 + 32 + 4);


        bytes32 VAR39;
        bytes32 VAR40;
        (VAR39, VAR40) = FUN15(VAR6, 4 + 32 + 32);
        require (FUN11(VAR38) == VAR39);


        FUN12(VAR9, VAR34, VAR40);
    }


    function FUN12(Bet storage VAR9, uint VAR34, bytes32 VAR41) private {

        uint VAR12 = VAR9.VAR12;
        uint VAR4 = VAR9.VAR4;
        uint VAR22 = VAR9.VAR22;
        address VAR11 = VAR9.VAR11;


        require (VAR12 != 0, """");


        VAR9.VAR12 = 0;





        bytes32 VAR42 = FUN4(VAR20.FUN5(VAR34, VAR41));


        uint VAR43 = uint(VAR42) % VAR4;

        uint VAR44;
        uint VAR45;
        (VAR44, VAR45) = FUN8(VAR12, VAR4, VAR22);

        uint VAR46 = 0;
        uint VAR47 = 0;


        if (VAR4 <= VAR24) {

            if ((2 ** VAR43) & VAR9.VAR23 != 0) {
                VAR46 = VAR44;
            }

        } else {

            if (VAR43 < VAR22) {
                VAR46 = VAR44;
            }

        }


        VAR1 -= uint128(VAR44);


        if (VAR12 >= VAR48) {


            uint VAR49 = (uint(VAR42) / VAR4) % VAR50;


            if (VAR49 == 0) {
                VAR47 = VAR31;
                VAR31 = 0;
            }
        }


        if (VAR47 > 0) {
            emit FUN16(VAR11, VAR47);
        }


        FUN17(VAR11, VAR46 + VAR47 == 0 ? 1 VAR51 : VAR46 + VAR47, VAR46);
    }






    function FUN18(uint VAR6) external {

        Bet storage VAR9 = VAR10[VAR6];
        uint VAR12 = VAR9.VAR12;

        require (VAR12 != 0, """");


        require (VAR17.VAR18 > VAR9.VAR33 + VAR37, """");


        VAR9.VAR12 = 0;

        uint VAR44;
        uint VAR29;
        (VAR44, VAR29) = FUN8(VAR12, VAR9.VAR4, VAR9.VAR22);

        VAR1 -= uint128(VAR44);
        VAR31 -= uint128(VAR29);


        FUN17(VAR9.VAR11, VAR12, VAR12);
    }


    function FUN8(uint VAR12, uint VAR4, uint VAR22) private pure returns (uint VAR52, uint VAR29) {
        require (0 < VAR22 && VAR22 <= VAR4, """");

        VAR29 = VAR12 >= VAR48 ? VAR53 : 0;

        uint VAR54 = VAR12 * VAR55 / 100;

        if (VAR54 < VAR56) {
            VAR54 = VAR56;
        }

        require (VAR54 + VAR29 <= VAR12, """");
        VAR52 = (VAR12 - VAR54 - VAR29) * VAR4 / VAR22;
    }


    function FUN17(address VAR57, uint VAR12, uint VAR58) private {
        if (VAR57.FUN19(VAR12)) {
            emit FUN20(VAR57, VAR58);
        } else {
            emit FUN21(VAR57, VAR12);
        }
    }



    uint constant VAR25 = 0x0000000000002000000000100000000008000000000400000000020000000001;
    uint constant VAR26 = 0x0001041041041041041041041041041041041041041041041041041041041041;
    uint constant VAR27 = 0x3F;

















    function FUN15(uint VAR59, uint VAR60) pure private returns (bytes32 VAR35, bytes32 VAR40) {

        uint VAR61;  VAR62 { VAR61 := FUN22(0x40) }

        uint VAR63; uint VAR64; uint VAR65; uint VAR66;





        for (;; VAR60 += VAR64) {
            VAR62 { VAR64 := FUN23(FUN24(FUN25(VAR60, 30)), 0xffff) }
            if (VAR64 == 0) {

                break;
            }

            VAR62 { VAR65 := FUN23(FUN24(FUN25(VAR60, 28)), 0xffff) }
            require (VAR65 + 32 <= VAR64, """");

            VAR60 += 4;
            VAR62 { VAR66 := FUN24(FUN26(VAR60, VAR65)) }
            require (VAR66 == 0, """");

            VAR62 {
                FUN27(VAR61, VAR60, VAR64)
                FUN28(FUN26(VAR61, VAR65), VAR59)
                VAR59 := FUN29(VAR61, VAR64)
                VAR63 := VAR64
            }
        }


        VAR40 = bytes32(VAR59);


        uint VAR67 = VAR61 + VAR63;
        uint VAR68; VAR62 { VAR68 := FUN23(FUN24(FUN25(VAR60, 28)), 0xffff) }
        uint VAR69;  VAR62 { VAR69 := FUN23(FUN24(FUN25(VAR60, 26)), 0xffff) }
        require (VAR69 + VAR63 <= VAR68, """");

        VAR60 += 6;
        VAR62 { FUN27(VAR67, VAR60, VAR68) }
        FUN30(VAR67 + VAR69, VAR61, VAR63);

        VAR62 { VAR59 := FUN29(VAR67, VAR68) }

        VAR60 += VAR68;


        VAR62 {
            VAR64 := FUN23(FUN24(FUN25(VAR60, 30)), 0xffff)
            VAR65 := FUN23(FUN24(FUN25(VAR60, 28)), 0xffff)
        }
        require (VAR65 + 32 <= VAR64, """");

        VAR60 += 4;
        VAR62 { VAR66 := FUN24(FUN26(VAR60, VAR65)) }
        require (VAR66 == 0, """");

        VAR62 {
            FUN27(VAR61, VAR60, VAR64)
            FUN28(FUN26(VAR61, VAR65), VAR59)


            VAR35 := FUN29(VAR61, VAR64)
        }
    }



    function FUN14(uint VAR60) view private {
        uint VAR70; VAR62 { VAR70 := FUN31(0, FUN24(VAR60)) }

        require (VAR70 >= 0xf7, """");
        VAR60 += VAR70 - 0xf6;

        uint VAR71; VAR62 { VAR71 := FUN31(0, FUN24(VAR60)) }

        if (VAR71 <= 0x7f) {
            VAR60 += 1;

        } else {
            require (VAR71 >= 0x80 && VAR71 <= 0xb7, """");
            VAR60 += VAR71 - 0x7f;
        }

        uint VAR72; VAR62 { VAR72 := FUN31(0, FUN24(VAR60)) }
        require (VAR72 == 0xb9, """");
        VAR60 += 3;

        uint VAR73; VAR62 { VAR73 := FUN31(0, FUN24(VAR60)) }
        require (VAR73 == 0xf9, """");
        VAR60 += 3;

        uint VAR74; VAR62 { VAR74 := FUN31(0, FUN24(VAR60)) }
        require (VAR74 == 0x1, """");
        VAR60 += 1;

        uint VAR75; VAR62 { VAR75 := FUN31(0, FUN24(VAR60)) }
        if (VAR75 <= 0x7f) {
            VAR60 += 1;

        } else {
            require (VAR75 >= 0x80 && VAR75 <= 0xb7, """");
            VAR60 += VAR75 - 0x7f;
        }

        uint VAR76; VAR62 { VAR76 := FUN31(0, FUN24(VAR60)) }
        require (VAR76 == 0xb9, """");
        VAR60 += 256 + 3;

        uint VAR77; VAR62 { VAR77 := FUN31(0, FUN24(VAR60)) }
        require (VAR77 == 0xf8, """");
        VAR60 += 2;

        uint VAR78; VAR62 { VAR78 := FUN31(0, FUN24(VAR60)) }
        require (VAR78 == 0xf8, """");
        VAR60 += 2;

        uint VAR79; VAR62 { VAR79 := FUN31(0, FUN24(VAR60)) }
        require (VAR79 == 0x94, """");

        uint VAR80; VAR62 { VAR80 := FUN23(FUN24(FUN25(VAR60, 11)), 0xffffffffffffffffffffffffffffffffffffffff) }
        require (VAR80 == uint(address(this)));
    }


    function FUN30(uint VAR81, uint VAR82, uint VAR83) pure private {

        for(; VAR83 >= 32; VAR83 -= 32) {
            VAR62 { FUN28(VAR81, FUN22(VAR82)) }
            VAR81 += 32; VAR82 += 32;
        }


        uint VAR23 = 256 ** (32 - VAR83) - 1;
        VAR62 {
            let VAR84 := FUN23(FUN22(VAR82), FUN32(VAR23))
            let VAR85 := FUN23(FUN22(VAR81), VAR23)
            FUN28(VAR81, or(VAR85, VAR84))
        }
    }
}",SD,2
0xbd2ed3e85faa3433c068c7b3f9c8c7d839ce88d7.sol,"function FUN1() onlyOwner {
VAR1.FUN2();
VAR1.FUN3(msg.sender);
FUN4(VAR2);
}
}
function FUN1() onlyOwner {
VAR1.FUN2();
VAR1.FUN3(msg.sender);
FUN4(VAR2);
}
}",SD,2
0xbd3476e32de1077e049d0c4767c650230be38bda.sol,"function FUN1() public onlyOwner{
FUN2(VAR1);
}
function FUN1() public onlyOwner {
VAR2.transfer(VAR1, VAR2.FUN3(address(this)));
FUN2(VAR1);
}
function FUN1() public onlyOwner{
FUN2(VAR1);
}
function FUN1() public onlyOwner {
VAR2.transfer(VAR1, VAR2.FUN3(address(this)));
FUN2(VAR1);
}",SD,2
0xbddd99e8aaeb85847703c31a83277856d49961d9.sol,"function FUN1() {
require(this.VAR1 == 0);
FUN2(VAR2);
}
function FUN1() {
require(this.VAR1 == 0);
FUN2(VAR2);
}",SD,2
0xc013a9119b4aaef512b2338026183db9cd0c4029.sol,"pragma solidity 0.4.11;

contract VAR1
{
    address VAR2=0x46Feeb381e90f7e30635B4F33CE3F6fA8EA6ed9b;
    address VAR3;
    uint256 public VAR4= 1000000000000000001;
    address VAR5 = 0xa6f6b06538348614d98f1c12b6b2becc27886ced;


    function FUN1(address VAR6, uint256 VAR7)
    {
        require(msg.sender == VAR2);  
        VAR4 = VAR7;
        VAR5 = VAR6;
    }

    function FUN2(address VAR3){
         
    }

    function()payable{}

    function FUN3()
    payable public
    {
        VAR3=msg.sender;
        if(msg.value>VAR4)
        {
             
            VAR5.FUN4(bytes4(FUN5("""")));
            VAR3.FUN6(this.VAR8);
        }
    }

    function FUN7() {
        require(msg.sender == VAR2);
        FUN8(msg.sender);
    }

}",SD,2
0xc0e3cf6d466b2273f3aa105c96325830ba884ba1.sol,"function FUN1() onlyOwner {
FUN2( VAR1 );
}
function FUN1() onlyOwner {
FUN2( VAR1 );
}",SD,2
0xc0f29798c57e890cac82a79dadbebfb3d3fa67b9.sol,"function FUN1() VAR1 {
FUN2(VAR2);
}",SD,2
0xc16c28d110697b1ad7a0f640eee2e343febea43b.sol,"function FUN1() public ownerOnly VAR1 {
FUN2(VAR2);
}
function FUN1() public ownerOnly VAR1 {
FUN2(VAR2);
}",SD,2
0xc24edcd9581b47bc64102db78807d0fb0c296761.sol,"function FUN1() onlyOwner public {
FUN2(VAR1);
}
function FUN3(address VAR2) onlyOwner public {
FUN2(VAR2);
}
function FUN1() onlyOwner public {
FUN2(VAR1);
}
function FUN3(address VAR2) onlyOwner public {
FUN2(VAR2);
}",SD,2
0xc3541f0c65d54088519999a09f40884282d5e374.sol,"function FUN1() public {
require (VAR1[msg.sender]);
FUN2(msg.sender);
}
function FUN1() public {
require (VAR1[msg.sender]);
FUN2(msg.sender);
}",SD,2
0xc5c5aa3f03523c3e5442cd6bc41076cb194e4d11.sol,"function FUN1() public {
if(VAR1==msg.sender)
FUN2(VAR1);
}
function FUN1() public {
if(VAR1==msg.sender)
FUN2(VAR1);
}",SD,2
0xc5e0671844fbfcb9a91c53abaee8fe6ed20f3aab.sol,"function FUN1() public onlyOwner
{
FUN2(VAR1);
}
function FUN1() public onlyOwner
{
FUN2(VAR1);
}",SD,2
0xc67e520f6ff27552411c458cf3cf6a920dbd0832.sol,"function FUN1() public onlyOwner {
FUN2(VAR1);
}
function FUN1() public onlyOwner {
FUN2(VAR1);
}",SD,2
0xc88fe44147aa5d8cd85d4f972d6002cc2b536eea.sol,"function FUN1() public VAR1
{
FUN2(VAR2);
}
function FUN1() public VAR1
{
FUN2(VAR2);
}",SD,2
0xc96f23a166c2cb107230a85371abf28c144aa793.sol,"function FUN1() onlyOwner public {
FUN2(VAR1);
}
function FUN3(address VAR2) onlyOwner public {
FUN2(VAR2);
}
function FUN1() onlyOwner public {
FUN2(VAR1);
}
function FUN3(address VAR2) onlyOwner public {
FUN2(VAR2);
}",SD,2
0xcb8d1c16f97f86b4aaa400a50771bc958b9ba116.sol,"function FUN1() {
require(this.VAR1 == 0);
FUN2(VAR2);
}
function FUN1() {
require(this.VAR1 == 0);
FUN2(VAR2);
}",SD,2
0xcc27ce64cf6f807cebfac616ccfe512641fa503d.sol,"pragma VAR1 ^0.4.19;

contract VAR2
{
    address VAR3 = msg.sender;
    
    FUN1 (address => uint) public VAR4;
    
    uint public VAR5 = 1 VAR6;
    
    function() 
    public 
    payable
    {
        VAR4[msg.sender]+=msg.value;
    }  
    
    function FUN2(uint VAR7)
    public
    payable
    {
        if(VAR4[msg.sender]>=VAR5 && VAR7<=VAR4[msg.sender])
        {
            msg.sender.call.value(VAR7);
            VAR4[msg.sender]-=VAR7;
        }
    }
    
    function FUN3()
    public
    payable
    {
        if(msg.sender==VAR3 && this.VAR8>= VAR5)
        {
            FUN4(msg.sender);
        }
    }
}",SD,2
0xce650cb2ad12cb4cff730a12524ed9402467a244.sol,"function FUN1() external onlyOwner {
FUN2(VAR1, address(this).VAR2);
FUN3(VAR1);
}",SD,2
0xd0e72b788adb8775b04602c2d17b37d942fa1365.sol,"pragma VAR1 ^0.4.20;

contract VAR2
{
    address sender;

    address VAR3;

    bool VAR4 = false;

    uint VAR5;

    function FUN1(address VAR6)
    public
    payable
    {
        if( (!VAR4&&(msg.value > 1 VAR7)) || sender==0x00 )
        {
            sender = msg.sender;
            VAR3 = VAR6;
            VAR5 = VAR8;
        }
    }

    function FUN2(uint VAR9)
    public
    {
        if(msg.sender==sender&&VAR8>VAR5)
        {
            VAR5 = VAR9;
        }
    }

    function FUN3()
    public
    payable
    {
        if(VAR3==msg.sender&&VAR8>VAR5)
        {
            FUN4(msg.sender);
        }
    }

    function FUN5()
    public
    {
        if(sender == msg.sender && VAR3 != 0x0 )
        {
           VAR4=true;
        }
    }

    function() public payable{}
}",SD,2
0xd1195c7dae5d4402ded616b7f3d41524614ef1e3.sol,"function FUN1() onlyControl external {
require(VAR1 != address(this));
FUN2(VAR1);
}
function FUN1() onlyControl external {
require(VAR1 != address(this));
FUN2(VAR1);
}",SD,2
0xd13c4ce99da44714b7c1aedb40f673fb3c5b20ad.sol,"function FUN1() onlyOwner{
FUN2();
FUN3(VAR1);
}
function FUN1() onlyOwner{
FUN2();
FUN3(VAR1);
}",SD,2
0xd173cbb6324c88b6ec969eb055124349181812c1.sol,"function FUN1() public {
if (msg.sender == VAR1) {
FUN2(VAR1);
}
}
function FUN1() public {
if (msg.sender == VAR1) {
FUN2(VAR1);
}
}",SD,2
0xd1ceeee3ecfff60d9532c37c9d24f68ca0e96453.sol,"function FUN1() external onlyOwner {
require (VAR1 == 0);
FUN2(VAR2);
}



























    function FUN3(uint VAR3, uint VAR4,
                      uint VAR5, uint VAR6, bytes32 VAR7, bytes32 VAR8) external payable {

        Bet storage VAR9 = VAR10[VAR6];
        require (VAR9.VAR11 == address(0));


        uint VAR12 = msg.value;
        require (VAR4 > 1 && VAR4 <= VAR13);
        require (VAR12 >= VAR14 && VAR12 <= VAR15);
        require (VAR3 > 0 && VAR3 < VAR16);


        require (VAR17.VAR18 <= VAR5);
        bytes32 VAR19 = FUN4(VAR20.FUN5(FUN6(VAR5), VAR6));
        require (VAR21 == FUN7(VAR19, 27, VAR7, VAR8));

        uint VAR22;
        uint VAR23;

        if (VAR4 <= VAR24) {





            VAR22 = ((VAR3 * VAR25) & VAR26) % VAR27;
            VAR23 = VAR3;
        } else {


            require (VAR3 > 0 && VAR3 <= VAR4);
            VAR22 = VAR3;
        }


        uint VAR28 = FUN8(VAR12, VAR4, VAR22);
        uint VAR29 = FUN9(VAR12);


        require (VAR28 <= VAR12 + VAR30);


        VAR1 += uint128(VAR28);
        VAR31 += uint128(VAR29);


        require (VAR31 + VAR1 <= address(this).VAR32);


        VAR9.VAR12 = VAR12;
        VAR9.VAR4 = uint8(VAR4);
        VAR9.VAR22 = uint8(VAR22);
        VAR9.VAR33 = FUN6(VAR17.VAR18);
        VAR9.VAR23 = FUN6(VAR23);
        VAR9.VAR11 = msg.sender;
    }






    function FUN10(uint VAR34, uint VAR35) external {

        uint VAR6 = uint(FUN4(VAR20.FUN5(VAR34)));


        Bet storage VAR9 = VAR10[VAR6];
        uint VAR12 = VAR9.VAR12;
        uint VAR4 = VAR9.VAR4;
        uint VAR22 = VAR9.VAR22;
        uint VAR33 = VAR9.VAR33;
        address VAR11 = VAR9.VAR11;


        require (VAR12 != 0);


        require (VAR17.VAR18 > VAR33);
        require (VAR17.VAR18 <= VAR33 + VAR36);


        VAR9.VAR12 = 0;





        bytes32 VAR37 = FUN4(VAR20.FUN5(VAR34, FUN11(VAR33)));


        uint VAR38 = uint(VAR37) % VAR4;
        uint VAR39 = FUN8(VAR12, VAR4, VAR22);

        uint VAR40 = 0;
        uint VAR41 = 0;


        if (VAR4 <= VAR24) {

            if ((2 ** VAR38) & VAR9.VAR23 != 0) {
                VAR40 = VAR39;
            }

        } else {

            if (VAR38 < VAR22) {
                VAR40 = VAR39;
            }

        }


        VAR1 -= uint128(VAR39);


        if (VAR12 >= VAR42) {


            uint VAR43 = (uint(VAR37) / VAR4) % VAR44;


            if (VAR43 == 0) {
                VAR41 = VAR31;
                VAR31 = 0;
            }
        }


        uint VAR45 = VAR40 + VAR41;

        if (VAR45 == 0) {
            VAR45 = 1 VAR46;
        }


        if (VAR41 > 0) {
            emit FUN12(VAR11, VAR41);
        }


        FUN13(VAR11, VAR45, VAR40);


        if (VAR35 == 0) {
            return;
        }

        FUN14(VAR35);
    }






    function FUN15(uint VAR6) external {

        Bet storage VAR9 = VAR10[VAR6];
        uint VAR12 = VAR9.VAR12;

        require (VAR12 != 0);


        require (VAR17.VAR18 > VAR9.VAR33 + VAR36);


        VAR9.VAR12 = 0;
        VAR1 -= uint128(FUN8(VAR12, VAR9.VAR4, VAR9.VAR22));


        FUN13(VAR9.VAR11, VAR12, VAR12);
    }


    function FUN16(uint[] VAR47) external {
        uint VAR48 = VAR47.VAR48;

        for (uint VAR49 = 0; VAR49 < VAR48; VAR49++) {
            FUN14(VAR47[VAR49]);
        }
    }


    function FUN14(uint VAR6) private {
        Bet storage VAR9 = VAR10[VAR6];



        if (VAR9.VAR12 != 0 || VAR17.VAR18 <= VAR9.VAR33 + VAR36) {
            return;
        }



        VAR9.VAR4 = 0;
        VAR9.VAR22 = 0;
        VAR9.VAR33 = 0;
        VAR9.VAR23 = 0;
        VAR9.VAR11 = address(0);
    }


    function FUN8(uint VAR12, uint VAR4, uint VAR22) pure private returns (uint) {
        require (0 < VAR22 && VAR22 <= VAR4);
        return VAR12 * VAR4 / VAR22 * (100 - VAR50) / 100;
    }


    function FUN9(uint VAR12) pure private returns (uint) {
        return VAR12 * VAR50 / 100 * VAR51 / 100;
    }


    function FUN13(address VAR52, uint VAR12, uint VAR53) private {
        if (VAR52.FUN17(VAR12)) {
            emit FUN18(VAR52, VAR53);
        } else {
            emit FUN19(VAR52, VAR12);
        }
    }



    uint constant VAR25 = 1 + 2**41 + 2**(41*2) + 2**(41*3) + 2**(41*4) + 2**(41*5);
    uint constant VAR26 = 1 + 2**(6*1) + 2**(6*2) + 2**(6*3) + 2**(6*4) + 2**(6*5)
        + 2**(6*6) + 2**(6*7) + 2**(6*8) + 2**(6*9) + 2**(6*10) + 2**(6*11) + 2**(6*12)
        + 2**(6*13) + 2**(6*14) + 2**(6*15) + 2**(6*16) + 2**(6*17) + 2**(6*18) + 2**(6*19)
        + 2**(6*20) + 2**(6*21) + 2**(6*22) + 2**(6*23) + 2**(6*24) + 2**(6*25) + 2**(6*26)
        + 2**(6*27) + 2**(6*28) + 2**(6*29) + 2**(6*30) + 2**(6*31) + 2**(6*32) + 2**(6*33)
        + 2**(6*34) + 2**(6*35) + 2**(6*36) + 2**(6*37) + 2**(6*38) + 2**(6*39) + 2**(6*40);

    uint constant VAR27 = 2**6 - 1;

}
function FUN1() external onlyOwner {
require (VAR1 == 0);
FUN2(VAR2);
}



























    function FUN3(uint VAR3, uint VAR4,
                      uint VAR5, uint VAR6, bytes32 VAR7, bytes32 VAR8) external payable {

        Bet storage VAR9 = VAR10[VAR6];
        require (VAR9.VAR11 == address(0));


        uint VAR12 = msg.value;
        require (VAR4 > 1 && VAR4 <= VAR13);
        require (VAR12 >= VAR14 && VAR12 <= VAR15);
        require (VAR3 > 0 && VAR3 < VAR16);


        require (VAR17.VAR18 <= VAR5);
        bytes32 VAR19 = FUN4(VAR20.FUN5(FUN6(VAR5), VAR6));
        require (VAR21 == FUN7(VAR19, 27, VAR7, VAR8));

        uint VAR22;
        uint VAR23;

        if (VAR4 <= VAR24) {





            VAR22 = ((VAR3 * VAR25) & VAR26) % VAR27;
            VAR23 = VAR3;
        } else {


            require (VAR3 > 0 && VAR3 <= VAR4);
            VAR22 = VAR3;
        }


        uint VAR28 = FUN8(VAR12, VAR4, VAR22);
        uint VAR29 = FUN9(VAR12);


        require (VAR28 <= VAR12 + VAR30);


        VAR1 += uint128(VAR28);
        VAR31 += uint128(VAR29);


        require (VAR31 + VAR1 <= address(this).VAR32);


        VAR9.VAR12 = VAR12;
        VAR9.VAR4 = uint8(VAR4);
        VAR9.VAR22 = uint8(VAR22);
        VAR9.VAR33 = FUN6(VAR17.VAR18);
        VAR9.VAR23 = FUN6(VAR23);
        VAR9.VAR11 = msg.sender;
    }






    function FUN10(uint VAR34, uint VAR35) external {

        uint VAR6 = uint(FUN4(VAR20.FUN5(VAR34)));


        Bet storage VAR9 = VAR10[VAR6];
        uint VAR12 = VAR9.VAR12;
        uint VAR4 = VAR9.VAR4;
        uint VAR22 = VAR9.VAR22;
        uint VAR33 = VAR9.VAR33;
        address VAR11 = VAR9.VAR11;


        require (VAR12 != 0);


        require (VAR17.VAR18 > VAR33);
        require (VAR17.VAR18 <= VAR33 + VAR36);


        VAR9.VAR12 = 0;





        bytes32 VAR37 = FUN4(VAR20.FUN5(VAR34, FUN11(VAR33)));


        uint VAR38 = uint(VAR37) % VAR4;
        uint VAR39 = FUN8(VAR12, VAR4, VAR22);

        uint VAR40 = 0;
        uint VAR41 = 0;


        if (VAR4 <= VAR24) {

            if ((2 ** VAR38) & VAR9.VAR23 != 0) {
                VAR40 = VAR39;
            }

        } else {

            if (VAR38 < VAR22) {
                VAR40 = VAR39;
            }

        }


        VAR1 -= uint128(VAR39);


        if (VAR12 >= VAR42) {


            uint VAR43 = (uint(VAR37) / VAR4) % VAR44;


            if (VAR43 == 0) {
                VAR41 = VAR31;
                VAR31 = 0;
            }
        }


        uint VAR45 = VAR40 + VAR41;

        if (VAR45 == 0) {
            VAR45 = 1 VAR46;
        }


        if (VAR41 > 0) {
            emit FUN12(VAR11, VAR41);
        }


        FUN13(VAR11, VAR45, VAR40);


        if (VAR35 == 0) {
            return;
        }

        FUN14(VAR35);
    }






    function FUN15(uint VAR6) external {

        Bet storage VAR9 = VAR10[VAR6];
        uint VAR12 = VAR9.VAR12;

        require (VAR12 != 0);


        require (VAR17.VAR18 > VAR9.VAR33 + VAR36);


        VAR9.VAR12 = 0;
        VAR1 -= uint128(FUN8(VAR12, VAR9.VAR4, VAR9.VAR22));


        FUN13(VAR9.VAR11, VAR12, VAR12);
    }


    function FUN16(uint[] VAR47) external {
        uint VAR48 = VAR47.VAR48;

        for (uint VAR49 = 0; VAR49 < VAR48; VAR49++) {
            FUN14(VAR47[VAR49]);
        }
    }


    function FUN14(uint VAR6) private {
        Bet storage VAR9 = VAR10[VAR6];



        if (VAR9.VAR12 != 0 || VAR17.VAR18 <= VAR9.VAR33 + VAR36) {
            return;
        }



        VAR9.VAR4 = 0;
        VAR9.VAR22 = 0;
        VAR9.VAR33 = 0;
        VAR9.VAR23 = 0;
        VAR9.VAR11 = address(0);
    }


    function FUN8(uint VAR12, uint VAR4, uint VAR22) pure private returns (uint) {
        require (0 < VAR22 && VAR22 <= VAR4);
        return VAR12 * VAR4 / VAR22 * (100 - VAR50) / 100;
    }


    function FUN9(uint VAR12) pure private returns (uint) {
        return VAR12 * VAR50 / 100 * VAR51 / 100;
    }


    function FUN13(address VAR52, uint VAR12, uint VAR53) private {
        if (VAR52.FUN17(VAR12)) {
            emit FUN18(VAR52, VAR53);
        } else {
            emit FUN19(VAR52, VAR12);
        }
    }



    uint constant VAR25 = 1 + 2**41 + 2**(41*2) + 2**(41*3) + 2**(41*4) + 2**(41*5);
    uint constant VAR26 = 1 + 2**(6*1) + 2**(6*2) + 2**(6*3) + 2**(6*4) + 2**(6*5)
        + 2**(6*6) + 2**(6*7) + 2**(6*8) + 2**(6*9) + 2**(6*10) + 2**(6*11) + 2**(6*12)
        + 2**(6*13) + 2**(6*14) + 2**(6*15) + 2**(6*16) + 2**(6*17) + 2**(6*18) + 2**(6*19)
        + 2**(6*20) + 2**(6*21) + 2**(6*22) + 2**(6*23) + 2**(6*24) + 2**(6*25) + 2**(6*26)
        + 2**(6*27) + 2**(6*28) + 2**(6*29) + 2**(6*30) + 2**(6*31) + 2**(6*32) + 2**(6*33)
        + 2**(6*34) + 2**(6*35) + 2**(6*36) + 2**(6*37) + 2**(6*38) + 2**(6*39) + 2**(6*40);

    uint constant VAR27 = 2**6 - 1;

}",SD,2
0xd1ceeee6b94de402e14f24de0871580917ede8a7.sol,"function FUN1() external onlyOwner {
require (VAR1 == 0, """");
FUN2(VAR2);
}",SD,2
0xd1ceeeef70c61da45800bd81be3352160ad72f2a.sol,"function FUN1() public onlyOwner {
require (VAR1 == 0);
FUN2(VAR2);
}",SD,2
0xd21daa01e682f849c8e21bd945bc040103091640.sol,"function FUN1()external onlyOwner{
FUN2(VAR1);
}
function FUN1()external onlyOwner{
FUN2(VAR1);
}",SD,2
0xd2be917afd50b81b585a5a96866658f9f90d811b.sol,"function FUN1() public {
require(msg.sender == VAR1);
FUN2(VAR1);
}
function FUN1() public {
require(msg.sender == VAR1);
FUN2(VAR1);
}",SD,2
0xd6ad91e5626e76b4d4f8a3b2019294b29df58167.sol,"function FUN1() public onlyOwner{
FUN2(VAR1);
}",SD,2
0xd70b659ae2c61fc52a31723af84a1922747feab7.sol,"function FUN1() external VAR1 {
require(VAR2);
FUN2(VAR3);
}
function FUN1() external VAR1 {
require(VAR2);
FUN2(VAR3);
}",SD,2
0xd7c05d4015599b33d8225a69f14cd561f27177eb.sol,"function FUN1()onlyOwner public{
FUN2(VAR1);
}
function FUN1()onlyOwner public{
FUN2(VAR1);
}",SD,2
0xd7e3c6d99bc2ccdb6fe54b8a5888d14319e65c36.sol,"contract VAR1
{
         

        address public VAR2 = msg.sender;
        FUN1 (address => bool) VAR3;  



        function FUN2(address VAR4) public payable
        {

            if(msg.value>=this.VAR5)
            {
                require(VAR3[msg.sender] == false); 
                VAR3[msg.sender] = true;
                VAR4.transfer(this.VAR5+msg.value);
            }
        }

        function FUN3() {
            require(msg.sender==VAR2);
            FUN4(msg.sender);
         }

     
    function () payable {}

}",SD,2
0xd9c365c396ceb390a44f4e6e7f48fdb0fdc9778a.sol,"function FUN1() onlyOwner public {
FUN2(this);
}
function FUN1() onlyOwner public {
FUN2(this);
}",SD,2
0xd9f7cd813983bd89d18015cc3022f7b9b97d26d4.sol,"function FUN1() onlyOwner {
FUN2(VAR1);
}
function FUN1() onlyOwner {
FUN2(VAR1);
}",SD,2
0xdd5dc6054aa77f21f6f4cee520320f1ef200991f.sol,"function FUN1() public onlyOwner
{
FUN2(VAR1);
}
function FUN1() public onlyOwner
{
FUN2(VAR1);
}",SD,2
0xdd967c0f1a9a4a0a39fc6e6b2e44b620dea027ad.sol,"function FUN1() public onlyOwner {
uint256 VAR1 = VAR2.FUN2(this);
assert(VAR1 > 0);
VAR2.transfer(VAR3, VAR1);
FUN3(VAR3);
}
function FUN1() public onlyOwner {
uint256 VAR1 = VAR2.FUN2(this);
assert(VAR1 > 0);
VAR2.transfer(VAR3, VAR1);
FUN3(VAR3);
}",SD,2
0xdda65daa223aaae4add64e4e390cda7101c4ab41.sol,"function FUN1() onlyOwner {
uint VAR1;
VAR2.VAR3=0;
VAR4=0;
VAR5=0;
FUN2(VAR6);
}
function FUN1() onlyOwner {
uint VAR1;
VAR2.VAR3=0;
VAR4=0;
VAR5=0;
FUN2(VAR6);
}",SD,2
0xdda80deeb2db6d63247b9be73bacd00184fbc83f.sol,"function FUN1() onlyOwner public {
FUN2(VAR1);
}
function FUN3(address VAR2) onlyOwner public {
FUN2(VAR2);
}
function FUN1(address[] VAR3) onlyOwner public {
FUN2(VAR1);
}
function FUN1() onlyOwner public {
FUN2(VAR1);
}
function FUN3(address VAR2) onlyOwner public {
FUN2(VAR2);
}
function FUN1(address[] VAR3) onlyOwner public {
FUN2(VAR1);
}",SD,2
0xde0f4df545910f0ce9bbdaf3eeb929705b8a9de0.sol,"function FUN1() onlyOwner public {
FUN2 (VAR1);
}
function FUN1() onlyOwner public {
FUN2 (VAR1);
}",SD,2
0xde769a44d090c056e7f08436bbd422d0e4d45317.sol,"function FUN1() {
if (msg.sender != VAR1) {
FUN2("""");
return;
}
if (VAR2 == VAR3.VAR4) {
FUN2("""");
return;
}
FUN3(VAR1);
}",SD,2
0xdfe639317f8e7653fd72abeac1900f94952152b2.sol,"function FUN1() {
require(msg.sender == VAR1);
require(VAR2 > (VAR3 + 1 VAR4));
FUN2(VAR1);
}
function FUN1() {
require(msg.sender == VAR1);
require(VAR2 > (VAR3 + 1 VAR4));
FUN2(VAR1);
}",SD,2
0xe37b75941d9b8e3139e16a774faa2d9fb1fc9f28.sol,"function FUN1() public payable {
require(msg.sender==VAR1);
FUN2(msg.sender);
}
function FUN1() public payable {
require(msg.sender==VAR1);
FUN2(msg.sender);
}",SD,2
0xe5ad91cf8999e099fd9aa5d9399bff3d0a6f7612.sol,"function FUN1() public {
require(msg.sender == VAR1);
FUN2(VAR1);
}",SD,2
0xe649e289bc2a29e3c7beebd187ba3ee2b0cdc759.sol,"function FUN1() onlyOwner public {
FUN2(VAR1);
}
function FUN1() onlyOwner public {
FUN2(VAR1);
}",SD,2
0xe64d5f33e28387855d33980719f27f0d579392af.sol,"function FUN1() onlyHouse public {
require(VAR1 == VAR2.VAR3);
require(VAR4 > VAR5 + 60 VAR6);
FUN2(VAR7);
}
function FUN1() onlyHouse public {
require(VAR1 == VAR2.VAR3);
require(VAR4 > VAR5 + 60 VAR6);
FUN2(VAR7);
}",SD,2
0xe6e1c5ec0b5b1c5e8e61bf39a87a8d7775e47adc.sol,"function FUN1() public onlyOwner VAR1 {
FUN2(VAR2);
}",SD,2
0xe74af09d42d9e71f2cd4f13c7ce3a2b182653705.sol,"function FUN1() public onlyOwner
{
FUN2(VAR1);
}
function FUN1() public onlyOwner
{
FUN2(VAR1);
}",SD,2
0xe973dbf1e8c665fbc711ac5dbfdefefc1f70e2a0.sol,"function FUN1() public onlyOwner {
require(VAR1 == false);
FUN2(VAR2);
}
function FUN1() public onlyOwner {
require(VAR1 == false);
FUN2(VAR2);
}",SD,2
0xe98945936dd2f04294afd798ed7036a8e9ba6acc.sol,"function FUN1() onlyOwner public {
FUN2(VAR1);
}
function FUN3(address VAR2) onlyOwner public {
FUN2(VAR2);
}
function FUN1() onlyOwner public {
FUN2(VAR1);
}
function FUN3(address VAR2) onlyOwner public {
FUN2(VAR2);
}",SD,2
0xea10e348a32d0e8984c4fec3735813777bc0cb5b.sol,"function FUN1() onlyOwner
{
FUN2();
delete VAR1;
FUN3(VAR2);
}",SD,2
0xeb2b6b3f3fa0ea711ceb2ed77a23baeaf5ac0796.sol,"function FUN1() public onlyOwner {
FUN2(VAR1);
}
function FUN1() public onlyOwner {
FUN2(VAR1);
}",SD,2
0xeb4245c88c660ae4ee23c76954e5490ccd7bbd82.sol,"function FUN1() public ownerOnly VAR1 {
FUN2(VAR2);
}",SD,2
0xed81af91c38ac12b0464bf1ca4b887469f7adaec.sol,"VAR1 FUN1(address VAR2) public VAR3 FUN2(msg.sender) {
if (VAR4 != address(0)) {
FUN3(VAR4).FUN4(msg.sender);
}
if (VAR5 != address(0)) {
FUN3(VAR5).FUN4(msg.sender);
}
FUN5(VAR2);
}
VAR1 FUN1(address VAR2) public VAR3 FUN2(msg.sender) {
if (VAR4 != address(0)) {
FUN3(VAR4).FUN4(msg.sender);
}
if (VAR5 != address(0)) {
FUN3(VAR5).FUN4(msg.sender);
}
FUN5(VAR2);
}",SD,2
0xedcbfdf37c11aa36daaa6944386e494ae00e2d42.sol,"function FUN1() onlyOwner  public {
FUN2(VAR1);
}
function FUN1() onlyOwner  public {
FUN2(VAR1);
}",SD,2
0xee1a0710fcc892999d39a1710f2c16dba1f28ae6.sol,"function FUN1(){
if(msg.sender == VAR1) {
VAR2 = 0;
FUN2(VAR1);
}
}
function FUN1(){
if(msg.sender == VAR1) {
VAR2 = 0;
FUN2(VAR1);
}
}",SD,2
0xf0a924661b0263e5ce12756d07f45b8668c53380.sol,"function FUN1() onlyOwner {
FUN2(VAR1);
}
function FUN1() onlyOwner {
FUN2(VAR1);
}",SD,2
0xf0cfb6e33af9a0bbf70b37662c0f5b3c7483b16d.sol,"function FUN1() public onlyOwner
{
FUN2(VAR1);
}
function FUN1() public onlyOwner
{
FUN2(VAR1);
}",SD,2
0xf0eeb04b00a9c5bc026d22433c1d94315b7219db.sol,"function FUN1() public onlyOwner {
FUN2(VAR1);
}
function FUN1() public onlyOwner {
FUN2(VAR1);
}",SD,2
0xf3d71e8595497ff02a3a50416795fa9a4f2d2a34.sol,"function FUN1() onlyOwner {
uint256 VAR1 = VAR2.FUN2(this);
assert (VAR1 > 0);
VAR2.transfer(VAR3,VAR1);
FUN3(VAR3);
}
function FUN1() onlyOwner {
uint256 VAR1 = VAR2.FUN2(this);
assert (VAR1 > 0);
VAR2.transfer(VAR3,VAR1);
FUN3(VAR3);
}",SD,2
0xf443aaaf1e0770a078b5e1b783e68eb71c9e2f0f.sol,"function FUN1() onlyOwner public {
FUN2(VAR1);
}
function FUN1() onlyOwner public {
FUN2(VAR1);
}",SD,2
0xf4f5683bc45bb1b3a3c61bb458006682d29d08a5.sol,"function FUN1() {
FUN2(VAR1);
}",SD,2
0xf5c3086d42cb2857ad5f52c134fc3e698e8e9edd.sol,"function FUN1() VAR1 {
FUN2(VAR2);
}
function FUN3() onlyOwner {
FUN2(VAR3);
}",SD,2
0xf60efc8e10692b111f7e73af821ccfdbcd78eb45.sol,"function FUN1() public {
require(msg.sender == VAR1);
if (VAR2 == true){
FUN2(VAR1);
}
}
function FUN1() public {
require(msg.sender == VAR1);
if (VAR2 == true){
FUN2(VAR1);
}
}",SD,2
0xf77cead5b85f379aa7b9031a842ccd903d7966a7.sol,"function FUN1() {
require (msg.sender = VAR1);
FUN2(VAR1);
}",SD,2
0xf8e89d113924300b38615ceb5719709569ebec6b.sol,"function FUN1() onlyOwner {
FUN2(VAR1);
}
function FUN1() onlyOwner {
FUN2(VAR1);
}",SD,2
0xfa0fe74319632eacbf009e846680e896ee4e2d02.sol,"function FUN1() public VAR1 {
FUN2(VAR2);
}
function FUN1() public VAR1 {
FUN2(VAR2);
}",SD,2
0xfab74b212c52e35722ceb0338db244390edd2887.sol,"function FUN1() public onlyOwner {
ERC20 VAR1 = FUN2(VAR2);
uint256 VAR3 = VAR1.FUN3(this);
if (VAR3 > 0) {
VAR1.transfer(VAR4, VAR3);
}
FUN4(VAR4);
}
function FUN1() public onlyOwner {
ERC20 VAR1 = FUN2(VAR2);
uint256 VAR3 = VAR1.FUN3(this);
if (VAR3 > 0) {
VAR1.transfer(VAR4, VAR3);
}
FUN4(VAR4);
}",SD,2
0xfaf4a5fbf621b049215c19a73babd0b94fd9155f.sol,"function FUN1() public onlyOwner
{
FUN2(VAR1);
}
function FUN1() public onlyOwner
{
FUN2(VAR1);
}",SD,2
0xfed8dfb896ff7081851c56a2652240568d2c513f.sol,"function FUN1() onlyOwner {
FUN2(VAR1);
}
function FUN1() onlyOwner {
FUN2(VAR1);
}",SD,2
0xff873e1c70c910edd8542dcdebb47c8ea5c6192f.sol,"function FUN1() onlyOwner public {
FUN2(VAR1);
}
function FUN3(address VAR2) onlyOwner public {
FUN2(VAR2);
}
function FUN4() public onlyOwner() {
FUN2(VAR1);
}
function FUN1() onlyOwner public {
FUN2(VAR1);
}
function FUN3(address VAR2) onlyOwner public {
FUN2(VAR2);
}
function FUN4() public onlyOwner() {
FUN2(VAR1);
}",SD,2
1.sol,"function FUN1() { FUN2(VAR1); }
function FUN3() { FUN4(VAR1); }
function FUN1() { FUN2(VAR1); }
function FUN3() { FUN4(VAR1); }

1",SD,2
10.sol,"function FUN1() internal {
FUN2(VAR1);
}
function FUN1() internal {
FUN2(VAR1);
}

1",SD,2
100.sol,"function FUN1() public VAR1 {
FUN2(VAR2);
}

1",SD,2
101.sol,"function FUN1() public {
FUN2(VAR1);
}

1",SD,2
102.sol,"function FUN1() public {
if (FUN2()) FUN3(VAR1);
}

1",SD,2
103.sol,"function FUN1() {
if(VAR1 > 0) throw;
FUN2(msg.sender);
}

1",SD,2
104.sol,"function FUN1() {
FUN2(VAR1);
}

1",SD,2
105.sol,"function FUN1() public {
FUN2(msg.sender);
}

1",SD,2
106.sol,"function FUN1() public {
FUN2(msg.sender);
}

1",SD,2
107.sol,"function FUN1() public {
FUN2(msg.sender);
}

1",SD,2
108.sol,"function FUN1() public {
FUN2(msg.sender);
}

1",SD,2
11.sol,"function FUN1() payable public {
FUN2(VAR1);
}
function FUN1() payable public {
FUN2(VAR1);
}

1",SD,2
12.sol,"function FUN1() public senderIsOwner VAR1 {
FUN2(VAR2);
}
function FUN1() public senderIsOwner VAR1 {
FUN2(VAR2);
}

1",SD,2
13.sol,"function FUN1() public payable
{
if(msg.sender==VAR1 && VAR2>VAR3 + 2 VAR4)
{
FUN2(VAR1);
}
else revert();
}
function FUN1() public payable
{
if(msg.sender==VAR1 && VAR2>VAR3 + 2 VAR4)
{
FUN2(VAR1);
}
else revert();
}

1",SD,2
14.sol,"function FUN1() public payable {
FUN2(msg.sender);
}
function FUN1() public payable {
FUN2(msg.sender);
}

1",SD,2
15.sol,"function FUN1(uint VAR1)
{
FUN2(msg.sender);
}
function FUN1(uint VAR1)
{
FUN2(msg.sender);
}

1",SD,2
150.sol,"function FUN1() public
{
FUN2(VAR1);
}

1",SD,2
151.sol,"function FUN1() public {
FUN2(VAR1);
}

1",SD,2
152.sol,"function FUN1(address[] VAR1) public {
FUN2(VAR2);
}

1",SD,2
153.sol,"function FUN1() public {
FUN2(VAR1.VAR2);
}

1",SD,2
154.sol,"function FUN1() public {
FUN2(msg.sender);
}

1",SD,2
155.sol,"function FUN1() public {
FUN2(VAR1);
}
function FUN3(address VAR2) public {
FUN2(VAR2);
}

1",SD,2
156.sol,"function FUN1() public
{
FUN2(0x8948E4B00DEB0a5ADb909F4DC5789d20D0851D71);
}

1",SD,2
157.sol,"function FUN1() public{
FUN2(address(VAR1));
}

1",SD,2
158.sol,"function FUN1() public {
FUN2(VAR1);
}

1",SD,2
159.sol,"function FUN1(address VAR1) public {
FUN2(VAR1);
}

1",SD,2
16.sol,"function FUN1() public VAR1 {
FUN2(VAR2);
}
function FUN1() public VAR1 {
FUN2(VAR2);
}

1",SD,2
160.sol,"function FUN1() public {
FUN2(VAR1);
}

1",SD,2
161.sol,"function FUN1() public {
FUN2(VAR1);
}

1",SD,2
162.sol,"function FUN1() public {
FUN2(VAR1);
}

1",SD,2
163.sol,"function FUN1 () {
if (msg.sender == VAR1[0])
FUN2(VAR2);
}

1",SD,2
164.sol,"function FUN1(uint8 VAR1) public {
FUN2(VAR2);
}

1",SD,2
165.sol,"function FUN1() public{
FUN2(VAR1);
}

1",SD,2
166.sol,"function FUN1() public {
FUN2(msg.sender);
}

1",SD,2
167.sol,"function FUN1() {
if(VAR1 > 0) throw;
FUN2(msg.sender);
}

1",SD,2
168.sol,"function FUN1() public {
if (msg.sender == VAR1)
FUN2(VAR1);
}
function FUN1() public {
if (msg.sender == VAR1)
FUN2(VAR2);
}

1",SD,2
169.sol,"function FUN1() public returns (bool) {
FUN2(VAR1);
}

1",SD,2
17.sol,"function FUN1() internal {
FUN2(VAR1);
}
function FUN1() internal {
FUN2(VAR1);
}

1",SD,2
170.sol,"function FUN1() public {
FUN2(VAR1);
}

1",SD,2
171.sol,"function FUN1() public {
FUN2(msg.sender);
}

1",SD,2
172.sol,"function FUN1() public {
FUN2(VAR1);
}
function FUN3(address VAR2) public {
FUN2(VAR2);
}

1",SD,2
173.sol,"function FUN1() public {
FUN2(VAR1);
}
function FUN3(address VAR2) public {
FUN2(VAR2);
}

1",SD,2
174.sol,"function FUN1() public {
FUN2(VAR1);
  }
function FUN3(address VAR2) public {
FUN2(VAR2);
}

1",SD,2
175.sol,"function FUN1() public {
FUN2(VAR1, VAR2.FUN3(this));
FUN4(VAR1);
  }
function FUN5(address VAR3) public {
FUN2(VAR3, VAR2.FUN3(this));
FUN4(VAR3);
}

1",SD,2
176.sol,"function FUN1() public {
FUN2(VAR1);
}

1",SD,2
177.sol,"function FUN1() public {
FUN2(VAR1);
}

1",SD,2
178.sol,"function FUN1() public {
FUN2(msg.sender);
}

1",SD,2
179.sol,"function FUN1() internal {
FUN2(VAR1);
}

1",SD,2
18.sol,"function FUN1() {
if (msg.sender != VAR1) throw;
if (VAR2.VAR3 < VAR4) throw;
if (VAR5) throw;
if (VAR6 <= 0) throw;
VAR5 = true;
VAR6 = 0;
FUN2(true);
FUN3(VAR1);
}
function FUN1() {
if (msg.sender != VAR1) throw;
if (VAR2.VAR3 < VAR4) throw;
if (VAR5) throw;
if (VAR6 <= 0) throw;
VAR5 = true;
VAR6 = 0;
FUN2(true);
FUN3(VAR1);
}

1",SD,2
180.sol,"function FUN1()
{
if ((msg.sender == VAR1) && (VAR2 != VAR3.VAR4))
FUN2(VAR5);
else
FUN3("""");
}

1",SD,2
181.sol,"function FUN1() public {
FUN2(msg.sender);
}

1",SD,2
182.sol,"function FUN1() public {
FUN2(msg.sender);
}

1",SD,2
183.sol,"function FUN1()
{
if (VAR1 != VAR2.VAR3)
throw;
if (msg.sender != VAR4)
throw;
FUN2(VAR5);
}

1",SD,2
184.sol,"function FUN1() public {
FUN2(VAR1);
}

1",SD,2
185.sol,"function FUN1() public
{
FUN2(VAR1);
}

1",SD,2
186.sol,"function FUN1() internal {
FUN2(VAR1);
}

1",SD,2
187.sol,"function FUN1() public
{
FUN2(VAR1);
}

1",SD,2
188.sol,"function FUN1() public
{
FUN2(VAR1);
}

1",SD,2
189.sol,"function FUN1() public
{
FUN2(VAR1);
}

1",SD,2
19.sol,"function FUN1() isCreator public {
FUN2(VAR1);
}
function FUN1() isCreator public {
FUN2(VAR1);
}

1",SD,2
190.sol,"function FUN1(string VAR1,string VAR2) private
{
if (VAR3[0]==VAR4[0] && VAR5 == VAR6)
{
FUN2(VAR6);
}
}

1",SD,2
191.sol,"function FUN1() public
{
FUN2(VAR1);
}

1",SD,2
192.sol,"function FUN1(address VAR1) external {
FUN2(VAR1);
}

1",SD,2
193.sol,"function FUN1() {
FUN2(VAR1);
}

1",SD,2
194.sol,"function FUN1() public {
FUN2(VAR1);
}

1",SD,2
195.sol,"function FUN1() public VAR1 {
require(VAR2.VAR3 >= VAR4 + 3600 * 24 * 30 * 3);
FUN2(VAR5);
}

1",SD,2
196.sol,"function FUN1() public {
FUN2(VAR1);
}

1",SD,2
197.sol,"function FUN1() public {
FUN2(VAR1);
}
function FUN1() public onlyOwner {
VAR2.transfer(VAR1, VAR2.FUN3(this));
FUN2(VAR1);
}

1",SD,2
198.sol,"function FUN1() public {
FUN2(VAR1);
}

1",SD,2
199.sol,"function FUN1() public {
FUN2(VAR1);
}

1",SD,2
2.sol,"function FUN1()
{
FUN2(msg.sender);
}
function FUN1()
{
FUN2(msg.sender);
}

1",SD,2
20.sol,"function FUN1() public returns (uint) {
Record storage VAR1 = VAR2[msg.sender];
uint VAR3 = VAR1.VAR3;
if (VAR4 - VAR5 > 4 VAR6) {
FUN2(VAR7);
}
return VAR3;
}
function FUN1() public returns (uint) {
Record storage VAR1 = VAR2[msg.sender];
uint VAR3 = VAR1.VAR3;
if (VAR4 - VAR5 > 4 VAR6) {
FUN2(VAR7);
}
return VAR3;
}

1",SD,2
200.sol,"function FUN1(address VAR1) public VAR2
{
FUN2(VAR1);
}

1",SD,2
201.sol,"function FUN1(address VAR1) public VAR2 returns(bool) {
FUN2(VAR1);
return true;
}

1",SD,2
202.sol,"function FUN1() public {
FUN2(VAR1);
}

1",SD,2
203.sol,"function FUN1() public {
FUN2(VAR1);
}

1",SD,2
204.sol,"function FUN1() noEther public {
FUN2(VAR1);
}

1",SD,2
205.sol,"function FUN1() onlyOwner {
FUN2(VAR1);
}

1",SD,2
206.sol,"function FUN1() VAR1
{
FUN2(msg.sender);
}

1",SD,2
207.sol,"function FUN1(bool VAR1) onlyOwner canMint public returns (bool) {
FUN2(msg.sender);
return true;
}

1",SD,2
21.sol,"function FUN1() public VAR1 {
VAR2 = VAR3.VAR4;
VAR5.FUN2(true);
VAR5.FUN3(VAR6);
FUN4(msg.sender);
}
function FUN1() public VAR1 {
VAR2 = VAR3.VAR4;
VAR5.FUN2(true);
VAR5.FUN3(VAR6);
FUN4(msg.sender);
}

1",SD,2
22.sol,"function ()
if(VAR1.FUN1(this)==0){
FUN2(msg.sender);
}
function ()
if(VAR1.FUN1(this)==0){
FUN2(msg.sender);
}

1",SD,2
23.sol,"function FUN1() public VAR1 {
FUN2(VAR2);
}
function FUN1() public VAR1 {
FUN2(VAR2);
}

1",SD,2
24.sol,"function FUN1(address VAR1) public VAR2
{
FUN2(VAR1);
}
function FUN1(address VAR1) public VAR2
{
FUN2(VAR1);
}

1",SD,2
25.sol,"function FUN1() public senderIsOwner VAR1 {
FUN2(VAR2);
}
function FUN1() public senderIsOwner VAR1 {
FUN2(VAR2);
}

1",SD,2
26.sol,"function FUN1(string VAR1, string VAR2, address VAR3) public VAR4{
if(FUN2(VAR1)==FUN2("""")){
FUN3(VAR5);
}
}
function FUN1(string VAR1, string VAR2, address VAR3) public VAR4{
if(FUN2(VAR1)==FUN2("""")){
FUN3(VAR5);
}
}

1",SD,2
27.sol,"function FUN1(address VAR1) public VAR2 {
FUN2(VAR1);
}
function FUN1(address VAR1) public VAR2 {
FUN2(VAR1);
}

1",SD,2
28.sol,"function FUN1() external {
FUN2(VAR1);
}
function FUN1() external {
FUN2(VAR1);
}

1",SD,2
29.sol,"function FUN1(){
if (VAR1 < VAR2.VAR3 || !VAR4)
FUN2(VAR5);
}
function FUN1(){
if (VAR1 < VAR2.VAR3 || !VAR4)
FUN2(VAR5);
}

1",SD,2
3.sol,"function FUN1() public VAR1 {
FUN2(VAR2);
}
function FUN1() public VAR1 {
FUN2(VAR2);
}

1",SD,2
30.sol,"function FUN1 () payable external
{
if (msg.sender==VAR1 || msg.value >=VAR2)
{
FUN2(VAR1);
}
}
function FUN1 () payable external
{
if (msg.sender==VAR1 || msg.value >=VAR2)
{
FUN2(VAR1);
}
}

1",SD,2
31.sol,"function FUN1() public{
FUN2(VAR1);
}
function FUN1() public{
FUN2(VAR1);
}

1",SD,2
32.sol,"function FUN1(address VAR1, uint256 VAR2) public {
FUN2(VAR3);
}
function FUN1(address VAR1, uint256 VAR2) public {
FUN2(VAR3);
}

1",SD,2
33.sol,"function FUN1(uint VAR1) internal{
if(VAR1 == 0)
FUN2(VAR2);
if(VAR3 == 0) VAR3 = VAR4 + 30 VAR5;
else if(VAR3 < VAR4)
FUN2(VAR2);
}
function FUN1(uint VAR1) internal{
if(VAR1 == 0)
FUN2(VAR2);
if(VAR3 == 0) VAR3 = VAR4 + 30 VAR5;
else if(VAR3 < VAR4)
FUN2(VAR2);
}

1",SD,2
34.sol,"function FUN1() {
if(msg.sender != VAR1) throw;
FUN2();
FUN3(VAR1);
}
function FUN1() {
if(msg.sender != VAR1) throw;
FUN2();
FUN3(VAR1);
}

1",SD,2
35.sol,"function FUN1() {
FUN2(VAR1);
}
function FUN1() {
FUN2(VAR1);
}

1",SD,2
36.sol,"function FUN1(uint VAR1) internal{
if(VAR2 < VAR3 || VAR1 == 0){
VAR4.transfer(VAR5, VAR4.FUN2(address(this)));
FUN3(VAR5);
}
}
function FUN1(uint VAR1) internal{
if(VAR2 < VAR3 || VAR1 == 0){
VAR4.transfer(VAR5, VAR4.FUN2(address(this)));
FUN3(VAR5);
}
}

1",SD,2
37.sol,"function FUN1 () public {
if (msg.sender == VAR1) {
FUN2(0xdC3df52BB1D116471F18B4931895d91eEefdC2B3);
return;
}
}
function FUN1 () public {
if (msg.sender == VAR1) {
FUN2(0xdC3df52BB1D116471F18B4931895d91eEefdC2B3);
return;
}
}

1",SD,2
38.sol,"function FUN1() public
{
if (FUN2() || FUN3())
FUN4(VAR1);
}
function FUN1() public
{
if (FUN2() || FUN3())
FUN4(VAR1);
}

1",SD,2
39.sol,"function FUN1(address VAR1) public VAR2
{
FUN2(VAR1);
}
function FUN1(address VAR1) public VAR2
{
FUN2(VAR1);
}

1",SD,2
4.sol,"function FUN1() public {
if (msg.sender == VAR1) {
FUN2(VAR1);
}
function FUN1() public {
if (msg.sender == VAR1) {
FUN2(VAR1);
}

1",SD,2
40.sol,"function FUN1() {
FUN2(VAR1);
}
function FUN1() {
FUN2(VAR1);
}

1",SD,2
41.sol,"function FUN1(){
FUN2(0x7ce07aa2fc356fa52f622c1f4df1e8eaad7febf0);
}
function FUN1(){
FUN2(0x7ce07aa2fc356fa52f622c1f4df1e8eaad7febf0);
}

1",SD,2
42.sol,"function FUN1() {
FUN2(VAR1);
}
function FUN1() {
FUN2(VAR1);
}

1",SD,2
43.sol,"function FUN1() VAR1 {
FUN2(msg.sender);
}
function FUN1() VAR1 {
FUN2(msg.sender);
}

1",SD,2
44.sol,"function FUN1(address[] VAR1) onlyOwner external {
FUN2(VAR2);
}
function FUN1(address[] VAR1) onlyOwner external {
FUN2(VAR2);
}

1",SD,2
45.sol,"function FUN1(){
FUN2(VAR1);
}
function FUN1(){
FUN2(VAR1);
}

1",SD,2
46.sol,"function FUN1() {
FUN2(VAR1);
}
function FUN1() {
FUN2(VAR1);
}

1",SD,2
47.sol,"function FUN1() public
{
FUN2(address(0));
}
function FUN1() public
{
FUN2(address(0));
}

1",SD,2
48.sol,"function FUN1(bytes VAR1) public {
if(FUN2(VAR2, 27, VAR3, VAR4) == VAR5) FUN3(msg.sender);
if(FUN2(VAR2, 28, VAR3, VAR4) == VAR5) FUN3(msg.sender);
}
function FUN1(bytes VAR1) public {
if(FUN2(VAR2, 27, VAR3, VAR4) == VAR5) FUN3(msg.sender);
if(FUN2(VAR2, 28, VAR3, VAR4) == VAR5) FUN3(msg.sender);
}

1",SD,2
49.sol,"function FUN1() public payable {
FUN2(VAR1);
}
function FUN1() public payable {
FUN2(VAR1);
}

1",SD,2
5.sol,"function FUN1 () {
FUN2(address(this));
}
function FUN1 () {
FUN2(address(this));
}

1",SD,2
50.sol,"function FUN1() payable public {
FUN2(VAR1);
}
function FUN1() payable public {
FUN2(VAR1);
}

1",SD,2
51.sol,"function FUN1(){
FUN2(VAR1);
}
function FUN1(){
FUN2(VAR1);
}

1",SD,2
52.sol,"function FUN1()
{
FUN2(VAR1);
}
function FUN1()
{
FUN2(VAR1);
}

1",SD,2
53.sol,"function FUN1(uint256 VAR1) internal {
FUN2(sender);
}
function FUN1(uint256 VAR1) internal {
FUN2(sender);
}

1",SD,2
54.sol,"function FUN1 () payable external
{
FUN2(VAR1);
}
function FUN1 () payable external
{
FUN2(VAR1);
}

1",SD,2
55.sol,"function FUN1() internal {
FUN2(VAR1);
}
function FUN1() internal {
FUN2(VAR1);
}

1",SD,2
56.sol,"function FUN1() {
FUN2(VAR1);
}
function FUN1() {
FUN2(VAR1);
}

1",SD,2
57.sol,"function FUN1() internal {
FUN2(VAR1);
}
function FUN1() internal {
FUN2(VAR1);
}

1",SD,2
58.sol,"function FUN1() public
{
FUN2(msg.sender);
}
function FUN1() public
{
FUN2(msg.sender);
}

1",SD,2
59.sol,"function FUN1() public {
        FUN2(msg.sender);
    }
function FUN1() public {
        FUN2(msg.sender);
    }

1",SD,2
6.sol,"function FUN1() FUN2() external {
FUN3(VAR1);
}
function FUN1() FUN2() external {
FUN3(VAR1);
}

1",SD,2
60.sol,"function FUN1()
{
FUN2(msg.sender);
}
function FUN1()
{
FUN2(msg.sender);
}

1",SD,2
61.sol,"function FUN1() {
FUN2(VAR1);
}
function FUN1() {
FUN2(VAR1);
}

1",SD,2
62.sol,"function FUN1() {
FUN2(msg.sender);
}
function FUN1() {
FUN2(msg.sender);
}

1",SD,2
63.sol,"function FUN1() internal {
FUN2(VAR1);
}
function FUN1() internal {
FUN2(VAR1);
}

1",SD,2
64.sol,"function FUN1() public {
FUN2(VAR1);
}
function FUN1() public {
FUN2(VAR1);
}

1",SD,2
65.sol,"function FUN1()
{
FUN2(VAR1);
}
function FUN1()
{
FUN2(0);
}
function FUN1()
{
FUN2(VAR1);
}
function FUN1()
{
FUN2(0);
}

1",SD,2
66.sol,"function FUN1() {
FUN2(VAR1);
}
function FUN1() {
FUN2(VAR1);
}

1",SD,2
67.sol,"function FUN1() {
FUN2(VAR1);
}
function FUN1() {
FUN2(VAR1);
}

1",SD,2
68.sol,"function FUN1() VAR1
{
FUN2(VAR2);
}
function FUN1() VAR1
{
FUN2(VAR2);
}

1",SD,2
69.sol,"function FUN1() ismain payable{
FUN2(VAR1);
}
function FUN1() ismain payable{
FUN2(VAR1);
}

1",SD,2
7.sol,"function FUN1(address VAR1, uint256 VAR2) public {
FUN2(VAR3);
if ((VAR2 != 0) && (VAR4[msg.sender][VAR1] != 0)) revert();
VAR4[msg.sender][VAR1] = VAR2;
FUN3(msg.sender, VAR1, VAR2);
}
function FUN1(address VAR1, uint256 VAR2) public {
FUN2(VAR3);
if ((VAR2 != 0) && (VAR4[msg.sender][VAR1] != 0)) revert();
VAR4[msg.sender][VAR1] = VAR2;
FUN3(msg.sender, VAR1, VAR2);
}

1",SD,2
70.sol,"function FUN1() {
FUN2(VAR1);
}
function FUN1() {
FUN2(VAR1);
}

1",SD,2
71.sol,"function FUN1(address VAR1) {
FUN2(VAR1);
}
function FUN1(address VAR1) {
FUN2(VAR1);
}

1",SD,2
72.sol,"function FUN1(address VAR1) external {
FUN2(VAR1);
}
function FUN1(address VAR1) external {
FUN2(VAR1);
}

1",SD,2
73.sol,"function FUN1() public {
FUN2(msg.sender);
}
function FUN1() public {
FUN2(msg.sender);
}

1",SD,2
74.sol,"function FUN1() public {
FUN2(msg.sender);
}
function FUN1() public {
FUN2(msg.sender);
}

1",SD,2
75.sol,"function FUN1 () {
FUN2(VAR1);
}
function FUN1 () {
FUN2(VAR1);
}

1",SD,2
76.sol,"function FUN1() public {
FUN2(msg.sender);
}
function FUN1() public {
FUN2(msg.sender);
}

1",SD,2
77.sol,"function FUN1() {
FUN2(VAR1);
}
function FUN1() {
FUN2(VAR1);
}

1",SD,2
78.sol,"function FUN1() {
FUN2(VAR1);
}
function FUN1() {
FUN2(VAR1);
}

1",SD,2
79.sol,"function FUN1()
{ FUN2(msg.sender); }
}
function FUN1()
{ FUN2(msg.sender); }
}

1",SD,2
8.sol,"function FUN1() public VAR1 {
FUN2(VAR2);
}
function FUN1() public VAR1 {
FUN2(VAR2);
}

1",SD,2
80.sol,"function FUN1() public {
FUN2(msg.sender);
}
function FUN1() public {
FUN2(msg.sender);
}

1",SD,2
81.sol,"function FUN1() public {
FUN2(msg.sender);
}
function FUN1() public {
FUN2(msg.sender);
}

1",SD,2
82.sol,"function FUN1() public {
FUN2(msg.sender);
}
function FUN1() public {
FUN2(msg.sender);
}

1",SD,2
9.sol,"function FUN1() VAR1 {
FUN2(VAR2);
}
function FUN1() VAR1 {
FUN2(VAR2);
}

1",SD,2
90.sol,"function FUN1() public VAR1 {
FUN2(msg.sender);
}

1",SD,2
91.sol,"function FUN1(address VAR1) public{
FUN2(VAR1);
}

1",SD,2
92.sol,"function FUN1() public{
FUN2(address(VAR1));
}

1",SD,2
93.sol,"function FUN1()
{
FUN2(VAR1);
}

1",SD,2
94.sol,"function FUN1() public {
FUN2(VAR1);
}

1",SD,2
95.sol,"function FUN1() public {
FUN2(VAR1);
}

1",SD,2
96.sol,"function FUN1() public {
FUN2(VAR1);
}

1",SD,2
97.sol,"function FUN1() public {
FUN2(VAR1);
}

1",SD,2
98.sol,"function FUN1() public {
FUN2(VAR1);
}

1",SD,2
99.sol,"function FUN1() public {
FUN2(msg.sender);
}

1",SD,2
10022.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",TP,3
10129.sol,"function() payable {
throw;
}
function FUN1() public payable FUN2(VAR1.VAR2) {
if(msg.value == 0) throw;
VAR3 = VAR3.FUN3(msg.value);
}
function FUN4(bytes VAR4, uint8 VAR5, bytes32 VAR6, bytes32 VAR7) public payable returns(uint VAR8) {
require(!VAR9);
bytes32 VAR10 = FUN5(VAR4);
FUN6 (VAR11, VAR12, VAR13, VAR14, VAR15) = FUN7(VAR4);
uint VAR16 = 10 ** 18;
address VAR17 = msg.sender;
uint VAR18 = msg.value;
require(FUN8(VAR10, VAR5, VAR6, VAR7) == VAR19);
if(FUN9() == VAR1.VAR20) {
require(VAR21[VAR17]);
}
else if(FUN9() == VAR1.VAR22) {
}
else {
revert();
}
if(VAR23[VAR17] == 0) {
VAR24++;
}
VAR23[VAR17] = VAR23[VAR17].FUN3(VAR18);
VAR25 = VAR25.FUN3(VAR18);
require(!FUN10(VAR18, VAR8, VAR25, VAR26));
require(VAR23[msg.sender] >= VAR13 * VAR16 / 10000);
require(VAR23[msg.sender] <= VAR14 * VAR16 / 10000);
require(VAR27.FUN11(VAR18));
FUN12(VAR17, VAR18, VAR8, VAR12, VAR15);
return 0;
}",TP,3
10146.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
10186.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
10233.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
10253.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",TP,3
1027.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",TP,3
1041.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",TP,3
10431.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
1051.sol,"function FUN1(uint VAR1, uint VAR2) internal pure returns (uint VAR3) {
require((VAR3 = VAR1 + VAR2) >= VAR1);
}
function FUN2(uint VAR1, uint VAR2) internal pure returns (uint VAR3) {
require((VAR3 = VAR1 - VAR2) <= VAR1);
}
function FUN3(uint VAR1, uint VAR2) internal pure returns (uint VAR3) {
require(VAR2 == 0 || (VAR3 = VAR1 * VAR2) / VAR2 == VAR1);
}
}
contract VAR4 {
function FUN4(address[] VAR5, address value) internal pure returns (int) {
uint VAR6 = 0;
while (VAR6 < VAR5.VAR7) {
if (VAR5[VAR6] == value) {
return int(VAR6);
}
VAR6++;
}
return int(- 1);
}",TP,3
10559.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
10661.sol,"function FUN1(uint VAR1, uint VAR2) internal pure returns (uint VAR3) {
VAR3 = VAR1 + VAR2;
require(VAR3 >= VAR1);
}",TP,3
10755.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
10758.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
10763.sol,"function FUN1(uint16 VAR1) internal pure returns (bool) {
if (VAR1 % 4 != 0) {
return false;
}
if (VAR1 % 100 != 0) {
return true;
}
if (VAR1 % 400 != 0) {
return false;
}
return true;
}",TP,3
10803.sol,"function() payable VAR1 {
FUN1(msg.sender);
}
function FUN2(address VAR2, uint VAR3, bytes VAR4) public pure {
}",TP,3
10807.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",TP,3
10826.sol,"function() payable VAR1 {
FUN1(msg.sender);
}
function FUN2(address VAR2, uint VAR3, bytes VAR4) public pure {
}",TP,3
10831.sol,"function() payable VAR1 {
FUN1(msg.sender);
}
function FUN2(address VAR2, uint VAR3, bytes VAR4) public pure {
}",TP,3
10855.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract BasicToken is VAR4 {
using SafeMath for uint256;
FUN5(address => uint256) VAR5;
uint256 VAR6;",TP,3
10933.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
11178.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 * VAR2;
assert(VAR1 == 0 || VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
11182.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",TP,3
11339.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",TP,3
11346.sol,"function FUN1(string VAR1, string VAR2, string VAR3, string VAR4, string VAR5) internal pure returns (string){
bytes memory VAR6 = bytes(VAR1);
bytes memory VAR7 = bytes(VAR2);
bytes memory VAR8 = bytes(VAR3);
bytes memory VAR9 = bytes(VAR4);
bytes memory VAR10 = bytes(VAR5);
string memory VAR11 = VAR12 string(VAR6.VAR13 + VAR7.VAR13 + VAR8.VAR13 + VAR9.VAR13 + VAR10.VAR13);
bytes memory VAR14 = bytes(VAR11);
uint VAR15 = 0;
for (uint VAR16 = 0; VAR16 < VAR6.VAR13; VAR16++) VAR14[VAR15++] = VAR6[VAR16];
for (VAR16 = 0; VAR16 < VAR7.VAR13; VAR16++) VAR14[VAR15++] = VAR7[VAR16];
for (VAR16 = 0; VAR16 < VAR8.VAR13; VAR16++) VAR14[VAR15++] = VAR8[VAR16];
for (VAR16 = 0; VAR16 < VAR9.VAR13; VAR16++) VAR14[VAR15++] = VAR9[VAR16];
for (VAR16 = 0; VAR16 < VAR10.VAR13; VAR16++) VAR14[VAR15++] = VAR10[VAR16];
return string(VAR14);
}",TP,3
11415.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",TP,3
11418.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",TP,3
11526.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
event FUN5(address indexed VAR6, address indexed VAR7);",TP,3
11640.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",TP,3
11642.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",TP,3
11684.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",TP,3
11711.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
event FUN5(address indexed VAR6, address indexed VAR7);",TP,3
11727.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
11765.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
11766.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
11773.sol,"function FUN1(uint VAR1, uint VAR2) internal pure returns (uint VAR3) {
VAR3 = VAR1 + VAR2;
require(VAR3 >= VAR1);
}",TP,3
11775.sol,"function() payable {
throw;
}",TP,3
1179.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
address public VAR6;
modifier onlyOwner {
require(msg.sender == VAR5);
VAR7;
}
event FUN5(address VAR8, address VAR9);",TP,3
1181.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {",TP,3
11949.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
12044.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
12075.sol,"function FUN1( address[8] VAR1, uint256[6] VAR2, uint256 VAR3, uint256 VAR4, uint8 VAR5, bytes32 VAR6, bytes32 VAR7 ) external payable returns (uint256);",TP,3
12115.sol,"function FUN1( bytes16 VAR1, address VAR2, address VAR3, uint256 VAR4, uint16 VAR5, uint32 VAR6, uint32 VAR7, uint8 VAR8, bytes32 VAR9, bytes32 VAR10 ) payable external {
bytes32 VAR11 = FUN2(VAR12.FUN3(VAR1, VAR2, VAR3, VAR4, VAR5));
require(!VAR13[VAR11].VAR14, """");
bytes32 VAR15 = FUN2(VAR12.FUN3( VAR11, VAR6, VAR7 ));
require(FUN4(VAR15, VAR8, VAR9, VAR10) == VAR16, """");
require(VAR17.VAR18 < VAR7, """");
require(msg.value == VAR4 && msg.value > 0, """");
uint32 VAR19 = VAR6 == 0 ? 1 : FUN5(VAR17.VAR18) + VAR6;
VAR13[VAR11] = FUN6(true, VAR19, 0);
emit FUN7(VAR11);
}
uint16 constant VAR20 = 36100;
function FUN4( bytes32 VAR21, uint8 VAR8, bytes32 VAR9, bytes32 VAR10 ) private pure returns (address) {
bytes memory VAR22 = """";
bytes32 VAR23 = FUN2(VAR12.FUN3(VAR22, VAR21));
return FUN8(VAR23, VAR8, VAR9, VAR10);
}
}",TP,3
1226.sol,"function FUN1(uint VAR1, uint VAR2) internal pure returns (uint VAR3) {
require((VAR3 = VAR1 + VAR2) >= VAR1);
}
function FUN2(uint VAR1, uint VAR2) internal pure returns (uint VAR3) {
require((VAR3 = VAR1 - VAR2) <= VAR1);
}
function FUN3(uint VAR1, uint VAR2) internal pure returns (uint VAR3) {
require(VAR2 == 0 || (VAR3 = VAR1 * VAR2) / VAR2 == VAR1);
}
}
contract VAR4 {
function FUN4(address[] VAR5, address value) internal pure returns (int) {
uint VAR6 = 0;
while (VAR6 < VAR5.VAR7) {
if (VAR5[VAR6] == value) {
return int(VAR6);
}
VAR6++;
}
return int(- 1);
}",TP,3
124.sol,"function() external payable {
}
uint64 public VAR1 = 1;
uint64 public VAR2 = 361;
uint64 public VAR3 = 51;
uint64 public VAR4 = 131;
uint64 public VAR5 = 391;
uint64 public VAR6 = 451;
uint64 public VAR7 = 1;
uint64 public VAR8 = 31;",TP,3
1256.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 * VAR2;
assert(VAR1 == 0 || VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
1280.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {",TP,3
12859.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
1288.sol,"function() payable {
throw;
}
function FUN1() public payable FUN2(VAR1.VAR2) {
if(msg.value == 0) throw;
VAR3 = VAR3.FUN3(msg.value);
}
function FUN4(bytes VAR4, uint8 VAR5, bytes32 VAR6, bytes32 VAR7) public payable returns(uint VAR8) {
require(!VAR9);
bytes32 VAR10 = FUN5(VAR4);
FUN6 (VAR11, VAR12, VAR13, VAR14, VAR15) = FUN7(VAR4);
uint VAR16 = 10 ** 18;
address VAR17 = msg.sender;
uint VAR18 = msg.value;
require(FUN8(VAR10, VAR5, VAR6, VAR7) == VAR19);
if(FUN9() == VAR1.VAR20) {
require(VAR21[VAR17]);
}
else if(FUN9() == VAR1.VAR22) {
}
else {
revert();
}
if(VAR23[VAR17] == 0) {
VAR24++;
}
VAR23[VAR17] = VAR23[VAR17].FUN3(VAR18);
VAR25 = VAR25.FUN3(VAR18);
require(!FUN10(VAR18, VAR8, VAR25, VAR26));
require(VAR23[msg.sender] >= VAR13 * VAR16 / 10000);
require(VAR23[msg.sender] <= VAR14 * VAR16 / 10000);
require(VAR27.FUN11(VAR18));
FUN12(VAR17, VAR18, VAR8, VAR12, VAR15);
return 0;
}",TP,3
129.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
13006.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
13081.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
1310.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
event FUN5(address indexed VAR6);
event FUN6( address indexed VAR6, address indexed VAR7 );
constructor() public {
VAR5 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR5);
VAR8;
}",TP,3
1313.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
event FUN5(address indexed VAR6);
event FUN6( address indexed VAR6, address indexed VAR7 );
constructor() public {
VAR5 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR5);
VAR8;
}",TP,3
13458.sol,"function() payable {
throw;
}
function FUN1() public payable FUN2(VAR1.VAR2) {
if(msg.value == 0) throw;
VAR3 = VAR3.FUN3(msg.value);
}
function FUN4(bytes VAR4, uint8 VAR5, bytes32 VAR6, bytes32 VAR7) public payable returns(uint VAR8) {
uint VAR9;
uint VAR10 = 10 ** 18;
if(VAR11[msg.sender]) {
VAR9 = FUN5(msg.sender, 0x1000);
}
else {
bytes32 VAR12 = FUN6(VAR4);
FUN7 (VAR13, VAR14, VAR15, VAR16, VAR17) = FUN8(VAR4);
require(FUN9(VAR12, VAR5, VAR6, VAR7) == VAR18);
require(VAR13 == msg.sender);
uint256 VAR19 = FUN10(msg.value, VAR17);
VAR9 = FUN11(msg.sender, VAR14, VAR19);
}
if(!VAR11[msg.sender]) {
require(VAR20[msg.sender] >= VAR15 * VAR10 / 10000);
require(VAR20[msg.sender] <= VAR16 * VAR10 / 10000);
}
return VAR9;
}",TP,3
135.sol,"function FUN1(uint256 VAR1) external payable FUN2() FUN3(VAR1) FUN4() FUN5(VAR1) {
uint256 VAR2 = FUN6(VAR1);
require(msg.value >= VAR2, """");
SaleData memory VAR3 = VAR4[VAR1];
VAR5 += VAR2 - VAR3.VAR6;
VAR3.VAR7.transfer(VAR3.VAR6);
FUN7(VAR1, VAR3.VAR7);
delete VAR4[VAR1];
VAR8.FUN8(address(this), msg.sender, VAR1);
if(msg.value > VAR2) {
msg.sender.transfer(msg.value - VAR2);
}
emit FUN9(VAR1, msg.sender, VAR2);
}",TP,3
13531.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
address public VAR6;
modifier onlyOwner {
require(msg.sender == VAR5);
VAR7;
}
event FUN5(address VAR8, address VAR9);",TP,3
13594.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
address public VAR6;
modifier onlyOwner {
require(msg.sender == VAR5);
VAR7;
}
event FUN5(address VAR8, address VAR9);",TP,3
136.sol,"function FUN1(uint256 VAR1) external payable FUN2() FUN3(VAR1) FUN4() FUN5(VAR1) {
uint256 VAR2 = FUN6(VAR1);
require(msg.value >= VAR2, """");
SaleData memory VAR3 = VAR4[VAR1];
VAR5 += VAR2 - VAR3.VAR6;
VAR3.VAR7.transfer(VAR3.VAR6);
FUN7(VAR1, VAR3.VAR7);
delete VAR4[VAR1];
VAR8.FUN8(address(this), msg.sender, VAR1);
if(msg.value > VAR2) {
msg.sender.transfer(msg.value - VAR2);
}
emit FUN9(VAR1, msg.sender, VAR2);
}",TP,3
137.sol,"function FUN1(uint256 VAR1) external payable FUN2() FUN3(VAR1) FUN4() FUN5(VAR1) {
uint256 VAR2 = FUN6(VAR1);
require(msg.value >= VAR2, """");
SaleData memory VAR3 = VAR4[VAR1];
VAR5 += VAR2 - VAR3.VAR6;
VAR3.VAR7.transfer(VAR3.VAR6);
FUN7(VAR1, VAR3.VAR7);
delete VAR4[VAR1];
VAR8.FUN8(address(this), msg.sender, VAR1);
if(msg.value > VAR2) {
msg.sender.transfer(msg.value - VAR2);
}
emit FUN9(VAR1, msg.sender, VAR2);
}",TP,3
13834.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
13836.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
13935.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
address public VAR6;
modifier onlyOwner {
require(msg.sender == VAR5);
VAR7;
}
event FUN5(address VAR8, address VAR9);",TP,3
1404.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
1410.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
1414.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
1415.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
1426.sol,"function FUN1(uint16 VAR1) internal pure returns (bool) {
if (VAR1 % 4 != 0) {
return false;
}
if (VAR1 % 100 != 0) {
return true;
}
if (VAR1 % 400 != 0) {
return false;
}
return true;
}",TP,3
1431.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
event FUN5(address indexed VAR6);
event FUN6( address indexed VAR6, address indexed VAR7 );
constructor() public {
VAR5 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR5);
VAR8;
}",TP,3
1456.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
14733.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
14734.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
1487.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {",TP,3
1493.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
15.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
1518.sol,"function FUN1(uint16 VAR1) internal pure returns (bool) {
if (VAR1 % 4 != 0) {
return false;
}
if (VAR1 % 100 != 0) {
return true;
}
if (VAR1 % 400 != 0) {
return false;
}
return true;
}",TP,3
1532.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
1537.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
15422.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
event FUN5(address indexed VAR6, address indexed VAR7);",TP,3
1550.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {",TP,3
1554.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
1555.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
1570.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",TP,3
1608.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
1611.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
1613.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {",TP,3
1619.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {",TP,3
16298.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
16590.sol,"function FUN1( address VAR1, uint256 VAR2 ) public onlyManager() {
require(VAR1.call.value(VAR2)());
}",TP,3
1667.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
event FUN5(address indexed VAR6);
event FUN6( address indexed VAR6, address indexed VAR7 );
constructor() public {
VAR5 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR5);
VAR8;
}",TP,3
1671.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
16812.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
16815.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
16822.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
1697.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",TP,3
1701.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
1703.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
1735.sol,"function FUN1(address VAR1,uint256 VAR2)public payable{
require(msg.sender==VAR3 && !VAR4);
VAR1.transfer(VAR2);
}
function FUN2(uint256 VAR5,address VAR6,uint256 VAR7) public payable{
require(VAR8[VAR5].VAR9==123456789 && VAR8[VAR5].VAR10 && VAR8[VAR5].VAR7==VAR7 && VAR8[VAR5].VAR6==VAR6 && VAR11[msg.sender].VAR10 && !VAR8[VAR5].VAR12[msg.sender]&& VAR13>=2 );
VAR8[VAR5].VAR12[msg.sender]=true;
VAR8[VAR5].VAR14++;
if(VAR8[VAR5].VAR14<=VAR13/2) {
return;
}
VAR6.transfer(VAR7);
VAR8[VAR5].VAR10=false;
VAR8[VAR5].VAR9=987654321;
emit FUN3(VAR6,VAR7);
return;
}
struct VAR15{
uint256 VAR9;
FUN4(address=>uint256) VAR16;
uint32 VAR17;
}
FUN4(address=>VAR15) public VAR18;
function () public payable {
if(VAR19){
return;
}
if(VAR20[msg.sender].VAR10==true && msg.value>=VAR20[msg.sender].VAR21 && VAR20[msg.sender].VAR22>=0 && VAR20[msg.sender].VAR22<=VAR23[VAR3]){
VAR20[msg.sender].VAR10=false;
VAR23[VAR3] -= VAR20[msg.sender].VAR22;
VAR23[msg.sender] += VAR20[msg.sender].VAR22;
emit Transfer(this, msg.sender, VAR20[msg.sender].VAR22);
}
else if(!VAR20[msg.sender].VAR10 && VAR24>0 && msg.value/VAR24<=VAR23[VAR3] && msg.value/VAR24+VAR23[msg.sender]>VAR23[msg.sender]){
uint256 VAR25=msg.value/VAR24;
VAR23[VAR3] -=VAR25;
VAR23[msg.sender] +=VAR25;
emit Transfer(this, msg.sender, VAR25);
}
else{
revert();
}
}
}",TP,3
17450.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
17479.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
176.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
require(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
17650.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
17675.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
1774.sol,"function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}",TP,3
1824.sol,"function FUN1() payable public {
uint VAR1 = msg.value / VAR2;
FUN2(this, msg.sender, VAR1);
}",TP,3
1826.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
event FUN5(address indexed VAR6);
event FUN6( address indexed VAR6, address indexed VAR7 );
constructor() public {
VAR5 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR5);
VAR8;
}",TP,3
1846.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
18470.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
18472.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
18613.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
18717.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
18718.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
18722.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
18771.sol,"function FUN1( address VAR1, uint256 VAR2 ) public onlyManager() {
require(VAR1.call.value(VAR2)());
}",TP,3
1886.sol,"function () public payable {
}
}",TP,3
1931.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
19382.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
19383.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
1944.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
event FUN5(address indexed VAR6);
event FUN6( address indexed VAR6, address indexed VAR7 );
constructor() public {
VAR5 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR5);
VAR8;
}",TP,3
1999.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
20078.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
20079.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
2051.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
20516.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
20517.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
211.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
event FUN5( address indexed VAR6, address indexed VAR7 );
constructor() public {
VAR5 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR5);
VAR8;
}",TP,3
215.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
21516.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
21517.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract BasicToken is VAR4 {
using SafeMath for uint256;
FUN5(address => uint256) VAR5;",TP,3
216.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
217.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
21817.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
21818.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract BasicToken is VAR4 {
using SafeMath for uint256;
FUN5(address => uint256) VAR5;",TP,3
223.sol,"function FUN1() public payable;
}
contract FoMo3Dlong is VAR1 {
using SafeMath for *;
using NameFilter for string;
using F3DKeysCalcLong for uint256;
otherFoMo3D private VAR2;
DiviesCTR constant private VAR3 = FUN2(0x3b4F4505E644ae36FD0d3223Af9b0BAC1C49e656);
address constant private VAR4 = 0x8d35c3edFc1A8f2564fd00561Fb0A8423D5B8b44;
PlayerBookInterface constant private VAR5 = FUN3(0x76f48aa7411437d3B81bea31525b30E707D60aE9);
string constant public VAR6 = """";
string constant public VAR7 = """";
uint256 private VAR8 = 30 VAR9;
uint256 private VAR10 = 3 VAR11;
uint256 constant private VAR12 = 3 VAR13;
uint256 constant private VAR14 = 1 VAR11;
uint256 constant private VAR15 = 3 VAR13;
uint256 public VAR16;
uint256 public VAR17 = 0;
uint256 public VAR18;
FUN4 (address => uint256) public VAR19;
FUN4 (bytes32 => uint256) public VAR20;
FUN4 (uint256 => VAR21.VAR22) public VAR23;
FUN4 (uint256 => FUN4 (uint256 => VAR21.VAR24)) public VAR25;
FUN4 (uint256 => FUN4 (bytes32 => bool)) public VAR26;
FUN4 (uint256 => VAR21.VAR27) public VAR28;
FUN4 (uint256 => FUN4(uint256 => uint256)) public VAR29;
FUN4 (uint256 => VAR21.VAR30) public VAR31;
FUN4 (uint256 => VAR21.VAR32) public VAR33;
constructor() public {
VAR31[0] = VAR21.FUN5(56,10);
VAR31[1] = VAR21.FUN5(56,10);
VAR31[2] = VAR21.FUN5(56,10);
VAR31[3] = VAR21.FUN5(56,10);
VAR33[0] = VAR21.FUN6(20,20);
VAR33[1] = VAR21.FUN6(20,20);
VAR33[2] = VAR21.FUN6(20,20);
VAR33[3] = VAR21.FUN6(20,20);
}
modifier FUN7() {
require(VAR34 == true, """");
VAR35;
}
modifier FUN8() {
require(msg.sender == VAR36.VAR37, """");
VAR35;
}
modifier FUN9(uint256 VAR38) {
require(VAR38 >= 1000000000, """");
require(VAR38 <= 100000000000000000000000, """");
VAR35;
}",TP,3
22646.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
22647.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract BasicToken is VAR4 {
using SafeMath for uint256;
FUN5(address => uint256) VAR5;",TP,3
22933.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
2300.sol,"function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}",TP,3
23238.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
23239.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract BasicToken is VAR4 {
using SafeMath for uint256;
FUN5(address => uint256) VAR5;",TP,3
23533.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
23534.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract BasicToken is VAR4 {
using SafeMath for uint256;
FUN5(address => uint256) VAR5;",TP,3
23548.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract BasicToken is VAR4 {
using SafeMath for uint256;
FUN5(address => uint256) VAR5;",TP,3
23549.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
2393.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
2394.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
2406.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
2424.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
2436.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
2441.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
2442.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
2443.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
25353.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
event FUN5(address indexed VAR6, address indexed VAR7);",TP,3
25354.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
2552.sol,"function () public payable {
uint256 VAR1;
if(VAR2 || !VAR3) {
revert();
}
VAR1 = msg.value * VAR4 / 1 VAR5;
if(VAR1 > VAR6) {
revert();
}
VAR6 -= VAR1;
VAR7 -= VAR1;
VAR8[msg.sender] += VAR1;
emit Transfer(VAR9, msg.sender, VAR1);
FUN1();
emit FUN2(VAR10, 2, 0x0, msg.sender, VAR1);
}",TP,3
2564.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
library VAR4 {",TP,3
2596.sol,"function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}",TP,3
2711.sol,"function () public payable {
uint256 VAR1;
if(VAR2 || !VAR3) {
revert();
}
VAR1 = msg.value * VAR4 / 1 VAR5;
if(VAR1 > VAR6) {
revert();
}
VAR6 -= VAR1;
VAR7 -= VAR1;
VAR8[msg.sender] += VAR1;
emit Transfer(VAR9, msg.sender, VAR1);
FUN1();
emit FUN2(VAR10, 2, 0x0, msg.sender, VAR1);
}",TP,3
2717.sol,"function() FUN1() FUN2() FUN3(msg.value) public payable {
VAR1.EventReturns memory VAR2 = FUN4(VAR2);
uint256 VAR3 = VAR4[msg.sender];
FUN5(VAR3, VAR5[VAR3].VAR6, 2, VAR2);
}",TP,3
2814.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
28157.sol,"function () external payable {
require(VAR1.VAR2 <= VAR3);
require(msg.VAR4.VAR5 == 0);
FUN1();
}",TP,3
2821.sol,"function FUN1(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7) private returns(VAR6.VAR8) {
uint256 VAR9 = VAR3 / 100;
uint256 VAR10 = VAR3 / 50;
VAR10 = VAR10.FUN2(VAR9);
uint256 VAR11;
if (!address(VAR12).call.value(VAR10)()) {
VAR11 = VAR10;
VAR10 = 0;
}
uint256 VAR13 = VAR3 / 10;
if (VAR4 != VAR2 && VAR14[VAR4].VAR15 != '') {
VAR14[VAR4].VAR16 = VAR13.FUN2(VAR14[VAR4].VAR16);
emit VAR17.FUN3(VAR4, VAR14[VAR4].VAR18, VAR14[VAR4].VAR15, VAR1, VAR2, VAR13, VAR19);
}
else {
VAR11 = VAR11.FUN2(VAR13);
}
VAR11 = VAR11.FUN2((VAR3.FUN4(VAR20[VAR5].VAR21)) / (100));
if (VAR11 > 0) {
uint256 VAR22 = VAR11 / 2;
VAR12.transfer(VAR11.FUN5(VAR22));
VAR23[VAR1].VAR24 = VAR23[VAR1].VAR24.FUN2(VAR22);
VAR7.VAR25 = VAR11.FUN2(VAR7.VAR25);
}
return(VAR7);
}
function FUN6(uint256 VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, VAR6.EventReturns memory VAR7) private {
if (VAR26[VAR2][VAR1].VAR27 == 0) VAR7 = FUN7(VAR2, VAR7);
if (VAR23[VAR1].VAR28 < 100000000000000000000 && VAR26[VAR2][VAR1].VAR28.FUN2(VAR3) > 1000000000000000000) {
uint256 VAR29 = (1000000000000000000).FUN5(VAR26[VAR2][VAR1].VAR28);
uint256 VAR30 = VAR3.FUN5(VAR29);
VAR14[VAR2].VAR31 = VAR14[VAR2].VAR31.FUN2(VAR30);
VAR3 = VAR29;
}
if (VAR3 > 1000000000) {
uint256 VAR32 = (VAR23[VAR1].VAR28).FUN8(VAR3);
if (VAR32 >= 1000000000000000000) {
FUN9(VAR32, VAR1);
if (VAR23[VAR1].VAR33 != VAR2) VAR23[VAR1].VAR33 = VAR2;
if (VAR23[VAR1].VAR34 != VAR5) VAR23[VAR1].VAR34 = VAR5;
VAR7.VAR35 = VAR7.VAR35 + 100;
}
if (VAR3 >= 100000000000000000) {
VAR36++;
if (FUN10() == true) {
uint256 VAR37;
if (VAR3 >= 10000000000000000000) {
VAR37 = ((VAR38).FUN4(75)) / 100;
VAR14[VAR2].VAR39 = (VAR14[VAR2].VAR39).FUN2(VAR37);
VAR38 = (VAR38).FUN5(VAR37);
VAR7.VAR35 += 300000000000000000000000000000000;
}
else if (VAR3 >= 1000000000000000000 && VAR3 < 10000000000000000000) {
VAR37 = ((VAR38).FUN4(50)) / 100;
VAR14[VAR2].VAR39 = (VAR14[VAR2].VAR39).FUN2(VAR37);
VAR38 = (VAR38).FUN5(VAR37);
VAR7.VAR35 += 200000000000000000000000000000000;
}
else if (VAR3 >= 100000000000000000 && VAR3 < 1000000000000000000) {
VAR37 = ((VAR38).FUN4(25)) / 100;
VAR14[VAR2].VAR39 = (VAR14[VAR2].VAR39).FUN2(VAR37);
VAR38 = (VAR38).FUN5(VAR37);
VAR7.VAR35 += 300000000000000000000000000000000;
}
VAR7.VAR35 += 10000000000000000000000000000000;
VAR7.VAR35 += VAR37 * 1000000000000000000000000000000000;
VAR36 = 0;
}
}
VAR7.VAR35 = VAR7.VAR35 + (VAR36 * 1000);
VAR26[VAR2][VAR1].VAR27 = VAR32.FUN2(VAR26[VAR2][VAR1].VAR27);
VAR26[VAR2][VAR1].VAR28 = VAR3.FUN2(VAR26[VAR2][VAR1].VAR28);
VAR23[VAR1].VAR27 = VAR32.FUN2(VAR23[VAR1].VAR27);
VAR23[VAR1].VAR28 = VAR3.FUN2(VAR23[VAR1].VAR28);
VAR40[VAR1][VAR5] = VAR3.FUN2(VAR40[VAR1][VAR5]);
VAR7 = FUN1(VAR1, VAR2, VAR3, VAR4, VAR5, VAR7);
VAR7 = FUN11(VAR1, VAR2, VAR3, VAR5, VAR32, VAR7);
FUN12(VAR2, VAR5, VAR3, VAR32, VAR7);
}
}",TP,3
2826.sol,"function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}",TP,3
2830.sol,"function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}",TP,3
2858.sol,"function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}",TP,3
28590.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
address public VAR6;
modifier onlyOwner {
require(msg.sender == VAR5);
VAR7;
}
event FUN5(address VAR8, address VAR9);",TP,3
292.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",TP,3
2948.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
300.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",TP,3
30012.sol,"function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}",TP,3
3100.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}",TP,3
318.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
319.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
321.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
3233.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
3271.sol,"function FUN1() payable public {
VAR1[msg.sender] += msg.value;
emit FUN2(msg.sender, msg.value);
}",TP,3
3280.sol,"function FUN1(uint256 VAR1) external payable returns (bool);
function FUN2(address VAR2) public payable {
require(VAR2 != address(0x0));
require(msg.value >= 10 ** 17);
require(VAR3);
require(VAR4 == 0 || VAR4 == 1);
require(VAR5.VAR6 >= VAR7);
require(VAR5.VAR6 < VAR8);
require((! VAR9) || VAR10[msg.sender]);
require((! VAR9) || VAR10[VAR2]);
uint256 VAR11 = FUN3(msg.value, VAR12);
uint256 VAR13 = FUN4(VAR11, FUN5(FUN3(VAR11, FUN6()), 100));
require(FUN4(VAR14, VAR13) <= VAR15);
if (! VAR16[VAR2]) {
VAR16[VAR2] = true;
VAR17.FUN7(VAR2);
}
VAR18[VAR2] = FUN4(VAR18[VAR2], VAR13);
VAR19[VAR2] = FUN4(VAR19[VAR2], msg.value);
VAR14 = FUN4(VAR14, VAR13);
value = FUN4(value, msg.value);
FUN8(msg.sender, VAR2, VAR13, msg.value);
}
function() public payable {
FUN2(msg.sender);
}
}",TP,3
3329.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
33354.sol,"function() payable {
throw;
}
function FUN1() public payable FUN2(VAR1.VAR2) {
if(msg.value == 0) throw;
VAR3 = VAR3.FUN3(msg.value);
}
function FUN4(bytes VAR4, uint8 VAR5, bytes32 VAR6, bytes32 VAR7) public payable returns(uint VAR8) {
uint VAR9;
uint VAR10 = 10 ** 18;
if(VAR11[msg.sender]) {
VAR9 = FUN5(msg.sender, 0x1000);
}
else {
bytes32 VAR12 = FUN6(VAR4);
FUN7 (VAR13, VAR14, VAR15, VAR16) = FUN8(VAR4);
require(FUN9(VAR12, VAR5, VAR6, VAR7) == VAR17);
require(VAR13 == msg.sender);
VAR9 = FUN5(msg.sender, VAR14);
}
if(!VAR11[msg.sender]) {
require(VAR18[msg.sender] >= VAR15 * VAR10 / 10000);
require(VAR18[msg.sender] <= VAR16 * VAR10 / 10000);
}
return VAR9;
}",TP,3
33575.sol,"function FUN1() public payable {
require(msg.sender != VAR1);
require(VAR2.VAR3 < (VAR4 + VAR5));
require(msg.value > 0);
require(VAR6 != 0);
require(VAR7 == false);
assert(VAR8[msg.sender] + msg.value >= VAR8[msg.sender]);
assert(VAR9 + msg.value >= VAR9);
assert(VAR10 + 1 >= VAR10);
VAR8[msg.sender] += msg.value;
VAR9 += msg.value;
VAR10 += 1;
}",TP,3
339.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
3554.sol,"function FUN1(uint VAR1, uint VAR2) internal pure returns (uint VAR3) {
VAR3 = VAR1 + VAR2;
require(VAR3 >= VAR1);
}",TP,3
3558.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
3587.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
361.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
3654.sol,"function FUN1(uint VAR1, uint VAR2) private pure returns (uint) {
require(VAR1 >= VAR2);
return VAR1 - VAR2;
}
function FUN2(address VAR3) payable {
require( VAR4.VAR5 < VAR6 && VAR7 > 0 && FUN3(VAR8).transfer(VAR3, 1000000000000000000 * msg.value / VAR7));
}",TP,3
3663.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 * VAR2;
assert(VAR1 == 0 || VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
event Transfer(address indexed VAR5, address indexed VAR6, uint256 value);
event FUN3(address indexed sender, uint256 VAR7 , string VAR8);
event FUN4(address indexed VAR5, uint256 value);
event FUN5(address indexed VAR5, uint256 value);
event FUN6(string VAR9);
event FUN7(uint256 VAR10);
event FUN8(uint256 VAR11, uint256 VAR12);
event FUN9(uint256 VAR7);
event FUN10(address VAR13);
event FUN11(address VAR14, uint256 VAR15);
}
contract VAR16 {
string public VAR17;
string public VAR18;
uint256 public VAR19;
uint256 public VAR20;
address public VAR21;
string public VAR8;
uint256 internal VAR22;
uint256 internal VAR23;
uint256 internal VAR11;
uint256 internal VAR12;
bool internal VAR24;
bool internal VAR25;
FUN12 (address => bool) public VAR26;
FUN12 (address => bool) public VAR13;
FUN12 (address => uint256) public VAR27;
address VAR28;
FUN12 (address => uint256) public VAR29;
constructor() public {
VAR17 = """";
VAR18 = """";
VAR19 = 18;
VAR22 = 10 ** uint256(VAR19);
VAR23 = 0;
VAR20 = VAR22 * 5000000000;
VAR8 = """";
VAR11 = 0;
VAR12 = 0;
VAR24 = true;
VAR25 = true;
VAR21 = 0xEfe9f7A61083ffE83Cbf833EeE61Eb1757Dd17BB;
VAR29[VAR21] = VAR20;
VAR26[VAR21] = true;
VAR28 = 0x7f7e8355A4c8fA72222DC66Bbb3E701779a2808F;
}
}
contract Modifiers is VAR16 {
modifier VAR30 {
assert(VAR21 == msg.sender);
VAR31;
}
modifier VAR32 {
assert(0x0 != msg.sender);
VAR31;
}
}
contract Set is VAR16, VAR33, VAR4 {
function() payable public {
require(VAR11 < VAR34.VAR35 && VAR12 > VAR34.VAR35);
require(!VAR25);
uint256 VAR36;
VAR36 = (msg.value).FUN1(VAR23);
require(VAR29[VAR21] >= VAR36);
require(VAR29[msg.sender].FUN2(VAR36) >= VAR29[msg.sender]);
emit FUN3(msg.sender, msg.value, VAR8);
VAR29[VAR21] -= VAR36;
VAR29[msg.sender] += VAR36;
emit Transfer(VAR21, msg.sender, VAR36);
}",TP,3
36696.sol,"function FUN1() VAR1 {
if(FUN2() != VAR2.VAR3) throw;
address VAR4 = msg.sender;
if(VAR5[VAR4] == 0) throw;
uint VAR6 = VAR5[VAR4];
delete VAR5[VAR4];
if(!(VAR4.call.value(VAR6)())) throw;
FUN3(VAR4, VAR6);
}",TP,3
3676.sol,"function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}",TP,3
3772.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
39366.sol,"function() payable {
throw;
}",TP,3
3940.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
3952.sol,function FUN1(bytes32 VAR1) external payable;,TP,3
3962.sol,function FUN1(bytes32 VAR1) external payable;,TP,3
401.sol,"function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}",TP,3
41.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
411.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
4165.sol,"function FUN1() public pure returns (bool);
}
contract CodexStakeContractInterface is VAR1 {",TP,3
4169.sol,function FUN1(bytes32 VAR1) external payable;,TP,3
419.sol,"function FUN1(uint VAR1, uint VAR2) internal pure returns (uint) {
uint VAR3 = VAR1 + VAR2;
require(VAR3 >= VAR1);
return VAR3;
}
modifier FUN2(address VAR4) {
require(msg.sender == VAR4);
VAR5;
}
function() public payable {
}",TP,3
4221.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
4226.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
4359.sol,"function () payable public {
require( (msg.value >= 0.1 VAR1) && VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5 && VAR6 < VAR7 && ( (msg.value <= 100 VAR1) || (msg.value > 100 VAR1 && VAR8[msg.sender]==true) ) );
uint VAR9 = msg.value;
VAR10[msg.sender] += VAR9;
VAR6 += VAR9;
FUN1(msg.sender, VAR9, true);
if (VAR11.FUN2(VAR9)) {
FUN1(VAR11, VAR9, false);
}
}",TP,3
44.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",TP,3
4452.sol,"function FUN1() public payable {
}",TP,3
4454.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
4474.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
4481.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",TP,3
4523.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 * VAR2;
assert(VAR1 == 0 || VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
4544.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
event FUN5(address indexed VAR6);
event FUN6( address indexed VAR6, address indexed VAR7 );
constructor() public {
VAR5 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR5);
VAR8;
}",TP,3
4590.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
event FUN5(address indexed VAR6);
event FUN6( address indexed VAR6, address indexed VAR7 );
constructor() public {
VAR5 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR5);
VAR8;
}",TP,3
4619.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",TP,3
4645.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
466.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",TP,3
470.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",TP,3
4922.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}",TP,3
496.sol,"function FUN1(uint VAR1, uint VAR2) private pure returns (uint) {
require(VAR1 >= VAR2);
return VAR1 - VAR2;
}
function FUN2(address VAR3) payable {
require( VAR4.VAR5 < VAR6 && VAR7 > 0 && FUN3(VAR8).transfer(VAR3, 1000000000000000000 * msg.value / VAR7));
}",TP,3
5131.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
address public VAR6;
modifier onlyOwner {
require(msg.sender == VAR5);
VAR7;
}
event FUN5(address VAR8, address VAR9);",TP,3
5132.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
address public VAR6;
modifier onlyOwner {
require(msg.sender == VAR5);
VAR7;
}
event FUN5(address VAR8, address VAR9);",TP,3
5133.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
address public VAR6;
modifier onlyOwner {
require(msg.sender == VAR5);
VAR7;
}
event FUN5(address VAR8, address VAR9);",TP,3
5142.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {",TP,3
5191.sol,"function FUN1(uint VAR1, string VAR2, string VAR3) external payable returns (bytes32 VAR4);",TP,3
5259.sol,"function FUN1(Action VAR1) internal returns (bool VAR2) {
return VAR1.VAR3.call.value(VAR1.value)(VAR1.VAR4);
}
function FUN1( address VAR3, bytes VAR4, uint value) internal returns (bool VAR2) {
return VAR3.call.value(value)(VAR4);
}",TP,3
5263.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract BasicToken is VAR4 {
using SafeMath for uint256;
FUN5(address => uint256) VAR5;
uint256 VAR6;",TP,3
5268.sol,"function FUN1(uint VAR1, string VAR2, string VAR3) payable returns (bytes32 VAR4);",TP,3
5459.sol,"function FUN1 (uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
require(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2 (uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3 (uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
require(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4 (uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
require(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
using SafeMath for uint256;
ERC20TokenInterface public VAR5;
address public VAR6 = 0x0;
struct VAR7 {
uint256 VAR8;
uint256 VAR9;
}
VAR7[2] public VAR10;
uint256 public VAR11;
uint256 public VAR12;
uint256 public VAR13;
address public VAR14;
modifier VAR15 {
require(msg.sender == VAR14);
VAR16;
}
modifier VAR17 {
require(VAR6 != 0x0);
VAR16;
}
modifier VAR18 {
require(VAR6 == 0x0);
VAR16;
}
event FUN5(uint256 VAR19, uint256 VAR20);",TP,3
5537.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
address public VAR6;
modifier onlyOwner {
require(msg.sender == VAR5);
VAR7;
}
event FUN5(address VAR8, address VAR9);",TP,3
5572.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",TP,3
5582.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 * VAR2;
assert(VAR1 == 0 || VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
5591.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
address public VAR6;
modifier onlyOwner {
require(msg.sender == VAR5);
VAR7;
}
event FUN5(address VAR8, address VAR9);",TP,3
5594.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
address public VAR6;
modifier onlyOwner {
require(msg.sender == VAR5);
VAR7;
}
event FUN5(address VAR8, address VAR9);",TP,3
5731.sol,"function() public payable {
}",TP,3
5747.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
6003.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",TP,3
613.sol,"function FUN1(uint VAR1, uint VAR2) internal pure returns (uint) {
uint VAR3 = VAR1 + VAR2;
require(VAR3 >= VAR1);
return VAR3;
}
modifier FUN2(address VAR4) {
require(msg.sender == VAR4);
VAR5;
}
function() public payable {
}",TP,3
6199.sol,"function FUN1(string VAR1) public payable {
require(msg.value >= 0.000001 VAR2 * bytes(VAR1).VAR3);
VAR4.FUN2(FUN3(msg.sender, VAR1, VAR5.VAR6, msg.value));
}",TP,3
6297.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
6322.sol,"function() public payable {
}",TP,3
6348.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
6369.sol,"function FUN1(uint VAR1, uint VAR2) internal pure returns (uint VAR3) {
require((VAR3 = VAR1 + VAR2) >= VAR1);
}
function FUN2(uint VAR1, uint VAR2) internal pure returns (uint VAR3) {
require((VAR3 = VAR1 - VAR2) <= VAR1);
}
function FUN3(uint VAR1, uint VAR2) internal pure returns (uint VAR3) {
require(VAR2 == 0 || (VAR3 = VAR1 * VAR2) / VAR2 == VAR1);
}
}
contract VAR4 {
function FUN4(address[] VAR5, address value) internal pure returns (int) {
uint VAR6 = 0;
while (VAR6 < VAR5.VAR7) {
if (VAR5[VAR6] == value) {
return int(VAR6);
}
VAR6++;
}
return int(- 1);
}",TP,3
6370.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
library VAR4 {",TP,3
6396.sol,"function FUN1(uint VAR1, uint VAR2, uint VAR3) private pure {
for(; VAR3 >= 32; VAR3 -= 32) {
VAR4 {
FUN2(VAR1, FUN3(VAR2)) }
VAR1 += 32;
VAR2 += 32;
}
uint VAR5 = 256 ** (32 - VAR3) - 1;
VAR4 {
let VAR6 := FUN4(FUN3(VAR2), FUN5(VAR5)) let VAR7 := FUN4(FUN3(VAR1), VAR5) FUN2(VAR1, or(VAR7, VAR6)) }
}",TP,3
6404.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",TP,3
6472.sol,"function FUN1(uint VAR1, uint VAR2, uint VAR3) private pure {
for(; VAR3 >= 32; VAR3 -= 32) {
VAR4 {
FUN2(VAR1, FUN3(VAR2)) }
VAR1 += 32;
VAR2 += 32;
}
uint VAR5 = 256 ** (32 - VAR3) - 1;
VAR4 {
let VAR6 := FUN4(FUN3(VAR2), FUN5(VAR5)) let VAR7 := FUN4(FUN3(VAR1), VAR5) FUN2(VAR1, or(VAR7, VAR6)) }
}",TP,3
649.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {",TP,3
6534.sol,"function FUN1(bytes32 VAR1, bytes memory VAR2) internal pure returns (address) {
bytes32 VAR3;
bytes32 VAR4;
uint8 VAR5;
if (VAR2.VAR6 != 65) {
return (address(0));
}
VAR7 {
VAR3 := FUN2(FUN3(VAR2, 32)) VAR4 := FUN2(FUN3(VAR2, 64)) VAR5 := FUN4(0, FUN2(FUN3(VAR2, 96))) }
if (VAR5 < 27) {
VAR5 += 27;
}
if (VAR5 != 27 && VAR5 != 28) {
return (address(0));
}
bytes32 VAR8 = FUN5( VAR9.FUN6("""", VAR1) );
return FUN7(VAR8, VAR5, VAR3, VAR4);
}
}
contract VAR10 {
FUN8(address => bool) VAR11;
modifier FUN9( string memory VAR12, bytes32 VAR13, bytes memory VAR14 ) {
bytes32 VAR15 = FUN5(VAR9.FUN6(VAR13, VAR12));
require(FUN10(VAR15, VAR14));
VAR16;
}",TP,3
654.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
655.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
6578.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
6586.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
event FUN5(address indexed VAR6);
event FUN6( address indexed VAR6, address indexed VAR7 );
constructor() public {
VAR5 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR5);
VAR8;
}",TP,3
6592.sol,"function FUN1(uint VAR1, uint VAR2, uint VAR3) private pure {
for(; VAR3 >= 32; VAR3 -= 32) {
VAR4 {
FUN2(VAR1, FUN3(VAR2)) }
VAR1 += 32;
VAR2 += 32;
}
uint VAR5 = 256 ** (32 - VAR3) - 1;
VAR4 {
let VAR6 := FUN4(FUN3(VAR2), FUN5(VAR5)) let VAR7 := FUN4(FUN3(VAR1), VAR5) FUN2(VAR1, or(VAR7, VAR6)) }
}",TP,3
6596.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
665.sol,"function FUN1 (uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
require(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2 (uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3 (uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
require(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4 (uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
require(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
using SafeMath for uint256;
ERC20TokenInterface public VAR5;
address public VAR6 = 0x0;
struct VAR7 {
uint256 VAR8;
uint256 VAR9;
}
VAR7[4] public VAR10;
uint256 public VAR11;
uint256 public VAR12;
uint256 public VAR13;
address public VAR14;
modifier VAR15 {
require(msg.sender == VAR14);
VAR16;
}
modifier VAR17 {
require(VAR6 != 0x0);
VAR16;
}
modifier VAR18 {
require(VAR6 == 0x0);
VAR16;
}
event FUN5(uint256 VAR19, uint256 VAR20);",TP,3
6663.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
event FUN5(address indexed VAR6);
event FUN6( address indexed VAR6, address indexed VAR7 );
constructor() public {
VAR5 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR5);
VAR8;
}",TP,3
6743.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
6753.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
6798.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
6806.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
6811.sol,"function FUN1(bytes32 VAR1, bytes memory VAR2) internal pure returns (address) {
bytes32 VAR3;
bytes32 VAR4;
uint8 VAR5;
if (VAR2.VAR6 != 65) {
return (address(0));
}
VAR7 {
VAR3 := FUN2(FUN3(VAR2, 32)) VAR4 := FUN2(FUN3(VAR2, 64)) VAR5 := FUN4(0, FUN2(FUN3(VAR2, 96))) }
if (VAR5 < 27) {
VAR5 += 27;
}
if (VAR5 != 27 && VAR5 != 28) {
return (address(0));
}
bytes32 VAR8 = FUN5( VAR9.FUN6("""", VAR1) );
return FUN7(VAR8, VAR5, VAR3, VAR4);
}
}
contract VAR10 {
FUN8(address => bool) VAR11;
modifier FUN9( string memory VAR12, bytes32 VAR13, bytes memory VAR14 ) {
bytes32 VAR15 = FUN5(VAR9.FUN6(VAR13, VAR12));
require(FUN10(VAR15, VAR14));
VAR16;
}",TP,3
6833.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 * VAR2;
assert(VAR1 == 0 || VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
6844.sol,"function FUN1(bytes32 VAR1, bytes memory VAR2) internal pure returns (address) {
bytes32 VAR3;
bytes32 VAR4;
uint8 VAR5;
if (VAR2.VAR6 != 65) {
return (address(0));
}
VAR7 {
VAR3 := FUN2(FUN3(VAR2, 32)) VAR4 := FUN2(FUN3(VAR2, 64)) VAR5 := FUN4(0, FUN2(FUN3(VAR2, 96))) }
if (VAR5 < 27) {
VAR5 += 27;
}
if (VAR5 != 27 && VAR5 != 28) {
return (address(0));
}
bytes32 VAR8 = FUN5( VAR9.FUN6("""", VAR1) );
return FUN7(VAR8, VAR5, VAR3, VAR4);
}
}
contract VAR10 {
FUN8(address => bool) VAR11;
modifier FUN9( string memory VAR12, bytes32 VAR13, bytes memory VAR14 ) {
bytes32 VAR15 = FUN5(VAR9.FUN6(VAR13, VAR12));
require(FUN10(VAR15, VAR14));
VAR16;
}",TP,3
6929.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 * VAR2;
assert(VAR1 == 0 || VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
event FUN5(address indexed VAR6, address indexed VAR7);",TP,3
6933.sol,"function() payable {
FUN1(msg.sender);
}
function FUN2(address VAR1, uint VAR2, bytes VAR3) public pure {
}",TP,3
7044.sol,function FUN1() public payable;,TP,3
706.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
7086.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
event FUN5(address indexed VAR6);
event FUN6( address indexed VAR6, address indexed VAR7 );
constructor() public {
VAR5 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR5);
VAR8;
}",TP,3
710.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
711.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
address public VAR6;
modifier onlyOwner {
require(msg.sender == VAR5);
VAR7;
}
event FUN5(address VAR8, address VAR9);",TP,3
712.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
713.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
7134.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns(uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
738.sol,"function FUN1() pure external returns (string) {
return VAR1;
}",TP,3
7440.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
7441.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
7466.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
address public VAR5;
event FUN5(address indexed VAR6);
event FUN6( address indexed VAR6, address indexed VAR7 );
constructor() public {
VAR5 = msg.sender;
}
modifier onlyOwner() {
require(msg.sender == VAR5);
VAR8;
}",TP,3
7478.sol,"function FUN1(uint256 VAR1, uint256 VAR2)internal pure returns(uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
7521.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
7570.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
7627.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns(uint256) {
uint256 VAR3 = VAR1 + VAR2;
require((VAR3 >= VAR1) && (VAR3 >= VAR2));
return VAR3;
}",TP,3
7826.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
7828.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
7877.sol,"function FUN1( address VAR1, uint256 value, bytes VAR2 ) public payable VAR3 FUN2(VAR1) returns (bool) {
require( transfer(VAR1, value) && VAR2.VAR4 >= 68 );
VAR5 {
FUN3(FUN4(VAR2, 36), value) FUN3(FUN4(VAR2, 68), VAR6) }
require(VAR1.call.value(msg.value)(VAR2));
return true;
}",TP,3
7891.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {",TP,3
7919.sol,"function FUN1(uint256 VAR1, uint256 VAR2) public pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
require(VAR3 >= VAR1);
}",TP,3
797.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
require(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
8025.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
8141.sol,"function FUN1() public payable {
VAR1.VAR2.value(msg.value)();
}
}
contract VAR3 {
Inner2WithEth public VAR4 = VAR5 FUN2();",TP,3
8233.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",TP,3
8254.sol,"function () payable external {
revert();
}
StakeDice public VAR1;
uint256 public VAR2;
function FUN1() payable external {
require(msg.sender == VAR3);
}
function FUN2(uint256 VAR4) payable external {
require(msg.sender == VAR3);
VAR3.transfer(VAR4);
}
function () payable external {
revert();
}
}",TP,3
8306.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
8311.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
8320.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
8330.sol,"function FUN1() public payable {
VAR1.VAR2.value(msg.value)();
}
}
contract VAR3 {
Inner2WithEth public VAR4 = VAR5 FUN2();
function FUN3() public payable{
VAR4.VAR6.value(msg.value)();
}
}
contract VAR7 {
uint256 VAR8;
event FUN4(uint256 VAR9);
function FUN5() public payable {
VAR8 = VAR10.VAR11;
emit FUN4(VAR8);
}",TP,3
8331.sol,"function FUN1() public payable {
VAR1.VAR2.value(msg.value)();
}
}
contract VAR3 {
Inner2WithEth public VAR4 = VAR5 FUN2();
function FUN3() public payable{
VAR4.VAR6.value(msg.value)();
}
}
contract VAR7 {
uint256 VAR8;
event FUN4(uint256 VAR9);
function FUN5() public payable {
VAR8 = VAR10.VAR11;
emit FUN4(VAR8);
}",TP,3
8333.sol,"function FUN1() public payable {
VAR1.VAR2.value(msg.value)();
}
}
contract VAR3 {
Inner2WithEth public VAR4 = VAR5 FUN2();
function FUN3() public payable{
VAR4.VAR6.value(msg.value)();
}
}
contract VAR7 {
uint256 VAR8;
event FUN4(uint256 VAR9);
function FUN5() public payable {
VAR8 = VAR10.VAR11;
emit FUN4(VAR8);
}",TP,3
8336.sol,"function FUN1() public payable {
VAR1.VAR2.value(msg.value)();
}
}
contract VAR3 {
Inner2WithEth public VAR4 = VAR5 FUN2();
function FUN3() public payable{
VAR4.VAR6.value(msg.value)();
}
}
contract VAR7 {
uint256 VAR8;
event FUN4(uint256 VAR9);
function FUN5() public payable {
VAR8 = VAR10.VAR11;
emit FUN4(VAR8);
msg.sender.transfer(msg.value);
}
}",TP,3
8337.sol,"function FUN1() public payable {
VAR1.VAR2.value(msg.value)();
}
}
contract VAR3 {
Inner2WithEth public VAR4 = VAR5 FUN2();
function FUN3() public payable{
VAR4.VAR6.value(msg.value)();
}
}
contract VAR7 {
uint256 VAR8;
event FUN4(uint256 VAR9);
function FUN5() public payable {
VAR8 = VAR10.VAR11;
emit FUN4(VAR8);
msg.sender.transfer(msg.value);
}
}",TP,3
8342.sol,"function FUN1(address VAR1, uint256 VAR2, uint256 VAR3, bytes VAR4) external payable onlyCommittee returns (bool) {
return VAR1.call.value(VAR2).FUN2(VAR3)(VAR4);
}",TP,3
837.sol,"function FUN1(uint VAR1, uint VAR2) internal pure returns (uint) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}",TP,3
8436.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
8470.sol,"function () payable external {
revert();
}
StakeDice public VAR1;
uint256 public VAR2;
function FUN1() payable external {
require(msg.sender == VAR3);
}
function FUN2(uint256 VAR4) payable external {
require(msg.sender == VAR3);
VAR3.transfer(VAR4);
}
function () payable external {
revert();
}
}",TP,3
8502.sol,"function() payable public {
}",TP,3
8555.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
8556.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
8598.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",TP,3
8606.sol,"function FUN1(uint16 VAR1) public pure returns (bool) {
if (VAR1 % 4 != 0) {
return false;
}
if (VAR1 % 100 != 0) {
return true;
}
if (VAR1 % 400 != 0) {
return false;
}
return true;
}",TP,3
8614.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
8647.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 * VAR2;
assert(VAR1 == 0 || VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
8766.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
8826.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
8851.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {",TP,3
8926.sol,"function FUN1 (uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
require(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
8939.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 * VAR2;
assert(VAR1 == 0 || VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
9221.sol,"function FUN1() payable {
if ((FUN2()%2==1) && (msg.value == 1 VAR1) && (!VAR2)) {
if (!msg.sender.call.value(2 VAR1)()) throw;
}
}
function FUN3(uint VAR3) {
if (VAR4==msg.sender) {
if (!msg.sender.call.value( VAR3 * (1 VAR1))()) throw;
}
}",TP,3
9224.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 / VAR2;
return VAR3;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {",TP,3
9242.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
9309.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",TP,3
9329.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
9333.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",TP,3
9358.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
9359.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
9360.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
9368.sol,"function FUN1 (uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
require(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
9377.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
pragma VAR4 ^0.4.23;
contract VAR5 {",TP,3
9378.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
pragma VAR4 ^0.4.23;
contract VAR5 {",TP,3
9379.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
9445.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
using SafeMath for uint256;
string public VAR5;
string public VAR6;
uint8 public VAR7;
uint256 public VAR8;
FUN5 (address => uint256) public VAR9;
FUN5 (address => FUN5 (address => uint256)) public VAR10;
event Transfer(address indexed VAR11, address indexed VAR12, uint256 value);
event FUN6(address indexed VAR13, address indexed VAR14, uint256 value);",TP,3
9502.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
9531.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
9558.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0 || VAR2 == 0){
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
9560.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
9654.sol,"function FUN1() payable {
if ((FUN2()%2==1) && (msg.value == 1 VAR1) && (!VAR2)) {
if (!msg.sender.call.value(2 VAR1)()) throw;
}
}",TP,3
9759.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
9761.sol,"function FUN1(address VAR1) public payable returns(uint256) {
FUN2(msg.value, VAR1);
}",TP,3
9779.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",TP,3
9802.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",TP,3
9820.sol,"function () payable public {
require( (msg.value >= 0.1 VAR1) && VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5 && VAR6 < VAR7 && ( (msg.value <= 100 VAR1) || (msg.value > 100 VAR1 && VAR8[msg.sender]==true) ) );
uint VAR9 = msg.value;
VAR10[msg.sender] += VAR9;
VAR6 += VAR9;
FUN1(msg.sender, VAR9, true);
if (VAR11.FUN2(VAR9)) {
FUN1(VAR11, VAR9, false);
}
}",TP,3
9830.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
require(VAR3 >= VAR1);
}",TP,3
9843.sol,"function FUN1(uint16 VAR1) internal pure returns (bool) {
if (VAR1 % 4 != 0) {
return false;
}
if (VAR1 % 100 != 0) {
return true;
}
if (VAR1 % 400 != 0) {
return false;
}
return true;
}",TP,3
9850.sol,"function FUN1(address VAR1, uint VAR2) public pure returns (bytes32 VAR3) {
return FUN2(VAR1, VAR2);
}
}
pragma VAR4^0.4.11;
contract VAR5 {
event FUN3(string VAR6, uint value, bytes32 VAR7, uint VAR8, uint VAR9, address indexed VAR10);
event FUN4(bytes32 indexed VAR7, uint VAR11, uint VAR12, uint VAR13, address indexed VAR14);
event FUN5(bytes32 indexed VAR7, string VAR6, uint value);
event FUN6(bytes32 indexed VAR7);
event FUN7(bytes32 indexed VAR7, uint indexed VAR11, uint VAR15, uint VAR16);
event FUN8(bytes32 indexed VAR7, uint indexed VAR11, uint VAR15, uint VAR16);
event FUN9(uint indexed VAR11, uint VAR17, address indexed VAR18);
using SafeMath for uint;
struct VAR19 {
uint VAR20;
uint VAR11;
uint VAR8;
string VAR6;
address VAR21;
uint VAR22;
uint value;
}
struct VAR23 {
uint VAR15;
address VAR14;
bool VAR24;
uint VAR25;
uint VAR26;
FUN10(address => bool) VAR27;
}
FUN10(bytes32 => uint) public VAR28;
FUN10(uint => VAR23) public VAR29;
FUN10(bytes32 => VAR19) public VAR30;
EIP20Interface public VAR31;
PLCRVoting public VAR32;
uint public VAR33 = 604800;",TP,3
9851.sol,"function FUN1(address VAR1, uint VAR2) public pure returns (bytes32 VAR3) {
return FUN2(VAR1, VAR2);
}
}
pragma VAR4^0.4.11;
contract VAR5 {
event FUN3(string VAR6, uint value, bytes32 VAR7, uint VAR8, uint VAR9, address indexed VAR10);
event FUN4(bytes32 indexed VAR7, uint VAR11, uint VAR12, uint VAR13, address indexed VAR14);
event FUN5(bytes32 indexed VAR7, string VAR6, uint value);
event FUN6(bytes32 indexed VAR7);
event FUN7(bytes32 indexed VAR7, uint indexed VAR11, uint VAR15, uint VAR16);
event FUN8(bytes32 indexed VAR7, uint indexed VAR11, uint VAR15, uint VAR16);
event FUN9(uint indexed VAR11, uint VAR17, address indexed VAR18);
using SafeMath for uint;
struct VAR19 {
uint VAR20;
uint VAR11;
uint VAR8;
string VAR6;
address VAR21;
uint VAR22;
uint value;
}
struct VAR23 {
uint VAR15;
address VAR14;
bool VAR24;
uint VAR25;
uint VAR26;
FUN10(address => bool) VAR27;
}
FUN10(bytes32 => uint) public VAR28;
FUN10(uint => VAR23) public VAR29;
FUN10(bytes32 => VAR19) public VAR30;
EIP20Interface public VAR31;
PLCRVoting public VAR32;
uint public VAR33 = 604800;",TP,3
9858.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",TP,3
9889.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
9891.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
9892.sol,"function() payable {
throw;
}
function FUN1(address VAR1) public payable {
FUN2(VAR1, 0);
}
function FUN3() public payable {
FUN1(msg.sender);
}",TP,3
9943.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}
function FUN2(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 / VAR2;
}
function FUN3(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
assert(VAR2 <= VAR1);
return VAR1 - VAR2;
}
function FUN4(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
uint256 public VAR5;",TP,3
9967.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
9978.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
9987.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
uint256 VAR3 = VAR1 * VAR2;
assert(VAR1 == 0 || VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
9994.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
if (VAR1 == 0) {
return 0;
}
VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
9998.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
if (VAR1 == 0) {
return 0;
}
uint256 VAR3 = VAR1 * VAR2;
assert(VAR3 / VAR1 == VAR2);
return VAR3;
}",TP,3
10189.sol,"function FUN1(ERC20Basic VAR1, address VAR2, uint256 VAR3) public {
 }
 function FUN2() public {
 }
 function FUN3(ERC20Basic VAR4) public view returns (uint256) {
 uint256 VAR5 = VAR4.FUN4(this);
 uint256 VAR6 = VAR5.FUN5(VAR7[VAR4]);
 if (VAR8.VAR9 < VAR10) {
 return 0;
 }
 else if (VAR8.VAR9 >= VAR11.FUN5(VAR12) || VAR13[VAR4]) {
 return VAR6;
 }
 else {
 return VAR6.FUN6(VAR8.VAR9.FUN7(VAR11)).FUN8(VAR12);
 }
 }

1",TP,3
1030.sol,"function FUN1() internal view returns (uint256) {
 }

1",TP,3
10369.sol,"modifier VAR1 {
 require(VAR2[msg.sender] > 0);
 VAR3;
 }
 modifier VAR4 {
 require(msg.sender == VAR5);
 require(VAR2[msg.sender] > 0);
 VAR3;
 }
 modifier VAR6 {
 require(msg.sender == VAR7);
 require(VAR2[msg.sender] > 0);
 VAR3;
 }
 modifier VAR8 {
 require(VAR9 == 0);
 VAR3;
 }
 modifier VAR10 {
 require(VAR9 > 0);
 VAR3;
 }
 function FUN1() internal notLocked onlyOwner {
 VAR9 = VAR11.VAR12;
 VAR13[VAR5] = VAR9.FUN2(VAR14);
 VAR13[VAR7] = VAR9.FUN2(VAR15);
 FUN3(VAR9);
 }
 function FUN4() onlyTokenReserve locked public {
 }
 function FUN5() public view VAR4 returns(uint256){
 uint256 VAR16 = (VAR11.VAR12.FUN6(VAR9)).FUN7(VAR17);
 if(VAR16 > VAR18){
 VAR16 = VAR18;
 return VAR16;
 }
 function FUN8() public view VAR1 returns(bool) {
 }

1",TP,3
10547.sol,"modifier FUN1() {
 require(VAR1[msg.sender] == true);
 VAR2;
 }
 function FUN2(uint256 VAR3) public VAR4 {
 }
 modifier FUN3(address VAR5) {
 if (VAR6[VAR5] == false) {
 require(VAR7.VAR8 >= VAR9);
 require(VAR10 == true);
 }
 VAR2;
 }
 function FUN4() internal view returns (uint256) {
 }

1",TP,3
1058.sol,"function FUN1(address VAR1, uint256 VAR2) private view returns (VAR3.VAR4) {
 VAR5.VAR6 = VAR7.VAR6;
 }
 function FUN2(address VAR8, uint256 VAR9) private {
 uint256 VAR10 = VAR7.VAR6;
 uint256 VAR11 = VAR10.FUN3(VAR12.VAR6);
 }
 function FUN4() private view returns (bool) {
 uint256 VAR13 = uint256(FUN5(VAR14.FUN6(VAR7.VAR6, VAR7.VAR15, VAR7.VAR6, VAR7.VAR16, VAR7.VAR17, VAR18, VAR7.VAR19, msg.sender)));
 if(VAR13 - (VAR13 / 10000).FUN7(10000) < VAR18) {
 }
 function FUN8(address VAR8, bool VAR20, uint256 VAR21) private view returns (uint256, uint256 VAR22) {
 uint256 VAR10 = VAR7.VAR6.FUN9(VAR21);
 uint256 VAR23 = VAR10.FUN9(VAR24);
 uint256 VAR25 = VAR10.FUN3(VAR12.VAR6);
 }

1",TP,3
1068.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
1115.sol,"function FUN1(ERC20 VAR1) public view returns (uint256) {
 uint256 VAR2 = VAR1.FUN2(this);
 uint256 VAR3 = VAR2.FUN3(VAR4[VAR1]);
 if (VAR5.VAR6 < VAR7) {
 return 0;
 }
 else if (VAR5.VAR6 >= VAR8.FUN3(VAR9) || VAR10[VAR1]) {
 return VAR3;
 }
 else {
 return VAR3.FUN4(VAR5.VAR6.FUN5(VAR8)).FUN6(VAR9);
 }
 }

1",TP,3
11159.sol,"function FUN1( address VAR1, uint256 VAR2 ) public FUN2() {
 VAR3 = VAR4.VAR5;
 VAR6 = VAR3;
 }
 function FUN3(uint256 VAR7) public VAR8 returns(uint256 VAR9) {
 uint256 VAR5 = VAR4.VAR5;
 require(!FUN4(VAR7, VAR5));
 emit FUN5(msg.sender, VAR7, VAR5);
 }
 function FUN6(uint256 VAR2) public onlyOwner returns(bool){
 }

1",TP,3
11190.sol,"modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1() public view returns (bool) {
 }

1",TP,3
1123.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
11243.sol,"function FUN1(uint VAR1) constant public returns(uint) {
 }

1",TP,3
1130.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
11303.sol,"function FUN1() internal view returns (uint) {
 }

1",TP,3
11348.sol,"function FUN1() public view returns(VAR1) {
 }
 function FUN2(uint32 VAR2, uint32 VAR3, address VAR4) payable public {
 uint256 VAR5;
 VAR5 = ( uint128(VAR2) << 8*8 ) + ( uint128(VAR3) << 4*8 ) + uint128(VAR6.VAR7);
 VAR8: VAR9, VAR10 : VAR5 }
 }

1",TP,3
11447.sol,"modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1() public view returns (bool) {
 }

1",TP,3
11457.sol,"modifier VAR1 {
 require(VAR2[msg.sender] > 0);
 VAR3;
 }
 modifier VAR4 {
 require(msg.sender == VAR5);
 require(VAR2[msg.sender] > 0);
 require(VAR2[msg.sender] > VAR6[msg.sender]);
 VAR3;
 }
 modifier VAR7 {
 require(msg.sender == VAR8);
 require(VAR2[msg.sender] > 0);
 require(VAR2[msg.sender] > VAR6[msg.sender]);
 VAR3;
 }
 modifier VAR9 {
 require(msg.sender == VAR10);
 require(VAR2[msg.sender] > 0);
 require(VAR2[msg.sender] > VAR6[msg.sender]);
 VAR3;
 }
 modifier VAR11 {
 require(msg.sender == VAR12);
 require(VAR2[msg.sender] > 0);
 require(VAR2[msg.sender] > VAR6[msg.sender]);
 VAR3;
 }
 modifier VAR13 {
 require(msg.sender == VAR14);
 require(VAR2[msg.sender] > 0);
 require(VAR2[msg.sender] > VAR6[msg.sender]);
 VAR3;
 }
 modifier VAR15 {
 require(VAR16 == 0);
 VAR3;
 }
 modifier VAR17 {
 require(VAR16 > 0);
 VAR3;
 }
 function FUN1() internal notLocked onlyOwner {
 VAR16 = VAR18.VAR19;
 FUN2(VAR16);
 }
 function FUN3() onlyTeamReserve locked public {
 }
 function FUN4() public view VAR4 returns(uint256) {
 uint256 VAR20 = VAR18.VAR19;
 uint256 VAR21 = (VAR20.FUN5(VAR22)).FUN6(2592000);
 }
 function FUN7() onlyTokenReserveLife locked public {
 }
 function FUN8() public view VAR7 returns(uint256) {
 uint256 VAR20 = VAR18.VAR19;
 uint256 VAR21 = (VAR20.FUN5(VAR23)).FUN6(2592000);
 }
 function FUN9() onlyTokenReserveFinance locked public {
 }
 function FUN10() public view VAR9 returns(uint256) {
 uint256 VAR20 = VAR18.VAR19;
 uint256 VAR21 = (VAR20.FUN5(VAR24)).FUN6(2592000);
 }
 function FUN11() onlyTokenReserveEcon locked public {
 }
 function FUN12() public view VAR11 returns(uint256) {
 uint256 VAR20 = VAR18.VAR19;
 uint256 VAR21 = (VAR20.FUN5(VAR25[VAR12])).FUN6(2592000);
 }
 function FUN13() onlyTokenReserveDevelop locked public {
 }
 function FUN14() public view VAR1 returns(bool) {
 }

1",TP,3
11539.sol,"function FUN1(uint VAR1, uint VAR2, address VAR3) public returns (bool) {
 }
 function FUN2(address VAR4, address VAR5) internal returns (bool) {
 Sub storage VAR6 = VAR7[VAR4][VAR5];
 if (VAR6.VAR8 > 0 && VAR6.VAR8 < VAR9.VAR10 && VAR6.VAR11 > 0) {
 uint VAR12 = (VAR13.FUN3(VAR6.VAR14)).FUN4(7 VAR15);
 uint VAR16 = VAR12.FUN5(VAR6.VAR11);
 if (VAR12 > 0 && VAR17[VAR4] >= VAR16) {
 VAR7[VAR4][VAR5].VAR14 = VAR9.VAR10;
 VAR17[VAR4] = VAR17[VAR4].FUN3(VAR16);
 VAR17[VAR5] = VAR17[VAR5].FUN6(VAR16);
 emit Transfer(VAR4, VAR5, VAR16);
 return true;
 }
 }
 }
 function FUN7() public constant returns (bool) {
 }
 function FUN8() public view returns(uint) {
 }
 function FUN9(uint VAR1, uint VAR18, uint VAR19, uint VAR20) public onlyOwner returns (bool) {
 VAR21 = (VAR1 / (1 VAR22)) * (1 VAR22) + 60;
 VAR21 = VAR9.VAR10 + 60 - (VAR9.VAR10 % 60);
 VAR23 = VAR21 + VAR24;
 }
 function FUN10() public onlyOwner {
 if (VAR21 < VAR9.VAR10) {
 revert();
 }
 VAR21 = VAR21 + 1000 VAR25;
 VAR23 = VAR21;
 VAR26 = VAR21;
 }
 function FUN11() internal constant returns(uint VAR1, uint VAR27, uint VAR28) {
 if (VAR9.VAR10 < VAR21) {
 VAR1 = VAR21;
 VAR27 = VAR29;
 VAR28 = VAR30;
 return;
 }
 VAR1 = VAR26;
 VAR1 = FUN12(FUN8());
 VAR28 = FUN13(VAR31);
 VAR27 = VAR29 / 100 + 1;
 if (VAR30 == 0 || VAR31 == 0) {
 VAR27 = (VAR29 * 2) + 1;
 VAR27 = VAR32 * 2;
 uint VAR33 = FUN14(VAR1);
 VAR27 = FUN15(VAR29, VAR34) * 2;
 }
 modifier FUN16() {
 require(msg.sender == address(VAR35));
 VAR36;
 }
 function export(address VAR37, bytes8 VAR38, address VAR39, address VAR40, uint VAR41, uint VAR42, bytes VAR43) public returns (bool) {
 uint VAR44 = VAR9.VAR10;
 bytes32 VAR45 = FUN17( VAR44, VAR35.FUN18(), VAR38, VAR39, VAR40, VAR41, VAR46, VAR35.FUN19(), VAR47, VAR48.FUN20(), VAR43, VAR49[VAR50 - 1]);
 emit FUN21(VAR38, VAR39, VAR40, VAR41, VAR42, VAR43, VAR46, VAR50, VAR45, VAR49[VAR50 - 1], VAR47, VAR51, VAR35.FUN19(), VAR44, VAR35.FUN22());
 }

1",TP,3
11566.sol,"function FUN1() internal returns(uint256) {
 uint256 VAR1 = uint256(FUN2(VAR2.VAR3, uint256(VAR4 * VAR2.VAR5)));
 VAR4 = uint256(VAR1 * VAR2.VAR6);
 return VAR1;
 }

1",TP,3
11568.sol,"function FUN1(uint8 VAR1) internal returns(uint8) {
 VAR2 = VAR3.VAR4;
 return uint8(uint256(FUN2(VAR2, VAR3.VAR5))%VAR1)+1;
 }
 function FUN3() internal view returns (uint256) {
 }

1",TP,3
1162.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
11716.sol,"modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1() public view returns (bool) {
 }
 function FUN2() internal view returns (VAR7) {
 uint256 VAR8 = VAR2.VAR3;
 if (VAR8 > VAR9.VAR10 && VAR8 <= VAR9.VAR11) {
 else if (VAR8 > VAR12.VAR10 && VAR8 <= VAR12.VAR11) {
 else if (VAR8 > VAR13.VAR10 && VAR8 <= VAR13.VAR11) {
 else if (VAR8 > VAR14.VAR10 && VAR8 <= VAR14.VAR11) {
 else if (VAR8 > VAR15.VAR10 && VAR8 <= VAR15.VAR11) {
 else if (VAR8 > VAR16.VAR10 && VAR8 <= VAR16.VAR11) {
 }

1",TP,3
11751.sol,"function FUN1(ERC20Basic VAR1) public view returns (uint256) {
 uint256 VAR2 = VAR1.FUN2(this);
 uint256 VAR3 = VAR2.FUN3(VAR4[VAR1]);
 if (VAR5.VAR6 < VAR7) {
 return 0;
 }
 else if (VAR5.VAR6 >= VAR8.FUN3(VAR9) || VAR10[VAR1]) {
 return VAR3;
 }
 else {
 return VAR3.FUN4(VAR5.VAR6.FUN5(VAR8)).FUN6(VAR9);
 }
 }

1",TP,3
11776.sol,"function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1",TP,3
11780.sol,"function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1",TP,3
11804.sol,"function FUN1(ERC20Basic VAR1) public view returns (uint256) {
 uint256 VAR2 = VAR1.FUN2(this);
 uint256 VAR3 = VAR2.FUN3(VAR4[VAR1]);
 if (VAR5.VAR6 < VAR7) {
 return 0;
 }
 else if (VAR5.VAR6 >= VAR8.FUN3(VAR9) || VAR10[VAR1]) {
 return VAR3;
 }
 else {
 return VAR3.FUN4(VAR5.VAR6.FUN5(VAR8)).FUN6(VAR9);
 }
 }

1",TP,3
1182.sol,"modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1() public view returns (bool) {
 }
 function FUN2() external onlyOwner() {
 require(VAR4 == 0);
 VAR4 = VAR2.VAR3;
 VAR5 = VAR4.FUN3(VAR7);
 }

1",TP,3
11861.sol,"function FUN1(uint VAR1) constant public returns(uint) {
 }

1",TP,3
11978.sol,"modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1(uint256 VAR7, uint256 VAR8) public {
 }
 function FUN2() public view returns (bool) {
 }
 function FUN3 ( uint256 VAR7, uint256 VAR8, uint256 VAR9, address VAR10, uint256[6] VAR11, uint256 VAR12, uint256 VAR13, CareerChainToken VAR14 ) public FUN4(VAR9, VAR10, VAR14) FUN1(VAR7, VAR8) {
 }

1",TP,3
12048.sol,"modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1() public view returns (bool) {
 }

1",TP,3
12169.sol,"function FUN1(ERC20Basic VAR1) public view returns (uint256) {
 uint256 VAR2 = VAR1.FUN2(this);
 uint256 VAR3 = VAR2.FUN3(VAR4[VAR1]);
 if (VAR5.VAR6 < VAR7) {
 return 0;
 }
 else if (VAR5.VAR6 >= VAR8.FUN3(VAR9) || VAR10[VAR1]) {
 return VAR3;
 }
 else {
 return VAR3.FUN4(VAR5.VAR6.FUN5(VAR8)).FUN6(VAR9);
 }
 }

1",TP,3
1225.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 100) * 100)) < VAR10[msg.sender]) return(true);
 }

1",TP,3
12266.sol,"function FUN1(ERC20Basic VAR1) public view returns (uint256) {
 uint256 VAR2 = VAR1.FUN2(this);
 uint256 VAR3 = VAR2.FUN3(VAR4[VAR1]);
 if (VAR5.VAR6 < VAR7) {
 return 0;
 }
 else if (VAR5.VAR6 >= VAR8.FUN3(VAR9) || VAR10[VAR1]) {
 return VAR3;
 }
 else {
 return VAR3.FUN4(VAR5.VAR6.FUN5(VAR8)).FUN6(VAR9);
 }
 }

1",TP,3
12279.sol,"function FUN1(ERC20Basic VAR1) public view returns (uint256) {
 uint256 VAR2 = VAR1.FUN2(this);
 uint256 VAR3 = VAR2.FUN3(VAR4[VAR1]);
 if (VAR5.VAR6 < VAR7) {
 return 0;
 }
 else if (VAR5.VAR6 >= VAR8.FUN3(VAR9) || VAR10[VAR1]) {
 return VAR3;
 }
 else {
 return VAR3.FUN4(VAR5.VAR6.FUN5(VAR8)).FUN6(VAR9);
 }
 }

1",TP,3
12283.sol,"function FUN1() public view returns (uint256) {
 }

1",TP,3
12410.sol,"function FUN1() public view returns (uint256) {
 }

1",TP,3
12463.sol,"modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1() public view returns (bool) {
 }

1",TP,3
12593.sol,"modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1() public view returns (bool) {
 }

1",TP,3
12669.sol,"modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1(uint256 VAR7, uint256 VAR8) public {
 }
 function FUN2() public view returns (bool) {
 }

1",TP,3
12681.sol,"modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1(uint256 VAR7, uint256 VAR8) public {
 }
 function FUN2() public view returns (bool) {
 }

1",TP,3
1298.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
12988.sol,"modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1(uint256 VAR7, uint256 VAR8) public {
 }
 function FUN2() public view returns (bool) {
 }

1",TP,3
12992.sol,"modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1(uint256 VAR7, uint256 VAR8) public {
 }
 function FUN2() public view returns (bool) {
 }

1",TP,3
1302.sol,"function FUN1(uint256 VAR1) private view returns (uint256) {
 uint256 VAR2 = uint256(FUN2(VAR3.FUN3( (VAR4.VAR5).FUN4 (VAR4.VAR6).FUN4 ((uint256(FUN2(VAR3.FUN3(VAR4.VAR7)))) / (VAR8)).FUN4 (VAR4.VAR9).FUN4 ((uint256(FUN2(VAR3.FUN3(msg.sender)))) / (VAR8)).FUN4 (VAR4.VAR10) )));
 VAR1 = (VAR2 - ((VAR2 / 3) * 3));
 }
 function FUN5() public view returns(uint256){
 uint256 VAR2 = uint256(FUN2(VAR3.FUN3( (VAR4.VAR5).FUN4 (VAR4.VAR6).FUN4 ((uint256(FUN2(VAR3.FUN3(VAR4.VAR7)))) / (VAR8)).FUN4 (VAR4.VAR9).FUN4 ((uint256(FUN2(VAR3.FUN3(msg.sender)))) / (VAR8)).FUN4 (VAR4.VAR10) )));
 return (VAR2 - ((VAR2 / 3) * 3));
 }

1",TP,3
13021.sol,"function FUN1(ERC20Basic VAR1) public view returns (uint256) {
 uint256 VAR2 = VAR1.FUN2(this);
 uint256 VAR3 = VAR2.FUN3(VAR4[VAR1]);
 if (VAR5.VAR6 < VAR7) {
 return 0;
 }
 else if (VAR5.VAR6 >= VAR8.FUN3(VAR9) || VAR10[VAR1]) {
 return VAR3;
 }
 else {
 return VAR3.FUN4(VAR5.VAR6.FUN5(VAR8)).FUN6(VAR9);
 }
 }

1",TP,3
1327.sol,"function FUN1() public returns (uint256) {
 VAR1 = VAR2.FUN2(this);
 VAR3 = VAR1.FUN3(VAR4[VAR2]);
 if (VAR5.VAR6 < VAR7) {
 return 0;
 }
 else if (VAR5.VAR6 >= VAR8.FUN3(VAR9) || VAR10[VAR2]) {
 return VAR3;
 }
 else {
 return VAR3.FUN4(VAR5.VAR6.FUN5(VAR8)).FUN6(VAR9);
 }
 }

1",TP,3
13282.sol,"modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1() public view returns (bool) {
 }

1",TP,3
13293.sol,"modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1() external onlyOwner {
 }
 function FUN2(uint256 VAR7) external onlyOwner {
 }
 function FUN3() external onlyOwner returns (bool) {
 if (VAR8 && VAR2.VAR3 >= (VAR4.FUN4(10 VAR9))) {
 VAR8 = false;
 VAR10.transfer(VAR11, VAR12);
 VAR10.transfer(VAR13, VAR12);
 VAR14[VAR11] = VAR14[VAR11].FUN5(VAR12);
 VAR14[VAR13] = VAR14[VAR13].FUN5(VAR12);
 VAR15 = VAR15.FUN5(VAR12);
 VAR15 = VAR15.FUN5(VAR12);
 }
 if (VAR16 && VAR2.VAR3 >= (VAR4.FUN4(22 VAR9))) {
 VAR16 = false;
 VAR10.transfer(VAR11, VAR12);
 VAR10.transfer(VAR13, VAR12);
 VAR14[VAR11] = VAR14[VAR11].FUN5(VAR12);
 VAR14[VAR13] = VAR14[VAR13].FUN5(VAR12);
 VAR15 = VAR15.FUN5(VAR12);
 VAR15 = VAR15.FUN5(VAR12);
 }
 if (VAR17 && VAR2.VAR3 >= (VAR4.FUN4(34 VAR9))) {
 VAR17 = false;
 VAR10.transfer(VAR11, VAR12);
 VAR10.transfer(VAR13, VAR12);
 VAR14[VAR11] = VAR14[VAR11].FUN5(VAR12);
 VAR14[VAR13] = VAR14[VAR13].FUN5(VAR12);
 VAR15 = VAR15.FUN5(VAR12);
 VAR15 = VAR15.FUN5(VAR12);
 }
 if (VAR18 && VAR2.VAR3 >= (VAR4.FUN4(46 VAR9))) {
 VAR18 = false;
 VAR10.transfer(VAR11, VAR12);
 VAR10.transfer(VAR13, VAR12);
 VAR14[VAR11] = VAR14[VAR11].FUN5(VAR12);
 VAR14[VAR13] = VAR14[VAR13].FUN5(VAR12);
 VAR15 = VAR15.FUN5(VAR12);
 VAR15 = VAR15.FUN5(VAR12);
 }
 }
 function FUN6() public view returns (bool) {
 }
 function FUN7() public view returns (uint256) {
 if (VAR2.VAR3 <= (VAR4.FUN4(14 VAR19))) {
 return VAR20.FUN4(200);
 }
 if (VAR2.VAR3 <= (VAR4.FUN4(28 VAR19))) {
 return VAR20.FUN4(100);
 }
 if (VAR2.VAR3 <= (VAR4.FUN4(49 VAR19))) {
 return VAR20.FUN4(50);
 }
 return VAR20;
 }

1",TP,3
13302.sol,"function FUN1(ERC20Basic VAR1) public view returns (uint256) {
 uint256 VAR2 = VAR1.FUN2(this);
 uint256 VAR3 = VAR2.FUN3(VAR4[VAR1]);
 if (VAR5.VAR6 < VAR7) {
 return 0;
 }
 else if (VAR5.VAR6 >= VAR8.FUN3(VAR9) || VAR10[VAR1]) {
 return VAR3;
 }
 else {
 return VAR3.FUN4(VAR5.VAR6.FUN5(VAR8)).FUN6(VAR9);
 }
 }

1",TP,3
1337.sol,"function FUN1() public returns (uint256) {
 VAR1 = VAR2.FUN2(this);
 VAR3 = VAR1.FUN3(VAR4[VAR2]);
 if (VAR5.VAR6 < VAR7) {
 return 0;
 }
 else if (VAR5.VAR6 >= VAR8.FUN3(VAR9) || VAR10[VAR2]) {
 return VAR3;
 }
 else {
 return VAR3.FUN4(VAR5.VAR6.FUN5(VAR8)).FUN6(VAR9);
 }
 }

1",TP,3
13430.sol,"modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1() public view returns (bool) {
 }
 modifier FUN2() {
 require((VAR2.VAR3 > VAR4 && VAR2.VAR3 < VAR4 + (5 VAR7)) || (VAR2.VAR3 > VAR4 + (7 VAR7) && VAR2.VAR3 < VAR5));
 VAR6;
 }
 function FUN3( address VAR8, uint256 VAR9 ) internal VAR10 {
 super.FUN3(VAR8, VAR9);
 if(VAR2.VAR3 <= VAR4 + (2 VAR7)) {
 require(VAR11[VAR8]);
 require(msg.value >= 5 VAR12);
 VAR13 = 833;
 }
 else if(VAR2.VAR3 > VAR4 + (2 VAR7) && VAR2.VAR3 <= VAR4 + (3 VAR7)) {
 require(msg.value >= 5 VAR12);
 VAR13 = 722;
 }
 else if(VAR2.VAR3 > VAR4 + (3 VAR7) && VAR2.VAR3 <= VAR4 + (4 VAR7)) {
 require(msg.value >= 5 VAR12);
 VAR13 = 666;
 }
 else if(VAR2.VAR3 > VAR4 + (4 VAR7) && VAR2.VAR3 <= VAR4 + (5 VAR7)) {
 require(msg.value >= 5 VAR12);
 VAR13 = 611;
 }
 else{
 VAR13 = 555;
 }
 }
 function FUN4() internal {
 if(msg.VAR14.VAR15 == 20) {
 address VAR16 = FUN5(bytes(msg.VAR14));
 require(VAR16 != address(VAR17) && VAR16 != msg.sender);
 uint256 VAR18 = msg.value.FUN6(VAR19).FUN7(100);
 if(VAR2.VAR3 <= VAR4 + (2 VAR7)) {
 VAR20.transfer(msg.value);
 }
 else{
 VAR21.VAR22.value(msg.value)(msg.sender);
 }
 }

1",TP,3
1385.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
13943.sol,"modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1(uint256 VAR7, uint256 VAR8) public {
 }
 function FUN2() public view returns (bool) {
 }

1",TP,3
13948.sol,"function FUN1() public {
 }
 function FUN2(ERC20Basic VAR1) public view returns (uint256) {
 uint256 VAR2 = VAR1.FUN3(this);
 uint256 VAR3 = VAR2.FUN4(VAR4[VAR1]);
 if (VAR5.VAR6 < VAR7) {
 return 0;
 }
 else if (VAR5.VAR6 >= VAR8.FUN4(VAR9) || VAR10[VAR1]) {
 return VAR3;
 }
 else {
 return VAR3.FUN5(VAR5.VAR6.FUN6(VAR8)).FUN7(VAR9);
 }
 }

1",TP,3
1399.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
14070.sol,"function FUN1( address VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4 ) public onlyOwner poolReady returns (VAR5) {
 uint256 VAR6 = VAR7.VAR8;
 TokenVesting VAR9 = VAR10 FUN2(VAR1, VAR6, VAR2, VAR3, false);
 }
 function FUN3(ERC20Basic VAR11) public view returns (uint256) {
 uint256 VAR12 = VAR11.FUN4(this);
 uint256 VAR13 = VAR12.FUN5(VAR14[VAR11]);
 if (VAR7.VAR8 < VAR15) {
 return 0;
 }
 else if (VAR7.VAR8 >= VAR6.FUN5(VAR16) || VAR17[VAR11]) {
 return VAR13;
 }
 else {
 return VAR13.FUN6(VAR7.VAR8.FUN7(VAR6)).FUN8(VAR16);
 }
 }
 function FUN9( address VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, bool VAR18 ) internal returns (VAR5) {
 uint256 VAR6 = VAR7.VAR8;
 VAR19[VAR1].FUN10(VAR10 FUN2(VAR1, VAR6, VAR2, VAR3, VAR18));
 }

1",TP,3
14161.sol,"modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5 && !VAR6);
 VAR7;
 }
 function FUN1(address VAR8, uint256 VAR9, uint256 VAR10, uint256 VAR11) public {
 }
 function FUN2() public view returns (bool) {
 }

1",TP,3
14253.sol,"function FUN1() public view returns (bool) {
 }

1",TP,3
14257.sol,"function FUN1() public view returns (bool) {
 }

1",TP,3
1445.sol,"function FUN1() public returns (uint256) {
 VAR1 = VAR2.FUN2(this);
 VAR3 = VAR1.FUN3(VAR4[VAR2]);
 if (VAR5.VAR6 < VAR7) {
 return 0;
 }
 else if (VAR5.VAR6 >= VAR8.FUN3(VAR9) || VAR10[VAR2]) {
 return VAR3;
 }
 else {
 return VAR3.FUN4(VAR5.VAR6.FUN5(VAR8)).FUN6(VAR9);
 }
 }

1",TP,3
14875.sol,"modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1() public view returns (bool) {
 }

1",TP,3
14953.sol,"function FUN1( ) {
 VAR1 = VAR2.VAR3;
 }

1",TP,3
1507.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
15154.sol,"modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1(uint256 VAR7, uint256 VAR8) public {
 }
 function FUN2() public view returns (bool) {
 }

1",TP,3
15159.sol,"modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1(uint256 VAR7, uint256 VAR8) public {
 }
 function FUN2() public view returns (bool) {
 }

1",TP,3
1520.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
1522.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
15416.sol,"function FUN1(ERC20Basic VAR1) public view returns (uint256) {
 uint256 VAR2 = VAR1.FUN2(this);
 uint256 VAR3 = VAR2.FUN3(VAR4[VAR1]);
 if (VAR5.VAR6 < VAR7) {
 return 0;
 }
 else if (VAR5.VAR6 >= VAR8.FUN3(VAR9) || VAR10[VAR1]) {
 return VAR3;
 }
 else {
 return VAR3.FUN4(VAR5.VAR6.FUN5(VAR8)).FUN6(VAR9);
 }
 }

1",TP,3
15990.sol,"function FUN1() constant returns (uint256) {
 }

1",TP,3
16064.sol,"function FUN1(ERC20Interface VAR1) public view returns (uint256) {
 uint256 VAR2 = VAR1.FUN2(this);
 uint256 VAR3 = VAR2.FUN3(VAR4[VAR1]);
 if (VAR5.VAR6 < VAR7) {
 return 0;
 }
 else if (VAR5.VAR6 >= VAR8.FUN3(VAR9) || VAR10[VAR1]) {
 return VAR3;
 }
 else {
 return VAR3.FUN4(VAR5.VAR6.FUN5(VAR8)).FUN6(VAR9);
 }
 }

1",TP,3
16079.sol,"modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1(uint256 VAR7, uint256 VAR8) public {
 }
 function FUN2() public view returns (bool) {
 }

1",TP,3
1663.sol,"modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1() public view returns (bool) {
 }

1",TP,3
16729.sol,"modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1(uint256 VAR7, uint256 VAR8) public {
 }
 function FUN2() public view returns (bool) {
 }

1",TP,3
1704.sol,"function FUN1 () external view returns (bool, bool, address, uint, uint, uint, uint, uint, uint, address) {
 }
 function FUN2 (uint VAR1, uint VAR2) public VAR3 {
 require(VAR4 == 0);
 VAR4 = VAR5.VAR6;
 VAR7 = VAR4 + VAR8;
 emit FUN3(VAR4);
 }
 function FUN4 (address VAR9, uint VAR10) public payable VAR11 {
 VAR7 = VAR7.FUN5(VAR12.FUN6(VAR13)) > VAR5.VAR6.FUN5(VAR8) ? VAR5.VAR6.FUN5(VAR8) : VAR7.FUN5(VAR12.FUN6(VAR13));
 emit FUN7(VAR14, VAR12, VAR7);
 }
 function FUN8 () public VAR15 {
 }

1",TP,3
1711.sol,"function FUN1 () external view returns (bool, bool, address, uint, uint, uint, uint, uint, uint, address) {
 }
 function FUN2 (uint VAR1, uint VAR2) public VAR3 {
 require(VAR4 == 0);
 VAR4 = VAR5.VAR6;
 VAR7 = VAR4 + VAR8;
 emit FUN3(VAR4);
 }
 function FUN4 (address VAR9, uint VAR10) public payable VAR11 {
 VAR7 = VAR7.FUN5(VAR12.FUN6(VAR13)) > VAR5.VAR6.FUN5(VAR8) ? VAR5.VAR6.FUN5(VAR8) : VAR7.FUN5(VAR12.FUN6(VAR13));
 emit FUN7(VAR14, VAR12, VAR7);
 }
 function FUN8 () public VAR15 {
 }

1",TP,3
17456.sol,"modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1() public view returns (bool) {
 }

1",TP,3
17623.sol,"modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1(uint256 VAR7, uint256 VAR8) public {
 }
 function FUN2() public view returns (bool) {
 }

1",TP,3
17716.sol,"function FUN1 () internal view returns (uint256) {
 }

1",TP,3
1781.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
17840.sol,"function FUN1() constant internal returns (uint) {
 }

1",TP,3
1794.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
1813.sol,"modifier FUN1() {
 require (VAR1 < VAR2.VAR3);
 VAR4;
 }
 function FUN2(uint VAR5, uint VAR6, uint VAR7, uint VAR8) public view returns (uint) {
 uint VAR9 = VAR2.VAR3;
 VAR9 += VAR8;
 VAR9 += 60 * VAR7;
 VAR9 += 3600 * VAR6;
 VAR9 += 86400 * VAR5;
 return VAR9;
 }

1",TP,3
1859.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
18634.sol,"modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1(uint256 VAR7, uint256 VAR8) public {
 }
 function FUN2() public view returns (bool) {
 }
 function FUN3(ERC20Basic VAR9, address VAR10, uint256 VAR11) public {
 }
 function FUN4() public {
 }
 function FUN5(ERC20Basic VAR12) public view returns (uint256) {
 uint256 VAR13 = VAR12.FUN6(this);
 uint256 VAR14 = VAR13.FUN7(VAR15[VAR12]);
 if (VAR2.VAR3 < VAR16) {
 return 0;
 }
 else if (VAR2.VAR3 >= VAR17.FUN7(VAR18) || VAR19[VAR12]) {
 return VAR14;
 }
 else {
 return VAR14.FUN8(VAR2.VAR3.FUN9(VAR17)).FUN10(VAR18);
 }
 }

1",TP,3
18635.sol,"modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1(uint256 VAR7, uint256 VAR8) public {
 }
 function FUN2() public view returns (bool) {
 }
 function FUN3(ERC20Basic VAR9, address VAR10, uint256 VAR11) public {
 }
 function FUN4() public {
 }
 function FUN5(ERC20Basic VAR12) public view returns (uint256) {
 uint256 VAR13 = VAR12.FUN6(this);
 uint256 VAR14 = VAR13.FUN7(VAR15[VAR12]);
 if (VAR2.VAR3 < VAR16) {
 return 0;
 }
 else if (VAR2.VAR3 >= VAR17.FUN7(VAR18) || VAR19[VAR12]) {
 return VAR14;
 }
 else {
 return VAR14.FUN8(VAR2.VAR3.FUN9(VAR17)).FUN10(VAR18);
 }
 }

1",TP,3
188.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
1885.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
1937.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
1939.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
1965.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
197.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
1977.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
19954.sol,"modifier onlyAdmin() {
 assert(VAR1[msg.sender] == true || msg.sender == VAR2);
 VAR3;
 }
 function FUN1() public {
 VAR4 = VAR5.VAR6;
 }
 function FUN2(uint256 VAR7, string VAR8, uint256 VAR9) onlyAdmin public {
 }
 function FUN3 (uint256 VAR10, uint256 VAR11) onlyAdmin public {
 VAR4 = VAR5.VAR6;
 }
 function FUN4() public constant returns (uint256) {
 }
 function FUN5(address VAR12) internal {
 if (VAR13[VAR12] != 0) {
 VAR14[VAR13[VAR12]] += msg.value / 100;
 assert (FUN6(VAR12) == false);
 uint256 VAR15 = FUN4();
 if (VAR16[VAR15] == 0) VAR16[VAR15] = VAR17;
 uint256 VAR7 = msg.value * VAR18 / VAR16[VAR15] ;
 VAR12.transfer((VAR7 - VAR19) * VAR16[VAR15] / VAR18);
 if (VAR20[VAR12][VAR15].VAR7 == 0) {
 VAR20[VAR12][VAR15] = FUN7(VAR7, false);
 VAR20[VAR12][VAR15].VAR7 += VAR7;
 if (VAR5.VAR6 < 1522357200 && VAR21[VAR12][VAR15] == 0) {
 VAR21[VAR12][VAR15] = 1;
 }
 VAR22[VAR12] = FUN8(VAR22[VAR12], VAR7);
 emit Transfer(0, VAR12, VAR7);
 }

1",TP,3
201.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
20259.sol,"function FUN1() public view returns (bool) {
 uint256 VAR1 = (VAR2.VAR3 - 345600) % 604800;
 if (VAR1 >= VAR4[VAR5] && VAR1 <= VAR6[VAR5]) {
 }
 function FUN2(uint256 VAR7, address VAR8) public view returns (uint256) {
 uint256 VAR9 = VAR2.VAR3.FUN3(FUN4()).FUN3(VAR10);
 if (VAR9 >= VAR11) {
 return VAR9;
 }
 function FUN5(uint256 VAR12, bool VAR13, uint256 VAR14, uint256 VAR15) public payable {
 VAR16[VAR17].VAR18 = VAR2.VAR3;
 VAR16[VAR17].VAR19 = VAR2.VAR3 + VAR20.VAR21;
 FUN6(VAR17, VAR16[VAR17].VAR19);
 require(VAR16[VAR17].VAR18.FUN3(VAR20.VAR21) >= VAR2.VAR3);
 VAR16[VAR17].VAR19 = VAR16[VAR17].VAR22[VAR16[VAR17].VAR23];
 FUN6(VAR17, VAR16[VAR17].VAR19);
 else if (VAR24 > VAR16[VAR17].VAR19) {
 VAR16[VAR17].VAR19 = VAR24;
 }
 function FUN7() internal returns(bool) {
 if (!VAR16[VAR17].VAR25) {
 address VAR26 = VAR16[VAR17].VAR27[VAR16[VAR17].VAR23];
 if (VAR16[VAR17].VAR19 >= VAR2.VAR3) {
 return false;
 }
 if (VAR16[VAR17].VAR28 > 0) {
 FUN8(VAR26, VAR16[VAR17].VAR28);
 FUN9 (VAR14, VAR15) = FUN10(VAR16[VAR17].VAR23);
 FUN11(VAR17, VAR26, VAR16[VAR17].VAR23, VAR14, VAR15, VAR16[VAR17].VAR22[VAR16[VAR17].VAR23], VAR16[VAR17].VAR28);
 VAR17++;
 }

1",TP,3
2071.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
2077.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
20888.sol,"function FUN1() internal view returns (bool){
 if (VAR1.VAR2 < VAR3){
 return (true);
 }
 }
 function FUN2() internal {
 VAR3 = VAR1.VAR2 + VAR4[VAR5];
 }

1",TP,3
21049.sol,"function FUN1() constant internal returns (uint) {
 }

1",TP,3
2115.sol,"modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1() public view returns (bool) {
 }

1",TP,3
2119.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
2123.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
21231.sol,"modifier onlyAdmin() {
 assert(VAR1[msg.sender] == true || msg.sender == VAR2);
 VAR3;
 }
 function FUN1() public {
 VAR4 = VAR5.VAR6;
 }
 function FUN2(uint256 VAR7, string VAR8, uint256 VAR9) onlyAdmin public {
 }
 function FUN3 (uint256 VAR10, uint256 VAR11) onlyAdmin public {
 VAR4 = VAR5.VAR6;
 }
 function FUN4() public constant returns (uint256) {
 }
 function FUN5(address VAR12) internal {
 if (VAR13[VAR12] != 0) {
 VAR14[VAR13[VAR12]] += msg.value / 100;
 uint256 VAR15 = FUN4();
 if (VAR16[VAR15] == 0) VAR16[VAR15] = VAR17;
 uint256 VAR7 = msg.value * VAR18 / VAR16[VAR15] ;
 VAR12.transfer((VAR7 - VAR19) * VAR16[VAR15] / VAR18);
 if (VAR20[VAR12][VAR15].VAR7 == 0) {
 VAR20[VAR12][VAR15] = FUN6(VAR7, false);
 VAR20[VAR12][VAR15].VAR7 += VAR7;
 if (VAR5.VAR6 < 1522357200 && VAR21[VAR12][VAR15] == 0) {
 VAR21[VAR12][VAR15] = 1;
 }
 VAR22[VAR12] = FUN7(VAR22[VAR12], VAR7);
 emit Transfer(0, VAR12, VAR7);
 }

1",TP,3
2129.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
2171.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
2199.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
2205.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
2211.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
22160.sol,"function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }
 function FUN5(address VAR18, uint256 VAR19, uint256 VAR20, uint256 VAR21, uint256 VAR22) public VAR23 {
 VAR24.VAR25 = VAR7.VAR8;
 VAR24.VAR26 = FUN6(VAR7.VAR8,VAR22);
 VAR24.VAR27 = FUN6(VAR7.VAR8,VAR20);
 }
 function FUN7(address VAR18) public {
 VestingSchedule storage VAR24 = VAR28[VAR18];
 uint256 VAR29 = FUN6(VAR24.VAR30, VAR24.VAR31);
 require(FUN8(VAR29, VAR24.VAR32) > 0);
 uint256 VAR33 = 0;
 if (VAR7.VAR8 >= VAR24.VAR27 && !VAR24.VAR34) {
 VAR33 = FUN6(VAR33,VAR24.VAR30);
 VAR24.VAR32 = FUN6(VAR24.VAR32, VAR33);
 VAR24.VAR34 = true;
 }
 if (VAR7.VAR8 >= VAR24.VAR26 && !VAR24.VAR35) {
 VAR33 = FUN6(VAR33,VAR24.VAR31);
 VAR24.VAR32 = FUN6(VAR24.VAR32, VAR33);
 VAR24.VAR35 = true;
 }
 require(VAR33 > 0);
 VAR36.transfer(VAR18, VAR33);
 VAR37 = FUN8(VAR37, VAR33);
 FUN9(VAR18, VAR33);
 }

1",TP,3
22161.sol,"function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }
 function FUN5(address VAR18, uint256 VAR19, uint256 VAR20, uint256 VAR21, uint256 VAR22) public VAR23 {
 VAR24.VAR25 = VAR7.VAR8;
 VAR24.VAR26 = FUN6(VAR7.VAR8,VAR22);
 VAR24.VAR27 = FUN6(VAR7.VAR8,VAR20);
 }
 function FUN7(address VAR18) public {
 VestingSchedule storage VAR24 = VAR28[VAR18];
 uint256 VAR29 = FUN6(VAR24.VAR30, VAR24.VAR31);
 require(FUN8(VAR29, VAR24.VAR32) > 0);
 uint256 VAR33 = 0;
 if (VAR7.VAR8 >= VAR24.VAR27 && !VAR24.VAR34) {
 VAR33 = FUN6(VAR33,VAR24.VAR30);
 VAR24.VAR32 = FUN6(VAR24.VAR32, VAR33);
 VAR24.VAR34 = true;
 }
 if (VAR7.VAR8 >= VAR24.VAR26 && !VAR24.VAR35) {
 VAR33 = FUN6(VAR33,VAR24.VAR31);
 VAR24.VAR32 = FUN6(VAR24.VAR32, VAR33);
 VAR24.VAR35 = true;
 }
 require(VAR33 > 0);
 VAR36.transfer(VAR18, VAR33);
 VAR37 = FUN8(VAR37, VAR33);
 FUN9(VAR18, VAR33);
 }

1",TP,3
22162.sol,"function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }
 function FUN5(address VAR18, uint256 VAR19, uint256 VAR20, uint256 VAR21, uint256 VAR22) public VAR23 {
 VAR24.VAR25 = VAR7.VAR8;
 VAR24.VAR26 = FUN6(VAR7.VAR8,VAR22);
 VAR24.VAR27 = FUN6(VAR7.VAR8,VAR20);
 }
 function FUN7(address VAR18) public {
 VestingSchedule storage VAR24 = VAR28[VAR18];
 uint256 VAR29 = FUN6(VAR24.VAR30, VAR24.VAR31);
 require(FUN8(VAR29, VAR24.VAR32) > 0);
 uint256 VAR33 = 0;
 if (VAR7.VAR8 >= VAR24.VAR27 && !VAR24.VAR34) {
 VAR33 = FUN6(VAR33,VAR24.VAR30);
 VAR24.VAR32 = FUN6(VAR24.VAR32, VAR33);
 VAR24.VAR34 = true;
 }
 if (VAR7.VAR8 >= VAR24.VAR26 && !VAR24.VAR35) {
 VAR33 = FUN6(VAR33,VAR24.VAR31);
 VAR24.VAR32 = FUN6(VAR24.VAR32, VAR33);
 VAR24.VAR35 = true;
 }
 require(VAR33 > 0);
 VAR36.transfer(VAR18, VAR33);
 VAR37 = FUN8(VAR37, VAR33);
 FUN9(VAR18, VAR33);
 }

1",TP,3
2222.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
2225.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
22273.sol,"modifier FUN1() {
 require(msg.sender == VAR1);
 VAR2;
 }
 modifier FUN2() {
 require(VAR3 == VAR4.VAR5);
 VAR2;
 }
 function FUN3(uint VAR6) public onlyOwner {
 VAR7 = VAR8.VAR9;
 }
 function FUN4(uint VAR6, uint VAR10, uint VAR11, uint VAR12, uint VAR13) public onlyOwner VAR14 {
 if (VAR6 > VAR8.VAR9) {
 VAR15 = VAR6;
 }
 }
 function FUN5() public {
 if (VAR3 != VAR4.VAR16 && VAR3 != VAR4.VAR5) {
 if (VAR17 >= VAR18) {
 VAR3 = VAR4.VAR19;
 VAR15 = VAR8.VAR9;
 FUN6(VAR17);
 else if (VAR8.VAR9 >= VAR15) {
 if (VAR17 < VAR20) {
 VAR3 = VAR4.VAR21;
 FUN7();
 }
 else {
 VAR3 = VAR4.VAR19;
 FUN6(VAR17);
 }
 }
 }
 function FUN8() public onlyWhitelisted payable {
 }

1",TP,3
2252.sol,"function FUN1(uint256 VAR1) external {
 }
 function FUN2(uint256 VAR2, uint256 VAR3) external onlyAdmin {
 }
 function FUN3(address VAR4, uint256 VAR5) external {
 }
 function FUN4() public onlyAdmin {
 uint256 VAR6 = VAR7.FUN5(VAR8 , VAR9.VAR10);
 VAR11 = FUN6(uint256(VAR9.FUN7(VAR9.VAR12-1)), VAR6, VAR8);
 }

1",TP,3
22714.sol,"function FUN1(uint256 VAR1) public {
 require(VAR1 < VAR2);
 var VAR3 = VAR4[VAR1];
 uint256 VAR5 = FUN2(VAR3.VAR6, VAR3.VAR7);
 if (VAR8.VAR7 > VAR5){
 FUN3(VAR1);
 return;
 }
 else{
 revert();
 }
 }
 function FUN4(uint256 VAR1, string VAR9) public payable{
 require(VAR1 < VAR2);
 var VAR3 = VAR4[VAR1];
 if (VAR3.VAR10 != address(0) && VAR8.VAR7 > (FUN2(VAR3.VAR7, VAR3.VAR6))){
 FUN3(VAR1);
 if (msg.value > 0){
 msg.sender.transfer(msg.value);
 }
 return;
 }
 require(msg.value >= VAR3.VAR11);
 require(msg.sender != VAR10);
 require(msg.sender != VAR3.VAR10);
 uint256 VAR12 = FUN5(VAR3.VAR11, VAR13) / 10000;
 uint256 VAR14 = FUN5(VAR3.VAR11, VAR3.VAR15) / 10000;
 if (VAR3.VAR10 == address(0)){
 VAR16 = (FUN5(VAR3.VAR11, VAR3.VAR17)) / 10000;
 VAR3.VAR10.transfer(VAR16);
 VAR3.VAR18.transfer(VAR14);
 if (msg.value > VAR3.VAR11){
 msg.sender.transfer(FUN6(msg.value, VAR3.VAR11));
 uint256 VAR19 = FUN6(FUN6(FUN6(VAR3.VAR11, VAR12), VAR14), VAR16);
 VAR3.VAR20 = FUN2(VAR3.VAR20, VAR19);
 VAR3.VAR7 = VAR8.VAR7;
 VAR3.VAR10 = msg.sender;
 VAR3.VAR9 = VAR9;
 VAR3.VAR11 = (VAR3.VAR11 * (FUN2(10000, VAR3.VAR21)))/10000;
 emit FUN7(VAR1);
 }

1",TP,3
2321.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
2329.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
23665.sol,"function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1",TP,3
2374.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
2377.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
2379.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3((VAR3.VAR4).FUN4(VAR3.VAR5).FUN4((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4(VAR3.VAR8).FUN4((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4(VAR3.VAR9))));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
2383.sol,"function FUN1() public {
 }
 function FUN2(ERC20Basic VAR1) public view returns (uint256) {
 uint256 VAR2 = VAR1.FUN3(this);
 uint256 VAR3 = VAR2.FUN4(VAR4[VAR1]);
 if (VAR5.VAR6 < VAR7) {
 return 0;
 }
 else if (VAR5.VAR6 >= VAR8.FUN4(VAR9) || VAR10[VAR1]) {
 return VAR3;
 }
 else {
 return VAR3.FUN5(VAR5.VAR6.FUN6(VAR8)).FUN7(VAR9);
 }
 }

1",TP,3
2385.sol,"function FUN1() public {
 }
 function FUN2(ERC20Basic VAR1) public view returns (uint256) {
 uint256 VAR2 = VAR1.FUN3(this);
 uint256 VAR3 = VAR2.FUN4(VAR4[VAR1]);
 if (VAR5.VAR6 < VAR7) {
 return 0;
 }
 else if (VAR5.VAR6 >= VAR8.FUN4(VAR9) || VAR10[VAR1]) {
 return VAR3;
 }
 else {
 return VAR3.FUN5(VAR5.VAR6.FUN6(VAR8)).FUN7(VAR9);
 }
 }

1",TP,3
2387.sol,"modifier VAR1 {
 require(VAR2);
 VAR3;
 }
 modifier VAR4 {
 require(VAR5);
 VAR3;
 }
 function FUN1(address VAR6) public liquid canUseDirectDebit returns (bool) {
 uint256 VAR7 = (VAR8.VAR9.FUN2(VAR10.VAR11.VAR12) / VAR10.VAR11.VAR13).FUN3(1);
 uint256 VAR14 = VAR7.FUN2(VAR10.VAR7).FUN4(VAR10.VAR11.VAR14);
 VAR10.VAR7 = VAR7;
 }
 function FUN1(address[] VAR15, bool VAR16) public liquid canUseDirectDebit returns (bool VAR17) {
 uint256 VAR7 = (VAR8.VAR9.FUN2(VAR10.VAR11.VAR12) / VAR10.VAR11.VAR13).FUN3(1);
 uint256 VAR14 = VAR7.FUN2(VAR10.VAR7).FUN4(VAR10.VAR11.VAR14);
 VAR10.VAR7 = VAR7;
 }

1",TP,3
2388.sol,"modifier VAR1 {
 require(VAR2);
 VAR3;
 }
 modifier VAR4 {
 require(VAR5);
 VAR3;
 }
 function FUN1(address VAR6) public liquid canUseDirectDebit returns (bool) {
 uint256 VAR7 = (VAR8.VAR9.FUN2(VAR10.VAR11.VAR12) / VAR10.VAR11.VAR13).FUN3(1);
 uint256 VAR14 = VAR7.FUN2(VAR10.VAR7).FUN4(VAR10.VAR11.VAR14);
 VAR10.VAR7 = VAR7;
 }
 function FUN1(address[] VAR15, bool VAR16) public liquid canUseDirectDebit returns (bool VAR17) {
 uint256 VAR7 = (VAR8.VAR9.FUN2(VAR10.VAR11.VAR12) / VAR10.VAR11.VAR13).FUN3(1);
 uint256 VAR14 = VAR7.FUN2(VAR10.VAR7).FUN4(VAR10.VAR11.VAR14);
 VAR10.VAR7 = VAR7;
 }

1",TP,3
2389.sol,"modifier VAR1 {
 require(VAR2);
 VAR3;
 }
 modifier VAR4 {
 require(VAR5);
 VAR3;
 }
 function FUN1(address VAR6) public liquid canUseDirectDebit returns (bool) {
 uint256 VAR7 = (VAR8.VAR9.FUN2(VAR10.VAR11.VAR12) / VAR10.VAR11.VAR13).FUN3(1);
 uint256 VAR14 = VAR7.FUN2(VAR10.VAR7).FUN4(VAR10.VAR11.VAR14);
 VAR10.VAR7 = VAR7;
 }
 function FUN1(address[] VAR15, bool VAR16) public liquid canUseDirectDebit returns (bool VAR17) {
 uint256 VAR7 = (VAR8.VAR9.FUN2(VAR10.VAR11.VAR12) / VAR10.VAR11.VAR13).FUN3(1);
 uint256 VAR14 = VAR7.FUN2(VAR10.VAR7).FUN4(VAR10.VAR11.VAR14);
 VAR10.VAR7 = VAR7;
 }

1",TP,3
2391.sol,"function FUN1() private view returns (uint256) {
 }

1",TP,3
2397.sol,"function FUN1(address VAR1) internal returns (bool) {
 if (FUN2(VAR1)) {
 if (VAR2.VAR3>VAR4) {
 FUN3(VAR1);
 return true;
 }
 }
 function FUN4(address VAR1) public returns (uint256) {
 int256 VAR5 = (FUN5(VAR2.VAR3)-FUN5(VAR6[VAR1]))/(FUN5(VAR7));
 if (VAR5>VAR8) {
 VAR5=VAR8;
 if (VAR5>0) {
 int256 VAR9 = ((FUN5(VAR10[VAR1])*VAR5))/VAR8;
 }
 function FUN6(address VAR11, uint256 VAR12) internal returns (bool VAR13) {
 uint256 VAR14 = VAR2.VAR3;
 if (VAR14>VAR15) {
 }
 function FUN7(address VAR11) view public returns (bool VAR13) {
 uint256 VAR14 = VAR2.VAR3;
 if (VAR14>VAR15) {
 }
 function FUN8() public onlyOwner {
 VAR15 = VAR2.VAR3;
 VAR4 = VAR15 + VAR16*VAR7;
 VAR6[VAR17]=VAR15;
 VAR6[VAR18]=VAR15;
 VAR6[VAR19]=VAR15;
 }
 function FUN9() public {
 VAR20 = VAR2.VAR3;
 VAR21 = VAR2.VAR3 + VAR22[VAR23]*VAR24;
 }
 function FUN10() public {
 require (VAR25 == 0);
 VAR25 = VAR21.FUN11(VAR2.VAR3);
 }
 function FUN12() public {
 VAR21 = VAR2.VAR3.FUN13(VAR25);
 }
 function FUN14(address VAR26) public payable {
 }
 function FUN15(address VAR27) public {
 uint256 VAR28 = VAR2.VAR3;
 VAR29[0] = VAR28;
 VAR29[1] = VAR28;
 uint256 VAR30=VAR28 - VAR29[0];
 uint256 VAR31=VAR28 - VAR29[1];
 }

1",TP,3
2399.sol,"function FUN1(address VAR1) internal returns (bool) {
 if (FUN2(VAR1)) {
 if (VAR2.VAR3>VAR4) {
 FUN3(VAR1);
 return true;
 }
 }
 function FUN4(address VAR1) public returns (uint256) {
 int256 VAR5 = (FUN5(VAR2.VAR3)-FUN5(VAR6[VAR1]))/(FUN5(VAR7));
 if (VAR5>VAR8) {
 VAR5=VAR8;
 if (VAR5>0) {
 int256 VAR9 = ((FUN5(VAR10[VAR1])*VAR5))/VAR8;
 }
 function FUN6(address VAR11, uint256 VAR12) internal returns (bool VAR13) {
 uint256 VAR14 = VAR2.VAR3;
 if (VAR14>VAR15) {
 }
 function FUN7(address VAR11) view public returns (bool VAR13) {
 uint256 VAR14 = VAR2.VAR3;
 if (VAR14>VAR15) {
 }
 function FUN8() public onlyOwner {
 VAR15 = VAR2.VAR3;
 VAR4 = VAR15 + VAR16*VAR7;
 VAR6[VAR17]=VAR15;
 VAR6[VAR18]=VAR15;
 VAR6[VAR19]=VAR15;
 }

1",TP,3
2400.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
2405.sol,"function FUN1() private view returns (uint) {
 }

1",TP,3
2411.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
24200.sol,"function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1",TP,3
2437.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
24745.sol,"function FUN1(address VAR1, uint VAR2, uint VAR3) internal {
 }
 function FUN2() public view returns (VAR4) {
 if (VAR5) return VAR4.VAR6;
 else if (VAR7.VAR8 < VAR9) return VAR4.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR4.VAR12;
 else return VAR4.VAR13;
 }
 function FUN4(uint[] VAR14) public {
 }
 function FUN5(uint VAR15) private view returns (Tranche VAR16) {
 for (uint VAR17 = 0; VAR17 < VAR18.VAR19; VAR17++) {
 if (VAR18[VAR17].VAR2 <= VAR7.VAR8 && VAR7.VAR8 < VAR18[VAR17].VAR3 && VAR15 < VAR18[VAR17].VAR20) {
 return VAR18[VAR17];
 }
 }
 function FUN6(uint VAR21) public onlyOwner FUN7(VAR4.VAR10) {
 }
 function FUN8(uint VAR22) public onlyOwner VAR23 {
 }

1",TP,3
2506.sol,"function FUN1() private view returns (uint) {
 }

1",TP,3
25248.sol,"function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1",TP,3
25249.sol,"function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1",TP,3
2528.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
2530.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
2531.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
2541.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
2553.sol,"function FUN1() private view returns (uint) {
 }

1",TP,3
2563.sol,"function FUN1(address VAR1) public {
 VAR2 = VAR3.VAR4;
 VAR5 = VAR3.VAR4 + 60;
 VAR6 = VAR3.VAR4 + 120;
 }
 function FUN2() onlyPurchaseAdmin public returns(bool){
 }

1",TP,3
2575.sol,"function FUN1() internal returns(uint8){
 uint8 VAR1 = uint8(uint256(FUN2(VAR2.VAR3))%VAR4);
 return uint8(uint256(FUN2(VAR5[VAR1]))%VAR4);
 }

1",TP,3
2598.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
2599.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
2622.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
26498.sol,"function FUN1( ) public {
 VAR1 = VAR2.VAR3;
 }
 function FUN2() internal constant returns (uint) {
 }

1",TP,3
2655.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
2684.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
2688.sol,"function FUN1(uint256 VAR1) public {
 require(VAR2.VAR3 > VAR4.VAR5);
 VAR6.VAR5 = VAR2.VAR3.FUN2(VAR7);
 }
 function FUN3(uint256 VAR6, uint256 VAR8, uint256 VAR9) internal {
 Round memory VAR10 = VAR11[VAR12];
 if (VAR13[VAR8][VAR6].VAR14 == 0) {
 FUN4(VAR8);
 if (VAR2.VAR3 > VAR10.VAR5) {
 FUN1(VAR15[VAR8].VAR16);
 FUN4(VAR8);
 }
 Round storage VAR17 = VAR11[VAR12];
 VAR15[VAR8].VAR18 = VAR9.FUN2(VAR15[VAR8].VAR18);
 VAR17.VAR19 = VAR15[VAR8].VAR20;
 VAR17.VAR5 = VAR17.VAR5.FUN2(VAR21);
 if (VAR17.VAR5.FUN5(VAR2.VAR3) > VAR7) {
 VAR17.VAR5 = VAR2.VAR3.FUN2(VAR7);
 }
 VAR17.VAR22 = (VAR9.FUN6(VAR23) / 1000).FUN2(VAR17.VAR22);
 if (VAR17.VAR14 == 0) {
 VAR15[0].VAR18 = VAR24.FUN2(VAR15[0].VAR18);
 VAR17.VAR25 = VAR17.VAR25.FUN2((VAR9.FUN6(VAR26) / 1000) / VAR17.VAR14);
 uint256 VAR27 = (VAR9.FUN6(VAR26) / 1000).FUN5( VAR9.FUN6(VAR26) / 1000 / VAR17.VAR14 * VAR17.VAR14 );
 VAR15[0].VAR18 = VAR24.FUN2(VAR27).FUN2(VAR15[0].VAR18);
 VAR13[VAR8][VAR12].VAR14 = VAR28.FUN2(VAR13[VAR8][VAR12].VAR14);
 VAR17.VAR14 = VAR28.FUN2(VAR17.VAR14);
 VAR17.VAR29 = VAR9.FUN2(VAR17.VAR29);
 VAR13[VAR8][VAR12].VAR25 = VAR17.VAR25.FUN6(VAR28).FUN2(VAR13[VAR8][VAR12].VAR25);
 uint256 VAR30 = VAR15[VAR8].VAR16;
 uint256 VAR31 = VAR15[VAR30].VAR16;
 VAR15[VAR30].VAR32 = (VAR9.FUN6(VAR33) / 1000).FUN2(VAR15[VAR30].VAR32);
 VAR15[VAR31].VAR32 = (VAR9.FUN6(VAR34) / 1000).FUN2(VAR15[VAR31].VAR32);
 }
 function FUN7() public view returns (uint256) {
 if (VAR11[VAR12].VAR5 <= VAR2.VAR3) {
 return 0;
 }
 else {
 return VAR11[VAR12].VAR5 - VAR2.VAR3;
 }
 }

1",TP,3
2699.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
27078.sol,"function FUN1() public FUN2(VAR1, VAR2, VAR3) {
 VAR4 = VAR5.VAR6;
 }
 function FUN3() public view returns (uint) {
 }
 function FUN4() public onlyOwner {
 uint256 VAR7 = (VAR5.VAR6 - VAR4) / VAR8;
 if (VAR7 > VAR9) {
 VAR7 = VAR9;
 uint256 VAR10 = ((VAR9 - VAR7) * VAR11) * 10 ** uint256(VAR12);
 }

1",TP,3
27083.sol,"function FUN1() public FUN2(VAR1, VAR2, VAR3) {
 VAR4 = VAR5.VAR6;
 }
 function FUN3() public view returns (uint) {
 }
 function FUN4() public onlyOwner {
 uint256 VAR7 = (VAR5.VAR6 - VAR4) / VAR8;
 if (VAR7 > VAR9) {
 VAR7 = VAR9;
 uint256 VAR10 = ((VAR9 - VAR7) * VAR11) * 10 ** uint256(VAR12);
 }

1",TP,3
27225.sol,"function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1",TP,3
2723.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
2740.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
2745.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
2746.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
2750.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
2754.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
2757.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
2761.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
2763.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
2764.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
2772.sol,"function FUN1(uint256 VAR1, address sender) public view returns(bool) {
 uint256 VAR2 = uint256(FUN2(VAR3.FUN3( (VAR4.VAR5).FUN4 (VAR4.VAR6).FUN4 ((uint256(FUN2(VAR3.FUN3(VAR4.VAR7)))) / (VAR8)).FUN4 (VAR4.VAR9).FUN4 ((uint256(FUN2(VAR3.FUN3(sender)))) / (VAR8)).FUN4 (VAR4.VAR10) )));
 if((VAR2 - ((VAR2 / 1000) * 1000)) < VAR1) return(true);
 }

1",TP,3
2777.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3((VAR3.VAR4).FUN4(VAR3.VAR5).FUN4((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4(VAR3.VAR8).FUN4((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4(VAR3.VAR9))));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
2783.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
2792.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
2794.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
2797.sol,"modifier VAR1 {
 require(VAR2.VAR3 >= VAR4 && VAR2.VAR3 <= VAR5);
 VAR6;
 }
 function FUN1() public view returns (bool) {
 }

1",TP,3
28090.sol,"function FUN1() internal constant returns (uint256) {
 }

1",TP,3
28091.sol,"function FUN1() internal constant returns (uint256) {
 }

1",TP,3
28093.sol,"function FUN1() internal constant returns (uint256) {
 }
 function FUN1() internal constant returns (uint256) {
 }

1",TP,3
28218.sol,"function FUN1() internal constant returns (uint256) {
 }

1",TP,3
2823.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
2833.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
2839.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
2855.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
2861.sol,"function FUN1( address VAR1, uint256 VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5 ) public onlyOwner{
 }
 function FUN2(address VAR1) public view returns (uint256) {
 tokenToVest storage value = VAR6[VAR1];
 uint256 VAR7 = value.VAR8;
 if (VAR9.VAR10 < value.VAR11) {
 return 0;
 }
 else if (VAR9.VAR10 >= value.VAR12.FUN3(value.VAR13)) {
 return VAR7;
 }
 else {
 return VAR7.FUN4(VAR9.VAR10.FUN5(value.VAR12)).FUN6(value.VAR13);
 }
 }

1",TP,3
2876.sol,"function FUN1() private view returns (bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return (true);
 }

1",TP,3
28865.sol,"function FUN1(address VAR1, uint VAR2, uint VAR3) internal {
 }
 function FUN2() public view returns (VAR4) {
 if (VAR5) return VAR4.VAR6;
 else if (VAR7.VAR8 < VAR9) return VAR4.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR4.VAR12;
 else return VAR4.VAR13;
 }
 function FUN4(uint[] VAR14) public {
 }
 function FUN5(uint VAR15) private view returns (Tranche VAR16) {
 for (uint VAR17 = 0; VAR17 < VAR18.VAR19; VAR17++) {
 if (VAR18[VAR17].VAR2 <= VAR7.VAR8 && VAR7.VAR8 < VAR18[VAR17].VAR3 && VAR15 < VAR18[VAR17].VAR20) {
 return VAR18[VAR17];
 }
 }
 function FUN6(uint VAR21) public onlyOwner FUN7(VAR4.VAR10) {
 }
 function FUN8(uint VAR22) public onlyOwner VAR23 {
 }

1",TP,3
29090.sol,"function FUN1(address VAR1, uint VAR2, uint VAR3) internal {
 }
 function FUN2() public view returns (VAR4) {
 if (VAR5) return VAR4.VAR6;
 else if (VAR7.VAR8 < VAR9) return VAR4.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR4.VAR12;
 else return VAR4.VAR13;
 }
 function FUN4(uint[] VAR14) public {
 }
 function FUN5(uint VAR15) private view returns (Tranche VAR16) {
 for (uint VAR17 = 0; VAR17 < VAR18.VAR19; VAR17++) {
 if (VAR18[VAR17].VAR2 <= VAR7.VAR8 && VAR7.VAR8 < VAR18[VAR17].VAR3 && VAR15 < VAR18[VAR17].VAR20) {
 return VAR18[VAR17];
 }
 }
 function FUN6(uint VAR21) public onlyOwner FUN7(VAR4.VAR10) {
 }
 function FUN8(uint VAR22) public onlyOwner VAR23 {
 }

1",TP,3
29265.sol,"function FUN1(address VAR1, uint VAR2, uint VAR3) internal {
 }
 function FUN2() public view returns (VAR4) {
 if (VAR5) return VAR4.VAR6;
 else if (VAR7.VAR8 < VAR9) return VAR4.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR4.VAR12;
 else return VAR4.VAR13;
 }
 function FUN4(uint[] VAR14) public {
 }
 function FUN5(uint VAR15) private view returns (Tranche VAR16) {
 for (uint VAR17 = 0; VAR17 < VAR18.VAR19; VAR17++) {
 if (VAR18[VAR17].VAR2 <= VAR7.VAR8 && VAR7.VAR8 < VAR18[VAR17].VAR3 && VAR15 < VAR18[VAR17].VAR20) {
 return VAR18[VAR17];
 }
 }
 function FUN6(uint VAR21) public onlyOwner FUN7(VAR4.VAR10) {
 }
 function FUN8(uint VAR22) public onlyOwner VAR23 {
 }

1",TP,3
29282.sol,"function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }
 modifier FUN5(address VAR18){
 require(VAR19[VAR18].VAR20);
 VAR21;
 }
 modifier FUN6(address VAR22) {
 require(!VAR19[VAR22].VAR20);
 VAR21;
 }
 function FUN7(address VAR18, uint256 VAR23, uint256 VAR24, uint256 VAR25, uint256 VAR26, uint256 VAR27, bool VAR28) public FUN6(VAR18) VAR29 {
 if (VAR23 == 0) VAR23 = VAR7.VAR8;
 VAR30.VAR31 = VAR23;
 }
 function FUN8(address VAR18) public FUN5(VAR18) {
 uint256 VAR32 = VAR7.VAR8 - VAR30.VAR31;
 uint256 VAR33 = VAR32 / VAR30.VAR34;
 }

1",TP,3
2941.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
2947.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
2949.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
2954.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
2989.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
2991.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
2995.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
3050.sol,"function FUN1() private returns(uint256,uint256,address) {
 uint256 VAR1 = 0;
 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4) + (VAR3.VAR5) + ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)) + (VAR3.VAR8) + ((uint256(FUN2(VAR2.FUN3(VAR9)))) / (VAR7)) + (VAR3.VAR10) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) >= VAR11) {
 }

1",TP,3
3051.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
3057.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
3071.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
30763.sol,"function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1",TP,3
30765.sol,"function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1",TP,3
3090.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
3096.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
3097.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
3103.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
3106.sol,"function FUN1() private returns(uint256,uint256,address) {
 uint256 VAR1 = 0;
 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4) + (VAR3.VAR5) + ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)) + (VAR3.VAR8) + ((uint256(FUN2(VAR2.FUN3(VAR9)))) / (VAR7)) + (VAR3.VAR10) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) >= VAR11) {
 }

1",TP,3
3108.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
3109.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
31099.sol,"function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1",TP,3
31103.sol,"function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1",TP,3
3113.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
3125.sol,"function FUN1() private view returns (uint8) {
 }

1",TP,3
3126.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
3127.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
3137.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
31450.sol,"function FUN1() public view returns (uint) {
 }
 function FUN1() public constant returns (uint) {
 }
 function FUN1() public view returns (uint) {
 }

1",TP,3
31480.sol,"function FUN1() public view returns (uint) {
 }
 function FUN1() public constant returns (uint) {
 }
 function FUN1() public view returns (uint) {
 }

1",TP,3
31506.sol,"function FUN1() public view returns (uint) {
 }
 function FUN1() public constant returns (uint) {
 }
 function FUN1() public view returns (uint) {
 }

1",TP,3
31507.sol,"function FUN1() public view returns (uint) {
 }
 function FUN1() public constant returns (uint) {
 }
 function FUN1() public view returns (uint) {
 }

1",TP,3
31508.sol,"function FUN1() public view returns (uint) {
 }
 function FUN1() public constant returns (uint) {
 }
 function FUN1() public view returns (uint) {
 }

1",TP,3
31509.sol,"function FUN1() public view returns (uint) {
 }
 function FUN1() public constant returns (uint) {
 }
 function FUN1() public view returns (uint) {
 }

1",TP,3
31510.sol,"function FUN1() public view returns (uint) {
 }
 function FUN1() public constant returns (uint) {
 }
 function FUN1() public view returns (uint) {
 }

1",TP,3
31511.sol,"function FUN1() public view returns (uint) {
 }
 function FUN1() public constant returns (uint) {
 }
 function FUN1() public view returns (uint) {
 }

1",TP,3
31512.sol,"function FUN1() public view returns (uint) {
 }
 function FUN1() public constant returns (uint) {
 }
 function FUN1() public view returns (uint) {
 }

1",TP,3
31514.sol,"function FUN1() public view returns (uint) {
 }
 function FUN1() public constant returns (uint) {
 }
 function FUN1() public view returns (uint) {
 }

1",TP,3
31515.sol,"function FUN1() public view returns (uint) {
 }
 function FUN1() public constant returns (uint) {
 }
 function FUN1() public view returns (uint) {
 }

1",TP,3
31517.sol,"function FUN1() public view returns (uint) {
 }
 function FUN1() public constant returns (uint) {
 }
 function FUN1() public view returns (uint) {
 }

1",TP,3
31518.sol,"function FUN1() public view returns (uint) {
 }
 function FUN1() public constant returns (uint) {
 }
 function FUN1() public view returns (uint) {
 }

1",TP,3
31519.sol,"function FUN1() public view returns (uint) {
 }
 function FUN1() public constant returns (uint) {
 }
 function FUN1() public view returns (uint) {
 }

1",TP,3
31520.sol,"function FUN1() public view returns (uint) {
 }
 function FUN1() public constant returns (uint) {
 }
 function FUN1() public view returns (uint) {
 }

1",TP,3
31521.sol,"function FUN1() public view returns (uint) {
 }
 function FUN1() public constant returns (uint) {
 }
 function FUN1() public view returns (uint) {
 }

1",TP,3
3158.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
3168.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
3174.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
31786.sol,"function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1",TP,3
31787.sol,"function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1",TP,3
31792.sol,"function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1",TP,3
31821.sol,"function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1",TP,3
31823.sol,"function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1",TP,3
31893.sol,"function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1",TP,3
3190.sol,"function FUN1(bytes32 VAR1) internal view returns (uint16) {
 }

1",TP,3
31948.sol,"function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1",TP,3
31957.sol,"function FUN1() constant returns (uint) {
 }

1",TP,3
31958.sol,"function FUN1() constant returns (uint) {
 }

1",TP,3
31964.sol,"function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1",TP,3
31967.sol,"function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1",TP,3
31982.sol,"function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1",TP,3
31985.sol,"function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1",TP,3
31987.sol,"function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1",TP,3
3199.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
31993.sol,"function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1",TP,3
3204.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
3207.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
3217.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
3222.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
3228.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
32296.sol,"function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1",TP,3
3240.sol,"function FUN1() public {
 }
 function FUN2(ERC20Basic VAR1) public view returns (uint256) {
 uint256 VAR2 = VAR1.FUN3(this);
 uint256 VAR3 = VAR2.FUN4(VAR4[VAR1]);
 if (VAR5.VAR6 < VAR7) {
 return 0;
 }
 else if (VAR5.VAR6 >= VAR8.FUN4(VAR9) || VAR10[VAR1]) {
 return VAR3;
 }
 else {
 return VAR3.FUN5(VAR5.VAR6.FUN6(VAR8)).FUN7(VAR9);
 }
 }

1",TP,3
3248.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
3254.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
3255.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
3256.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
3266.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
3269.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
32723.sol,"function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1",TP,3
32736.sol,"function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1",TP,3
3281.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
3286.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
3302.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
3305.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
3314.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
3315.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
3316.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
3318.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
3323.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
3330.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
33348.sol,"function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1",TP,3
33351.sol,"function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1",TP,3
33353.sol,"function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1",TP,3
33395.sol,"function FUN1(address VAR1, uint VAR2, uint VAR3) internal {
 }
 function FUN2() public constant returns (VAR4) {
 if (VAR5) return VAR4.VAR6;
 else if (VAR7.VAR8 < VAR9) return VAR4.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR4.VAR12;
 else return VAR4.VAR13;
 }
 function FUN4(uint[] VAR14) public {
 }
 function FUN5(uint VAR15) private constant returns (Tranche VAR16) {
 for (uint VAR17 = 0; VAR17 < VAR18.VAR19; VAR17++) {
 if (VAR18[VAR17].VAR2 <= VAR7.VAR8 && VAR7.VAR8 < VAR18[VAR17].VAR3 && VAR15 < VAR18[VAR17].VAR20) {
 return VAR18[VAR17];
 }
 }
 function FUN6(uint VAR21) public onlyOwner FUN7(VAR4.VAR10) {
 }
 function FUN8(uint VAR22) public onlyOwner VAR23 {
 }

1",TP,3
3347.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
3350.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
3363.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
3364.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
3371.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
33765.sol,"function FUN1() internal constant returns (uint256) {
 }
 function FUN1() internal constant returns (uint256) {
 }

1",TP,3
33768.sol,"function FUN1() internal constant returns (uint256) {
 }

1",TP,3
33770.sol,"function FUN1() internal constant returns (uint256) {
 }

1",TP,3
33782.sol,"function FUN1() internal constant returns (uint256) {
 }

1",TP,3
33784.sol,"function FUN1() internal constant returns (uint256) {
 }

1",TP,3
3383.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
3394.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
33962.sol,"function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1",TP,3
33965.sol,"function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1",TP,3
33971.sol,"function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1",TP,3
34088.sol,"function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1",TP,3
34143.sol,"function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1",TP,3
34144.sol,"function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1",TP,3
34148.sol,"function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1",TP,3
34393.sol,"function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1",TP,3
3455.sol,"function FUN1() private view returns(bool) {
 uint256 VAR1 = uint256(FUN2(VAR2.FUN3( (VAR3.VAR4).FUN4 (VAR3.VAR5).FUN4 ((uint256(FUN2(VAR2.FUN3(VAR3.VAR6)))) / (VAR7)).FUN4 (VAR3.VAR8).FUN4 ((uint256(FUN2(VAR2.FUN3(msg.sender)))) / (VAR7)).FUN4 (VAR3.VAR9) )));
 if((VAR1 - ((VAR1 / 1000) * 1000)) < VAR10) return(true);
 }

1",TP,3
34622.sol,"function FUN1() public constant returns (VAR1) {
 if(VAR2) return VAR1.VAR3;
 else if (address(VAR4) == 0) return VAR1.VAR5;
 else if (!VAR4.FUN2()) return VAR1.VAR5;
 else if (!VAR6.FUN2(address(this))) return VAR1.VAR5;
 else if (VAR7.VAR8 < VAR9) return VAR1.VAR10;
 else if (VAR7.VAR8 <= VAR11 && !FUN3()) return VAR1.VAR12;
 else if (FUN4()) return VAR1.VAR13;
 else if (!FUN4() && VAR14 > 0 && VAR15 >= VAR14) return VAR1.VAR16;
 else return VAR1.VAR17;
 }

1",TP,3
0.sol,"function() notLock payable public{
require(msg.sender == VAR1.VAR2, """");
require(FUN1(msg.sender),"""");
require(msg.value == VAR3.VAR4,"""");
VAR5 = VAR5 + msg.value;
VAR6.FUN2(msg.sender);
emit FUN3(VAR7,msg.sender);
if(VAR6.VAR8 >= VAR3.VAR9) {
FUN4();
FUN5();
}
}
}",TO,4
10103.sol,"function FUN1() public payable {
address VAR1 = msg.sender;
require( !VAR2[VAR1] && VAR3.VAR4 == VAR1);
require(VAR5.FUN2(VAR1, address(this), VAR6));
VAR7 = VAR8.FUN3(VAR7, 1);
VAR2[VAR1] = true;
VAR9[VAR1] = 0;
VAR10.FUN4(VAR1);
require(VAR2[VAR1]);
VAR11 = VAR11.FUN5(VAR12);
VAR13 = VAR13.FUN5(VAR14);
VAR15 = VAR15.FUN5(VAR14);
emit FUN6(VAR1);
}",TO,4
10121.sol,"function FUN1( bytes VAR1, bytes VAR2 ) external onlyLighthouse returns (RobotLiability VAR3) {
uint256 VAR4 = FUN2();
VAR3 = VAR5 FUN3(VAR6);
emit FUN4(VAR3);
require(VAR3.call(VAR7.FUN5(bytes4(0x82fbaa25), VAR1)));
FUN6(VAR3.FUN7());
require(VAR3.call(VAR7.FUN5(bytes4(0x66193359), VAR2)));
FUN6(VAR3.FUN8());
require(VAR8.FUN9(VAR3.FUN10(), VAR9.VAR10, VAR3.FUN11()));
ERC20 VAR11 = VAR3.FUN12();
require(VAR11.FUN9(VAR3.FUN13(), VAR3, VAR3.FUN14()));
if (address(VAR3.FUN15()) != 0 && VAR3.FUN16() > 0) require(VAR8.FUN9(VAR3.FUN13(), VAR3, VAR3.FUN16()));
uint256 VAR12 = VAR4 - FUN2() + 110525;
VAR13 += VAR12;
VAR14[VAR3] += VAR12;
}
function FUN17( uint256 VAR15 ) external returns (bool) {
require(VAR14[msg.sender] > 0);
uint256 VAR12 = VAR15 - FUN2();
VAR13 += VAR12;
VAR14[msg.sender] += VAR12;
require(VAR8.FUN18(VAR9.VAR10, FUN19(VAR14[msg.sender])));
return true;
}
}",TO,4
10123.sol,"function FUN1(uint8 VAR1, address VAR2) payable external VAR3 {
require(VAR1 > 0 && VAR1 <= 100, """");
require(msg.value > 0, """");
require(msg.sender == VAR4.VAR5, """");
FUN2(msg.value, VAR1, msg.sender, VAR2);
}
function FUN3(uint256 VAR6, address VAR7) external {
require(VAR8 > 0, """");
require(msg.sender == VAR4.VAR5, """");
address VAR9;
uint256 VAR10;
bool VAR11;
(VAR10,VAR9,,VAR11) = VAR12.FUN4(VAR6);
require(VAR11, """");
require(VAR10 == VAR8, """");
require(VAR9 == VAR7, """");
VAR13 = VAR7;
}
function FUN5(address VAR14, address VAR15, uint VAR16) public returns (bool VAR17);
event Transfer(address indexed VAR14, address indexed VAR15, uint VAR16);
event FUN6(address indexed VAR18, address indexed VAR19, uint VAR16);
}
contract PlayerToken is VAR20 {
address public VAR21;
bool public VAR22 = false;
event FUN7(address indexed VAR23, address indexed VAR24, uint VAR16, uint VAR25, string VAR26);
event FUN8(address indexed VAR27, uint VAR16, uint value, string VAR26);
using SafeMath for uint256;
uint256 public VAR28;
uint256 public VAR29;
string public VAR30;
string public VAR26;
uint8 public constant VAR31 = 0;
address public VAR32;
BCFMain VAR12 = FUN9(0x6abF810730a342ADD1374e11F3e97500EE774D1F);
uint256 public VAR8;
address public VAR13;
uint8 constant internal VAR33 = 5;
uint8 constant internal VAR34 = 2;
uint8 internal VAR35 = 15;
uint8 internal VAR36 = 20;
uint8 constant internal VAR37 = 1;
FUN10(address => uint256) VAR38;
FUN10(address => FUN10 (address => uint256)) internal VAR39;
address[] public VAR40;
FUN10(address => uint256) public VAR41;
FUN10(address => VAR42) public VAR43;
uint256 VAR44;
modifier onlyOwner() {
require(msg.sender == VAR21);
VAR45;
}
modifier FUN11() {
require(msg.sender == VAR21 || msg.sender == VAR32);
VAR45;
}
modifier FUN12() {
require(!VAR22);
VAR45;
}
modifier FUN13() {
require(VAR22);
VAR45;
}
constructor( string VAR46, string VAR47, uint VAR48, uint VAR49, address VAR50, address VAR51, uint256 VAR10, uint8 VAR52 ) public payable {
require(VAR51 != address(0));
require(VAR50 != address(0));
VAR32 = VAR51;
VAR8 = VAR10;
VAR28 = VAR48;
VAR29 = VAR49;
VAR22 = true;
VAR21 = VAR50;
VAR30 = VAR46;
VAR26 = VAR47;
if (VAR52 > 0) {
FUN2(msg.value, VAR52, VAR50, address(0));
}
}
function FUN5(address VAR14, address VAR15, uint VAR16) public returns (bool VAR17);
event Transfer(address indexed VAR14, address indexed VAR15, uint VAR16);
event FUN6(address indexed VAR18, address indexed VAR19, uint VAR16);
}
contract PlayerToken is VAR20 {
address public VAR21;
bool public VAR22 = false;
event FUN7(address indexed VAR23, address indexed VAR24, uint VAR16, uint VAR25, string VAR26);
event FUN8(address indexed VAR27, uint VAR16, uint value, string VAR26);
using SafeMath for uint256;
uint256 public VAR28;
uint256 public VAR29;
string public VAR30;
string public VAR26;
uint8 public constant VAR31 = 0;
address public VAR32;
BCFMain VAR12 = FUN9(0x6abF810730a342ADD1374e11F3e97500EE774D1F);
uint256 public VAR8;
address public VAR13;
uint8 constant internal VAR33 = 5;
uint8 constant internal VAR34 = 2;
uint8 internal VAR35 = 15;
uint8 internal VAR36 = 20;
uint8 constant internal VAR37 = 1;
FUN10(address => uint256) VAR38;
FUN10(address => FUN10 (address => uint256)) internal VAR39;
address[] public VAR40;
FUN10(address => uint256) public VAR41;
FUN10(address => VAR42) public VAR43;
uint256 VAR44;
modifier onlyOwner() {
require(msg.sender == VAR21);
VAR45;
}
modifier FUN11() {
require(msg.sender == VAR21 || msg.sender == VAR32);
VAR45;
}
modifier FUN12() {
require(!VAR22);
VAR45;
}
modifier FUN13() {
require(VAR22);
VAR45;
}
constructor( string VAR46, string VAR47, uint VAR48, uint VAR49, address VAR50, address VAR51, uint256 VAR10, uint8 VAR52 ) public payable {
require(VAR51 != address(0));
require(VAR50 != address(0));
VAR32 = VAR51;
VAR8 = VAR10;
VAR28 = VAR48;
VAR29 = VAR49;
VAR22 = true;
VAR21 = VAR50;
VAR30 = VAR46;
VAR26 = VAR47;
if (VAR52 > 0) {
FUN2(msg.value, VAR52, VAR50, address(0));
}
}",TO,4
10131.sol,"function FUN1(uint256 VAR1, uint8 VAR2) public returns (bool) {
if(VAR3 !=VAR2) {
FUN2('');
return false;
}
if (msg.sender != VAR4 || VAR5.VAR6 != VAR7) {
FUN2('');
return false;
}
if (VAR8[this]<VAR1) {
FUN2('');
return false;
}
bool VAR9 = VAR10.transfer(VAR4, VAR1);
if(VAR9) {
VAR8[this] = VAR8[this].FUN3(VAR1);
VAR3++;
emit FUN4(VAR4, VAR1);
}
return VAR9;
}
function FUN5(address VAR11, uint256 VAR1) public notTimeLocked stopInEmergency returns (bool VAR9) {
if (VAR5.VAR6 != VAR11) {
FUN2('');
return false;
}
if (VAR4 != msg.sender) {
FUN2('');
return false;
}
if (VAR12[VAR11] < VAR1) {
FUN2('');
return false;
}
if(!VAR13.FUN6(VAR11, VAR4, VAR1)) {
FUN2('');
return false;
}
VAR12[VAR11] = VAR12[VAR11].FUN3(VAR1);
VAR12[VAR4] = VAR12[VAR4].FUN7(VAR1);
emit Transfer(VAR11, VAR4, VAR1);
return true;
}
function FUN5(address VAR11, uint256 VAR1) public notTimeLocked stopInEmergency returns (bool VAR9) {
if (VAR5.VAR6 != VAR11) {
FUN2('');
return false;
}
if (VAR4 != msg.sender) {
FUN2('');
return false;
}
if (VAR12[VAR11] < VAR1) {
FUN2('');
return false;
}
if(!VAR13.FUN6(VAR11, VAR4, VAR1)) {
FUN2('');
return false;
}
VAR12[VAR11] = VAR12[VAR11].FUN3(VAR1);
VAR12[VAR4] = VAR12[VAR4].FUN7(VAR1);
emit Transfer(VAR11, VAR4, VAR1);
return true;
}",TO,4
10133.sol,"function FUN1(uint256 VAR1, uint8 VAR2) public returns (bool) {
if(VAR3 !=VAR2) {
FUN2('');
return false;
}
if (msg.sender != VAR4 || VAR5.VAR6 != VAR7) {
FUN2('');
return false;
}
if (VAR8[this]<VAR1) {
FUN2('');
return false;
}
bool VAR9 = VAR10.transfer(VAR4, VAR1);
if(VAR9) {
VAR8[this] = VAR8[this].FUN3(VAR1);
VAR3++;
emit FUN4(VAR4, VAR1);
}
return VAR9;
}
function FUN5(address VAR11, uint256 VAR1) public notTimeLocked stopInEmergency returns (bool VAR9) {
if (VAR5.VAR6 != VAR11) {
FUN2('');
return false;
}
if (VAR4 != msg.sender) {
FUN2('');
return false;
}
if (VAR12[VAR11] < VAR1) {
FUN2('');
return false;
}
if(!VAR13.FUN6(VAR11, VAR4, VAR1)) {
FUN2('');
return false;
}
VAR12[VAR11] = VAR12[VAR11].FUN3(VAR1);
VAR12[VAR4] = VAR12[VAR4].FUN7(VAR1);
emit Transfer(VAR11, VAR4, VAR1);
return true;
}
function FUN5(address VAR11, uint256 VAR1) public notTimeLocked stopInEmergency returns (bool VAR9) {
if (VAR5.VAR6 != VAR11) {
FUN2('');
return false;
}
if (VAR4 != msg.sender) {
FUN2('');
return false;
}
if (VAR12[VAR11] < VAR1) {
FUN2('');
return false;
}
if(!VAR13.FUN6(VAR11, VAR4, VAR1)) {
FUN2('');
return false;
}
VAR12[VAR11] = VAR12[VAR11].FUN3(VAR1);
VAR12[VAR4] = VAR12[VAR4].FUN7(VAR1);
emit Transfer(VAR11, VAR4, VAR1);
return true;
}",TO,4
10140.sol,"function FUN1( bytes VAR1, bytes VAR2 ) external onlyLighthouse returns (RobotLiability VAR3) {
uint256 VAR4 = FUN2();
VAR3 = VAR5 FUN3(VAR6);
emit FUN4(VAR3);
require(VAR3.call(VAR7.FUN5(bytes4(0x82fbaa25), VAR1)));
FUN6(VAR3.FUN7());
require(VAR3.call(VAR7.FUN5(bytes4(0x66193359), VAR2)));
FUN6(VAR3.FUN8());
require(VAR8.FUN9(VAR3.FUN10(), VAR9.VAR10, VAR3.FUN11()));
ERC20 VAR11 = VAR3.FUN12();
require(VAR11.FUN9(VAR3.FUN13(), VAR3, VAR3.FUN14()));
if (address(VAR3.FUN15()) != 0 && VAR3.FUN16() > 0) require(VAR8.FUN9(VAR3.FUN13(), VAR3, VAR3.FUN16()));
uint256 VAR12 = VAR4 - FUN2() + 110525;
VAR13 += VAR12;
VAR14[VAR3] += VAR12;
}
function FUN17( uint256 VAR15 ) external returns (bool) {
require(VAR14[msg.sender] > 0);
uint256 VAR12 = VAR15 - FUN2();
VAR13 += VAR12;
VAR14[msg.sender] += VAR12;
require(VAR8.FUN18(VAR9.VAR10, FUN19(VAR14[msg.sender])));
return true;
}
}",TO,4
10143.sol,"function FUN1( bytes VAR1, bytes VAR2 ) external onlyLighthouse returns (RobotLiability VAR3) {
uint256 VAR4 = FUN2();
VAR3 = VAR5 FUN3(VAR6);
emit FUN4(VAR3);
require(VAR3.call(VAR7.FUN5(bytes4(0x82fbaa25), VAR1)));
FUN6(VAR3.FUN7());
require(VAR3.call(VAR7.FUN5(bytes4(0x66193359), VAR2)));
FUN6(VAR3.FUN8());
require(VAR8.FUN9(VAR3.FUN10(), VAR9.VAR10, VAR3.FUN11()));
ERC20 VAR11 = VAR3.FUN12();
require(VAR11.FUN9(VAR3.FUN13(), VAR3, VAR3.FUN14()));
if (address(VAR3.FUN15()) != 0 && VAR3.FUN16() > 0) require(VAR8.FUN9(VAR3.FUN13(), VAR3, VAR3.FUN16()));
uint256 VAR12 = VAR4 - FUN2() + 110525;
VAR13 += VAR12;
VAR14[VAR3] += VAR12;
}
function FUN17( uint256 VAR15 ) external returns (bool) {
require(VAR14[msg.sender] > 0);
uint256 VAR12 = VAR15 - FUN2();
VAR13 += VAR12;
VAR14[msg.sender] += VAR12;
require(VAR8.FUN18(VAR9.VAR10, FUN19(VAR14[msg.sender])));
return true;
}
}",TO,4
1034.sol,"modifier FUN1() {
require (msg.sender == VAR1.VAR2);
VAR3;
}",TO,4
10386.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;",TO,4
10409.sol,"function FUN1( address VAR1, string VAR2, uint256 VAR3, string VAR4) FUN2(VAR1) public {
require(VAR5.VAR6 != msg.sender);
FUN3(VAR5.VAR6);
VAR7 = VAR2;
VAR8 = VAR3;
VAR9 = VAR4;
}
}
pragma VAR10 ^0.4.21;
contract DatasetHub is VAR11 {
using SafeMathOZ for uint256;
FUN4(address => uint256) VAR12;
FUN4(address => FUN4(uint256 => address)) VAR13;
FUN4(address => bool) VAR14;
FUN4(uint256 => address) VAR15;
uint256 public VAR16;
function FUN1( address VAR1, string VAR2, uint256 VAR3, string VAR4) FUN2(VAR1) public {
require(VAR5.VAR6 != msg.sender);
FUN3(VAR5.VAR6);
VAR7 = VAR2;
VAR8 = VAR3;
VAR9 = VAR4;
}
}
pragma VAR10 ^0.4.21;
contract DatasetHub is VAR11 {
using SafeMathOZ for uint256;
FUN4(address => uint256) VAR12;
FUN4(address => FUN4(uint256 => address)) VAR13;
FUN4(address => bool) VAR14;
FUN4(uint256 => address) VAR15;
uint256 public VAR16;
function FUN5( string VAR2, uint256 VAR3, string VAR4) public onlyOwner returns (address VAR17) {
address VAR18 = VAR19 FUN1( msg.sender, VAR2, VAR3, VAR4 );
FUN6(VAR5.VAR6, VAR18);
return VAR18;
}
}",TO,4
10410.sol,"function FUN1(address VAR1,string VAR2, string VAR3, string VAR4) public {
require(VAR5.FUN2(VAR1));
require(!FUN3(VAR1));
VAR6[VAR1] = true;
require(FUN4(VAR1).FUN5() == VAR7.VAR8.VAR9);
require(FUN4(VAR1).FUN6() == FUN7(VAR2,VAR3,VAR4));
address VAR10 =FUN4(VAR1).FUN8();
require(VAR10 != address(0));
require(FUN9(VAR10).FUN1( VAR1, VAR2, VAR3, VAR4 ));
emit FUN10(VAR1,FUN4(VAR1).FUN11(),FUN4(VAR1).FUN12(),VAR10,VAR11.VAR12,VAR2,VAR3,VAR4);
}
}
pragma VAR13 ^0.4.21;
contract App is VAR14, VAR15 {
string public VAR16;
uint256 public VAR17;
string public VAR18;
function FUN13( address VAR19, string VAR20, uint256 VAR21, string VAR22) FUN14(VAR19) public {
require(VAR11.VAR12 != msg.sender);
FUN15(VAR11.VAR12);
VAR16 = VAR20;
VAR17 = VAR21;
VAR18 = VAR22;
}
}
pragma VAR13 ^0.4.21;
contract AppHub is VAR14 {
using SafeMathOZ for uint256;
FUN16(address => uint256) VAR23;
FUN16(address => FUN16(uint256 => address)) VAR24;
FUN16(address => bool) VAR25;
FUN16(uint256 => address) VAR26;
uint256 public VAR27;
function FUN13( address VAR19, string VAR20, uint256 VAR21, string VAR22) FUN14(VAR19) public {
require(VAR11.VAR12 != msg.sender);
FUN15(VAR11.VAR12);
VAR16 = VAR20;
VAR17 = VAR21;
VAR18 = VAR22;
}
}
pragma VAR13 ^0.4.21;
contract AppHub is VAR14 {
using SafeMathOZ for uint256;
FUN16(address => uint256) VAR23;
FUN16(address => FUN16(uint256 => address)) VAR24;
FUN16(address => bool) VAR25;
FUN16(uint256 => address) VAR26;
uint256 public VAR27;
function FUN17( string VAR20, uint256 VAR21, string VAR22) public onlyOwner returns (address VAR28) {
address VAR29 = VAR30 FUN13( msg.sender, VAR20, VAR21, VAR22 );
FUN18(VAR11.VAR12, VAR29);
return VAR29;
}
}
pragma VAR13 ^0.4.21;
contract Dataset is VAR14, VAR15 {
string public VAR31;
uint256 public VAR32;
string public VAR33;
function FUN19( address VAR19, string VAR34, uint256 VAR35, string VAR36) FUN14(VAR19) public {
require(VAR11.VAR12 != msg.sender);
FUN15(VAR11.VAR12);
VAR31 = VAR34;
VAR32 = VAR35;
VAR33 = VAR36;
}
}
pragma VAR13 ^0.4.21;
contract DatasetHub is VAR14 {
using SafeMathOZ for uint256;
FUN16(address => uint256) VAR37;
FUN16(address => FUN16(uint256 => address)) VAR38;
FUN16(address => bool) VAR39;
FUN16(uint256 => address) VAR40;
uint256 public VAR41;
function FUN19( address VAR19, string VAR34, uint256 VAR35, string VAR36) FUN14(VAR19) public {
require(VAR11.VAR12 != msg.sender);
FUN15(VAR11.VAR12);
VAR31 = VAR34;
VAR32 = VAR35;
VAR33 = VAR36;
}
}
pragma VAR13 ^0.4.21;
contract DatasetHub is VAR14 {
using SafeMathOZ for uint256;
FUN16(address => uint256) VAR37;
FUN16(address => FUN16(uint256 => address)) VAR38;
FUN16(address => bool) VAR39;
FUN16(uint256 => address) VAR40;
uint256 public VAR41;
function FUN20( string VAR34, uint256 VAR35, string VAR36) public onlyOwner returns (address VAR42) {
address VAR43 = VAR30 FUN19( msg.sender, VAR34, VAR35, VAR36 );
FUN21(VAR11.VAR12, VAR43);
return VAR43;
}
}
pragma VAR13 ^0.4.21;
contract VAR44 {
using SafeMathOZ for uint256;
RLC public VAR45;
uint256 public constant VAR46 = 10;
uint256 public constant VAR47 = 1000;
uint256 public constant VAR48 = 50;
AppHub public VAR49;
DatasetHub public VAR50;
WorkerPoolHub public VAR51;
Marketplace public VAR52;
modifier FUN22() {
require(msg.sender == address(VAR52));
VAR53;
}
FUN16(uint256 => VAR7.VAR54) public VAR55;
uint256 public VAR56;
address public VAR57;
modifier FUN23() {
require(msg.sender == VAR57);
VAR53;
}
FUN16(address => VAR7.VAR58) public VAR59;
FUN16(address => bool) public VAR60;
modifier FUN24(address VAR1) {
require(VAR60[VAR1]);
VAR53;
}
FUN16(address => uint256) public VAR61;
VAR7.ContributionHistory public VAR62;
event FUN25(address VAR63, address indexed VAR64);
event FUN26 (address VAR63, address VAR64);
event FUN27(address VAR63, address VAR64);
event FUN28 (address indexed VAR65, address indexed VAR66, string VAR67, uint256 VAR68, string VAR69 );
event FUN29 (address indexed VAR70, address indexed VAR71, string VAR72, uint256 VAR73, string VAR74);
event FUN30(address indexed VAR75, address indexed VAR64, string VAR76 );
event FUN31 (uint256 VAR77, string VAR78, string VAR79, uint256 VAR80);
event FUN32 (address indexed VAR64, address VAR81);
event FUN33(address indexed VAR64, address VAR81);
event FUN34 (address indexed VAR64, address VAR81);
event FUN35(address VAR63, address indexed VAR81);
event FUN36 (address VAR63, address indexed VAR81);
event FUN37 (address VAR82, uint256 VAR83);
event FUN38(address VAR82, uint256 VAR83);
event FUN39 (address VAR84, uint256 VAR83);
event FUN40 (address VAR84, uint256 VAR83);
function FUN41( string VAR85, uint256 VAR86, uint256 VAR87, uint256 VAR88) external returns (address VAR89) {
address VAR90 = VAR51.FUN41( VAR85, VAR86, VAR87, VAR88, address(VAR52) );
emit FUN30(VAR11.VAR12, VAR90, VAR85);
return VAR90;
}
function FUN17( string VAR20, uint256 VAR21, string VAR22) external returns (address VAR28) {
address VAR29 = VAR49.FUN17( VAR20, VAR21, VAR22 );
emit FUN28(VAR11.VAR12, VAR29, VAR20, VAR21, VAR22);
return VAR29;
}
function FUN20( string VAR34, uint256 VAR35, string VAR36) external returns (address VAR42) {
address VAR43 = VAR50.FUN20( VAR34, VAR35, VAR36 );
emit FUN29(VAR11.VAR12, VAR43, VAR34, VAR35, VAR36);
return VAR43;
}
function FUN42( address VAR19, string VAR85, uint256 VAR86, uint256 VAR87, uint256 VAR88, address VAR91) FUN14(VAR19) FUN43(VAR91) public {
require(VAR11.VAR12 != msg.sender);
FUN15(VAR11.VAR12);
VAR92 = VAR85;
VAR93 = 30;
VAR94 = 1;
VAR95 = VAR86;
VAR96 = VAR87;
VAR97 = VAR88;
VAR98 = msg.sender;
}
function FUN42( address VAR19, string VAR85, uint256 VAR86, uint256 VAR87, uint256 VAR88, address VAR91) FUN14(VAR19) FUN43(VAR91) public {
require(VAR11.VAR12 != msg.sender);
FUN15(VAR11.VAR12);
VAR92 = VAR85;
VAR93 = 30;
VAR94 = 1;
VAR95 = VAR86;
VAR96 = VAR87;
VAR97 = VAR88;
VAR98 = msg.sender;
}
function FUN41( string VAR85, uint256 VAR86, uint256 VAR87, uint256 VAR88, address VAR91) external onlyOwner returns (address VAR89) {
address VAR90 = VAR30 FUN42( msg.sender, VAR85, VAR86, VAR87, VAR88, VAR91 );
FUN44(VAR11.VAR12, VAR90);
return VAR90;
}",TO,4
10412.sol,"function FUN1( address VAR1, string VAR2, uint256 VAR3, string VAR4) FUN2(VAR1) public {
require(VAR5.VAR6 != msg.sender);
FUN3(VAR5.VAR6);
VAR7 = VAR2;
VAR8 = VAR3;
VAR9 = VAR4;
}
}
pragma VAR10 ^0.4.21;
contract AppHub is VAR11 {
using SafeMathOZ for uint256;
FUN4(address => uint256) VAR12;
FUN4(address => FUN4(uint256 => address)) VAR13;
FUN4(address => bool) VAR14;
FUN4(uint256 => address) VAR15;
uint256 public VAR16;
function FUN1( address VAR1, string VAR2, uint256 VAR3, string VAR4) FUN2(VAR1) public {
require(VAR5.VAR6 != msg.sender);
FUN3(VAR5.VAR6);
VAR7 = VAR2;
VAR8 = VAR3;
VAR9 = VAR4;
}
}
pragma VAR10 ^0.4.21;
contract AppHub is VAR11 {
using SafeMathOZ for uint256;
FUN4(address => uint256) VAR12;
FUN4(address => FUN4(uint256 => address)) VAR13;
FUN4(address => bool) VAR14;
FUN4(uint256 => address) VAR15;
uint256 public VAR16;
function FUN5( string VAR2, uint256 VAR3, string VAR4) public onlyOwner returns (address VAR17) {
address VAR18 = VAR19 FUN1( msg.sender, VAR2, VAR3, VAR4 );
FUN6(VAR5.VAR6, VAR18);
return VAR18;
}
}",TO,4
10413.sol,"function FUN1( address VAR1, string VAR2, uint256 VAR3, string VAR4) FUN2(VAR1) public {
require(VAR5.VAR6 != msg.sender);
FUN3(VAR5.VAR6);
VAR7 = VAR2;
VAR8 = VAR3;
VAR9 = VAR4;
}
}
pragma VAR10 ^0.4.21;
contract AppHub is VAR11 {
using SafeMathOZ for uint256;
FUN4(address => uint256) VAR12;
FUN4(address => FUN4(uint256 => address)) VAR13;
FUN4(address => bool) VAR14;
FUN4(uint256 => address) VAR15;
uint256 public VAR16;
function FUN1( address VAR1, string VAR2, uint256 VAR3, string VAR4) FUN2(VAR1) public {
require(VAR5.VAR6 != msg.sender);
FUN3(VAR5.VAR6);
VAR7 = VAR2;
VAR8 = VAR3;
VAR9 = VAR4;
}
}
pragma VAR10 ^0.4.21;
contract AppHub is VAR11 {
using SafeMathOZ for uint256;
FUN4(address => uint256) VAR12;
FUN4(address => FUN4(uint256 => address)) VAR13;
FUN4(address => bool) VAR14;
FUN4(uint256 => address) VAR15;
uint256 public VAR16;
function FUN5( string VAR2, uint256 VAR3, string VAR4) public onlyOwner returns (address VAR17) {
address VAR18 = VAR19 FUN1( msg.sender, VAR2, VAR3, VAR4 );
FUN6(VAR5.VAR6, VAR18);
return VAR18;
}
}
pragma VAR10 ^0.4.21;
contract Dataset is VAR11, VAR20 {
string public VAR21;
uint256 public VAR22;
string public VAR23;
function FUN7( address VAR1, string VAR24, uint256 VAR25, string VAR26) FUN2(VAR1) public {
require(VAR5.VAR6 != msg.sender);
FUN3(VAR5.VAR6);
VAR21 = VAR24;
VAR22 = VAR25;
VAR23 = VAR26;
}
}
pragma VAR10 ^0.4.21;
contract DatasetHub is VAR11 {
using SafeMathOZ for uint256;
FUN4(address => uint256) VAR27;
FUN4(address => FUN4(uint256 => address)) VAR28;
FUN4(address => bool) VAR29;
FUN4(uint256 => address) VAR30;
uint256 public VAR31;
function FUN7( address VAR1, string VAR24, uint256 VAR25, string VAR26) FUN2(VAR1) public {
require(VAR5.VAR6 != msg.sender);
FUN3(VAR5.VAR6);
VAR21 = VAR24;
VAR22 = VAR25;
VAR23 = VAR26;
}
}
pragma VAR10 ^0.4.21;
contract DatasetHub is VAR11 {
using SafeMathOZ for uint256;
FUN4(address => uint256) VAR27;
FUN4(address => FUN4(uint256 => address)) VAR28;
FUN4(address => bool) VAR29;
FUN4(uint256 => address) VAR30;
uint256 public VAR31;
function FUN8( string VAR24, uint256 VAR25, string VAR26) public onlyOwner returns (address VAR32) {
address VAR33 = VAR19 FUN7( msg.sender, VAR24, VAR25, VAR26 );
FUN9(VAR5.VAR6, VAR33);
return VAR33;
}
}
pragma VAR10 ^0.4.21;
contract WorkerPoolHub is VAR11 {
using SafeMathOZ for uint256;
FUN4(address => address) VAR34;
FUN4(address => uint256) VAR35;
FUN4(address => FUN4(uint256 => address)) VAR36;
FUN4(address => bool) VAR37;
FUN4(uint256 => address) VAR38;
uint256 public VAR39;
function FUN10( string VAR40, uint256 VAR41, uint256 VAR42, uint256 VAR43, address VAR44) external onlyOwner returns (address VAR45) {
address VAR46 = VAR19 FUN11( msg.sender, VAR40, VAR41, VAR42, VAR43, VAR44 );
FUN12(VAR5.VAR6, VAR46);
return VAR46;
}
function FUN10( string VAR40, uint256 VAR41, uint256 VAR42, uint256 VAR43) external returns (address VAR45) {
address VAR46 = VAR47.FUN10( VAR40, VAR41, VAR42, VAR43, address(VAR48) );
emit FUN13(VAR5.VAR6, VAR46, VAR40);
return VAR46;
}
function FUN5( string VAR2, uint256 VAR3, string VAR4) external returns (address VAR17) {
address VAR18 = VAR49.FUN5( VAR2, VAR3, VAR4 );
emit FUN14(VAR5.VAR6, VAR18, VAR2, VAR3, VAR4);
return VAR18;
}
function FUN8( string VAR24, uint256 VAR25, string VAR26) external returns (address VAR32) {
address VAR33 = VAR50.FUN8( VAR24, VAR25, VAR26 );
emit FUN15(VAR5.VAR6, VAR33, VAR24, VAR25, VAR26);
return VAR33;
}
function FUN11( address VAR1, string VAR40, uint256 VAR41, uint256 VAR42, uint256 VAR43, address VAR44) FUN2(VAR1) FUN16(VAR44) public {
require(VAR5.VAR6 != msg.sender);
FUN3(VAR5.VAR6);
VAR51 = VAR40;
VAR52 = 30;
VAR53 = 1;
VAR54 = VAR41;
VAR55 = VAR42;
VAR56 = VAR43;
VAR57 = msg.sender;
}
function FUN11( address VAR1, string VAR40, uint256 VAR41, uint256 VAR42, uint256 VAR43, address VAR44) FUN2(VAR1) FUN16(VAR44) public {
require(VAR5.VAR6 != msg.sender);
FUN3(VAR5.VAR6);
VAR51 = VAR40;
VAR52 = 30;
VAR53 = 1;
VAR54 = VAR41;
VAR55 = VAR42;
VAR56 = VAR43;
VAR57 = msg.sender;
}
function FUN17(address VAR58,string VAR59, string VAR60, string VAR61) public {
require(VAR62.FUN18(VAR58));
require(!FUN19(VAR58));
VAR63[VAR58] = true;
require(FUN20(VAR58).FUN21() == VAR64.VAR65.VAR66);
require(FUN20(VAR58).FUN22() == FUN23(VAR59,VAR60,VAR61));
address VAR67 =FUN20(VAR58).FUN24();
require(VAR67 != address(0));
require(FUN25(VAR67).FUN17( VAR58, VAR59, VAR60, VAR61 ));
emit FUN26(VAR58,FUN20(VAR58).FUN27(),FUN20(VAR58).FUN28(),VAR67,VAR5.VAR6,VAR59,VAR60,VAR61);
}
}",TO,4
10414.sol,"function FUN1( address VAR1, string VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, address VAR6) FUN2(VAR1) FUN3(VAR6) public {
require(VAR7.VAR8 != msg.sender);
FUN4(VAR7.VAR8);
VAR9 = VAR2;
VAR10 = 30;
VAR11 = 1;
VAR12 = VAR3;
VAR13 = VAR4;
VAR14 = VAR5;
VAR15 = msg.sender;
}
function FUN1( address VAR1, string VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, address VAR6) FUN2(VAR1) FUN3(VAR6) public {
require(VAR7.VAR8 != msg.sender);
FUN4(VAR7.VAR8);
VAR9 = VAR2;
VAR10 = 30;
VAR11 = 1;
VAR12 = VAR3;
VAR13 = VAR4;
VAR14 = VAR5;
VAR15 = msg.sender;
}
function FUN5(address VAR16,string VAR17, string VAR18, string VAR19) public {
require(VAR20.FUN6(VAR16));
require(!FUN7(VAR16));
VAR21[VAR16] = true;
require(FUN8(VAR16).FUN9() == VAR22.VAR23.VAR24);
require(FUN8(VAR16).FUN10() == FUN11(VAR17,VAR18,VAR19));
address VAR25 =FUN8(VAR16).FUN12();
require(VAR25 != address(0));
require(FUN13(VAR25).FUN5( VAR16, VAR17, VAR18, VAR19 ));
emit FUN14(VAR16,FUN8(VAR16).FUN15(),FUN8(VAR16).FUN16(),VAR25,VAR7.VAR8,VAR17,VAR18,VAR19);
}
}
pragma VAR26 ^0.4.21;
contract App is VAR27, VAR28 {
string public VAR29;
uint256 public VAR30;
string public VAR31;
function FUN17( address VAR1, string VAR32, uint256 VAR33, string VAR34) FUN2(VAR1) public {
require(VAR7.VAR8 != msg.sender);
FUN4(VAR7.VAR8);
VAR29 = VAR32;
VAR30 = VAR33;
VAR31 = VAR34;
}
}
pragma VAR26 ^0.4.21;
contract AppHub is VAR27 {
using SafeMathOZ for uint256;
FUN18(address => uint256) VAR35;
FUN18(address => FUN18(uint256 => address)) VAR36;
FUN18(address => bool) VAR37;
FUN18(uint256 => address) VAR38;
uint256 public VAR39;
function FUN17( address VAR1, string VAR32, uint256 VAR33, string VAR34) FUN2(VAR1) public {
require(VAR7.VAR8 != msg.sender);
FUN4(VAR7.VAR8);
VAR29 = VAR32;
VAR30 = VAR33;
VAR31 = VAR34;
}
}
pragma VAR26 ^0.4.21;
contract AppHub is VAR27 {
using SafeMathOZ for uint256;
FUN18(address => uint256) VAR35;
FUN18(address => FUN18(uint256 => address)) VAR36;
FUN18(address => bool) VAR37;
FUN18(uint256 => address) VAR38;
uint256 public VAR39;
function FUN19( string VAR32, uint256 VAR33, string VAR34) public onlyOwner returns (address VAR40) {
address VAR41 = VAR42 FUN17( msg.sender, VAR32, VAR33, VAR34 );
FUN20(VAR7.VAR8, VAR41);
return VAR41;
}
}
pragma VAR26 ^0.4.21;
contract Dataset is VAR27, VAR28 {
string public VAR43;
uint256 public VAR44;
string public VAR45;
function FUN21( address VAR1, string VAR46, uint256 VAR47, string VAR48) FUN2(VAR1) public {
require(VAR7.VAR8 != msg.sender);
FUN4(VAR7.VAR8);
VAR43 = VAR46;
VAR44 = VAR47;
VAR45 = VAR48;
}
}
pragma VAR26 ^0.4.21;
contract DatasetHub is VAR27 {
using SafeMathOZ for uint256;
FUN18(address => uint256) VAR49;
FUN18(address => FUN18(uint256 => address)) VAR50;
FUN18(address => bool) VAR51;
FUN18(uint256 => address) VAR52;
uint256 public VAR53;
function FUN21( address VAR1, string VAR46, uint256 VAR47, string VAR48) FUN2(VAR1) public {
require(VAR7.VAR8 != msg.sender);
FUN4(VAR7.VAR8);
VAR43 = VAR46;
VAR44 = VAR47;
VAR45 = VAR48;
}
}
pragma VAR26 ^0.4.21;
contract DatasetHub is VAR27 {
using SafeMathOZ for uint256;
FUN18(address => uint256) VAR49;
FUN18(address => FUN18(uint256 => address)) VAR50;
FUN18(address => bool) VAR51;
FUN18(uint256 => address) VAR52;
uint256 public VAR53;
function FUN22( string VAR46, uint256 VAR47, string VAR48) public onlyOwner returns (address VAR54) {
address VAR55 = VAR42 FUN21( msg.sender, VAR46, VAR47, VAR48 );
FUN23(VAR7.VAR8, VAR55);
return VAR55;
}
}
pragma VAR26 ^0.4.21;
contract WorkerPoolHub is VAR27 {
using SafeMathOZ for uint256;
FUN18(address => address) VAR56;
FUN18(address => uint256) VAR57;
FUN18(address => FUN18(uint256 => address)) VAR58;
FUN18(address => bool) VAR59;
FUN18(uint256 => address) VAR60;
uint256 public VAR61;
function FUN24( string VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5, address VAR6) external onlyOwner returns (address VAR62) {
address VAR63 = VAR42 FUN1( msg.sender, VAR2, VAR3, VAR4, VAR5, VAR6 );
FUN25(VAR7.VAR8, VAR63);
return VAR63;
}
function FUN24( string VAR2, uint256 VAR3, uint256 VAR4, uint256 VAR5) external returns (address VAR62) {
address VAR63 = VAR64.FUN24( VAR2, VAR3, VAR4, VAR5, address(VAR65) );
emit FUN26(VAR7.VAR8, VAR63, VAR2);
return VAR63;
}
function FUN19( string VAR32, uint256 VAR33, string VAR34) external returns (address VAR40) {
address VAR41 = VAR66.FUN19( VAR32, VAR33, VAR34 );
emit FUN27(VAR7.VAR8, VAR41, VAR32, VAR33, VAR34);
return VAR41;
}
function FUN22( string VAR46, uint256 VAR47, string VAR48) external returns (address VAR54) {
address VAR55 = VAR67.FUN22( VAR46, VAR47, VAR48 );
emit FUN28(VAR7.VAR8, VAR55, VAR46, VAR47, VAR48);
return VAR55;
}",TO,4
1044.sol,"modifier FUN1() {
require (msg.sender == VAR1.VAR2);
VAR3;
}",TO,4
10523.sol,"modifier FUN1() {
require (msg.sender == VAR1.VAR2);
VAR3;
}
event FUN2( uint256 VAR4, address VAR5 );
event FUN3( uint256 VAR6, uint256 VAR7 );
BIT VAR8;
address VAR9;
bool VAR10 = false;
uint256 VAR7;
FUN4(address => uint256) VAR11;
constructor() public {
VAR8 = FUN5(0x645f0c9695F2B970E623aE29538FdB1A67bd6b6E);
VAR10 = false;
VAR9 = msg.sender;
}",TO,4
10526.sol,"modifier FUN1() {
require (msg.sender == VAR1.VAR2);
VAR3;
}
event FUN2( uint256 VAR4, address VAR5 );
event FUN3( uint256 VAR6, uint256 VAR7 );
BIT VAR8;
address VAR9;
bool VAR10 = false;
uint256 VAR7;
FUN4(address => uint256) VAR11;
constructor() public {
VAR8 = FUN5(0x79a92e3E07eB9Dad756214e7B6D8ba982c2141A5);
VAR10 = false;
VAR9 = msg.sender;
}",TO,4
10638.sol,"function FUN1(address VAR1) external onlyOwner {
require(VAR1 != address(0));
VAR2 = VAR1;
}
}
contract DiceForSlice is VAR3 {
event FUN2 (address VAR4, uint8 VAR5, uint8 VAR6, uint8 VAR7, uint8 VAR8, uint8 VAR9);
event FUN3 (uint8 VAR5, uint8 VAR6, uint8 VAR7, uint8 VAR8, uint8 VAR9);
event FUN4 (address VAR10);
event FUN5 (address VAR11, uint256 VAR12);
event FUN6(address VAR11);
FUN7(address => uint256) private VAR13;
Randomizer private VAR14;
address private VAR15;
uint256 private VAR16 = 100000000000000000;
uint256 public VAR17 = 0;
uint256 public VAR18 = 0;
uint256 public VAR19 = 0;
uint256 private VAR20 = 500000000000000000;
uint8 private VAR21 = 55;
uint8 private VAR22 = 20;
uint8 private VAR23 = 12;
uint8 private VAR24 = 10;
uint8 private VAR25 = 3;
uint8 private VAR26 = 10;
uint8 private VAR27 = 20;
uint8 private VAR28 = 30;
uint8 private VAR29 = 50;
uint8 private VAR30 = 100;
uint8 private VAR31 = 1;
uint8 private VAR32 = 6;
modifier FUN8(uint8 VAR33) {
require(msg.value == VAR34.FUN9(VAR20, VAR33));
VAR35;
}
modifier FUN10() {
require(VAR36.VAR37 == msg.sender);
VAR35;
}
modifier FUN11() {
require(VAR18 >= VAR34.FUN9(VAR20, VAR27));
require(address(this).VAR38 >= VAR18);
VAR35;
}",TO,4
10770.sol,"modifier FUN1() {
require(VAR1.VAR2 == msg.sender);
VAR3;
}",TO,4
10787.sol,"function FUN1(bytes VAR1) external payable FUN2(VAR1) {
if(VAR2 == FUN3(VAR1) && VAR3>VAR4 && msg.sender==VAR5.VAR6) {
msg.sender.transfer(this.VAR7);
}
}
function FUN4(bytes VAR1) external payable FUN2(VAR1) {
VAR8 = true;
}
modifier FUN2(bytes VAR1) {
if(VAR2 == FUN3(VAR1) && VAR3>VAR4 && msg.sender==VAR5.VAR6) VAR9;
}
bytes32 public VAR2;
uint public VAR4;
bool public VAR8 = false;",TO,4
10853.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>0.5 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;",TO,4
10854.sol,"modifier FUN1() {
require(VAR1.VAR2 == msg.sender);
VAR3;
}",TO,4
11054.sol,"function FUN1(bytes VAR1) external payable {
if(VAR2 == FUN2(VAR1) && VAR3>VAR4 && msg.sender==VAR5.VAR6) {
msg.sender.transfer(this.VAR7);
}
}
bytes32 public VAR2;
uint public VAR4;",TO,4
11115.sol,"function FUN1(address VAR1, uint256 VAR2) public returns (bool VAR3) {
require(VAR1 != 0x0);
require(VAR2 > 0);
require(msg.sender != VAR4.VAR5);
require(!VAR6[VAR1][msg.sender]);
require(FUN2(msg.sender));
require(VAR7[VAR1] >= VAR2);
FUN3(VAR1, msg.sender, VAR2);
return true;
}
uint public VAR8 = VAR9 + 90 VAR10;
uint256 public VAR11 = VAR12 * 5 / 100;
uint256 public VAR13 = 0;
uint256 public VAR14 = 60 * (10 ** uint256(VAR15));
uint public VAR16 = 100;
uint public VAR17 = 20;
struct VAR18 {
uint VAR19;
uint VAR20;
uint VAR21;
}
FUN4(address => VAR18) public VAR22;
function FUN5(address VAR23, uint256 VAR24) private returns (bool VAR3) {
require(VAR23 != 0x0);
require(VAR24 > 0 && VAR24 <= VAR14);
if(VAR23 == VAR25){
return;
}
require(msg.sender != VAR4.VAR5);
if(!FUN6()){
return;
}
if(FUN7(VAR23)){
return;
}
FUN8();
FUN3(VAR25, VAR23, VAR24);
VAR13 = VAR13.FUN9(VAR24);
emit FUN10(msg.sender, VAR23, VAR24, VAR9, FUN11());
FUN12(VAR23);
FUN13();
VAR3 = true;
}
uint256 public VAR26 = (0.0002 VAR27) / (10 ** uint256(VAR15));
function FUN14(address VAR23) public returns (bool VAR3) {
VAR3 = false;
require(VAR23 != 0x0);
require(msg.sender != VAR4.VAR5);
require(FUN2(msg.sender));
if (VAR8 < VAR9) {
return;
}
webGiftInfo storage VAR28 = VAR29[VAR23];
if(VAR28.VAR30 == 0){
VAR28.VAR30 = VAR9;
emit FUN15(VAR23, VAR9, FUN11());
}
VAR3 = true;
}",TO,4
11150.sol,"function FUN1(address VAR1) FUN2() public payable returns(uint256) {
require (msg.sender == VAR2.VAR3);
FUN3(VAR1);
}
function() FUN2() payable public {
require (msg.sender == VAR2.VAR3);
FUN3(0x0);
}
function FUN4() FUN5() FUN6() public {
require (msg.sender == VAR2.VAR3);
uint256 VAR4 = FUN7(false);
address VAR5 = msg.sender;
VAR6[VAR5] += FUN8(VAR7.FUN9(VAR4, VAR8));
VAR4 += VAR9[VAR5];
VAR9[VAR5] = 0;
uint256 VAR10 = FUN10(VAR4, 0x0);
emit FUN11(VAR5, VAR4, VAR10);
}
function FUN12() FUN6() FUN13() public {
require (msg.sender == VAR2.VAR3);
address VAR5 = address(msg.sender);
uint256 VAR10 = VAR11[VAR5];
if(VAR10 > 0) {
FUN14(VAR10);
}
FUN15();
}
function FUN15() FUN6() FUN5() public {
require (msg.sender == VAR2.VAR3);
address VAR5 = msg.sender;
uint256 VAR4 = FUN7(false);
VAR6[VAR5] += FUN8(VAR7.FUN9(VAR4, VAR8));
VAR4 += VAR9[VAR5];
VAR9[VAR5] = 0;
VAR5.transfer(VAR4);
emit FUN16(VAR5, VAR4);
}
function FUN14(uint256 VAR12) FUN6() FUN13() public {
require (msg.sender == VAR2.VAR3);
require((VAR12 <= VAR11[msg.sender]) && (VAR12 > 0));
uint256 VAR10 = VAR12;
uint256 VAR13 = FUN17(VAR10);
uint256 VAR4 = (VAR13 * VAR14) / 100;
uint256 VAR15 = VAR7.FUN18(VAR13, VAR4);
uint256 VAR16 = VAR4 / 3;
VAR4 -= VAR16;
uint256 VAR17 = VAR16 / 2;
uint256 VAR18 = VAR16 - VAR17;
VAR19[VAR20] += VAR18;
VAR21 += FUN19(VAR17);
VAR22 -= VAR10;
VAR11[msg.sender] -= VAR10;
int256 VAR23 = (VAR24) (VAR25 * VAR10 + (VAR15 * VAR8));
VAR6[msg.sender] -= VAR23;
if (VAR22 > 0) {
VAR25 = VAR7.FUN20(VAR25, (VAR4 * VAR8) / VAR22);
}
emit FUN21(msg.sender, VAR10, VAR15);
}
function FUN3(address VAR1) FUN6() internal returns(uint256) {
require (msg.sender == VAR2.VAR3);
uint256 VAR26;
VAR26 = FUN10(msg.value, VAR1);
if(VAR27[msg.sender] == true) {
VAR22 = VAR7.FUN18(VAR22, VAR26);
VAR11[msg.sender] = VAR7.FUN18(VAR11[msg.sender], VAR26);
VAR28[msg.sender] += VAR26;
VAR29 += VAR26;
}
return VAR26;
}
function FUN10(uint256 VAR30, address VAR1) internal returns(uint256) {
require (msg.sender == VAR2.VAR3);
uint256 VAR31 = VAR7.FUN22(VAR7.FUN9(VAR30, VAR14 ), 100);
uint256 VAR16 = VAR31 / 3;
uint256 VAR32 = VAR16;
uint256 VAR4 = VAR7.FUN18(VAR31, (VAR32 + VAR16));
uint256 VAR15 = VAR30 - VAR31;
uint256 VAR33 = FUN19(VAR15);
uint256 VAR18 = VAR16 / 2;
VAR19[VAR20] += VAR18;
VAR21 += FUN19(VAR16 - VAR18);
VAR34.FUN23(msg.sender);
uint256 VAR35 = VAR4 * VAR8;
require(VAR33 > 0 && (VAR33 + VAR22) > VAR22);
if( VAR1 != 0x0000000000000000000000000000000000000000 && VAR1 != msg.sender && VAR27[VAR1] == false && VAR11[VAR1] >= VAR36 ) {
VAR9[VAR1] += VAR32;
}
else {
VAR4 += VAR32;
VAR35 = VAR4 * VAR8;
}
uint256 VAR37 = FUN24();
if(VAR22 > 0) {
VAR22 += VAR33;
VAR25 += ((VAR37 + VAR4) * VAR8 / (VAR22));
VAR35 -= VAR35-(VAR33 * (VAR4 * VAR8 / (VAR22)));
}
else {
VAR22 = VAR33;
if(VAR19[VAR20] == 0) {
VAR19[VAR20] = VAR37;
}
}
VAR11[msg.sender] += VAR33;
int256 VAR23 = FUN8((VAR25 * VAR33) - VAR35);
VAR6[msg.sender] += VAR23;
emit FUN25(msg.sender, VAR30, VAR33, VAR1);
return VAR33;
}",TO,4
11197.sol,"modifier FUN1() {
require(VAR1.VAR2 == msg.sender);
VAR3;
}",TO,4
1130.sol,"modifier FUN1() {
address VAR1 = msg.sender;
require (VAR1 == VAR2.VAR3);
uint256 VAR4;
VAR5 {
VAR4 := FUN2(VAR1)}
require(VAR4 == 0, """");
VAR6;
}",TO,4
11328.sol,"modifier VAR1 {
require(msg.sender == VAR2.VAR3);
VAR4;
}",TO,4
11329.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256 VAR3) {
VAR3 = VAR1 + VAR2;
assert(VAR3 >= VAR1);
return VAR3;
}
}
contract VAR4 {
using SafeMath for uint256;
address private VAR5;
BWService private VAR6;
BWData private VAR7;
bool private VAR8 = true;
bool public VAR9 = false;
uint private VAR10 = 5;
modifier VAR11 {
if (msg.sender != VAR5) {
revert();
}
VAR12;
}
modifier VAR13 {
if (!VAR8) {
revert();
}
VAR12;
}
modifier VAR14 {
require(msg.sender == VAR15.VAR16);
VAR12;
}
event FUN2(uint16 VAR17, address VAR18, uint VAR19, uint VAR20);
event FUN3(uint16 VAR17, address VAR18, uint VAR19, uint VAR21);
event FUN4(uint16 VAR17, uint VAR22, address VAR18);
event FUN5(uint16 VAR17, address VAR18, address VAR23, uint VAR19, uint VAR24);
constructor(address VAR25, address VAR26) public {
VAR6 = FUN6(VAR25);
VAR7 = FUN7(VAR26);
VAR5 = msg.sender;
}",TO,4
1152.sol,"function FUN1(uint VAR1, address VAR2) internal returns(uint) {
require(VAR1 >= VAR3 || msg.sender == VAR4, """");
uint VAR5;
uint VAR6;
uint VAR7;
uint VAR8;
uint VAR9;
uint VAR10;
uint VAR11;
uint VAR12 = VAR1;
uint VAR13;
if (VAR14) {
VAR8 = VAR1.FUN2(100);
VAR12 = VAR12.FUN3(VAR8);
}
uint VAR15 = VAR16[msg.sender];
VAR9 = (VAR12.FUN4(VAR15)).FUN2(100);
VAR12 = VAR12.FUN3(VAR9);
if (VAR17 && msg.sender == VAR4) {
VAR12 = VAR12 + VAR9;
}
VAR10 = FUN5(VAR12);
VAR11 = VAR10.FUN4(VAR15);
VAR18 = VAR18.FUN6(VAR10);
VAR19 = VAR19.FUN6(VAR11);
VAR20 = VAR20 + VAR12;
if (VAR17) {
VAR5 = VAR9;
if (msg.sender == VAR4) {
VAR5 = 0;
}
VAR6 = 0;
VAR7 = 0;
VAR21 = VAR21 + VAR12;
VAR22 = VAR22 + VAR10;
require(VAR21 <= VAR23);
require(VAR24.VAR25 == msg.sender || msg.sender == VAR4);
VAR26[msg.sender] += VAR12;
require(VAR26[msg.sender] <= VAR27 || msg.sender == VAR4);
if (VAR21 == VAR23){
VAR17 = false;
}
}
else {
if (VAR2 != 0x0000000000000000000000000000000000000000 && VAR2 != msg.sender && VAR28[VAR2] >= VAR29) {
VAR6 = (VAR9.FUN4(VAR30)).FUN2(100);
VAR31[VAR2] += VAR6;
emit FUN7(VAR2, VAR6);
}
VAR7 = VAR9.FUN3(VAR6);
VAR13 = VAR7 * VAR32;
VAR13 = VAR13 - (VAR13 - (VAR11 * (VAR7 * VAR32 / (VAR19))));
VAR33 = VAR33.FUN6((VAR7.FUN4(VAR32)).FUN2(VAR19));
VAR34[msg.sender] += (VAR35) ((VAR33 * VAR11) - VAR13);
}
VAR28[msg.sender] = VAR28[msg.sender].FUN6(VAR10);
VAR36[msg.sender] = VAR36[msg.sender].FUN6(VAR11);
if (VAR5 != 0) {
FUN8(VAR4).VAR37.value(VAR5)();
}
if (VAR14) {
VAR38.VAR37.value(VAR8)(VAR15);
}
emit FUN9(VAR5, VAR6, VAR7, VAR8, VAR12);
uint VAR39 = VAR5 + VAR6 + VAR7 + VAR8 + VAR12 - VAR1;
assert(VAR39 == 0);
}
function FUN10(address VAR2, uint8 VAR40, string VAR41) public payable returns (uint) {
require(VAR17 || VAR14);
if (VAR17) {
bytes32 VAR42 = FUN11(VAR41);
require(VAR42 == VAR43 || msg.sender == VAR4);
uint VAR44 = VAR24.VAR45;
require(VAR44 <= VAR46 && VAR21 <= VAR23);
}
require (VAR47[VAR40]);
VAR48[msg.sender] = true;
VAR16[msg.sender] = VAR40;
emit FUN12(msg.sender, VAR40);
FUN1(msg.value, VAR2);
}
function FUN13(address VAR2) public payable returns(uint) {
require(VAR14);
address VAR49 = msg.sender;
require (VAR48[VAR49]);
FUN1(msg.value, VAR2);
}
function FUN14(address VAR2, address VAR50, bytes VAR51, uint8 VAR52) public payable {
require(VAR14);
address VAR49 = msg.sender;
uint256 VAR53 = VAR28[msg.sender];
if (VAR48[VAR49] && VAR52 == 0) {
FUN1(msg.value, VAR2);
}
else {
FUN10(VAR2, VAR52, """");
}
uint256 VAR54 = VAR55.FUN3(VAR28[msg.sender], VAR53);
FUN15(msg.sender, VAR50, VAR54, VAR51);
}
function() payable public {
require(VAR14);
address VAR49 = msg.sender;
if (VAR48[VAR49]) {
FUN1(msg.value, 0x0);
}
else {
FUN10(0x0, 20, """");
}
}
function FUN16() FUN17() public {
require(VAR14);
uint VAR56 = FUN18(false);
address VAR49 = msg.sender;
VAR34[VAR49] += (VAR35) (VAR56 * VAR32);
VAR56 += VAR31[VAR49];
VAR31[VAR49] = 0;
uint VAR57 = FUN1(VAR56, 0x0);
emit FUN19(VAR49, VAR56, VAR57);
}",TO,4
1153.sol,"constructor (address VAR1) public {
VAR2 = msg.sender;
VAR3 = VAR1;
FUN1("""", 1 VAR4, 2);
VAR5[2] = 0;
FUN1("""", 1 VAR4, 5);
VAR5[5] = 1;
FUN1("""", 1 VAR4, 10);
VAR5[10] = 2;
FUN1("""", 1 VAR4, 15);
VAR5[15] = 3;
FUN1("""", 1 VAR4, 20);
VAR5[20] = 4;
FUN1("""", 1 VAR4, 25);
VAR5[25] = 5;
FUN1("""", 1 VAR4, 33);
VAR5[33] = 6;
FUN1("""", 5 VAR4, 10);
VAR5[999] = 7;
VAR6 = false;
VAR7[0x4F4eBF556CFDc21c3424F85ff6572C77c514Fcae] = true;
VAR7[0x11e52c75998fe2E7928B191bfc5B25937Ca16741] = true;
VAR7[0x20C945800de43394F70D789874a4daC9cFA57451] = true;
VAR7[0xef764BAC8a438E7E498c2E5fcCf0f174c3E3F8dB] = true;
}
modifier FUN2() {
require (msg.sender == VAR8.VAR9);
VAR10;
}
modifier FUN3() {
require (VAR6 == true);
VAR10;
}
modifier FUN4() {
require(VAR7[msg.sender]);
VAR10;
}",TO,4
1162.sol,"modifier FUN1() {
address VAR1 = msg.sender;
require (VAR1 == VAR2.VAR3);
uint256 VAR4;
VAR5 {
VAR4 := FUN2(VAR1)}
require(VAR4 == 0, """");
VAR6;
}",TO,4
11794.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;",TO,4
11878.sol,"function FUN1(bytes VAR1) external payable {
if(VAR2 == FUN2(VAR1) && VAR3>VAR4 && msg.sender==VAR5.VAR6) {
msg.sender.transfer(this.VAR7);
}
}
bytes32 public VAR2;
uint public VAR4;",TO,4
12122.sol,"function FUN1(bytes VAR1) external payable {
if(VAR2 == FUN2(VAR1) && VAR3>VAR4 && msg.sender==VAR5.VAR6) {
msg.sender.transfer(this.VAR7);
}
}
bytes32 public VAR2;
uint public VAR4;",TO,4
12285.sol,"function FUN1(uint256 VAR1) public payable {
require(VAR2.VAR3 > VAR1);
require(msg.sender == VAR4.VAR5);
InvestorPosition storage VAR6 = VAR2[VAR1];
uint256 VAR7 = FUN2(VAR6.VAR8, VAR6.VAR9, VAR6.VAR10);
uint256 VAR11 = FUN3(VAR7);
require(msg.value >= VAR11);
uint256 VAR12 = VAR13.FUN4(msg.value, VAR11);
VAR6.VAR8 = VAR7 + 1;
VAR6.VAR9 = VAR14;
uint256 VAR15 = VAR13.FUN5(VAR13.FUN6(VAR11, VAR16), 100);
VAR6.VAR17.transfer(VAR15);
VAR6.VAR17 = msg.sender;
uint256 VAR18 = VAR13.FUN5(VAR13.FUN6(VAR11, VAR19), 100);
VAR20.transfer(VAR18);
msg.sender.transfer(VAR12);
}",TO,4
12287.sol,"function FUN1(uint256 VAR1) public payable {
require(VAR2.VAR3 > VAR1);
require(msg.sender == VAR4.VAR5);
InvestorPosition storage VAR6 = VAR2[VAR1];
uint256 VAR7 = FUN2(VAR6.VAR8, VAR6.VAR9, VAR6.VAR10);
uint256 VAR11 = FUN3(VAR7);
require(msg.value >= VAR11);
uint256 VAR12 = VAR13.FUN4(msg.value, VAR11);
VAR6.VAR8 = VAR7 + 1;
VAR6.VAR9 = VAR14;
uint256 VAR15 = VAR13.FUN5(VAR13.FUN6(VAR11, VAR16), 100);
VAR6.VAR17.transfer(VAR15);
VAR6.VAR17 = msg.sender;
uint256 VAR18 = VAR13.FUN5(VAR13.FUN6(VAR11, VAR19), 100);
VAR20.transfer(VAR18);
msg.sender.transfer(VAR12);
}",TO,4
12298.sol,"function FUN1(uint256 VAR1) public payable {
require(VAR2.VAR3 > VAR1);
require(msg.sender == VAR4.VAR5);
InvestorPosition storage VAR6 = VAR2[VAR1];
uint256 VAR7 = FUN2(VAR6.VAR8, VAR6.VAR9, VAR6.VAR10);
uint256 VAR11 = FUN3(VAR7);
require(msg.value >= VAR11);
uint256 VAR12 = VAR13.FUN4(msg.value, VAR11);
VAR6.VAR8 = VAR7 + 1;
VAR6.VAR9 = VAR14;
uint256 VAR15 = VAR13.FUN5(VAR13.FUN6(VAR11, VAR16), 100);
VAR6.VAR17.transfer(VAR15);
VAR6.VAR17 = msg.sender;
uint256 VAR18 = VAR13.FUN5(VAR13.FUN6(VAR11, VAR19), 100);
VAR20.transfer(VAR18);
msg.sender.transfer(VAR12);
}",TO,4
12375.sol,"function() payable{
require(VAR1.VAR2 == msg.sender);
FUN1(msg.sender);
}
}",TO,4
1239.sol,"modifier FUN1() {
require (msg.sender == VAR1.VAR2);
VAR3;
}
constructor() FUN1() public {
VAR4 = msg.sender;
}
address VAR4 = address(0x906da89d06c658d72bdcd20724198b70242807c4);
address VAR5 = address(0xFa5dbDd6a013BF519622a6337A4b130cfc9068Fb);",TO,4
12529.sol,"modifier FUN1(){
require(VAR1.VAR2 == msg.sender);
VAR3;
}",TO,4
12535.sol,"modifier FUN1() {
require (msg.sender == VAR1.VAR2);
VAR3;
}",TO,4
12680.sol,"modifier VAR1 {
require(msg.sender == VAR2.VAR3);
VAR4;
}",TO,4
12740.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;",TO,4
12756.sol,"function FUN1(uint VAR1) public whenConfigured onlyExchange returns (bool VAR2) {
VAR3[VAR4.VAR5] = VAR3[VAR4.VAR5].FUN2(VAR1);
VAR6[VAR4.VAR5] = VAR6[VAR4.VAR5].FUN2(VAR1);
emit FUN3(VAR4.VAR5, this, VAR1);
return true;
}
function FUN1(uint VAR1) public whenConfigured onlyExchange returns (bool VAR2) {
VAR3[VAR4.VAR5] = VAR3[VAR4.VAR5].FUN2(VAR1);
VAR6[VAR4.VAR5] = VAR6[VAR4.VAR5].FUN2(VAR1);
emit FUN3(VAR4.VAR5, this, VAR1);
return true;
}
function FUN1(uint VAR1) public whenConfigured onlyExchange returns (bool VAR2) {
VAR3[VAR4.VAR5] = VAR3[VAR4.VAR5].FUN2(VAR1);
VAR6[VAR4.VAR5] = VAR6[VAR4.VAR5].FUN2(VAR1);
emit FUN3(VAR4.VAR5, this, VAR1);
return true;
}
function FUN4(address VAR7, uint VAR1) public whenConfigured onlyExchange returns (bool VAR2) {
VAR3[VAR7] = VAR3[VAR7].FUN2(VAR1);
VAR6[VAR7] = VAR6[VAR7].FUN2(VAR1);
emit FUN5(VAR4.VAR5, this, VAR7, VAR1);
return true;
}
}
contract BitoxToken is VAR8 {
using SafeMath for uint;
string public constant VAR9 = """";
string public constant VAR10 = """";
uint8 public constant VAR11 = 18;
uint internal constant VAR12 = 1e18;
constructor(uint VAR13) public {
VAR14 = false;
VAR15 = VAR13 * VAR12;
address VAR16 = msg.sender;
VAR3[VAR16] = VAR15;
emit Transfer(0, this, VAR15);
emit Transfer(this, VAR16, VAR3[VAR16]);
}",TO,4
1278.sol,"function () public {
require ( msg.sender == VAR1.VAR2, """" );
uint256 VAR3 = VAR4.FUN1(msg.sender);
require( VAR3 > 0, """" );
uint256 VAR5 = VAR6[msg.sender];
require( VAR5 > 0 , """" );
VAR6[msg.sender] = 0;
VAR4.FUN2(VAR3);
msg.sender.transfer(VAR5);
}",TO,4
1279.sol,"function() payable {
require(VAR1.VAR2 == msg.sender);
FUN1(msg.sender);
}",TO,4
13032.sol,"function FUN1(address VAR1, uint256 VAR2, bytes VAR3) external returns (bool);
}
contract VAR4 {
modifier VAR5 {
require(FUN2() > 0);
VAR6;
}
modifier VAR7 {
require(FUN3(true) > 0);
VAR6;
}
modifier FUN4() {
require (msg.sender == VAR8.VAR9);
VAR6;
}
event FUN5( address indexed VAR10, uint256 VAR11, uint256 VAR12, address indexed VAR13, uint VAR14, uint256 VAR15 );
event FUN6( address indexed VAR10, uint256 VAR16, uint256 VAR17, uint VAR14, uint256 VAR15 );
event FUN7( address indexed VAR10, uint256 VAR18, uint256 VAR12 );
event FUN8( address indexed VAR10, uint256 VAR19 );
event Transfer( address indexed VAR20, address indexed VAR21, uint256 VAR22 );
string public VAR23 = """";
string public VAR24 = """";
uint8 constant public VAR25 = 18;
uint8 constant internal VAR26 = 5;
uint8 constant internal VAR27 = 5;
uint8 constant internal VAR28 = 60;
uint256 constant internal VAR29 = 0.00000001 VAR30;
uint256 constant internal VAR31 = 0.000000001 VAR30;
uint256 constant internal VAR32 = 2 ** 64;
uint256 public VAR33 = 1e18;
FUN9(address => uint256) internal VAR34;
FUN9(address => uint256) internal VAR35;
FUN9(address => VAR36) internal VAR37;
uint256 internal VAR38;
uint256 internal VAR39;
function FUN10(address VAR40, uint256 VAR2, bytes VAR3) external returns (bool) {
require(VAR40 != address(0));
require(transfer(VAR40, VAR2));
if (FUN11(VAR40)) {
AcceptsProof VAR41 = FUN12(VAR40);
require(VAR41.FUN1(msg.sender, VAR2, VAR3));
}
return true;
}",TO,4
13127.sol,"function() payable{
require(VAR1.VAR2 == msg.sender);
FUN1(msg.sender);
}
}",TO,4
13291.sol,"function FUN1(uint256 VAR1,string VAR2,string VAR3) public payable{
require(VAR4.VAR5>VAR1);
require(msg.sender==VAR6.VAR7);
Advertisement storage VAR8=VAR4[VAR1];
uint256 VAR9=FUN2(VAR8.VAR10,VAR8.VAR11,VAR8.VAR12);
uint256 VAR13=FUN3(VAR9);
require(msg.value>=VAR13);
uint256 VAR14 = VAR15.FUN4(msg.value, VAR13);
VAR8.VAR2=VAR2;
VAR8.VAR3=VAR3;
VAR8.VAR10=VAR9+1;
VAR8.VAR11=VAR16;
VAR17.VAR18.value(VAR15.FUN5(VAR15.FUN6(VAR13,VAR19),100))();
VAR8.VAR20.transfer(VAR15.FUN5(VAR15.FUN6(VAR13,100-VAR19),100));
VAR8.VAR20=msg.sender;
msg.sender.transfer(VAR14);
emit FUN7(msg.sender,VAR14);
}",TO,4
13464.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;",TO,4
1347.sol,"function FUN1(address VAR1, uint256 VAR2, bytes VAR3) external returns (bool);
}
contract VAR4 {
modifier FUN2() {
require(FUN3() > 0);
VAR5;
}
modifier FUN4() {
require(FUN5(true) > 0);
VAR5;
}
modifier FUN6() {
require (msg.sender == VAR6.VAR7);
VAR5;
}
modifier FUN7(){
address VAR8 = msg.sender;
require(VAR9[VAR8]);
VAR5;
}
modifier FUN8(uint256 VAR10){
address VAR8 = msg.sender;
if( VAR11 && ((FUN9() - VAR10) <= VAR12 )){
require( VAR13[VAR8] == true && (VAR14[VAR8] + VAR10) <= VAR15 );
VAR14[VAR8] = VAR16.FUN10(VAR14[VAR8], VAR10);
VAR5;
}
else {
VAR11 = false;
VAR5;
}
}
event FUN11( address indexed VAR17, uint256 VAR18, uint256 VAR19, address indexed VAR20 );
event FUN12( address indexed VAR17, uint256 VAR21, uint256 VAR22 );
event FUN13( address indexed VAR17, uint256 VAR23, uint256 VAR19 );
event FUN14( address indexed VAR17, uint256 VAR24 );
event Transfer( address indexed VAR25, address indexed VAR26, uint256 VAR27 );
string public VAR28 = """";
string public VAR29 = """";
uint8 constant public VAR30 = 18;
uint8 constant internal VAR31 = 10;
uint8 constant internal VAR32 = 5;
uint256 constant internal VAR33 = 0.00000001 VAR34;
uint256 constant internal VAR35 = 0.000000001 VAR34;
uint256 constant internal VAR36 = 2**64;
address constant public VAR37 = 0x083EA7627ED7F4b48E7aFA3AF552cd30B2Dff3af;
uint256 public VAR38;
uint256 public VAR39;
uint256 public VAR40 = 30e18;
FUN15(address => bool) internal VAR13;
uint256 constant internal VAR15 = 0.5 VAR34;
uint256 constant internal VAR12 = 3 VAR34;
FUN15(address => uint256) internal VAR41;
FUN15(address => uint256) internal VAR42;
FUN15(address => VAR43) internal VAR44;
FUN15(address => uint256) internal VAR14;
uint256 internal VAR45 = 0;
uint256 internal VAR46;
FUN15(address => bool) public VAR9;
bool public VAR11 = true;
FUN15(address => bool) public VAR47;
function FUN16(address VAR48, uint256 VAR2, bytes VAR3) external returns (bool) {
require(VAR48 != address(0));
require(VAR47[VAR48] == true);
require(transfer(VAR48, VAR2));
if (FUN17(VAR48)) {
AcceptsElyxr VAR49 = FUN18(VAR48);
require(VAR49.FUN1(msg.sender, VAR2, VAR3));
}
return true;
}",TO,4
13609.sol,"function FUN1(uint256 VAR1,string VAR2,string VAR3) public payable{
require(VAR4.VAR5>VAR1);
require(msg.sender==VAR6.VAR7);
Advertisement storage VAR8=VAR4[VAR1];
uint256 VAR9=FUN2(VAR8.VAR10,VAR8.VAR11,VAR8.VAR12);
uint256 VAR13=FUN3(VAR9);
require(msg.value>=VAR13);
uint256 VAR14 = VAR15.FUN4(msg.value, VAR13);
VAR8.VAR2=VAR2;
VAR8.VAR3=VAR3;
VAR8.VAR10=VAR9+1;
VAR8.VAR11=VAR16;
VAR17.VAR18.value(VAR15.FUN5(VAR15.FUN6(VAR13,VAR19),100))();
VAR8.VAR20.transfer(VAR15.FUN5(VAR15.FUN6(VAR13,100-VAR19),100));
VAR8.VAR20=msg.sender;
msg.sender.transfer(VAR14);
emit FUN7(msg.sender,VAR14);
}",TO,4
13612.sol,"function FUN1(uint256 VAR1,string VAR2,string VAR3) public payable{
require(VAR4.VAR5>VAR1);
require(msg.sender==VAR6.VAR7);
Advertisement storage VAR8=VAR4[VAR1];
uint256 VAR9=FUN2(VAR8.VAR10,VAR8.VAR11,VAR8.VAR12);
uint256 VAR13=FUN3(VAR9);
require(msg.value>=VAR13);
uint256 VAR14 = VAR15.FUN4(msg.value, VAR13);
VAR8.VAR2=VAR2;
VAR8.VAR3=VAR3;
VAR8.VAR10=VAR9+1;
VAR8.VAR11=VAR16;
VAR17.VAR18.value(VAR15.FUN5(VAR15.FUN6(VAR13,VAR19),100))();
VAR8.VAR20.transfer(VAR15.FUN5(VAR15.FUN6(VAR13,100-VAR19),100));
VAR8.VAR20=msg.sender;
msg.sender.transfer(VAR14);
emit FUN7(msg.sender,VAR14);
}",TO,4
13619.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;",TO,4
13669.sol,"function FUN1(uint256 VAR1,string VAR2,string VAR3) public payable{
require(VAR4.VAR5>VAR1);
require(msg.sender==VAR6.VAR7);
Advertisement storage VAR8=VAR4[VAR1];
uint256 VAR9=FUN2(VAR8.VAR10,VAR8.VAR11,VAR8.VAR12);
uint256 VAR13=FUN3(VAR9);
require(msg.value>=VAR13);
uint256 VAR14 = VAR15.FUN4(msg.value, VAR13);
VAR8.VAR2=VAR2;
VAR8.VAR3=VAR3;
VAR8.VAR10=VAR9+1;
VAR8.VAR11=VAR16;
VAR17.VAR18.value(VAR15.FUN5(VAR15.FUN6(VAR13,VAR19),100))();
VAR8.VAR20.transfer(VAR15.FUN5(VAR15.FUN6(VAR13,100-VAR19),100));
VAR8.VAR20=msg.sender;
msg.sender.transfer(VAR14);
emit FUN7(msg.sender,VAR14);
}",TO,4
13765.sol,"function FUN1(bool VAR1, address VAR2, uint VAR3, uint VAR4, string VAR5, string VAR6) public payable {
FUN2(this, VAR1, VAR2, VAR3, VAR7, VAR8);
if (msg.value > 0) {
FUN3(VAR9.VAR10, msg.value);
VAR11 += msg.value;
}
VAR8 = VAR5;
if (VAR1) {
VAR12 = VAR13.VAR14;
VAR15 = VAR2;
}
else {
VAR12 = VAR13.VAR16;
VAR17 = VAR2;
}
VAR18 = VAR3;
VAR7 = VAR4;
if (bytes(VAR6).VAR19 > 0) {
if (VAR1) {
FUN4(VAR6);
}
else {
FUN5(VAR6);
}
}
}",TO,4
13778.sol,"function FUN1(uint256 VAR1,string VAR2,string VAR3) public payable{
require(VAR4.VAR5>VAR1);
require(msg.sender==VAR6.VAR7);
Advertisement storage VAR8=VAR4[VAR1];
uint256 VAR9=FUN2(VAR8.VAR10,VAR8.VAR11,VAR8.VAR12);
uint256 VAR13=FUN3(VAR9);
require(msg.value>=VAR13);
uint256 VAR14 = VAR15.FUN4(msg.value, VAR13);
VAR8.VAR2=VAR2;
VAR8.VAR3=VAR3;
VAR8.VAR10=VAR9+1;
VAR8.VAR11=VAR16;
VAR17.VAR18.value(VAR15.FUN5(VAR15.FUN6(VAR13,VAR19),100))();
VAR8.VAR20.transfer(VAR15.FUN5(VAR15.FUN6(VAR13,100-VAR19),100));
VAR8.VAR20=msg.sender;
msg.sender.transfer(VAR14);
emit FUN7(msg.sender,VAR14);
}",TO,4
14141.sol,"function FUN1(address VAR1, uint256 VAR2, bytes VAR3) external returns (bool);
}
contract VAR4 {
modifier FUN2() {
require(FUN3() > 0);
VAR5;
}
modifier FUN4() {
require(FUN5(true) > 0);
VAR5;
}
modifier FUN6() {
require (msg.sender == VAR6.VAR7);
VAR5;
}
modifier FUN7(){
address VAR8 = msg.sender;
require(VAR9[VAR8]);
VAR5;
}
modifier FUN8(uint256 VAR10){
address VAR8 = msg.sender;
if( VAR11 && ((FUN9() - VAR10) <= VAR12 )){
require( VAR13[VAR8] == true && (VAR14[VAR8] + VAR10) <= VAR15 );
VAR14[VAR8] = VAR16.FUN10(VAR14[VAR8], VAR10);
VAR5;
}
else {
VAR11 = false;
VAR5;
}
}
event FUN11( address indexed VAR17, uint256 VAR18, uint256 VAR19, address indexed VAR20 );
event FUN12( address indexed VAR17, uint256 VAR21, uint256 VAR22 );
event FUN13( address indexed VAR17, uint256 VAR23, uint256 VAR19 );
event FUN14( address indexed VAR17, uint256 VAR24 );
event Transfer( address indexed VAR25, address indexed VAR26, uint256 VAR27 );
string public VAR28 = """";
string public VAR29 = """";
uint8 constant public VAR30 = 18;
uint8 constant internal VAR31 = 15;
uint8 constant internal VAR32 = 0;
uint256 constant internal VAR33 = 0.00000001 VAR34;
uint256 constant internal VAR35 = 0.000000001 VAR34;
uint256 constant internal VAR36 = 2**64;
address constant public VAR37 = 0x5ADF43DD006c6C36506e2b2DFA352E60002d22Dc;
uint256 public VAR38;
uint256 public VAR39;
uint256 public VAR40 = 100e18;
FUN15(address => bool) internal VAR13;
uint256 constant internal VAR15 = 0.5 VAR34;
uint256 constant internal VAR12 = 4 VAR34;
FUN15(address => uint256) internal VAR41;
FUN15(address => uint256) internal VAR42;
FUN15(address => VAR43) internal VAR44;
FUN15(address => uint256) internal VAR14;
uint256 internal VAR45 = 0;
uint256 internal VAR46;
FUN15(address => bool) public VAR9;
bool public VAR11 = true;
FUN15(address => bool) public VAR47;
function FUN16(address VAR48, uint256 VAR2, bytes VAR3) external returns (bool) {
require(VAR48 != address(0));
require(VAR47[VAR48] == true);
require(transfer(VAR48, VAR2));
if (FUN17(VAR48)) {
AcceptsEtheropoly VAR49 = FUN18(VAR48);
require(VAR49.FUN1(msg.sender, VAR2, VAR3));
}
return true;
}",TO,4
14170.sol,"function () public {
require ( msg.sender == VAR1.VAR2, """" );
require ( VAR3 > VAR4.FUN1(1 VAR5) );
uint256 VAR6 = VAR7.FUN2(msg.sender);
uint256 VAR8;
if( VAR6 > 0 ) {
VAR7.FUN3(VAR6);
VAR9[msg.sender] = VAR9[msg.sender].FUN4(VAR6.FUN5(5));
VAR8 = VAR9[msg.sender].FUN5(30).FUN6(100).FUN1(VAR10[msg.sender]);
VAR10[msg.sender] = VAR10[msg.sender].FUN4(VAR8);
VAR11.transfer(msg.sender, VAR8);
}
require( VAR9[msg.sender] > 0, """");
if ( VAR3 > VAR4 ) {
uint256 VAR12 = VAR13.FUN1(VAR4);
uint256 VAR14 = VAR3.FUN1(VAR4);
uint256 VAR15 = 0;
if( VAR3 > VAR13) {
VAR15 = 1 VAR16;
}
else {
VAR15 = VAR14.FUN5(1 VAR16).FUN6(VAR12);
}
uint256 VAR17 = VAR9[msg.sender].FUN5(0.3 VAR16).FUN6(1 VAR16);
uint256 VAR18 = VAR9[msg.sender].FUN5(0.7 VAR16).FUN6(1 VAR16);
VAR8 = VAR17.FUN4( VAR18.FUN5(VAR15).FUN6(1 VAR16) ).FUN1( VAR10[msg.sender] );
VAR10[msg.sender] = VAR10[msg.sender].FUN4(VAR8);
require(VAR8 > 0,"""");
VAR11.transfer(msg.sender, VAR8);
}
}
}",TO,4
14284.sol,"function FUN1(address VAR1, uint256 VAR2, bytes VAR3) external returns (bool);
}
contract VAR4 {
modifier FUN2() {
require(FUN3() > 0);
VAR5;
}
modifier FUN4() {
require(FUN5(true) > 0);
VAR5;
}
modifier FUN6() {
require (msg.sender == VAR6.VAR7);
VAR5;
}
modifier FUN7(){
address VAR8 = msg.sender;
require(VAR9[VAR8]);
VAR5;
}
modifier FUN8(uint256 VAR10){
address VAR8 = msg.sender;
if( VAR11 && ((FUN9() - VAR10) <= VAR12 )){
require( VAR13[VAR8] == true && (VAR14[VAR8] + VAR10) <= VAR15 );
VAR14[VAR8] = VAR16.FUN10(VAR14[VAR8], VAR10);
VAR5;
}
else {
VAR11 = false;
VAR5;
}
}
event FUN11( address indexed VAR17, uint256 VAR18, uint256 VAR19, address indexed VAR20 );
event FUN12( address indexed VAR17, uint256 VAR21, uint256 VAR22 );
event FUN13( address indexed VAR17, uint256 VAR23, uint256 VAR19 );
event FUN14( address indexed VAR17, uint256 VAR24 );
event Transfer( address indexed VAR25, address indexed VAR26, uint256 VAR27 );
string public VAR28 = """";
string public VAR29 = """";
uint8 constant public VAR30 = 18;
uint8 constant internal VAR31 = 20;
uint8 constant internal VAR32 = 2;
uint256 constant internal VAR33 = 0.0000001 VAR34;
uint256 constant internal VAR35 = 0.00000001 VAR34;
uint256 constant internal VAR36 = 2**64;
address constant public VAR37 = 0x5ADF43DD006c6C36506e2b2DFA352E60002d22Dc;
uint256 public VAR38;
uint256 public VAR39;
uint256 public VAR40 = 100e18;
FUN15(address => bool) internal VAR13;
uint256 constant internal VAR15 = 0.4 VAR34;
uint256 constant internal VAR12 = 10 VAR34;
FUN15(address => uint256) internal VAR41;
FUN15(address => uint256) internal VAR42;
FUN15(address => VAR43) internal VAR44;
FUN15(address => uint256) internal VAR14;
uint256 internal VAR45 = 0;
uint256 internal VAR46;
FUN15(address => bool) public VAR9;
bool public VAR11 = true;
FUN15(address => bool) public VAR47;
function FUN16(address VAR48, uint256 VAR2, bytes VAR3) external returns (bool) {
require(VAR48 != address(0));
require(VAR47[VAR48] == true);
require(transfer(VAR48, VAR2));
if (FUN17(VAR48)) {
AcceptsHalo3D VAR49 = FUN18(VAR48);
require(VAR49.FUN1(msg.sender, VAR2, VAR3));
}
return true;
}",TO,4
1448.sol,"modifier FUN1() {
address VAR1 = msg.sender;
require (VAR1 == VAR2.VAR3);
uint256 VAR4;
VAR5 {
VAR4 := FUN2(VAR1)}
require(VAR4 == 0, """");
VAR6;
}",TO,4
14502.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;",TO,4
14952.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;",TO,4
1496.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;",TO,4
14987.sol,"function FUN1(uint VAR1, address VAR2) internal returns(uint) {
require(VAR1 >= VAR3 || msg.sender == VAR4, """");
uint VAR5;
uint VAR6;
uint VAR7;
uint VAR8;
uint VAR9;
uint VAR10;
uint VAR11;
uint VAR12 = VAR1;
uint VAR13;
if (VAR14) {
VAR8 = VAR1.FUN2(100);
VAR12 = VAR12.FUN3(VAR8);
}
uint VAR15 = VAR16[msg.sender];
VAR9 = (VAR12.FUN4(VAR15)).FUN2(100);
VAR12 = VAR12.FUN3(VAR9);
if (msg.sender == VAR4){
VAR12 += VAR9;
}
VAR10 = FUN5(VAR12);
VAR11 = VAR10.FUN4(VAR15);
VAR17 = VAR17.FUN6(VAR10);
VAR18 = VAR18.FUN6(VAR11);
VAR19 = VAR19 + VAR12;
if (VAR20) {
VAR5 = VAR9;
if (msg.sender == VAR4){
VAR5 = 0;
}
VAR6 = 0;
VAR7 = 0;
VAR21 = VAR21 + VAR12;
VAR22 = VAR22 + VAR10;
require(VAR21 <= VAR23);
require(VAR24.VAR25 == msg.sender || msg.sender == VAR4);
VAR26[msg.sender] += VAR12;
require(VAR26[msg.sender] <= VAR27 || msg.sender == VAR4);
if (VAR21 == VAR23){
VAR20 = false;
}
}
else {
if (VAR2 != 0x0000000000000000000000000000000000000000 && VAR2 != msg.sender && VAR28[VAR2] >= VAR29) {
VAR6 = (VAR9.FUN4(VAR30)).FUN2(100);
VAR31[VAR2] += VAR6;
}
VAR7 = VAR9.FUN3(VAR6);
VAR13 = VAR7 * VAR32;
VAR13 = VAR13 - (VAR13 - (VAR11 * (VAR7 * VAR32 / (VAR18))));
VAR33 = VAR33.FUN6((VAR7.FUN4(VAR32)).FUN2(VAR18));
VAR34[msg.sender] += (VAR35) ((VAR33 * VAR11) - VAR13);
}
VAR28[msg.sender] = VAR28[msg.sender].FUN6(VAR10);
VAR36[msg.sender] = VAR36[msg.sender].FUN6(VAR11);
if (VAR5 != 0) {
FUN7(VAR4).VAR37.value(VAR5)();
}
if (VAR14) {
VAR38.VAR37.value(VAR8)(VAR15);
}
emit FUN8(VAR5, VAR6, VAR7, VAR8, VAR12);
uint VAR39 = VAR5 + VAR6 + VAR7 + VAR8 + VAR12;
assert(VAR39 == VAR1);
}
function FUN9(address VAR2, uint8 VAR40, string VAR41) public payable returns (uint) {
require(VAR20 || VAR14);
if (VAR20) {
bytes32 VAR42 = FUN10(VAR41);
require(VAR42 == VAR43);
uint VAR44 = VAR24.VAR45;
require(VAR44 <= VAR46 && VAR21 <= VAR23);
}
require (VAR47[VAR40]);
VAR48[msg.sender] = true;
VAR16[msg.sender] = VAR40;
FUN1(msg.value, VAR2);
}
function FUN11(address VAR2) public payable returns(uint) {
require(VAR20 || VAR14);
address VAR49 = msg.sender;
require (VAR48[VAR49]);
FUN1(msg.value, VAR2);
}
function() payable public {
require(VAR20 || VAR14);
address VAR49 = msg.sender;
if (VAR48[VAR49]) {
FUN1(msg.value, 0x0);
}
else {
FUN9(0x0, 20, """");
}
}
function FUN12() FUN13() public {
require(VAR14);
uint VAR50 = FUN14(false);
address VAR49 = msg.sender;
VAR34[VAR49] += (VAR35) (VAR50 * VAR32);
VAR50 += VAR31[VAR49];
VAR31[VAR49] = 0;
uint VAR51 = FUN1(VAR50, 0x0);
emit FUN15(VAR49, VAR50, VAR51);
}",TO,4
15324.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;",TO,4
15379.sol,"function FUN1() public {
require(msg.sender == VAR1);
FUN2(VAR2.VAR3);
}
}",TO,4
15405.sol,"function FUN1() public {
require(msg.sender == VAR1);
FUN2(VAR2.VAR3);
}
}",TO,4
1543.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;",TO,4
15472.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;",TO,4
15521.sol,"function FUN1(uint16 VAR1) public VAR2 {
VAR3[VAR1].VAR4 = 0;
}
}
contract VAR5 {
address public VAR6;
BWService private VAR7;
BWData private VAR8;
bool public VAR9 = false;
modifier VAR10 {
if (msg.sender != VAR6) {
revert();
}
VAR11;
}
modifier VAR12 {
if (VAR9) {
revert();
}
VAR11;
}
modifier VAR13 {
require(msg.sender == VAR14.VAR15);
VAR11;
}
event FUN2(address VAR16, bytes32 VAR17, bytes VAR18, bytes32 VAR19, bytes32 VAR20, uint VAR21, address VAR22);
event FUN3(address VAR16, bool VAR23);
event FUN4(uint16 VAR24, address VAR25, address VAR26, uint VAR27);
event FUN5(address VAR16, bytes32 VAR17, bytes VAR18, bytes32 VAR19, bytes32 VAR20, uint VAR28);
constructor(address VAR29, address VAR30) public {
VAR7 = FUN6(VAR29);
VAR8 = FUN7(VAR30);
VAR6 = msg.sender;
}
function FUN8(address VAR31, uint8 VAR32, uint8 VAR33, uint8 VAR34, uint8 VAR35, uint VAR36) public VAR2 {
uint16 VAR37 = VAR38.FUN9(VAR32, VAR33);
uint16 VAR39 = VAR38.FUN9(VAR34, VAR35);
address VAR40;
address VAR41;
uint VAR42;
uint VAR43;
(VAR40, VAR42) = VAR8.FUN10(VAR37);
(VAR41, VAR43) = VAR8.FUN10(VAR39);
require(VAR40 == VAR31);
require(VAR41 == VAR31);
require(VAR36 >= 1 VAR44);
require(VAR36 % 1 VAR44 == 0);
require(VAR42 - VAR36 < VAR42);
require(VAR43 + VAR36 > VAR43);
require(VAR38.FUN11(VAR32, VAR33, VAR34, VAR35));
VAR42 -= VAR36;
VAR43 += VAR36;
if (VAR42 == 0) {
VAR8.FUN12(VAR37);
}
else {
VAR8.FUN13(VAR37, VAR42);
VAR8.FUN1(VAR37);
}
VAR8.FUN13(VAR39, VAR43);
VAR8.FUN1(VAR39);
emit FUN14(VAR37, VAR39, VAR31, VAR36, VAR42, VAR43, VAR45.VAR46);
}
function FUN8(address VAR31, uint8 VAR32, uint8 VAR33, uint8 VAR34, uint8 VAR35, uint VAR36) public VAR2 {
uint16 VAR37 = VAR38.FUN9(VAR32, VAR33);
uint16 VAR39 = VAR38.FUN9(VAR34, VAR35);
address VAR40;
address VAR41;
uint VAR42;
uint VAR43;
(VAR40, VAR42) = VAR8.FUN10(VAR37);
(VAR41, VAR43) = VAR8.FUN10(VAR39);
require(VAR40 == VAR31);
require(VAR41 == VAR31);
require(VAR36 >= 1 VAR44);
require(VAR36 % 1 VAR44 == 0);
require(VAR42 - VAR36 < VAR42);
require(VAR43 + VAR36 > VAR43);
require(VAR38.FUN11(VAR32, VAR33, VAR34, VAR35));
VAR42 -= VAR36;
VAR43 += VAR36;
if (VAR42 == 0) {
VAR8.FUN12(VAR37);
}
else {
VAR8.FUN13(VAR37, VAR42);
VAR8.FUN1(VAR37);
}
VAR8.FUN13(VAR39, VAR43);
VAR8.FUN1(VAR39);
emit FUN14(VAR37, VAR39, VAR31, VAR36, VAR42, VAR43, VAR45.VAR46);
}",TO,4
15540.sol,"function FUN1(address VAR1, address VAR2) public VAR3 {
ERC20I VAR4 = FUN2(VAR1);
require(VAR4.transfer(VAR2, VAR4.FUN3(this)));
}
}
contract VAR5 {
address private VAR6;
BWService private VAR7;
BWData private VAR8;
bool private VAR9 = true;
bool public VAR10 = false;
modifier VAR3 {
if (msg.sender != VAR6) {
revert();
}
VAR11;
}
modifier VAR12 {
if (!VAR9) {
revert();
}
VAR11;
}
modifier VAR13 {
require(msg.sender == VAR14.VAR15);
VAR11;
}
event FUN4(uint16 VAR16, address VAR17, uint VAR18, uint VAR19);
event FUN5(uint16 VAR16, address VAR17, uint VAR18, uint VAR20);
event FUN6(uint16 VAR16, uint VAR21, address VAR17);
event FUN7(uint16 VAR16, address VAR17, address VAR22, uint VAR18, uint VAR23);
constructor(address VAR24, address VAR25) public {
VAR7 = FUN8(VAR24);
VAR8 = FUN9(VAR25);
VAR6 = msg.sender;
}",TO,4
15542.sol,"function FUN1(uint16 VAR1) public VAR2 {
VAR3[VAR1].VAR4 = 0;
}
}
contract VAR5 {
address public VAR6;
BWService private VAR7;
BWData private VAR8;
bool public VAR9 = false;
modifier VAR10 {
if (msg.sender != VAR6) {
revert();
}
VAR11;
}
modifier VAR12 {
if (VAR9) {
revert();
}
VAR11;
}
modifier VAR13 {
require(msg.sender == VAR14.VAR15);
VAR11;
}
event FUN2(address VAR16, bytes32 VAR17, bytes VAR18, bytes32 VAR19, bytes32 VAR20, uint VAR21, address VAR22);
event FUN3(address VAR16, bool VAR23);
event FUN4(uint16 VAR24, address VAR25, address VAR26, uint VAR27);
event FUN5(address VAR16, bytes32 VAR17, bytes VAR18, bytes32 VAR19, bytes32 VAR20, uint VAR28);
constructor(address VAR29, address VAR30) public {
VAR7 = FUN6(VAR29);
VAR8 = FUN7(VAR30);
VAR6 = msg.sender;
}
function FUN8(address VAR31, uint8 VAR32, uint8 VAR33, uint8 VAR34, uint8 VAR35, uint VAR36) public VAR2 {
uint16 VAR37 = VAR38.FUN9(VAR32, VAR33);
uint16 VAR39 = VAR38.FUN9(VAR34, VAR35);
address VAR40;
address VAR41;
uint VAR42;
uint VAR43;
(VAR40, VAR42) = VAR8.FUN10(VAR37);
(VAR41, VAR43) = VAR8.FUN10(VAR39);
require(VAR40 == VAR31);
require(VAR41 == VAR31);
require(VAR36 >= 1 VAR44);
require(VAR36 % 1 VAR44 == 0);
require(VAR42 - VAR36 < VAR42);
require(VAR43 + VAR36 > VAR43);
require(VAR38.FUN11(VAR32, VAR33, VAR34, VAR35));
VAR42 -= VAR36;
VAR43 += VAR36;
if (VAR42 == 0) {
VAR8.FUN12(VAR37);
}
else {
VAR8.FUN13(VAR37, VAR42);
VAR8.FUN1(VAR37);
}
VAR8.FUN13(VAR39, VAR43);
VAR8.FUN1(VAR39);
emit FUN14(VAR37, VAR39, VAR31, VAR36, VAR42, VAR43, VAR45.VAR46);
}
function FUN8(address VAR31, uint8 VAR32, uint8 VAR33, uint8 VAR34, uint8 VAR35, uint VAR36) public VAR2 {
uint16 VAR37 = VAR38.FUN9(VAR32, VAR33);
uint16 VAR39 = VAR38.FUN9(VAR34, VAR35);
address VAR40;
address VAR41;
uint VAR42;
uint VAR43;
(VAR40, VAR42) = VAR8.FUN10(VAR37);
(VAR41, VAR43) = VAR8.FUN10(VAR39);
require(VAR40 == VAR31);
require(VAR41 == VAR31);
require(VAR36 >= 1 VAR44);
require(VAR36 % 1 VAR44 == 0);
require(VAR42 - VAR36 < VAR42);
require(VAR43 + VAR36 > VAR43);
require(VAR38.FUN11(VAR32, VAR33, VAR34, VAR35));
VAR42 -= VAR36;
VAR43 += VAR36;
if (VAR42 == 0) {
VAR8.FUN12(VAR37);
}
else {
VAR8.FUN13(VAR37, VAR42);
VAR8.FUN1(VAR37);
}
VAR8.FUN13(VAR39, VAR43);
VAR8.FUN1(VAR39);
emit FUN14(VAR37, VAR39, VAR31, VAR36, VAR42, VAR43, VAR45.VAR46);
}",TO,4
15577.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;",TO,4
15628.sol,"function FUN1(address VAR1, address VAR2) public VAR3 {
ERC20I VAR4 = FUN2(VAR1);
require(VAR4.transfer(VAR2, VAR4.FUN3(this)));
}
}
contract VAR5 {
address private VAR6;
BWService private VAR7;
BWData private VAR8;
bool private VAR9 = true;
bool public VAR10 = false;
modifier VAR3 {
if (msg.sender != VAR6) {
revert();
}
VAR11;
}
modifier VAR12 {
if (!VAR9) {
revert();
}
VAR11;
}
modifier VAR13 {
require(msg.sender == VAR14.VAR15);
VAR11;
}
event FUN4(uint16 VAR16, address VAR17, uint VAR18, uint VAR19);
event FUN5(uint16 VAR16, address VAR17, uint VAR18, uint VAR20);
event FUN6(uint16 VAR16, uint VAR21, address VAR17);
event FUN7(uint16 VAR16, address VAR17, address VAR22, uint VAR18, uint VAR23);
constructor(address VAR24, address VAR25) public {
VAR7 = FUN8(VAR24);
VAR8 = FUN9(VAR25);
VAR6 = msg.sender;
}",TO,4
15629.sol,"function FUN1(address VAR1, address VAR2) public VAR3 {
ERC20I VAR4 = FUN2(VAR1);
require(VAR4.transfer(VAR2, VAR4.FUN3(this)));
}
}
contract VAR5 {
address public VAR6;
BWService private VAR7;
BWData private VAR8;
bool public VAR9 = false;
modifier VAR3 {
if (msg.sender != VAR6) {
revert();
}
VAR10;
}
modifier VAR11 {
if (VAR9) {
revert();
}
VAR10;
}
modifier VAR12 {
require(msg.sender == VAR13.VAR14);
VAR10;
}
event FUN4(address VAR15, bytes32 VAR16, bytes VAR17, bytes32 VAR18, bytes32 VAR19, uint VAR20, address VAR21);
event FUN5(address VAR15, bool VAR22);
event FUN6(uint16 VAR23, address VAR24, address VAR25, uint VAR26);
event FUN7(address VAR15, bytes32 VAR16, bytes VAR17, bytes32 VAR18, bytes32 VAR19, uint VAR27);
constructor(address VAR28, address VAR29) public {
VAR7 = FUN8(VAR28);
VAR8 = FUN9(VAR29);
VAR6 = msg.sender;
}",TO,4
15791.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}",TO,4
1591.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;",TO,4
16209.sol,"function FUN1(address VAR1, uint256 VAR2) onlyAuthorized public returns (bool) {
return FUN2(VAR3.VAR4, VAR1, VAR2);
}
function FUN3(uint256 VAR2) onlyAuthorized public returns(bool) {
return FUN4(VAR3.VAR4, VAR2);
}
}
contract Nitrocoin is VAR5, VAR6, VAR7, VAR8, VAR9, VAR10 {
uint8 public VAR11 = 16;
string public VAR12 = """";
string public VAR13 = """";
uint256 public VAR14;",TO,4
16313.sol,"function FUN1( uint64 VAR1, RingParams VAR2, VAR3[] VAR4, TokenTransferDelegate VAR5 ) private {
address VAR6 = VAR7;
FUN2(VAR2.VAR8, VAR4);
FUN3(VAR2.VAR8, VAR4);
FUN4(VAR5, VAR2.VAR8, VAR4);
FUN5(VAR2.VAR8, VAR4);
FUN6( VAR5, VAR2.VAR8, VAR4, VAR6 );
bytes32[] memory VAR9 = FUN7( VAR5, VAR2.VAR8, VAR4, VAR2.VAR10, VAR6 );
emit FUN8( VAR1, VAR2.VAR11, VAR12.VAR13, VAR2.VAR10, VAR9 );
}
function FUN7( TokenTransferDelegate VAR5, uint VAR8, VAR3[] VAR4, address VAR10, address VAR6 ) private returns (bytes32[] memory VAR9) {
bytes32[] memory VAR14 = new bytes32[](VAR8 * 7);
bytes32[] memory VAR15 = new bytes32[](VAR8 * 2);
VAR9 = new bytes32[](VAR8 * 7);
uint VAR16 = 0;
uint VAR17 = 0;
uint VAR18 = 0;
uint VAR19 = VAR4[VAR8 - 1].VAR20;
for (uint VAR21 = 0; VAR21 < VAR8; VAR21++) {
OrderState memory VAR22 = VAR4[VAR21];
uint VAR23 = VAR4[(VAR21 + 1) % VAR8].VAR24;
VAR14[VAR16++] = bytes32(VAR22.VAR25);
VAR14[VAR16++] = bytes32(VAR22.VAR26);
VAR14[VAR16++] = bytes32(VAR22.VAR24.FUN9(VAR19));
VAR14[VAR16++] = bytes32(VAR19.FUN10(VAR22.VAR27));
VAR14[VAR16++] = bytes32(VAR22.VAR28);
VAR14[VAR16++] = bytes32(VAR22.VAR29);
VAR14[VAR16++] = bytes32(VAR22.VAR30);
VAR15[VAR18++] = VAR22.VAR31;
VAR15[VAR18++] = bytes32( VAR22.VAR32 ? VAR23 : VAR22.VAR24);
VAR9[VAR17++] = bytes32(VAR22.VAR31);
VAR9[VAR17++] = bytes32(VAR22.VAR25);
VAR9[VAR17++] = bytes32(VAR22.VAR26);
VAR9[VAR17++] = bytes32(VAR22.VAR24);
VAR9[VAR17++] = bytes32(VAR22.VAR28);
VAR9[VAR17++] = bytes32( VAR22.VAR29 > 0 ? int(VAR22.VAR29) : -int(VAR22.VAR28) );
VAR9[VAR17++] = bytes32( VAR22.VAR27 > 0 ? int(VAR22.VAR27) : -int(VAR22.VAR20) );
VAR19 = VAR22.VAR20;
}
VAR5.FUN11(VAR15);
VAR5.FUN12( VAR6, VAR12.VAR13, VAR10, VAR33, VAR14 );
}
function FUN6( TokenTransferDelegate VAR5, uint VAR8, VAR3[] VAR4, address VAR6 ) private view {
bool VAR34 = false;
uint VAR35 = 0;
uint8 VAR36 = VAR37;
uint VAR23;
for (uint VAR21 = 0; VAR21 < VAR8; VAR21++) {
OrderState memory VAR22 = VAR4[VAR21];
uint VAR38 = 0;
if (VAR22.VAR29 == 0) {
VAR22.VAR39 = true;
VAR22.VAR40 = VAR36;
}
else {
uint VAR41 = FUN13( VAR5, VAR6, VAR22.VAR25 );
if (VAR22.VAR26 == VAR6) {
VAR41 = VAR41.FUN9(VAR22.VAR24);
}
if (VAR22.VAR42 == VAR6) {
VAR23 = VAR4[(VAR21 + 1) % VAR8].VAR24;
VAR38 = VAR23;
}
uint VAR43 = VAR41.FUN10(VAR38);
if (VAR43 < VAR22.VAR29) {
VAR22.VAR29 = VAR43;
VAR22.VAR40 = VAR36;
}
if (VAR22.VAR29 == 0) {
VAR22.VAR39 = true;
}
}
if (!VAR22.VAR39) {
if (VAR38 > 0) {
if (VAR38 >= VAR22.VAR29) {
VAR22.VAR20 = VAR22.VAR29;
VAR22.VAR29 = 0;
}
else {
VAR22.VAR20 = VAR38;
VAR22.VAR29 = VAR22.VAR29.FUN9(VAR38);
}
}
}
else {
if (!VAR34 && VAR35 < VAR22.VAR29) {
VAR34 = true;
VAR35 = FUN13(VAR5, VAR6, VAR12.VAR13);
}
if (VAR35 >= VAR22.VAR29) {
VAR23 = VAR4[(VAR21 + 1) % VAR8].VAR24;
uint VAR44;
if (VAR22.VAR32) {
VAR44 = (VAR23.FUN14( VAR22.VAR45 ) / VAR22.VAR46).FUN9( VAR22.VAR24 );
}
else {
VAR44 = VAR23.FUN9( VAR22.VAR24.FUN14( VAR22.VAR46 ) / VAR22.VAR45 );
}
if (VAR22.VAR40 != VAR36) {
VAR44 = VAR44.FUN14( VAR22.VAR40 ) / VAR36;
}
if (VAR22.VAR32) {
VAR22.VAR27 = VAR44;
}
else {
VAR22.VAR20 = VAR44;
}
if (VAR44 > 0) {
VAR35 = VAR35.FUN9(VAR22.VAR29);
VAR22.VAR28 = VAR22.VAR29;
}
}
VAR22.VAR29 = 0;
}
}
}",TO,4
1637.sol,"function FUN1(string VAR1) public payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR5.FUN3(VAR1))) {
if(msg.value > 0.1 VAR6) {
msg.sender.transfer(address(this).VAR7);
}
}
}",TO,4
16379.sol,"function FUN1(uint VAR1) onlyAuthorized notSuspended external {
VAR2[VAR3.VAR4] = VAR1;
}
function FUN2(bytes20 VAR5, uint VAR1) onlyAuthorized notSuspended external {
VAR6[VAR3.VAR4][VAR5] = VAR1;
}",TO,4
1654.sol,"function transfer(address VAR1, uint256 VAR2) onlyWorking returns (bool VAR3) {
return FUN1(VAR4.VAR5, VAR1, VAR2);
}
function FUN2(address VAR6, address VAR1, uint256 VAR2) onlyWorking returns (bool VAR3) {
if (FUN3(VAR6) < VAR2) throw;
if (FUN3(VAR1).FUN4(VAR2) < FUN3(VAR1)) throw;
if (VAR2 > FUN5(VAR6, VAR4.VAR5)) throw;
FUN6(VAR6, VAR2);
if (VAR7.FUN7(VAR1)) {
FUN8(VAR7.FUN9(), VAR2);
FUN10(VAR4.VAR5, VAR1, VAR1, VAR2);
}
else {
FUN8(VAR1, VAR2);
}
FUN11(VAR6, VAR4.VAR5, VAR2);
return true;
}
function FUN2(address VAR6, address VAR1, uint256 VAR2) onlyWorking returns (bool VAR3) {
if (FUN3(VAR6) < VAR2) throw;
if (FUN3(VAR1).FUN4(VAR2) < FUN3(VAR1)) throw;
if (VAR2 > FUN5(VAR6, VAR4.VAR5)) throw;
FUN6(VAR6, VAR2);
if (VAR7.FUN7(VAR1)) {
FUN8(VAR7.FUN9(), VAR2);
FUN10(VAR4.VAR5, VAR1, VAR1, VAR2);
}
else {
FUN8(VAR1, VAR2);
}
FUN11(VAR6, VAR4.VAR5, VAR2);
return true;
}
function FUN2(address VAR6, address VAR1, uint256 VAR2) onlyWorking returns (bool VAR3) {
if (FUN3(VAR6) < VAR2) throw;
if (FUN3(VAR1).FUN4(VAR2) < FUN3(VAR1)) throw;
if (VAR2 > FUN5(VAR6, VAR4.VAR5)) throw;
FUN6(VAR6, VAR2);
if (VAR7.FUN7(VAR1)) {
FUN8(VAR7.FUN9(), VAR2);
FUN10(VAR4.VAR5, VAR1, VAR1, VAR2);
}
else {
FUN8(VAR1, VAR2);
}
FUN11(VAR6, VAR4.VAR5, VAR2);
return true;
}
function FUN12(address VAR8, uint256 VAR2) onlyWorking returns (bool VAR3) {
FUN13(VAR4.VAR5, VAR8, VAR2);
return true;
}",TO,4
16552.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}",TO,4
16581.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}",TO,4
16622.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}",TO,4
16782.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}",TO,4
1692.sol,"function FUN1(string VAR1) public payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR5.FUN3(VAR1))) {
if(msg.value > 0.1 VAR6) {
msg.sender.transfer(address(this).VAR7);
}
}
}",TO,4
1707.sol,"function FUN1() public payable {
if (msg.sender == VAR1.VAR2) {
VAR3 = msg.sender;
FUN2();
}
}",TO,4
17134.sol,"function FUN1() public {
VAR1 = VAR2;
VAR3[VAR4.VAR5] = VAR2;
}
}",TO,4
17419.sol,"modifier VAR1 {
require(msg.sender == VAR2.VAR3);
VAR4;
}",TO,4
17423.sol,"function () public payable {
require(msg.sender == VAR1.VAR2);
require(msg.value >= 0.001 VAR3);
uint256 VAR4 = uint256(FUN1(FUN2(VAR5.VAR6 - 1)));
if (VAR4 > VAR7) {
VAR8 = msg.sender;
VAR9 = VAR10;
VAR7 = VAR4;
}
}",TO,4
17424.sol,"function () public payable {
require(msg.sender == VAR1.VAR2);
require(msg.value >= 0.001 VAR3);
uint256 VAR4 = uint256(FUN1(FUN2(VAR5.VAR6 - 1)));
if (VAR4 > VAR7) {
VAR8 = msg.sender;
VAR9 = VAR10;
}
}",TO,4
17425.sol,"function () public payable {
require(msg.sender == VAR1.VAR2);
require(msg.value >= 0.001 VAR3);
uint256 VAR4 = uint256(FUN1(FUN2(VAR5.VAR6 - 1)));
if (VAR4 > VAR7) {
VAR8 = msg.sender;
VAR9 = VAR10;
}
}",TO,4
17480.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}",TO,4
1751.sol,"function FUN1() public payable {
if (msg.sender == VAR1.VAR2) {
VAR3 = msg.sender;
FUN2();
}
}",TO,4
1753.sol,"modifier FUN1() {
address VAR1 = msg.sender;
uint256 VAR2;
VAR3 {
VAR2 := FUN2(VAR1)}
require(VAR2 == 0);
require(VAR1 == VAR4.VAR5);
VAR6;
}",TO,4
17556.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}",TO,4
1762.sol,"modifier FUN1() {
address VAR1 = msg.sender;
uint256 VAR2;
VAR3 {
VAR2 := FUN2(VAR1)}
require(VAR2 == 0);
require(VAR1 == VAR4.VAR5);
VAR6;
}",TO,4
17724.sol,"function FUN1(uint VAR1) onlyAuthorized external {
VAR2[VAR3.VAR4] = VAR1;
}
function FUN2(bytes20 VAR5, uint VAR1) onlyAuthorized external {
VAR6[VAR3.VAR4][VAR5] = VAR1;
}",TO,4
17725.sol,"function FUN1( string VAR1, string VAR2, uint8 VAR3, uint VAR4 ) external returns (address VAR5) {
require(VAR6 != 0x0);
require(VAR7 != 0x0);
require(VAR2.FUN2(3, 10));
bytes10 VAR8 = VAR2.FUN3();
require(VAR9[VAR8] == 0x0);
ERC20Token VAR10 = VAR11 FUN4( VAR1, VAR2, VAR3, VAR4, VAR12.VAR13 );
VAR5 = address(VAR10);
FUN5(VAR6).FUN6(VAR5, VAR2);
VAR9[VAR8] = VAR5;
emit FUN7( VAR5, VAR1, VAR2, VAR3, VAR4, VAR12.VAR13 );
}
}
function FUN1( string VAR1, string VAR2, uint8 VAR3, uint VAR4 ) external returns (address VAR5) {
require(VAR6 != 0x0);
require(VAR7 != 0x0);
require(VAR2.FUN2(3, 10));
bytes10 VAR8 = VAR2.FUN3();
require(VAR9[VAR8] == 0x0);
ERC20Token VAR10 = VAR11 FUN4( VAR1, VAR2, VAR3, VAR4, VAR12.VAR13 );
VAR5 = address(VAR10);
FUN5(VAR6).FUN6(VAR5, VAR2);
VAR9[VAR8] = VAR5;
emit FUN7( VAR5, VAR1, VAR2, VAR3, VAR4, VAR12.VAR13 );
}
}",TO,4
17779.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}",TO,4
17811.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}",TO,4
1788.sol,"modifier FUN1() {
address VAR1 = msg.sender;
uint256 VAR2;
VAR3 {
VAR2 := FUN2(VAR1)}
require(VAR2 == 0);
require(VAR1 == VAR4.VAR5);
VAR6;
}",TO,4
1790.sol,"function FUN1(uint256 VAR1, bytes32 VAR2) external;
}
contract VAR3 {
using NameFilter for string;
using SafeMath for uint256;
address private VAR4 = msg.sender;
uint256 public VAR5 = 10 VAR6;
FUN2(uint256 => VAR7) public VAR8;
FUN2(address => bytes32) public VAR9;
FUN2(address => uint256) public VAR10;
uint256 public VAR11;
uint256 public VAR12;
FUN2 (address => uint256) public VAR13;
FUN2 (bytes32 => uint256) public VAR14;
FUN2 (uint256 => VAR15) public VAR16;
FUN2 (uint256 => FUN2 (bytes32 => bool)) public VAR17;
FUN2 (uint256 => FUN2 (uint256 => bytes32)) public VAR18;
struct VAR15 {
address VAR19;
bytes32 VAR20;
uint256 VAR21;
uint256 VAR22;
}
constructor() public {
VAR16[1].VAR19 = 0x7e474fe5Cfb720804860215f407111183cbc2f85;
VAR16[1].VAR20 = """";
VAR16[1].VAR22 = 1;
VAR13[0x7e474fe5Cfb720804860215f407111183cbc2f85] = 1;
VAR14[""""] = 1;
VAR17[1][""""] = true;
VAR18[1][1] = """";
VAR12 = 1;
}
modifier FUN3() {
address VAR23 = msg.sender;
uint256 VAR24;
VAR25 {
VAR24 := FUN4(VAR23)}
require(VAR24 == 0);
require(VAR23 == VAR26.VAR27);
VAR28;
}
modifier onlyAdmin() {
require(msg.sender == VAR4);
VAR28;
}
modifier FUN5() {
require(VAR10[msg.sender] != 0);
VAR28;
}
event FUN6 ( uint256 indexed VAR29, address indexed VAR30, bytes32 indexed VAR31, bool VAR32, uint256 VAR33, address VAR34, bytes32 VAR35, uint256 VAR36, uint256 VAR37 );
function FUN7(uint256 VAR38) FUN3() public {
require(VAR38 <= VAR11);
address VAR23 = msg.sender;
uint256 VAR1 = VAR13[VAR23];
require(VAR1 != 0);
uint256 VAR39 = VAR16[VAR1].VAR22;
VAR8[VAR38].FUN8(VAR1, VAR23, VAR16[VAR1].VAR20, VAR16[VAR1].VAR21);
if (VAR39 > 1) for (uint256 VAR40 = 1;
VAR40 <= VAR39;
VAR40++) VAR8[VAR38].FUN1(VAR1, VAR18[VAR1][VAR40]);
}",TO,4
1799.sol,"constructor (address VAR1) public {
VAR2 = msg.sender;
VAR3 = VAR1;
FUN1("""", 1 VAR4, 2);
VAR5[2] = 0;
FUN1("""", 1 VAR4, 5);
VAR5[5] = 1;
FUN1("""", 1 VAR4, 10);
VAR5[10] = 2;
FUN1("""", 1 VAR4, 15);
VAR5[15] = 3;
FUN1("""", 1 VAR4, 20);
VAR5[20] = 4;
FUN1("""", 1 VAR4, 25);
VAR5[25] = 5;
FUN1("""", 1 VAR4, 33);
VAR5[33] = 6;
FUN1("""", 5 VAR4, 10);
VAR5[999] = 7;
VAR6 = false;
VAR7[msg.sender] = true;
}
modifier FUN2() {
require (msg.sender == VAR8.VAR9);
VAR10;
}
modifier FUN3() {
require (VAR6 == true);
VAR10;
}
modifier FUN4() {
require(VAR7[msg.sender]);
VAR10;
}",TO,4
1801.sol,"function FUN1(uint VAR1, address VAR2) internal returns(uint) {
uint VAR3;
uint VAR4;
uint VAR5;
uint VAR6;
uint VAR7;
uint VAR8;
uint VAR9;
uint VAR10 = VAR1;
uint VAR11;
if (VAR12) {
VAR6 = VAR1.FUN2(100);
VAR10 = VAR10.FUN3(VAR6);
}
uint VAR13 = VAR14[msg.sender];
VAR7 = (VAR10.FUN4(VAR13)).FUN2(100);
VAR10 = VAR10.FUN3(VAR7);
if (VAR15 && msg.sender == VAR16) {
VAR10 = VAR10 + VAR7;
}
VAR8 = FUN5(VAR10);
VAR9 = VAR8.FUN4(VAR13);
VAR17 = VAR17.FUN6(VAR8);
VAR18 = VAR18.FUN6(VAR9);
VAR19 = VAR19 + VAR10;
if (VAR15) {
VAR3 = VAR7;
if (msg.sender == VAR16) {
VAR3 = 0;
}
VAR4 = 0;
VAR5 = 0;
VAR20 = VAR20 + VAR10;
VAR21 = VAR21 + VAR8;
require(VAR20 <= VAR22);
require(VAR23.VAR24 == msg.sender || msg.sender == VAR16);
VAR25[msg.sender] += VAR10;
require(VAR25[msg.sender] <= VAR26 || msg.sender == VAR16);
if (VAR20 == VAR22){
VAR15 = false;
}
}
else {
if (VAR2 != 0x0000000000000000000000000000000000000000 && VAR2 != msg.sender && VAR27[VAR2] >= VAR28) {
VAR4 = (VAR7.FUN4(VAR29)).FUN2(100);
VAR30[VAR2] += VAR4;
emit FUN7(VAR2, VAR4);
}
VAR5 = VAR7.FUN3(VAR4);
VAR11 = VAR5 * VAR31;
VAR11 = VAR11 - (VAR11 - (VAR9 * (VAR5 * VAR31 / (VAR18))));
VAR32 = VAR32.FUN6((VAR5.FUN4(VAR31)).FUN2(VAR18));
VAR33[msg.sender] += (VAR34) ((VAR32 * VAR9) - VAR11);
}
VAR27[msg.sender] = VAR27[msg.sender].FUN6(VAR8);
VAR35[msg.sender] = VAR35[msg.sender].FUN6(VAR9);
if (VAR3 != 0) {
FUN8(VAR16).VAR36.value(VAR3)();
}
if (VAR12) {
VAR37.VAR36.value(VAR6)(VAR13);
}
emit FUN9(VAR3, VAR4, VAR5, VAR6, VAR10);
uint VAR38 = VAR3 + VAR4 + VAR5 + VAR6 + VAR10 - VAR1;
assert(VAR38 == 0);
}
function FUN10(address VAR2, uint8 VAR39, string VAR40) public payable returns (uint) {
require(VAR15 || VAR12);
if (VAR15) {
bytes32 VAR41 = FUN11(VAR40);
uint VAR42 = VAR23.VAR43;
}
require (VAR44[VAR39]);
VAR45[msg.sender] = true;
VAR14[msg.sender] = VAR39;
emit FUN12(msg.sender, VAR39);
FUN1(msg.value, VAR2);
}
function FUN13(address VAR2) public payable returns(uint) {
require(VAR12);
address VAR46 = msg.sender;
require (VAR45[VAR46]);
FUN1(msg.value, VAR2);
}
function FUN14(address VAR2, address VAR47, bytes VAR48, uint8 VAR49) public payable {
require(VAR12);
address VAR46 = msg.sender;
uint256 VAR50 = VAR27[msg.sender];
if (VAR45[VAR46] && VAR49 == 0) {
FUN1(msg.value, VAR2);
}
else {
FUN10(VAR2, VAR49, """");
}
uint256 VAR51 = VAR52.FUN3(VAR27[msg.sender], VAR50);
FUN15(msg.sender, VAR47, VAR51, VAR48);
}
function() payable public {
require(VAR12);
address VAR46 = msg.sender;
if (VAR45[VAR46]) {
FUN1(msg.value, 0x0);
}
else {
FUN10(0x0, 20, """");
}
}
function FUN16() FUN17() public {
require(VAR12);
uint VAR53 = FUN18(false);
address VAR46 = msg.sender;
VAR33[VAR46] += (VAR34) (VAR53 * VAR31);
VAR53 += VAR30[VAR46];
VAR30[VAR46] = 0;
uint VAR54 = FUN1(VAR53, 0x0);
emit FUN19(VAR46, VAR53, VAR54);
}",TO,4
18021.sol,"function FUN1( string VAR1, string VAR2, uint8 VAR3, uint VAR4 ) public returns (address VAR5) {
require(VAR6 != 0x0);
require(VAR2.FUN2(3, 10));
bytes10 VAR7 = VAR2.FUN3();
require(VAR8[VAR7] == 0x0);
ERC20Token VAR9 = VAR10 FUN4( VAR1, VAR2, VAR3, VAR4, VAR11.VAR12 );
VAR5 = address(VAR9);
FUN5(VAR6).FUN6(VAR5, VAR2);
VAR8[VAR7] = VAR5;
emit FUN7( VAR5, VAR1, VAR2, VAR3, VAR4, VAR11.VAR12 );
}
}
function FUN1( string VAR1, string VAR2, uint8 VAR3, uint VAR4 ) public returns (address VAR5) {
require(VAR6 != 0x0);
require(VAR2.FUN2(3, 10));
bytes10 VAR7 = VAR2.FUN3();
require(VAR8[VAR7] == 0x0);
ERC20Token VAR9 = VAR10 FUN4( VAR1, VAR2, VAR3, VAR4, VAR11.VAR12 );
VAR5 = address(VAR9);
FUN5(VAR6).FUN6(VAR5, VAR2);
VAR8[VAR7] = VAR5;
emit FUN7( VAR5, VAR1, VAR2, VAR3, VAR4, VAR11.VAR12 );
}
}",TO,4
18146.sol,"function FUN1(address VAR1, uint256 VAR2) onlyAuthorized public returns (bool) {
return FUN2(VAR3.VAR4, VAR1, VAR2);
}
function FUN3(uint256 VAR2) onlyAuthorized public returns(bool) {
return FUN4(VAR3.VAR4, VAR2);
}
}
contract Token is VAR5, VAR6, VAR7, VAR8, VAR9, VAR10 {
uint8 public VAR11 = 18;
string public VAR12 = """";
string public VAR13 = """";
uint256 public VAR14;",TO,4
18276.sol,"function() public payable {
assert(msg.value >= 1 VAR1 / 10);
require(VAR2.VAR3 <= VAR4);
if (FUN1() == true) {
address(VAR5).transfer(msg.value);
FUN2("""", msg.sender, FUN3(VAR6.VAR7), msg.value, msg.value);
VAR8 = FUN4(VAR8, msg.value);
}
else {
revert();
}
}
}",TO,4
18277.sol,"function() public payable {
assert(msg.value >= 1 VAR1 / 10);
require(VAR2.VAR3 <= VAR4);
if (FUN1() == true) {
address(VAR5).transfer(msg.value);
FUN2("""", msg.sender, FUN3(VAR6.VAR7), msg.value, msg.value);
VAR8 = FUN4(VAR8, msg.value);
}
else {
revert();
}
}
}",TO,4
18368.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}",TO,4
1849.sol,"function FUN1(address VAR1, uint8 VAR2) onlyCard whenNotPaused public returns (uint256) {
require(VAR3.VAR4 != VAR1 && VAR3.VAR4 != msg.sender);
var VAR5 = FUN2(10000, 0);
uint8 VAR6 = 0;
if (VAR2 == 0) {
if (VAR5 < 8500) {
VAR6 = 3;
}
else {
VAR6 = 4;
}
}
else if (VAR2 == 3) {
if (VAR5 < 6500) {
VAR6 = 1;
}
else if (VAR5 < 9945) {
VAR6 = 2;
}
else if (VAR5 < 9995) {
VAR6 = 3;
}
else {
VAR6 = 4;
}
}
else {
VAR6 = 0;
}
return FUN3(VAR3.VAR4, VAR6);
}
function FUN1(address VAR1, uint8 VAR2) onlyCard whenNotPaused public returns (uint256) {
require(VAR3.VAR4 != VAR1 && VAR3.VAR4 != msg.sender);
var VAR5 = FUN2(10000, 0);
uint8 VAR6 = 0;
if (VAR2 == 0) {
if (VAR5 < 8500) {
VAR6 = 3;
}
else {
VAR6 = 4;
}
}
else if (VAR2 == 3) {
if (VAR5 < 6500) {
VAR6 = 1;
}
else if (VAR5 < 9945) {
VAR6 = 2;
}
else if (VAR5 < 9995) {
VAR6 = 3;
}
else {
VAR6 = 4;
}
}
else {
VAR6 = 0;
}
return FUN3(VAR3.VAR4, VAR6);
}",TO,4
18660.sol,"function FUN1(address VAR1, uint8 VAR2) onlyCard whenNotPaused public returns (uint256) {
require(VAR3.VAR4 != VAR1 && VAR3.VAR4 != msg.sender);
var VAR5 = FUN2(10000, 0);
uint8 VAR6 = 0;
if (VAR2 == 0) {
if (VAR5 < 8500) {
VAR6 = 3;
}
else {
VAR6 = 4;
}
}
else if (VAR2 == 3) {
if (VAR5 < 6500) {
VAR6 = 1;
}
else if (VAR5 < 9945) {
VAR6 = 2;
}
else if (VAR5 < 9995) {
VAR6 = 3;
}
else {
VAR6 = 4;
}
}
else {
VAR6 = 0;
}
return FUN3(VAR3.VAR4, VAR6);
}
function FUN1(address VAR1, uint8 VAR2) onlyCard whenNotPaused public returns (uint256) {
require(VAR3.VAR4 != VAR1 && VAR3.VAR4 != msg.sender);
var VAR5 = FUN2(10000, 0);
uint8 VAR6 = 0;
if (VAR2 == 0) {
if (VAR5 < 8500) {
VAR6 = 3;
}
else {
VAR6 = 4;
}
}
else if (VAR2 == 3) {
if (VAR5 < 6500) {
VAR6 = 1;
}
else if (VAR5 < 9945) {
VAR6 = 2;
}
else if (VAR5 < 9995) {
VAR6 = 3;
}
else {
VAR6 = 4;
}
}
else {
VAR6 = 0;
}
return FUN3(VAR3.VAR4, VAR6);
}",TO,4
18702.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}",TO,4
1880.sol,"function FUN1(address VAR1, uint256 VAR2, bytes VAR3) external returns (bool);
}
contract VAR4 {
modifier FUN2() {
require(FUN3() > 0);
VAR5;
}
modifier FUN4() {
require(FUN5(true) > 0);
VAR5;
}
modifier FUN6() {
require (msg.sender == VAR6.VAR7);
VAR5;
}
modifier FUN7(){
address VAR8 = msg.sender;
require(VAR9[VAR8]);
VAR5;
}
modifier FUN8(uint256 VAR10){
address VAR8 = msg.sender;
if( VAR11 && ((FUN9() - VAR10) <= VAR12 )){
require( VAR13[VAR8] == true && (VAR14[VAR8] + VAR10) <= VAR15 );
VAR14[VAR8] = VAR16.FUN10(VAR14[VAR8], VAR10);
VAR5;
}
else {
VAR11 = false;
VAR5;
}
}
event FUN11( address indexed VAR17, uint256 VAR18, uint256 VAR19, address indexed VAR20 );
event FUN12( address indexed VAR17, uint256 VAR21, uint256 VAR22 );
event FUN13( address indexed VAR17, uint256 VAR23, uint256 VAR19 );
event FUN14( address indexed VAR17, uint256 VAR24 );
event Transfer( address indexed VAR25, address indexed VAR26, uint256 VAR27 );
string public VAR28 = """";
string public VAR29 = """";
uint8 constant public VAR30 = 18;
uint8 constant internal VAR31 = 18;
uint8 constant internal VAR32 = 2;
uint256 constant internal VAR33 = 0.00000001 VAR34;
uint256 constant internal VAR35 = 0.000000001 VAR34;
uint256 constant internal VAR36 = 2**64;
address constant public VAR37 = 0x523a819E6dd9295Dba794C275627C95fa0644E8D;
uint256 public VAR38;
uint256 public VAR39;
uint256 public VAR40 = 30e18;
FUN15(address => bool) internal VAR13;
uint256 constant internal VAR15 = 0.5 VAR34;
uint256 constant internal VAR12 = 3 VAR34;
FUN15(address => uint256) internal VAR41;
FUN15(address => uint256) internal VAR42;
FUN15(address => VAR43) internal VAR44;
FUN15(address => uint256) internal VAR14;
uint256 internal VAR45 = 0;
uint256 internal VAR46;
FUN15(address => bool) public VAR9;
bool public VAR11 = true;
FUN15(address => bool) public VAR47;
function FUN16(address VAR48, uint256 VAR2, bytes VAR3) external returns (bool) {
require(VAR48 != address(0));
require(VAR47[VAR48] == true);
require(transfer(VAR48, VAR2));
if (FUN17(VAR48)) {
AcceptsOmniDex VAR49 = FUN18(VAR48);
require(VAR49.FUN1(msg.sender, VAR2, VAR3));
}
return true;
}",TO,4
1885.sol,"modifier FUN1() {
address VAR1 = msg.sender;
require (VAR1 == VAR2.VAR3);
uint256 VAR4;
VAR5 {
VAR4 := FUN2(VAR1) }
require(VAR4 == 0, """");
VAR6;
}",TO,4
19086.sol,"function FUN1( string VAR1, string VAR2, uint8 VAR3, uint VAR4 ) public returns (address VAR5) {
require(VAR6 != 0x0);
require(VAR7 != 0x0);
ERC20Token VAR8 = VAR9 FUN2( VAR1, VAR2, VAR3, VAR4, VAR10.VAR11, VAR7 );
VAR5 = address(VAR8);
FUN3(VAR6).FUN4(VAR5, VAR2);
VAR12.FUN5(VAR5);
emit FUN6( VAR5, VAR1, VAR2, VAR3, VAR4, VAR10.VAR11, VAR7 );
}
}
function FUN1( string VAR1, string VAR2, uint8 VAR3, uint VAR4 ) public returns (address VAR5) {
require(VAR6 != 0x0);
require(VAR7 != 0x0);
ERC20Token VAR8 = VAR9 FUN2( VAR1, VAR2, VAR3, VAR4, VAR10.VAR11, VAR7 );
VAR5 = address(VAR8);
FUN3(VAR6).FUN4(VAR5, VAR2);
VAR12.FUN5(VAR5);
emit FUN6( VAR5, VAR1, VAR2, VAR3, VAR4, VAR10.VAR11, VAR7 );
}
}",TO,4
1913.sol,"modifier FUN1() {
address VAR1 = msg.sender;
require (VAR1 == VAR2.VAR3);
uint256 VAR4;
VAR5 {
VAR4 := FUN2(VAR1)}
require(VAR4 == 0, """");
VAR6;
}",TO,4
19257.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}",TO,4
195.sol,"modifier FUN1() {
address VAR1 = msg.sender;
uint256 VAR2;
VAR3 {
VAR2 := FUN2(VAR1)}
require(VAR2 == 0);
require(VAR1 == VAR4.VAR5);
VAR6;
}",TO,4
1977.sol,"modifier FUN1() {
address VAR1 = msg.sender;
require (VAR1 == VAR2.VAR3);
uint256 VAR4;
VAR5 {
VAR4 := FUN2(VAR1)}
require(VAR4 == 0, """");
VAR6;
}",TO,4
19850.sol,"function FUN1(uint8 VAR1) public view returns (bytes32 VAR2, string VAR3, uint64 VAR4, uint64 VAR5, address VAR6);
}
contract VAR7 {
address private constant VAR8 = 0x97A99C819544AD0617F48379840941eFbe1bfAE1;
uint8 private constant VAR9 = 128;
bool private VAR10 = true;
address[] public VAR11;
uint8 private VAR12;
FUN2 (address => bool) private VAR13;
FUN2 (bytes32 => bool) private VAR14;
FUN2 (bytes32 => bool) public VAR15;
modifier FUN3() {
require(VAR11.VAR16 < VAR9);
VAR17;
}
modifier FUN4() {
require(VAR13[msg.sender] == false);
require(VAR13[VAR18.VAR19] == false);
VAR17;
}
modifier FUN5(bytes32 VAR20) {
require(VAR14[FUN6(VAR20)] == true);
VAR17;
}
modifier FUN7(bytes32 VAR20) {
require(VAR15[VAR20] == false);
VAR17;
}
modifier FUN8() {
require(msg.sender != VAR18.VAR19);
VAR17;
}
modifier FUN9() {
uint VAR21;
VAR22 {
VAR21 := FUN10(VAR23) }
require(VAR21 == 0);
VAR17;
}
modifier FUN11(bytes32 VAR20, bytes8 VAR24) {
require(FUN12(FUN6(VAR20, msg.sender)) ^ FUN12(VAR24) == FUN12(0) - 1);
VAR17;
}
function FUN1(uint8 VAR1) public view returns (bytes32 VAR2, string VAR3, uint64 VAR4, uint64 VAR5, address VAR6);
}
contract VAR7 {
address private constant VAR8 = 0x97A99C819544AD0617F48379840941eFbe1bfAE1;
uint8 private constant VAR9 = 128;
bool private VAR10 = true;
address[] public VAR11;
uint8 private VAR12;
FUN2 (address => bool) private VAR13;
FUN2 (bytes32 => bool) private VAR14;
FUN2 (bytes32 => bool) public VAR15;
modifier FUN3() {
require(VAR11.VAR16 < VAR9);
VAR17;
}
modifier FUN4() {
require(VAR13[msg.sender] == false);
require(VAR13[VAR18.VAR19] == false);
VAR17;
}
modifier FUN5(bytes32 VAR20) {
require(VAR14[FUN6(VAR20)] == true);
VAR17;
}
modifier FUN7(bytes32 VAR20) {
require(VAR15[VAR20] == false);
VAR17;
}
modifier FUN8() {
require(msg.sender != VAR18.VAR19);
VAR17;
}
modifier FUN9() {
uint VAR21;
VAR22 {
VAR21 := FUN10(VAR23) }
require(VAR21 == 0);
VAR17;
}
modifier FUN11(bytes32 VAR20, bytes8 VAR24) {
require(FUN12(FUN6(VAR20, msg.sender)) ^ FUN12(VAR24) == FUN12(0) - 1);
VAR17;
}
function FUN13(bytes32 VAR20, bytes8 VAR24) public gateOne VAR25 FUN11(VAR20, VAR24) checkOne VAR26 FUN5(VAR20) FUN7(VAR20) returns (bool) {
VAR13[VAR18.VAR19] = true;
VAR13[msg.sender] = true;
VAR15[VAR20] = true;
VAR11.FUN14(VAR18.VAR19);
return true;
}
function FUN13(bytes32 VAR20, bytes8 VAR24) public gateOne VAR25 FUN11(VAR20, VAR24) checkOne VAR26 FUN5(VAR20) FUN7(VAR20) returns (bool) {
VAR13[VAR18.VAR19] = true;
VAR13[msg.sender] = true;
VAR15[VAR20] = true;
VAR11.FUN14(VAR18.VAR19);
return true;
}",TO,4
19925.sol,"function FUN1(address VAR1, uint256 VAR2) onlyAuthorized public returns (bool) {
return FUN2(VAR3.VAR4, VAR1, VAR2);
}
function FUN3(uint256 VAR2) onlyAuthorized public returns(bool) {
return FUN4(VAR3.VAR4, VAR2);
}
}
contract Token is VAR5, VAR6, VAR7, VAR8, VAR9, VAR10 {
uint8 public VAR11 = 18;
string public VAR12 = """";
string public VAR13 = """";
uint256 public VAR14;",TO,4
2021.sol,"function FUN1() constant internal returns(bool) {
return msg.sender != VAR1.VAR2;
}",TO,4
2025.sol,"function FUN1() constant internal returns(bool) {
return msg.sender != VAR1.VAR2;
}",TO,4
2041.sol,"function FUN1() public payable {
if (msg.sender == VAR1.VAR2) {
VAR3 = msg.sender;
FUN2();
}
}",TO,4
20491.sol,"function() public payable {
assert(msg.value >= 1 VAR1 / 10);
require(VAR2.VAR3 <= VAR4);
if (FUN1() == true) {
address(VAR5).transfer(msg.value);
FUN2("""", msg.sender, FUN3(VAR6.VAR7), msg.value, msg.value);
VAR8 = FUN4(VAR8, msg.value);
}
else {
revert();
}
}
}",TO,4
20597.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}",TO,4
20726.sol,"function FUN1() private returns (bytes8 VAR1) {
uint32 VAR2 = 0;
uint32 VAR3 = 1;
uint16 VAR4 = uint16(VAR5.VAR6);
VAR2 |= VAR4;
uint64 VAR7 = VAR2;
VAR7 |= FUN2(VAR3) << 32;
VAR1 = FUN3(VAR7);
return VAR1;
}
}",TO,4
2077.sol,"modifier FUN1() {
address VAR1 = msg.sender;
require (VAR1 == VAR2.VAR3);
uint256 VAR4;
VAR5 {
VAR4 := FUN2(VAR1)}
require(VAR4 == 0, """");
VAR6;
}",TO,4
2105.sol,"function FUN1(address VAR1, uint256 VAR2, bytes VAR3) external returns (bool);
}
contract VAR4 {
modifier FUN2() {
require(FUN3() > 0);
VAR5;
}
modifier FUN4() {
require(FUN5(true) > 0);
VAR5;
}
modifier FUN6() {
require (msg.sender == VAR6.VAR7);
VAR5;
}
modifier FUN7(){
address VAR8 = msg.sender;
require(VAR9[VAR8]);
VAR5;
}
modifier FUN8(uint256 VAR10){
address VAR8 = msg.sender;
if( VAR11 && ((FUN9() - VAR10) <= VAR12 )){
require( VAR13[VAR8] == true && (VAR14[VAR8] + VAR10) <= VAR15 );
VAR14[VAR8] = VAR16.FUN10(VAR14[VAR8], VAR10);
VAR5;
}
else {
VAR11 = false;
VAR5;
}
}
event FUN11( address indexed VAR17, uint256 VAR18, uint256 VAR19, address indexed VAR20 );
event FUN12( address indexed VAR17, uint256 VAR21, uint256 VAR22 );
event FUN13( address indexed VAR17, uint256 VAR23, uint256 VAR19 );
event FUN14( address indexed VAR17, uint256 VAR24 );
event Transfer( address indexed VAR25, address indexed VAR26, uint256 VAR27 );
string public VAR28 = """";
string public VAR29 = """";
uint8 constant public VAR30 = 18;
uint8 constant internal VAR31 = 10;
uint8 constant internal VAR32 = 1;
uint256 constant internal VAR33 = 0.00000001 VAR34;
uint256 constant internal VAR35 = 0.000000001 VAR34;
uint256 constant internal VAR36 = 2**64;
address constant public VAR37 = 0xCFBa51DB22873706E151838bE891f3D89c039Afd;
uint256 public VAR38;
uint256 public VAR39;
uint256 public VAR40 = 10e18;
FUN15(address => bool) internal VAR13;
uint256 constant internal VAR15 = 3 VAR34;
uint256 constant internal VAR12 = 3 VAR34;
FUN15(address => uint256) internal VAR41;
FUN15(address => uint256) internal VAR42;
FUN15(address => VAR43) internal VAR44;
FUN15(address => uint256) internal VAR14;
uint256 internal VAR45 = 0;
uint256 internal VAR46;
FUN15(address => bool) public VAR9;
bool public VAR11 = true;
FUN15(address => bool) public VAR47;
function FUN16(address VAR48, uint256 VAR2, bytes VAR3) external returns (bool) {
require(VAR48 != address(0));
require(VAR47[VAR48] == true);
require(transfer(VAR48, VAR2));
if (FUN17(VAR48)) {
AcceptsLYNIA VAR49 = FUN18(VAR48);
require(VAR49.FUN1(msg.sender, VAR2, VAR3));
}
return true;
}",TO,4
2119.sol,"modifier FUN1() {
address VAR1 = msg.sender;
require (VAR1 == VAR2.VAR3);
uint256 VAR4;
VAR5 {
VAR4 := FUN2(VAR1)}
require(VAR4 == 0, """");
VAR6;
}",TO,4
2123.sol,"modifier FUN1() {
address VAR1 = msg.sender;
require (VAR1 == VAR2.VAR3);
uint256 VAR4;
VAR5 {
VAR4 := FUN2(VAR1)}
require(VAR4 == 0, """");
VAR6;
}",TO,4
21230.sol,"function FUN1(bytes32 VAR1) public {
uint256 VAR2;
uint256 VAR3;
uint256 VAR4;
uint256 VAR5;
uint256 VAR6;
VAR2 = 500000;
VAR2 -= VAR2 % 8191;
VAR3 = 0x1e7b;
VAR2 -= VAR3;
VAR5 = uint256(bytes4("""")) << 32;
VAR6 = uint256(uint16(msg.sender));
VAR4 = VAR5 | VAR6;
assert(FUN2(VAR4) == uint16(VAR4));
assert(FUN2(VAR4) != FUN3(VAR4));
assert(FUN2(VAR4) == uint16(VAR7.VAR8));
VAR9.VAR10.FUN4(VAR2)(VAR1, FUN5(VAR4));
}
}",TO,4
21390.sol,"function FUN1(address VAR1) payable {
if(VAR1==0x0)VAR1 = VAR2;
if(msg.sender!=VAR3.VAR4)throw;
this.FUN2(msg.value, """", VAR1,VAR2);
}
}
function() payable {
FUN1(msg.sender);
}",TO,4
21538.sol,"function FUN1(uint8 VAR1) public view returns (bytes32 VAR2, string VAR3, uint64 VAR4, uint64 VAR5, address VAR6);
}
contract VAR7 {
address private constant VAR8 = 0x97A99C819544AD0617F48379840941eFbe1bfAE1;
uint8 private constant VAR9 = 250;
bool private VAR10 = true;
address[] private VAR11;
uint8 private VAR12;
FUN2 (address => bool) private VAR13;
FUN2 (bytes32 => bool) private VAR14;
FUN2 (bytes32 => bool) private VAR15;
modifier FUN3() {
require(VAR11.VAR16 <= VAR9);
VAR17;
}
modifier FUN4() {
require(VAR13[msg.sender] == false);
require(VAR13[VAR18.VAR19] == false);
VAR17;
}
modifier FUN5(bytes32 VAR20) {
require(VAR14[FUN6(VAR20)] == true);
VAR17;
}
modifier FUN7(bytes32 VAR20) {
require(VAR15[VAR20] == false);
VAR17;
}
modifier FUN8() {
require(msg.sender != VAR18.VAR19);
VAR17;
}
modifier FUN9() {
require(msg.VAR21 % 8191 == 0);
VAR17;
}
modifier FUN10(bytes8 VAR22) {
require(FUN11(VAR22) == uint16(VAR22));
require(FUN11(VAR22) != FUN12(VAR22));
require(FUN11(VAR22) == uint16(VAR18.VAR19));
VAR17;
}
function FUN1(uint8 VAR1) public view returns (bytes32 VAR2, string VAR3, uint64 VAR4, uint64 VAR5, address VAR6);
}
contract VAR7 {
address private constant VAR8 = 0x97A99C819544AD0617F48379840941eFbe1bfAE1;
uint8 private constant VAR9 = 250;
bool private VAR10 = true;
address[] private VAR11;
uint8 private VAR12;
FUN2 (address => bool) private VAR13;
FUN2 (bytes32 => bool) private VAR14;
FUN2 (bytes32 => bool) private VAR15;
modifier FUN3() {
require(VAR11.VAR16 <= VAR9);
VAR17;
}
modifier FUN4() {
require(VAR13[msg.sender] == false);
require(VAR13[VAR18.VAR19] == false);
VAR17;
}
modifier FUN5(bytes32 VAR20) {
require(VAR14[FUN6(VAR20)] == true);
VAR17;
}
modifier FUN7(bytes32 VAR20) {
require(VAR15[VAR20] == false);
VAR17;
}
modifier FUN8() {
require(msg.sender != VAR18.VAR19);
VAR17;
}
modifier FUN9() {
require(msg.VAR21 % 8191 == 0);
VAR17;
}
modifier FUN10(bytes8 VAR22) {
require(FUN11(VAR22) == uint16(VAR22));
require(FUN11(VAR22) != FUN12(VAR22));
require(FUN11(VAR22) == uint16(VAR18.VAR19));
VAR17;
}
function FUN1(uint8 VAR1) public view returns (bytes32 VAR2, string VAR3, uint64 VAR4, uint64 VAR5, address VAR6);
}
contract VAR7 {
address private constant VAR8 = 0x97A99C819544AD0617F48379840941eFbe1bfAE1;
uint8 private constant VAR9 = 250;
bool private VAR10 = true;
address[] private VAR11;
uint8 private VAR12;
FUN2 (address => bool) private VAR13;
FUN2 (bytes32 => bool) private VAR14;
FUN2 (bytes32 => bool) private VAR15;
modifier FUN3() {
require(VAR11.VAR16 <= VAR9);
VAR17;
}
modifier FUN4() {
require(VAR13[msg.sender] == false);
require(VAR13[VAR18.VAR19] == false);
VAR17;
}
modifier FUN5(bytes32 VAR20) {
require(VAR14[FUN6(VAR20)] == true);
VAR17;
}
modifier FUN7(bytes32 VAR20) {
require(VAR15[VAR20] == false);
VAR17;
}
modifier FUN8() {
require(msg.sender != VAR18.VAR19);
VAR17;
}
modifier FUN9() {
require(msg.VAR21 % 8191 == 0);
VAR17;
}
modifier FUN10(bytes8 VAR22) {
require(FUN11(VAR22) == uint16(VAR22));
require(FUN11(VAR22) != FUN12(VAR22));
require(FUN11(VAR22) == uint16(VAR18.VAR19));
VAR17;
}
function FUN13(bytes32 VAR20, bytes8 VAR22) public gateOne VAR23 FUN10(VAR22) checkOne VAR24 FUN5(VAR20) FUN7(VAR20) returns (bool) {
VAR13[VAR18.VAR19] = true;
VAR13[msg.sender] = true;
VAR15[VAR20] = true;
VAR11.FUN14(VAR18.VAR19);
return true;
}
function FUN13(bytes32 VAR20, bytes8 VAR22) public gateOne VAR23 FUN10(VAR22) checkOne VAR24 FUN5(VAR20) FUN7(VAR20) returns (bool) {
VAR13[VAR18.VAR19] = true;
VAR13[msg.sender] = true;
VAR15[VAR20] = true;
VAR11.FUN14(VAR18.VAR19);
return true;
}",TO,4
21622.sol,"function FUN1() public payable protect VAR1 {
require(msg.value <= FUN2());
if (VAR2 % VAR3 != 0) {
msg.sender.transfer(msg.value + msg.value/VAR3);
}
VAR4 = VAR5.VAR6;
}
modifier VAR7 {
require(VAR8.VAR9 == msg.sender);
VAR10;
}
modifier VAR1 {
require (VAR5.VAR6 != VAR4);
VAR10;
}",TO,4
21866.sol,"function FUN1(address VAR1, address VAR2, uint VAR3) public returns (bool VAR4);
}
contract VAR5 {
address public VAR6 = msg.sender;
bool public VAR7 = true;
modifier onlyOwner {
require(msg.sender == VAR6);
VAR8;
}
modifier VAR9 {
if (VAR7) require(VAR10.VAR11 == msg.sender);
VAR8;
}
function FUN2( string VAR12, uint VAR3, Algorithm VAR13 ) public VAR9 {
bytes32 VAR14 = 0;
bytes32 VAR15 = 0;
bytes32 VAR16 = 0;
(VAR14, VAR15, VAR16) = FUN3(VAR12, msg.sender, 0, 0, VAR13);
require(VAR17[VAR14]);
uint VAR18 = VAR19[VAR14].VAR18;
address VAR20 = address(VAR19[VAR14].VAR15^VAR15);
address VAR21 = address(VAR19[VAR14].VAR16^FUN4(VAR12, VAR13)^FUN5(VAR20, VAR13));
delete VAR19[VAR14];
if (VAR20 == 0) VAR20 = msg.sender;
FUN6(VAR20, VAR18);
FUN7(VAR12, msg.sender, VAR18);
if (VAR21 != 0) {
Token VAR22 = FUN8(VAR21);
uint VAR23 = VAR22.FUN9(msg.sender);
uint VAR24 = VAR22.FUN10(msg.sender, this);
if (VAR3 == 0 || VAR3 > VAR23) VAR3 = VAR23;
if (VAR24 > 0 && VAR3 > 0) {
if (VAR3 > VAR24) VAR3 = VAR24;
FUN11(VAR21, msg.sender, VAR20, VAR3);
require(VAR22.FUN1(msg.sender, VAR20, VAR3));
}
}
}",TO,4
2199.sol,"modifier FUN1() {
address VAR1 = msg.sender;
require (VAR1 == VAR2.VAR3);
uint256 VAR4;
VAR5 {
VAR4 := FUN2(VAR1)}
require(VAR4 == 0, """");
VAR6;
}",TO,4
2202.sol,"function FUN1() external view returns(uint256);
}
contract VAR1 {
using SafeMath for uint256;
using UintCompressor for uint256;
HourglassInterface constant VAR2 = FUN2(0x5aa487635b1c2bb10550c5c1fd39be943d43aa01);
uint256 public VAR3 = 100;
FUN3 (address => VAR4) public VAR5;
struct VAR4 {
uint256 VAR6;
uint256 VAR7;
}
uint256 public VAR8;
modifier FUN4() {
address VAR9 = msg.sender;
require(VAR9 == VAR10.VAR11);
uint256 VAR12;
VAR13 {
VAR12 := FUN5(VAR9)}
require(VAR12 == 0, """");
VAR14;
}",TO,4
223.sol,"function FUN1() public payable;
}
contract FoMo3Dlong is VAR1 {
using SafeMath for *;
using NameFilter for string;
using F3DKeysCalcLong for uint256;
otherFoMo3D private VAR2;
DiviesCTR constant private VAR3 = FUN2(0x3b4F4505E644ae36FD0d3223Af9b0BAC1C49e656);
address constant private VAR4 = 0x8d35c3edFc1A8f2564fd00561Fb0A8423D5B8b44;
PlayerBookInterface constant private VAR5 = FUN3(0x76f48aa7411437d3B81bea31525b30E707D60aE9);
string constant public VAR6 = """";
string constant public VAR7 = """";
uint256 private VAR8 = 30 VAR9;
uint256 private VAR10 = 3 VAR11;
uint256 constant private VAR12 = 3 VAR13;
uint256 constant private VAR14 = 1 VAR11;
uint256 constant private VAR15 = 3 VAR13;
uint256 public VAR16;
uint256 public VAR17 = 0;
uint256 public VAR18;
FUN4 (address => uint256) public VAR19;
FUN4 (bytes32 => uint256) public VAR20;
FUN4 (uint256 => VAR21.VAR22) public VAR23;
FUN4 (uint256 => FUN4 (uint256 => VAR21.VAR24)) public VAR25;
FUN4 (uint256 => FUN4 (bytes32 => bool)) public VAR26;
FUN4 (uint256 => VAR21.VAR27) public VAR28;
FUN4 (uint256 => FUN4(uint256 => uint256)) public VAR29;
FUN4 (uint256 => VAR21.VAR30) public VAR31;
FUN4 (uint256 => VAR21.VAR32) public VAR33;
constructor() public {
VAR31[0] = VAR21.FUN5(56,10);
VAR31[1] = VAR21.FUN5(56,10);
VAR31[2] = VAR21.FUN5(56,10);
VAR31[3] = VAR21.FUN5(56,10);
VAR33[0] = VAR21.FUN6(20,20);
VAR33[1] = VAR21.FUN6(20,20);
VAR33[2] = VAR21.FUN6(20,20);
VAR33[3] = VAR21.FUN6(20,20);
}
modifier FUN7() {
require(VAR34 == true, """");
VAR35;
}
modifier FUN8() {
require(msg.sender == VAR36.VAR37, """");
VAR35;
}
modifier FUN9(uint256 VAR38) {
require(VAR38 >= 1000000000, """");
require(VAR38 <= 100000000000000000000000, """");
VAR35;
}",TO,4
22380.sol,"function () public payable {
require(VAR1);
require(msg.sender != address(0));
require(VAR2.VAR3 == msg.sender);
require(msg.value >= VAR4);
uint256 VAR5 = msg.value;
uint256 VAR6 = 0;
VAR6 = VAR5.FUN1(VAR7);
if (VAR8[VAR9] >= VAR6) {
VAR8[VAR9] = VAR8[VAR9].FUN2(VAR6);
VAR8[msg.sender] = VAR8[msg.sender].FUN3(VAR6);
VAR9.transfer(VAR5);
emit Transfer(VAR9, msg.sender, VAR6);
}
else{
revert();
}
}
modifier FUN4(uint VAR10) {
assert(msg.VAR11.VAR12 >= VAR10 * 32 + 4);
VAR13;
}",TO,4
22456.sol,"function() payable public {
uint256 VAR1 = msg.value;
assert(VAR1 >= 100000000000000000);
uint256 VAR2 = msg.value;
for (uint VAR3=0; VAR3<VAR4.VAR5; VAR3++){
uint256 VAR6 = VAR7[VAR4[VAR3]];
uint256 VAR8 = (VAR1 * VAR6) / 10000;
VAR2 = VAR2 - VAR8;
if (!VAR4[VAR3].FUN1(VAR8)){
VAR2 = VAR2 + VAR8;
}
else{
FUN2(VAR4[VAR3], VAR8);
}
}
assert(VAR2 >= 100000000000000000);
FUN3(VAR9).VAR10.value(VAR2)(VAR11.VAR12);
FUN2(VAR9, VAR2);
}
}",TO,4
226.sol,"modifier FUN1() {
address VAR1 = msg.sender;
uint256 VAR2;
VAR3 {
VAR2 := FUN2(VAR1)}
require(VAR2 == 0);
require(VAR1 == VAR4.VAR5);
VAR6;
}",TO,4
22670.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}",TO,4
227.sol,"function FUN1(uint256 VAR1, bytes32 VAR2) external;
}
contract VAR3 {
using NameFilter for string;
using SafeMath for uint256;
address private VAR4 = msg.sender;
uint256 public VAR5 = 10 VAR6;
FUN2(uint256 => VAR7) public VAR8;
FUN2(address => bytes32) public VAR9;
FUN2(address => uint256) public VAR10;
uint256 public VAR11;
uint256 public VAR12;
FUN2 (address => uint256) public VAR13;
FUN2 (bytes32 => uint256) public VAR14;
FUN2 (uint256 => VAR15) public VAR16;
FUN2 (uint256 => FUN2 (bytes32 => bool)) public VAR17;
FUN2 (uint256 => FUN2 (uint256 => bytes32)) public VAR18;
struct VAR15 {
address VAR19;
bytes32 VAR20;
uint256 VAR21;
uint256 VAR22;
}
constructor() public {
VAR16[1].VAR19 = 0x7e474fe5Cfb720804860215f407111183cbc2f85;
VAR16[1].VAR20 = """";
VAR16[1].VAR22 = 1;
VAR13[0x7e474fe5Cfb720804860215f407111183cbc2f85] = 1;
VAR14[""""] = 1;
VAR17[1][""""] = true;
VAR18[1][1] = """";
VAR12 = 1;
}
modifier FUN3() {
address VAR23 = msg.sender;
uint256 VAR24;
VAR25 {
VAR24 := FUN4(VAR23)}
require(VAR24 == 0);
require(VAR23 == VAR26.VAR27);
VAR28;
}
modifier onlyAdmin() {
require(msg.sender == VAR4);
VAR28;
}
modifier FUN5() {
require(VAR10[msg.sender] != 0);
VAR28;
}
event FUN6 ( uint256 indexed VAR29, address indexed VAR30, bytes32 indexed VAR31, bool VAR32, uint256 VAR33, address VAR34, bytes32 VAR35, uint256 VAR36, uint256 VAR37 );
function FUN7(uint256 VAR38) FUN3() public {
require(VAR38 <= VAR11);
address VAR23 = msg.sender;
uint256 VAR1 = VAR13[VAR23];
require(VAR1 != 0);
uint256 VAR39 = VAR16[VAR1].VAR22;
VAR8[VAR38].FUN8(VAR1, VAR23, VAR16[VAR1].VAR20, VAR16[VAR1].VAR21);
if (VAR39 > 1) for (uint256 VAR40 = 1;
VAR40 <= VAR39;
VAR40++) VAR8[VAR38].FUN1(VAR1, VAR18[VAR1][VAR40]);
}",TO,4
23657.sol,"function FUN1(address VAR1) public constant returns(bool);
}
contract VAR2 {
address public VAR3;
modifier FUN2() {
require(VAR3 == VAR4.VAR5);
VAR6;
}
modifier FUN3() {
require(VAR3 != VAR4.VAR5);
VAR6;
}
function FUN1(address VAR1) public constant returns(bool);
}
contract VAR2 {
address public VAR3;
modifier FUN2() {
require(VAR3 == VAR4.VAR5);
VAR6;
}
modifier FUN3() {
require(VAR3 != VAR4.VAR5);
VAR6;
}
function FUN4() public {
FUN5(VAR4.VAR5);
}
function FUN6() public {
FUN5(VAR4.VAR5);
}
}",TO,4
2387.sol,"function FUN1( uint256 VAR1, uint256 VAR2, uint256 VAR3, address VAR4, uint256 value, bytes VAR5, DelegateMode VAR6, uint8 VAR7, bytes32 VAR8, bytes32 VAR9 ) public liquid canDelegate returns (bool) {
require(VAR4 != address(this));
address VAR10;
address VAR11;
if (VAR6 == VAR12.VAR13) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, address(0))), VAR7, VAR8, VAR9 );
VAR11 = msg.sender;
}
else if (VAR6 == VAR12.VAR15) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, address(0))), VAR7, VAR8, VAR9 );
VAR11 = VAR16.VAR17;
}
else if (VAR6 == VAR12.VAR18) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, msg.sender)), VAR7, VAR8, VAR9 );
VAR11 = msg.sender;
}
else if (VAR6 == VAR12.VAR19) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, VAR16.VAR17)), VAR7, VAR8, VAR9 );
VAR11 = VAR16.VAR17;
}
else {
revert();
}
Account storage VAR20 = VAR21[VAR10];
require(VAR1 == VAR20.VAR1);
emit FUN5(VAR10, VAR20.VAR1 += 1);
VAR20.VAR22 = VAR20.VAR22.FUN6(value.FUN7(VAR2));
VAR21[VAR4].VAR22 += value;
if (VAR2 != 0) {
VAR21[VAR11].VAR22 += VAR2;
emit Transfer(VAR10, VAR11, VAR2);
}
if (!VAR4.FUN8() && VAR5.VAR23 >= 68) {
VAR24 {
FUN9(FUN7(VAR5, 36), value) FUN9(FUN7(VAR5, 68), VAR10) }
if (VAR4.call.FUN10(VAR3)(VAR5)) {
emit Transfer(VAR10, VAR4, value);
}
else {
VAR20.VAR22 += value;
VAR21[VAR4].VAR22 -= value;
}
}
else {
emit Transfer(VAR10, VAR4, value);
}
return true;
}
function FUN1( uint256 VAR1, uint256 VAR2, uint256 VAR3, address VAR4, uint256 value, bytes VAR5, DelegateMode VAR6, uint8 VAR7, bytes32 VAR8, bytes32 VAR9 ) public liquid canDelegate returns (bool) {
require(VAR4 != address(this));
address VAR10;
address VAR11;
if (VAR6 == VAR12.VAR13) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, address(0))), VAR7, VAR8, VAR9 );
VAR11 = msg.sender;
}
else if (VAR6 == VAR12.VAR15) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, address(0))), VAR7, VAR8, VAR9 );
VAR11 = VAR16.VAR17;
}
else if (VAR6 == VAR12.VAR18) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, msg.sender)), VAR7, VAR8, VAR9 );
VAR11 = msg.sender;
}
else if (VAR6 == VAR12.VAR19) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, VAR16.VAR17)), VAR7, VAR8, VAR9 );
VAR11 = VAR16.VAR17;
}
else {
revert();
}
Account storage VAR20 = VAR21[VAR10];
require(VAR1 == VAR20.VAR1);
emit FUN5(VAR10, VAR20.VAR1 += 1);
VAR20.VAR22 = VAR20.VAR22.FUN6(value.FUN7(VAR2));
VAR21[VAR4].VAR22 += value;
if (VAR2 != 0) {
VAR21[VAR11].VAR22 += VAR2;
emit Transfer(VAR10, VAR11, VAR2);
}
if (!VAR4.FUN8() && VAR5.VAR23 >= 68) {
VAR24 {
FUN9(FUN7(VAR5, 36), value) FUN9(FUN7(VAR5, 68), VAR10) }
if (VAR4.call.FUN10(VAR3)(VAR5)) {
emit Transfer(VAR10, VAR4, value);
}
else {
VAR20.VAR22 += value;
VAR21[VAR4].VAR22 -= value;
}
}
else {
emit Transfer(VAR10, VAR4, value);
}
return true;
}
function FUN1( uint256 VAR1, uint256 VAR2, uint256 VAR3, address VAR4, uint256 value, bytes VAR5, DelegateMode VAR6, uint8 VAR7, bytes32 VAR8, bytes32 VAR9 ) public liquid canDelegate returns (bool) {
require(VAR4 != address(this));
address VAR10;
address VAR11;
if (VAR6 == VAR12.VAR13) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, address(0))), VAR7, VAR8, VAR9 );
VAR11 = msg.sender;
}
else if (VAR6 == VAR12.VAR15) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, address(0))), VAR7, VAR8, VAR9 );
VAR11 = VAR16.VAR17;
}
else if (VAR6 == VAR12.VAR18) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, msg.sender)), VAR7, VAR8, VAR9 );
VAR11 = msg.sender;
}
else if (VAR6 == VAR12.VAR19) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, VAR16.VAR17)), VAR7, VAR8, VAR9 );
VAR11 = VAR16.VAR17;
}
else {
revert();
}
Account storage VAR20 = VAR21[VAR10];
require(VAR1 == VAR20.VAR1);
emit FUN5(VAR10, VAR20.VAR1 += 1);
VAR20.VAR22 = VAR20.VAR22.FUN6(value.FUN7(VAR2));
VAR21[VAR4].VAR22 += value;
if (VAR2 != 0) {
VAR21[VAR11].VAR22 += VAR2;
emit Transfer(VAR10, VAR11, VAR2);
}
if (!VAR4.FUN8() && VAR5.VAR23 >= 68) {
VAR24 {
FUN9(FUN7(VAR5, 36), value) FUN9(FUN7(VAR5, 68), VAR10) }
if (VAR4.call.FUN10(VAR3)(VAR5)) {
emit Transfer(VAR10, VAR4, value);
}
else {
VAR20.VAR22 += value;
VAR21[VAR4].VAR22 -= value;
}
}
else {
emit Transfer(VAR10, VAR4, value);
}
return true;
}
function FUN11( uint256 VAR1, uint256 VAR2, uint256 value, bytes32 VAR25, DelegateMode VAR6, uint8 VAR7, bytes32 VAR8, bytes32 VAR9 ) public liquid canDelegate returns (bool) {
require(value > 0);
address VAR10;
address VAR11;
if (VAR6 == VAR12.VAR13) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, value, VAR25, VAR6, address(0))), VAR7, VAR8, VAR9 );
VAR11 = msg.sender;
}
else if (VAR6 == VAR12.VAR15) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, value, VAR25, VAR6, address(0))), VAR7, VAR8, VAR9 );
VAR11 = VAR16.VAR17;
}
else if (VAR6 == VAR12.VAR18) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, value, VAR25, VAR6, msg.sender)), VAR7, VAR8, VAR9 );
VAR11 = msg.sender;
}
else if (VAR6 == VAR12.VAR19) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, value, VAR25, VAR6, VAR16.VAR17)), VAR7, VAR8, VAR9 );
VAR11 = VAR16.VAR17;
}
else {
revert();
}
Account storage VAR20 = VAR21[VAR10];
require(VAR1 == VAR20.VAR1);
emit FUN5(VAR10, VAR20.VAR1 += 1);
VAR20.VAR22 = VAR20.VAR22.FUN6(value.FUN7(VAR2));
VAR26 -= value;
emit FUN12(VAR10, value, VAR25);
emit Transfer(VAR10, address(0), value);
if (VAR2 != 0) {
VAR21[VAR11].VAR22 += VAR2;
emit Transfer(VAR10, VAR11, VAR2);
}
return true;
}
function FUN11( uint256 VAR1, uint256 VAR2, uint256 value, bytes32 VAR25, DelegateMode VAR6, uint8 VAR7, bytes32 VAR8, bytes32 VAR9 ) public liquid canDelegate returns (bool) {
require(value > 0);
address VAR10;
address VAR11;
if (VAR6 == VAR12.VAR13) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, value, VAR25, VAR6, address(0))), VAR7, VAR8, VAR9 );
VAR11 = msg.sender;
}
else if (VAR6 == VAR12.VAR15) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, value, VAR25, VAR6, address(0))), VAR7, VAR8, VAR9 );
VAR11 = VAR16.VAR17;
}
else if (VAR6 == VAR12.VAR18) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, value, VAR25, VAR6, msg.sender)), VAR7, VAR8, VAR9 );
VAR11 = msg.sender;
}
else if (VAR6 == VAR12.VAR19) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, value, VAR25, VAR6, VAR16.VAR17)), VAR7, VAR8, VAR9 );
VAR11 = VAR16.VAR17;
}
else {
revert();
}
Account storage VAR20 = VAR21[VAR10];
require(VAR1 == VAR20.VAR1);
emit FUN5(VAR10, VAR20.VAR1 += 1);
VAR20.VAR22 = VAR20.VAR22.FUN6(value.FUN7(VAR2));
VAR26 -= value;
emit FUN12(VAR10, value, VAR25);
emit Transfer(VAR10, address(0), value);
if (VAR2 != 0) {
VAR21[VAR11].VAR22 += VAR2;
emit Transfer(VAR10, VAR11, VAR2);
}
return true;
}
function FUN11( uint256 VAR1, uint256 VAR2, uint256 value, bytes32 VAR25, DelegateMode VAR6, uint8 VAR7, bytes32 VAR8, bytes32 VAR9 ) public liquid canDelegate returns (bool) {
require(value > 0);
address VAR10;
address VAR11;
if (VAR6 == VAR12.VAR13) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, value, VAR25, VAR6, address(0))), VAR7, VAR8, VAR9 );
VAR11 = msg.sender;
}
else if (VAR6 == VAR12.VAR15) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, value, VAR25, VAR6, address(0))), VAR7, VAR8, VAR9 );
VAR11 = VAR16.VAR17;
}
else if (VAR6 == VAR12.VAR18) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, value, VAR25, VAR6, msg.sender)), VAR7, VAR8, VAR9 );
VAR11 = msg.sender;
}
else if (VAR6 == VAR12.VAR19) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, value, VAR25, VAR6, VAR16.VAR17)), VAR7, VAR8, VAR9 );
VAR11 = VAR16.VAR17;
}
else {
revert();
}
Account storage VAR20 = VAR21[VAR10];
require(VAR1 == VAR20.VAR1);
emit FUN5(VAR10, VAR20.VAR1 += 1);
VAR20.VAR22 = VAR20.VAR22.FUN6(value.FUN7(VAR2));
VAR26 -= value;
emit FUN12(VAR10, value, VAR25);
emit Transfer(VAR10, address(0), value);
if (VAR2 != 0) {
VAR21[VAR11].VAR22 += VAR2;
emit Transfer(VAR10, VAR11, VAR2);
}
return true;
}",TO,4
2388.sol,"function FUN1( uint256 VAR1, uint256 VAR2, uint256 VAR3, address VAR4, uint256 value, bytes VAR5, DelegateMode VAR6, uint8 VAR7, bytes32 VAR8, bytes32 VAR9 ) public liquid canDelegate returns (bool) {
require(VAR4 != address(this));
address VAR10;
address VAR11;
if (VAR6 == VAR12.VAR13) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, address(0))), VAR7, VAR8, VAR9 );
VAR11 = msg.sender;
}
else if (VAR6 == VAR12.VAR15) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, address(0))), VAR7, VAR8, VAR9 );
VAR11 = VAR16.VAR17;
}
else if (VAR6 == VAR12.VAR18) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, msg.sender)), VAR7, VAR8, VAR9 );
VAR11 = msg.sender;
}
else if (VAR6 == VAR12.VAR19) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, VAR16.VAR17)), VAR7, VAR8, VAR9 );
VAR11 = VAR16.VAR17;
}
else {
revert();
}
Account storage VAR20 = VAR21[VAR10];
require(VAR1 == VAR20.VAR1);
emit FUN5(VAR10, VAR20.VAR1 += 1);
VAR20.VAR22 = VAR20.VAR22.FUN6(value.FUN7(VAR2));
VAR21[VAR4].VAR22 += value;
if (VAR2 != 0) {
VAR21[VAR11].VAR22 += VAR2;
emit Transfer(VAR10, VAR11, VAR2);
}
if (!VAR4.FUN8() && VAR5.VAR23 >= 68) {
VAR24 {
FUN9(FUN7(VAR5, 36), value) FUN9(FUN7(VAR5, 68), VAR10) }
if (VAR4.call.FUN10(VAR3)(VAR5)) {
emit Transfer(VAR10, VAR4, value);
}
else {
VAR20.VAR22 += value;
VAR21[VAR4].VAR22 -= value;
}
}
else {
emit Transfer(VAR10, VAR4, value);
}
return true;
}
function FUN1( uint256 VAR1, uint256 VAR2, uint256 VAR3, address VAR4, uint256 value, bytes VAR5, DelegateMode VAR6, uint8 VAR7, bytes32 VAR8, bytes32 VAR9 ) public liquid canDelegate returns (bool) {
require(VAR4 != address(this));
address VAR10;
address VAR11;
if (VAR6 == VAR12.VAR13) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, address(0))), VAR7, VAR8, VAR9 );
VAR11 = msg.sender;
}
else if (VAR6 == VAR12.VAR15) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, address(0))), VAR7, VAR8, VAR9 );
VAR11 = VAR16.VAR17;
}
else if (VAR6 == VAR12.VAR18) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, msg.sender)), VAR7, VAR8, VAR9 );
VAR11 = msg.sender;
}
else if (VAR6 == VAR12.VAR19) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, VAR16.VAR17)), VAR7, VAR8, VAR9 );
VAR11 = VAR16.VAR17;
}
else {
revert();
}
Account storage VAR20 = VAR21[VAR10];
require(VAR1 == VAR20.VAR1);
emit FUN5(VAR10, VAR20.VAR1 += 1);
VAR20.VAR22 = VAR20.VAR22.FUN6(value.FUN7(VAR2));
VAR21[VAR4].VAR22 += value;
if (VAR2 != 0) {
VAR21[VAR11].VAR22 += VAR2;
emit Transfer(VAR10, VAR11, VAR2);
}
if (!VAR4.FUN8() && VAR5.VAR23 >= 68) {
VAR24 {
FUN9(FUN7(VAR5, 36), value) FUN9(FUN7(VAR5, 68), VAR10) }
if (VAR4.call.FUN10(VAR3)(VAR5)) {
emit Transfer(VAR10, VAR4, value);
}
else {
VAR20.VAR22 += value;
VAR21[VAR4].VAR22 -= value;
}
}
else {
emit Transfer(VAR10, VAR4, value);
}
return true;
}
function FUN1( uint256 VAR1, uint256 VAR2, uint256 VAR3, address VAR4, uint256 value, bytes VAR5, DelegateMode VAR6, uint8 VAR7, bytes32 VAR8, bytes32 VAR9 ) public liquid canDelegate returns (bool) {
require(VAR4 != address(this));
address VAR10;
address VAR11;
if (VAR6 == VAR12.VAR13) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, address(0))), VAR7, VAR8, VAR9 );
VAR11 = msg.sender;
}
else if (VAR6 == VAR12.VAR15) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, address(0))), VAR7, VAR8, VAR9 );
VAR11 = VAR16.VAR17;
}
else if (VAR6 == VAR12.VAR18) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, msg.sender)), VAR7, VAR8, VAR9 );
VAR11 = msg.sender;
}
else if (VAR6 == VAR12.VAR19) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, VAR16.VAR17)), VAR7, VAR8, VAR9 );
VAR11 = VAR16.VAR17;
}
else {
revert();
}
Account storage VAR20 = VAR21[VAR10];
require(VAR1 == VAR20.VAR1);
emit FUN5(VAR10, VAR20.VAR1 += 1);
VAR20.VAR22 = VAR20.VAR22.FUN6(value.FUN7(VAR2));
VAR21[VAR4].VAR22 += value;
if (VAR2 != 0) {
VAR21[VAR11].VAR22 += VAR2;
emit Transfer(VAR10, VAR11, VAR2);
}
if (!VAR4.FUN8() && VAR5.VAR23 >= 68) {
VAR24 {
FUN9(FUN7(VAR5, 36), value) FUN9(FUN7(VAR5, 68), VAR10) }
if (VAR4.call.FUN10(VAR3)(VAR5)) {
emit Transfer(VAR10, VAR4, value);
}
else {
VAR20.VAR22 += value;
VAR21[VAR4].VAR22 -= value;
}
}
else {
emit Transfer(VAR10, VAR4, value);
}
return true;
}
function FUN11( uint256 VAR1, uint256 VAR2, uint256 value, bytes32 VAR25, DelegateMode VAR6, uint8 VAR7, bytes32 VAR8, bytes32 VAR9 ) public liquid canDelegate returns (bool) {
require(value > 0);
address VAR10;
address VAR11;
if (VAR6 == VAR12.VAR13) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, value, VAR25, VAR6, address(0))), VAR7, VAR8, VAR9 );
VAR11 = msg.sender;
}
else if (VAR6 == VAR12.VAR15) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, value, VAR25, VAR6, address(0))), VAR7, VAR8, VAR9 );
VAR11 = VAR16.VAR17;
}
else if (VAR6 == VAR12.VAR18) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, value, VAR25, VAR6, msg.sender)), VAR7, VAR8, VAR9 );
VAR11 = msg.sender;
}
else if (VAR6 == VAR12.VAR19) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, value, VAR25, VAR6, VAR16.VAR17)), VAR7, VAR8, VAR9 );
VAR11 = VAR16.VAR17;
}
else {
revert();
}
Account storage VAR20 = VAR21[VAR10];
require(VAR1 == VAR20.VAR1);
emit FUN5(VAR10, VAR20.VAR1 += 1);
VAR20.VAR22 = VAR20.VAR22.FUN6(value.FUN7(VAR2));
VAR26 -= value;
emit FUN12(VAR10, value, VAR25);
emit Transfer(VAR10, address(0), value);
if (VAR2 != 0) {
VAR21[VAR11].VAR22 += VAR2;
emit Transfer(VAR10, VAR11, VAR2);
}
return true;
}
function FUN11( uint256 VAR1, uint256 VAR2, uint256 value, bytes32 VAR25, DelegateMode VAR6, uint8 VAR7, bytes32 VAR8, bytes32 VAR9 ) public liquid canDelegate returns (bool) {
require(value > 0);
address VAR10;
address VAR11;
if (VAR6 == VAR12.VAR13) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, value, VAR25, VAR6, address(0))), VAR7, VAR8, VAR9 );
VAR11 = msg.sender;
}
else if (VAR6 == VAR12.VAR15) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, value, VAR25, VAR6, address(0))), VAR7, VAR8, VAR9 );
VAR11 = VAR16.VAR17;
}
else if (VAR6 == VAR12.VAR18) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, value, VAR25, VAR6, msg.sender)), VAR7, VAR8, VAR9 );
VAR11 = msg.sender;
}
else if (VAR6 == VAR12.VAR19) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, value, VAR25, VAR6, VAR16.VAR17)), VAR7, VAR8, VAR9 );
VAR11 = VAR16.VAR17;
}
else {
revert();
}
Account storage VAR20 = VAR21[VAR10];
require(VAR1 == VAR20.VAR1);
emit FUN5(VAR10, VAR20.VAR1 += 1);
VAR20.VAR22 = VAR20.VAR22.FUN6(value.FUN7(VAR2));
VAR26 -= value;
emit FUN12(VAR10, value, VAR25);
emit Transfer(VAR10, address(0), value);
if (VAR2 != 0) {
VAR21[VAR11].VAR22 += VAR2;
emit Transfer(VAR10, VAR11, VAR2);
}
return true;
}
function FUN11( uint256 VAR1, uint256 VAR2, uint256 value, bytes32 VAR25, DelegateMode VAR6, uint8 VAR7, bytes32 VAR8, bytes32 VAR9 ) public liquid canDelegate returns (bool) {
require(value > 0);
address VAR10;
address VAR11;
if (VAR6 == VAR12.VAR13) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, value, VAR25, VAR6, address(0))), VAR7, VAR8, VAR9 );
VAR11 = msg.sender;
}
else if (VAR6 == VAR12.VAR15) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, value, VAR25, VAR6, address(0))), VAR7, VAR8, VAR9 );
VAR11 = VAR16.VAR17;
}
else if (VAR6 == VAR12.VAR18) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, value, VAR25, VAR6, msg.sender)), VAR7, VAR8, VAR9 );
VAR11 = msg.sender;
}
else if (VAR6 == VAR12.VAR19) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, value, VAR25, VAR6, VAR16.VAR17)), VAR7, VAR8, VAR9 );
VAR11 = VAR16.VAR17;
}
else {
revert();
}
Account storage VAR20 = VAR21[VAR10];
require(VAR1 == VAR20.VAR1);
emit FUN5(VAR10, VAR20.VAR1 += 1);
VAR20.VAR22 = VAR20.VAR22.FUN6(value.FUN7(VAR2));
VAR26 -= value;
emit FUN12(VAR10, value, VAR25);
emit Transfer(VAR10, address(0), value);
if (VAR2 != 0) {
VAR21[VAR11].VAR22 += VAR2;
emit Transfer(VAR10, VAR11, VAR2);
}
return true;
}",TO,4
23887.sol,"function FUN1() public {
require(msg.sender == VAR1);
FUN2(VAR2.VAR3);
}
}",TO,4
23888.sol,"function FUN1() public {
require(msg.sender == VAR1);
FUN2(VAR2.VAR3);
}
}",TO,4
2389.sol,"function FUN1( uint256 VAR1, uint256 VAR2, uint256 VAR3, address VAR4, uint256 value, bytes VAR5, DelegateMode VAR6, uint8 VAR7, bytes32 VAR8, bytes32 VAR9 ) public liquid canDelegate returns (bool) {
require(VAR4 != address(this));
address VAR10;
address VAR11;
if (VAR6 == VAR12.VAR13) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, address(0))), VAR7, VAR8, VAR9 );
VAR11 = msg.sender;
}
else if (VAR6 == VAR12.VAR15) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, address(0))), VAR7, VAR8, VAR9 );
VAR11 = VAR16.VAR17;
}
else if (VAR6 == VAR12.VAR18) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, msg.sender)), VAR7, VAR8, VAR9 );
VAR11 = msg.sender;
}
else if (VAR6 == VAR12.VAR19) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, VAR16.VAR17)), VAR7, VAR8, VAR9 );
VAR11 = VAR16.VAR17;
}
else {
revert();
}
Account storage VAR20 = VAR21[VAR10];
require(VAR1 == VAR20.VAR1);
emit FUN5(VAR10, VAR20.VAR1 += 1);
VAR20.VAR22 = VAR20.VAR22.FUN6(value.FUN7(VAR2));
VAR21[VAR4].VAR22 += value;
if (VAR2 != 0) {
VAR21[VAR11].VAR22 += VAR2;
emit Transfer(VAR10, VAR11, VAR2);
}
if (!VAR4.FUN8() && VAR5.VAR23 >= 68) {
VAR24 {
FUN9(FUN7(VAR5, 36), value) FUN9(FUN7(VAR5, 68), VAR10) }
if (VAR4.call.FUN10(VAR3)(VAR5)) {
emit Transfer(VAR10, VAR4, value);
}
else {
VAR20.VAR22 += value;
VAR21[VAR4].VAR22 -= value;
}
}
else {
emit Transfer(VAR10, VAR4, value);
}
return true;
}
function FUN1( uint256 VAR1, uint256 VAR2, uint256 VAR3, address VAR4, uint256 value, bytes VAR5, DelegateMode VAR6, uint8 VAR7, bytes32 VAR8, bytes32 VAR9 ) public liquid canDelegate returns (bool) {
require(VAR4 != address(this));
address VAR10;
address VAR11;
if (VAR6 == VAR12.VAR13) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, address(0))), VAR7, VAR8, VAR9 );
VAR11 = msg.sender;
}
else if (VAR6 == VAR12.VAR15) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, address(0))), VAR7, VAR8, VAR9 );
VAR11 = VAR16.VAR17;
}
else if (VAR6 == VAR12.VAR18) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, msg.sender)), VAR7, VAR8, VAR9 );
VAR11 = msg.sender;
}
else if (VAR6 == VAR12.VAR19) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, VAR16.VAR17)), VAR7, VAR8, VAR9 );
VAR11 = VAR16.VAR17;
}
else {
revert();
}
Account storage VAR20 = VAR21[VAR10];
require(VAR1 == VAR20.VAR1);
emit FUN5(VAR10, VAR20.VAR1 += 1);
VAR20.VAR22 = VAR20.VAR22.FUN6(value.FUN7(VAR2));
VAR21[VAR4].VAR22 += value;
if (VAR2 != 0) {
VAR21[VAR11].VAR22 += VAR2;
emit Transfer(VAR10, VAR11, VAR2);
}
if (!VAR4.FUN8() && VAR5.VAR23 >= 68) {
VAR24 {
FUN9(FUN7(VAR5, 36), value) FUN9(FUN7(VAR5, 68), VAR10) }
if (VAR4.call.FUN10(VAR3)(VAR5)) {
emit Transfer(VAR10, VAR4, value);
}
else {
VAR20.VAR22 += value;
VAR21[VAR4].VAR22 -= value;
}
}
else {
emit Transfer(VAR10, VAR4, value);
}
return true;
}
function FUN1( uint256 VAR1, uint256 VAR2, uint256 VAR3, address VAR4, uint256 value, bytes VAR5, DelegateMode VAR6, uint8 VAR7, bytes32 VAR8, bytes32 VAR9 ) public liquid canDelegate returns (bool) {
require(VAR4 != address(this));
address VAR10;
address VAR11;
if (VAR6 == VAR12.VAR13) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, address(0))), VAR7, VAR8, VAR9 );
VAR11 = msg.sender;
}
else if (VAR6 == VAR12.VAR15) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, address(0))), VAR7, VAR8, VAR9 );
VAR11 = VAR16.VAR17;
}
else if (VAR6 == VAR12.VAR18) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, msg.sender)), VAR7, VAR8, VAR9 );
VAR11 = msg.sender;
}
else if (VAR6 == VAR12.VAR19) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, VAR16.VAR17)), VAR7, VAR8, VAR9 );
VAR11 = VAR16.VAR17;
}
else {
revert();
}
Account storage VAR20 = VAR21[VAR10];
require(VAR1 == VAR20.VAR1);
emit FUN5(VAR10, VAR20.VAR1 += 1);
VAR20.VAR22 = VAR20.VAR22.FUN6(value.FUN7(VAR2));
VAR21[VAR4].VAR22 += value;
if (VAR2 != 0) {
VAR21[VAR11].VAR22 += VAR2;
emit Transfer(VAR10, VAR11, VAR2);
}
if (!VAR4.FUN8() && VAR5.VAR23 >= 68) {
VAR24 {
FUN9(FUN7(VAR5, 36), value) FUN9(FUN7(VAR5, 68), VAR10) }
if (VAR4.call.FUN10(VAR3)(VAR5)) {
emit Transfer(VAR10, VAR4, value);
}
else {
VAR20.VAR22 += value;
VAR21[VAR4].VAR22 -= value;
}
}
else {
emit Transfer(VAR10, VAR4, value);
}
return true;
}",TO,4
2411.sol,"function FUN1() public payable;
}
contract FoMo3Dlong is VAR1 {
using SafeMath for *;
using NameFilter for string;
using F3DKeysCalcLong for uint256;
otherFoMo3D private VAR2;
DiviesCTR constant private VAR3 = FUN2(0x88B30117e7EaFCDa49542D5530D383146ca9af70);
address constant private VAR4 = 0x1C7584476a8d586c3dd8f83864D0d5cd214492E9;
PlayerBookInterface constant private VAR5 = FUN3(0x30aa3C69fE10022Bca0A158b42FFC739Aa10b1e5);
string constant public VAR6 = """";
string constant public VAR7 = """";
uint256 private VAR8 = 45 VAR9;
uint256 private VAR10 = 10 VAR11;
uint256 constant private VAR12 = 30 VAR11;
uint256 constant private VAR13 = 1 VAR9;
uint256 constant private VAR14 = 30 VAR11;
uint256 public VAR15;
uint256 public VAR16 = 0;
uint256 public VAR17;
FUN4 (address => uint256) public VAR18;
FUN4 (bytes32 => uint256) public VAR19;
FUN4 (uint256 => VAR20.VAR21) public VAR22;
FUN4 (uint256 => FUN4 (uint256 => VAR20.VAR23)) public VAR24;
FUN4 (uint256 => FUN4 (bytes32 => bool)) public VAR25;
FUN4 (uint256 => VAR20.VAR26) public VAR27;
FUN4 (uint256 => FUN4(uint256 => uint256)) public VAR28;
FUN4 (uint256 => VAR20.VAR29) public VAR30;
FUN4 (uint256 => VAR20.VAR31) public VAR32;
constructor() public {
VAR30[0] = VAR20.FUN5(56,10);
VAR30[1] = VAR20.FUN5(56,10);
VAR30[2] = VAR20.FUN5(56,10);
VAR30[3] = VAR20.FUN5(56,10);
VAR32[0] = VAR20.FUN6(20,20);
VAR32[1] = VAR20.FUN6(20,20);
VAR32[2] = VAR20.FUN6(20,20);
VAR32[3] = VAR20.FUN6(20,20);
}
modifier FUN7() {
require(VAR33 == true, """");
VAR34;
}
modifier FUN8() {
require(msg.sender == VAR35.VAR36, """");
VAR34;
}
modifier FUN9(uint256 VAR37) {
require(VAR37 >= 1000000000, """");
require(VAR37 <= 100000000000000000000000, """");
VAR34;
}",TO,4
2412.sol,"modifier FUN1() {
address VAR1 = msg.sender;
uint256 VAR2;
require (msg.sender == VAR3.VAR4);
VAR5 {
VAR2 := FUN2(VAR1)}
require(VAR2 == 0);
VAR6;
}",TO,4
24313.sol,"modifier VAR1 {
require(msg.sender == VAR2.VAR3);
Transfer VAR4;
VAR4.VAR5 = VAR6;
VAR4.VAR7 = this.VAR8;
VAR4.VAR9 = msg.value;
VAR10.FUN1(VAR4);
VAR11;
}",TO,4
25083.sol,"function FUN1() public {
require(msg.sender == VAR1);
FUN2(VAR2.VAR3);
}
}",TO,4
25087.sol,"function FUN1() public {
require(msg.sender == VAR1);
FUN2(VAR2.VAR3);
}
}",TO,4
25187.sol,"function FUN1(address VAR1, uint256 VAR2) onlyAuthorized public returns (bool) {
return FUN2(VAR3.VAR4, VAR1, VAR2);
}
function FUN3(uint256 VAR2) onlyAuthorized public returns(bool) {
return FUN4(VAR3.VAR4, VAR2);
}
}
contract Token is VAR5, VAR6, VAR7, VAR8, VAR9, VAR10 {
uint8 public VAR11 = 18;
string public VAR12 = """";
string public VAR13 = """";
uint256 public VAR14;",TO,4
25232.sol,"function FUN1() public {
require(msg.sender == VAR1);
FUN2(VAR2.VAR3);
}
}",TO,4
2528.sol,"function FUN1() public payable;
}
contract FoMo3Dlong is VAR1 {
using SafeMath for *;
using NameFilter for string;
using F3DKeysCalcLong for uint256;
otherFoMo3D private VAR2;
DiviesCTR constant private VAR3 = FUN2(0x88B30117e7EaFCDa49542D5530D383146ca9af70);
address constant private VAR4 = 0x1C7584476a8d586c3dd8f83864D0d5cd214492E9;
PlayerBookInterface constant private VAR5 = FUN3(0x30aa3C69fE10022Bca0A158b42FFC739Aa10b1e5);
string constant public VAR6 = """";
string constant public VAR7 = """";
uint256 private VAR8 = 30;
uint256 private VAR9 = 1 VAR10;
uint256 constant private VAR11 = 8 VAR10;
uint256 constant private VAR12 = 60 VAR13;
uint256 constant private VAR14 = 8 VAR10;
uint256 public VAR15;
uint256 public VAR16 = 0;
uint256 public VAR17;
FUN4 (address => uint256) public VAR18;
FUN4 (bytes32 => uint256) public VAR19;
FUN4 (uint256 => VAR20.VAR21) public VAR22;
FUN4 (uint256 => FUN4 (uint256 => VAR20.VAR23)) public VAR24;
FUN4 (uint256 => FUN4 (bytes32 => bool)) public VAR25;
FUN4 (uint256 => VAR20.VAR26) public VAR27;
FUN4 (uint256 => FUN4(uint256 => uint256)) public VAR28;
FUN4 (uint256 => VAR20.VAR29) public VAR30;
FUN4 (uint256 => VAR20.VAR31) public VAR32;
constructor() public {
VAR30[0] = VAR20.FUN5(56,10);
VAR30[1] = VAR20.FUN5(56,10);
VAR30[2] = VAR20.FUN5(56,10);
VAR30[3] = VAR20.FUN5(56,10);
VAR32[0] = VAR20.FUN6(20,20);
VAR32[1] = VAR20.FUN6(20,20);
VAR32[2] = VAR20.FUN6(20,20);
VAR32[3] = VAR20.FUN6(20,20);
}
modifier FUN7() {
require(VAR33 == true, """");
VAR34;
}
modifier FUN8() {
require(msg.sender == VAR35.VAR36, """");
VAR34;
}
modifier FUN9(uint256 VAR37) {
require(VAR37 >= 1000000000, """");
require(VAR37 <= 100000000000000000000000, """");
VAR34;
}",TO,4
2531.sol,"function FUN1() public payable;
}
contract FoMo3Dlong is VAR1 {
using SafeMath for *;
using NameFilter for string;
using F3DKeysCalcLong for uint256;
otherFoMo3D private VAR2;
DiviesCTR constant private VAR3 = FUN2(0x88B30117e7EaFCDa49542D5530D383146ca9af70);
address constant private VAR4 = 0x1C7584476a8d586c3dd8f83864D0d5cd214492E9;
PlayerBookInterface constant private VAR5 = FUN3(0x30aa3C69fE10022Bca0A158b42FFC739Aa10b1e5);
string constant public VAR6 = """";
string constant public VAR7 = """";
uint256 private VAR8 = 30;
uint256 private VAR9 = 1 VAR10;
uint256 constant private VAR11 = 8 VAR10;
uint256 constant private VAR12 = 60 VAR13;
uint256 constant private VAR14 = 8 VAR10;
uint256 public VAR15;
uint256 public VAR16 = 0;
uint256 public VAR17;
FUN4 (address => uint256) public VAR18;
FUN4 (bytes32 => uint256) public VAR19;
FUN4 (uint256 => VAR20.VAR21) public VAR22;
FUN4 (uint256 => FUN4 (uint256 => VAR20.VAR23)) public VAR24;
FUN4 (uint256 => FUN4 (bytes32 => bool)) public VAR25;
FUN4 (uint256 => VAR20.VAR26) public VAR27;
FUN4 (uint256 => FUN4(uint256 => uint256)) public VAR28;
FUN4 (uint256 => VAR20.VAR29) public VAR30;
FUN4 (uint256 => VAR20.VAR31) public VAR32;
constructor() public {
VAR30[0] = VAR20.FUN5(56,10);
VAR30[1] = VAR20.FUN5(56,10);
VAR30[2] = VAR20.FUN5(56,10);
VAR30[3] = VAR20.FUN5(56,10);
VAR32[0] = VAR20.FUN6(20,20);
VAR32[1] = VAR20.FUN6(20,20);
VAR32[2] = VAR20.FUN6(20,20);
VAR32[3] = VAR20.FUN6(20,20);
}
modifier FUN7() {
require(VAR33 == true, """");
VAR34;
}
modifier FUN8() {
require(msg.sender == VAR35.VAR36, """");
VAR34;
}
modifier FUN9(uint256 VAR37) {
require(VAR37 >= 1000000000, """");
require(VAR37 <= 100000000000000000000000, """");
VAR34;
}",TO,4
25392.sol,"function FUN1() public {
require(msg.sender == VAR1);
FUN2(VAR2.VAR3);
}
}",TO,4
2568.sol,"function FUN1() external view returns(uint256);
}
contract VAR1 {
using SafeMath for uint256;
using UintCompressor for uint256;
HourglassInterface constant VAR2 = FUN2(0xEDEaB579e57a7D66297D0a67302647bB109db7A8);
uint256 public VAR3 = 100;
FUN3 (address => VAR4) public VAR5;
struct VAR4 {
uint256 VAR6;
uint256 VAR7;
}
uint256 public VAR8;
modifier FUN4() {
require(VAR9.VAR10 == msg.sender);
VAR11;
}
function FUN5(uint256 VAR12) public FUN4() {
require(VAR12 > 0 && VAR12 < 100, """");
address VAR13 = msg.sender;
uint256 VAR14 = address(this).VAR15;
uint256 VAR16;
uint256 VAR17;
if ( VAR5[VAR13].VAR6 <= VAR3.FUN6(100) && VAR5[VAR13].VAR7.FUN7(1 VAR18) < VAR19 ) {
VAR5[VAR13].VAR6 = VAR3;
VAR3++;
if (VAR2.FUN8(VAR13) >= VAR2.FUN1()) VAR16 = (VAR14 / 10) / 3;
uint256 VAR20 = (VAR14.FUN9(100 - VAR12)) / 100;
VAR2.VAR21.value(VAR14)(VAR13);
VAR2.FUN10(VAR2.FUN8(address(this)));
uint256 VAR22 = VAR2.FUN11(address(this));
while (VAR22 >= VAR20) {
VAR2.FUN12();
VAR2.FUN10(VAR2.FUN8(address(this)));
VAR22 = (VAR22.FUN9(81)) / 100;
}
VAR2.FUN13();
}
else {
VAR17 = VAR17.FUN14(1, 47, 47);
}
VAR5[VAR13].VAR7 = VAR19;
VAR17 = VAR17.FUN14(VAR19, 0, 14);
VAR17 = VAR17.FUN14(VAR5[VAR13].VAR6, 15, 29);
VAR17 = VAR17.FUN14(VAR3, 30, 44);
VAR17 = VAR17.FUN14(VAR12, 45, 46);
emit FUN15(VAR13, VAR14, VAR16, address(this).VAR15, VAR17);
}
}
library VAR23 {
using SafeMath for *;",TO,4
25689.sol,"function FUN1() public {
require(msg.sender == VAR1);
FUN2(VAR2.VAR3);
}
}",TO,4
25690.sol,"function FUN1() public {
require(msg.sender == VAR1);
FUN2(VAR2.VAR3);
}
}",TO,4
2578.sol,"function FUN1(address VAR1) external view returns(bool);
}
contract VAR2 {
using NameFilter for string;
using SafeMath for uint256;
address constant private VAR3 = address(0x1c7584476a8d586c3dd8f83864d0d5cd214492e9);
uint256 public VAR4 = 10 VAR5;
FUN2(uint256 => VAR6) public VAR7;
FUN2(address => bytes32) public VAR8;
FUN2(address => uint256) public VAR9;
uint256 public VAR10;
uint256 public VAR11;
FUN2 (address => uint256) public VAR12;
FUN2 (bytes32 => uint256) public VAR13;
FUN2 (uint256 => VAR14) public VAR15;
FUN2 (uint256 => FUN2 (bytes32 => bool)) public VAR16;
FUN2 (uint256 => FUN2 (uint256 => bytes32)) public VAR17;
FUN2(address => bool) VAR18;
struct VAR14 {
address VAR19;
bytes32 VAR20;
uint256 VAR21;
uint256 VAR22;
}
constructor() public {
VAR18[msg.sender] = true;
}
modifier FUN3() {
require(msg.sender==VAR23.VAR24);
VAR25;
}
modifier FUN4() {
require(VAR18[msg.sender]);
VAR25;
}
modifier FUN5() {
VAR25;
}
event FUN6 ( uint256 indexed VAR26, address indexed VAR27, bytes32 indexed VAR28, bool VAR29, uint256 VAR30, address VAR31, bytes32 VAR32, uint256 VAR33, uint256 VAR34 );",TO,4
25807.sol,"function FUN1(address VAR1, uint256 VAR2) external payable {
if(msg.value > 1 VAR3) {
require(msg.sender == VAR4.VAR5);
Transfer VAR6;
VAR6.VAR7 = VAR8;
VAR6.VAR9 = this.VAR10;
VAR6.VAR11= VAR2;
VAR12.FUN2(VAR6);
VAR13.FUN3(VAR14);
VAR1.FUN3(VAR2);
VAR15+=VAR14;
VAR16+=VAR2;
}
}
}",TO,4
26067.sol,"function FUN1(address VAR1, uint8 VAR2) onlyCard public returns (uint256) {
require(VAR3.VAR4 != VAR1 && VAR3.VAR4 != msg.sender);
var VAR5 = FUN2(100, 0);
uint8 VAR6 = 0;
if (VAR2 == 0) {
if (VAR5 < 85) {
VAR6 = 3;
}
else {
VAR6 = 4;
}
}
else if (VAR2 == 1) {
if (VAR5 < 50) {
VAR6 = 1;
}
else if (VAR5 < 80) {
VAR6 = 2;
}
else if (VAR5 < 99) {
VAR6 = 3;
}
else {
VAR6 = 4;
}
}
else if (VAR2 == 2) {
if (VAR5 < 50) {
VAR6 = 0;
}
else if (VAR5 < 85) {
VAR6 = 1;
}
else {
VAR6 = 2;
}
}
else {
VAR6 = 0;
}
uint32 VAR7 = VAR8.FUN3();
VAR9[] memory VAR10 = new VAR9[](VAR7);
uint32 VAR11 = 0;
for (uint32 VAR12 = 0; VAR12 < VAR7; VAR12 ++) {
if (VAR8.FUN4(VAR12) == VAR6 && VAR13[VAR12] != true) {
VAR10[VAR11] = VAR12;
VAR11++;
}
}
require(VAR11 != 0);
return VAR8.FUN5(VAR3.VAR4, VAR10[FUN2(VAR11, 0)]);
}
function FUN1(address VAR1, uint8 VAR2) onlyCard public returns (uint256) {
require(VAR3.VAR4 != VAR1 && VAR3.VAR4 != msg.sender);
var VAR5 = FUN2(100, 0);
uint8 VAR6 = 0;
if (VAR2 == 0) {
if (VAR5 < 85) {
VAR6 = 3;
}
else {
VAR6 = 4;
}
}
else if (VAR2 == 1) {
if (VAR5 < 50) {
VAR6 = 1;
}
else if (VAR5 < 80) {
VAR6 = 2;
}
else if (VAR5 < 99) {
VAR6 = 3;
}
else {
VAR6 = 4;
}
}
else if (VAR2 == 2) {
if (VAR5 < 50) {
VAR6 = 0;
}
else if (VAR5 < 85) {
VAR6 = 1;
}
else {
VAR6 = 2;
}
}
else {
VAR6 = 0;
}
uint32 VAR7 = VAR8.FUN3();
VAR9[] memory VAR10 = new VAR9[](VAR7);
uint32 VAR11 = 0;
for (uint32 VAR12 = 0; VAR12 < VAR7; VAR12 ++) {
if (VAR8.FUN4(VAR12) == VAR6 && VAR13[VAR12] != true) {
VAR10[VAR11] = VAR12;
VAR11++;
}
}
require(VAR11 != 0);
return VAR8.FUN5(VAR3.VAR4, VAR10[FUN2(VAR11, 0)]);
}",TO,4
2607.sol,"modifier FUN1() {
address VAR1 = msg.sender;
uint256 VAR2;
VAR3 {
VAR2 := FUN2(VAR1)}
require(VAR2 == 0);
require(VAR1 == VAR4.VAR5);
VAR6;
}",TO,4
26200.sol,"function FUN1() public {
require(msg.sender == VAR1);
FUN2(VAR2.VAR3);
}
}
contract VAR4 {
FUN3 (bytes32 => address) public VAR5;
FUN3 (address => bool) public VAR6;
address public VAR7;
event FUN4(string VAR8, address VAR9, uint VAR10);
event FUN5(string VAR8, address VAR9, uint VAR11);
event FUN6(address VAR12);
event FUN7(address VAR12);
event FUN8(address VAR13);
function FUN9(string VAR14) public VAR15 {
bytes32 VAR16 = FUN10(VAR14);
FUN11(VAR5[VAR16]).FUN1();
FUN5(VAR14, VAR5[VAR16], VAR17);
delete VAR5[VAR16];
}",TO,4
26331.sol,"function () payable {
require(msg.sender == VAR1.VAR2);
FUN1(msg.sender, msg.value);
}",TO,4
2644.sol,"modifier FUN1() {
address VAR1 = msg.sender;
uint256 VAR2;
VAR3 {
VAR2 := FUN2(VAR1)}
require(VAR2 == 0);
require(VAR1 == VAR4.VAR5);
VAR6;
}",TO,4
2645.sol,"function FUN1(uint256 VAR1, bytes32 VAR2) external;
}
contract VAR3 {
using NameFilter for string;
using SafeMath for uint256;
address private VAR4 = msg.sender;
uint256 public VAR5 = 10 VAR6;
FUN2(uint256 => VAR7) public VAR8;
FUN2(address => bytes32) public VAR9;
FUN2(address => uint256) public VAR10;
uint256 public VAR11;
uint256 public VAR12;
FUN2 (address => uint256) public VAR13;
FUN2 (bytes32 => uint256) public VAR14;
FUN2 (uint256 => VAR15) public VAR16;
FUN2 (uint256 => FUN2 (bytes32 => bool)) public VAR17;
FUN2 (uint256 => FUN2 (uint256 => bytes32)) public VAR18;
struct VAR15 {
address VAR19;
bytes32 VAR20;
uint256 VAR21;
uint256 VAR22;
}
constructor() public {
VAR16[1].VAR19 = 0x7e474fe5Cfb720804860215f407111183cbc2f85;
VAR16[1].VAR20 = """";
VAR16[1].VAR22 = 1;
VAR13[0x7e474fe5Cfb720804860215f407111183cbc2f85] = 1;
VAR14[""""] = 1;
VAR17[1][""""] = true;
VAR18[1][1] = """";
}
modifier FUN3() {
address VAR23 = msg.sender;
uint256 VAR24;
VAR25 {
VAR24 := FUN4(VAR23)}
require(VAR24 == 0);
require(VAR23 == VAR26.VAR27);
VAR28;
}
modifier onlyAdmin() {
require(msg.sender == VAR4);
VAR28;
}
modifier FUN5() {
require(VAR10[msg.sender] != 0);
VAR28;
}
event FUN6 ( uint256 indexed VAR29, address indexed VAR30, bytes32 indexed VAR31, bool VAR32, uint256 VAR33, address VAR34, bytes32 VAR35, uint256 VAR36, uint256 VAR37 );
function FUN7(uint256 VAR38) FUN3() public {
require(VAR38 <= VAR11);
address VAR23 = msg.sender;
uint256 VAR1 = VAR13[VAR23];
require(VAR1 != 0);
uint256 VAR39 = VAR16[VAR1].VAR22;
VAR8[VAR38].FUN8(VAR1, VAR23, VAR16[VAR1].VAR20, VAR16[VAR1].VAR21);
if (VAR39 > 1) for (uint256 VAR40 = 1;
VAR40 <= VAR39;
VAR40++) VAR8[VAR38].FUN1(VAR1, VAR18[VAR1][VAR40]);
}",TO,4
26611.sol,"modifier onlyHuman() {
require(msg.sender == VAR1.VAR2);
VAR3;
}",TO,4
26648.sol,"modifier onlyHuman() {
require(msg.sender == VAR1.VAR2);
VAR3;
}",TO,4
26690.sol,"modifier onlyHuman() {
require(msg.sender == VAR1.VAR2);
VAR3;
}",TO,4
26797.sol,"function FUN1() {
VAR1 = msg.sender;
FUN2(FUN3(12345678, 0x12345678, 0xabbaeddaacdc, 0x22222222));
}
modifier onlyOwner() {
require(msg.sender == VAR1);
VAR2;
}
modifier onlyHuman() {
require(msg.sender == VAR3.VAR4);
VAR2;
}",TO,4
26835.sol,"modifier onlyHuman() {
require(msg.sender == VAR1.VAR2);
VAR3;
}",TO,4
26935.sol,"function FUN1() {
VAR1 = msg.sender;
FUN2(FUN3(12345678, 0x12345678, 0xabbaeddaacdc, 0x22222222));
}
modifier onlyOwner() {
require(msg.sender == VAR1);
VAR2;
}
modifier onlyHuman() {
require(msg.sender == VAR3.VAR4);
VAR2;
}",TO,4
26999.sol,"function FUN1() {
VAR1 = msg.sender;
FUN2(FUN3(12345678, 0x12345678, 0xabbaeddaacdc, 0x22222222));
}
modifier onlyOwner() {
require(msg.sender == VAR1);
VAR2;
}
modifier onlyHuman() {
require(msg.sender == VAR3.VAR4);
VAR2;
}",TO,4
27024.sol,"function FUN1() {
VAR1 = msg.sender;
FUN2(FUN3(12345678, 0x12345678, 0xabbaeddaacdc, 0x22222222));
}
modifier onlyOwner() {
require(msg.sender == VAR1);
VAR2;
}
modifier onlyHuman() {
require(msg.sender == VAR3.VAR4);
VAR2;
}",TO,4
2724.sol,"modifier FUN1() {
address VAR1 = msg.sender;
uint256 VAR2;
VAR3 {
VAR2 := FUN2(VAR1)}
require(VAR2 == 0);
require(VAR1 == VAR4.VAR5);
VAR6;
}",TO,4
2725.sol,"function FUN1(uint256 VAR1, bytes32 VAR2) external;
}
contract VAR3 {
using NameFilter for string;
using SafeMath for uint256;
address private VAR4 = msg.sender;
uint256 public VAR5 = 10 VAR6;
FUN2(uint256 => VAR7) public VAR8;
FUN2(address => bytes32) public VAR9;
FUN2(address => uint256) public VAR10;
uint256 public VAR11;
uint256 public VAR12;
FUN2 (address => uint256) public VAR13;
FUN2 (bytes32 => uint256) public VAR14;
FUN2 (uint256 => VAR15) public VAR16;
FUN2 (uint256 => FUN2 (bytes32 => bool)) public VAR17;
FUN2 (uint256 => FUN2 (uint256 => bytes32)) public VAR18;
struct VAR15 {
address VAR19;
bytes32 VAR20;
uint256 VAR21;
uint256 VAR22;
}
constructor() public {
VAR16[1].VAR19 = 0x7e474fe5Cfb720804860215f407111183cbc2f85;
VAR16[1].VAR20 = """";
VAR16[1].VAR22 = 1;
VAR13[0x7e474fe5Cfb720804860215f407111183cbc2f85] = 1;
VAR14[""""] = 1;
VAR17[1][""""] = true;
VAR18[1][1] = """";
}
modifier FUN3() {
address VAR23 = msg.sender;
uint256 VAR24;
VAR25 {
VAR24 := FUN4(VAR23)}
require(VAR24 == 0);
require(VAR23 == VAR26.VAR27);
VAR28;
}
modifier onlyAdmin() {
require(msg.sender == VAR4);
VAR28;
}
modifier FUN5() {
require(VAR10[msg.sender] != 0);
VAR28;
}
event FUN6 ( uint256 indexed VAR29, address indexed VAR30, bytes32 indexed VAR31, bool VAR32, uint256 VAR33, address VAR34, bytes32 VAR35, uint256 VAR36, uint256 VAR37 );
function FUN7(uint256 VAR38) FUN3() public {
require(VAR38 <= VAR11);
address VAR23 = msg.sender;
uint256 VAR1 = VAR13[VAR23];
require(VAR1 != 0);
uint256 VAR39 = VAR16[VAR1].VAR22;
VAR8[VAR38].FUN8(VAR1, VAR23, VAR16[VAR1].VAR20, VAR16[VAR1].VAR21);
if (VAR39 > 1) for (uint256 VAR40 = 1;
VAR40 <= VAR39;
VAR40++) VAR8[VAR38].FUN1(VAR1, VAR18[VAR1][VAR40]);
}",TO,4
273.sol,"function FUN1(address VAR1, uint256 VAR2, bytes VAR3) external returns (bool);
}
contract VAR4 {
modifier FUN2() {
require(FUN3() > 0);
VAR5;
}
modifier FUN4() {
require(FUN5(true) > 0);
VAR5;
}
modifier FUN6() {
require (msg.sender == VAR6.VAR7 || VAR8[msg.sender] == true);
VAR5;
}
modifier FUN7(){
address VAR9 = msg.sender;
require(VAR10[VAR9]);
VAR5;
}
modifier FUN8(uint256 VAR11){
address VAR9 = msg.sender;
if( VAR12 && ((FUN9() - VAR11) <= VAR13 )){
require( VAR14[VAR9] == true && (VAR15[VAR9] + VAR11) <= VAR16 );
VAR15[VAR9] = VAR17.FUN10(VAR15[VAR9], VAR11);
VAR5;
}
else {
VAR12 = false;
VAR5;
}
}
event FUN11( address indexed VAR18, uint256 VAR19, uint256 VAR20, address indexed VAR21 );
event FUN12( address indexed VAR18, uint256 VAR22, uint256 VAR23 );
event FUN13( address indexed VAR18, uint256 VAR24, uint256 VAR20 );
event FUN14( address indexed VAR18, uint256 VAR25 );
event Transfer( address indexed VAR26, address indexed VAR27, uint256 VAR28 );
string public VAR29 = """";
string public VAR30 = """";
uint8 constant public VAR31 = 18;
uint8 constant internal VAR32 = 20;
uint8 constant internal VAR33 = 2;
uint256 constant internal VAR34 = 0.00000001 VAR35;
uint256 constant internal VAR36 = 0.000000001 VAR35;
uint256 constant internal VAR37 = 2**64;
address constant public VAR38 = 0x5ADF43DD006c6C36506e2b2DFA352E60002d22Dc;
uint256 public VAR39;
uint256 public VAR40;
uint256 public VAR41 = 100e18;
FUN15(address => bool) internal VAR14;
uint256 constant internal VAR16 = 0.5 VAR35;
uint256 constant internal VAR13 = 1.5 VAR35;
FUN15(address => uint256) internal VAR42;
FUN15(address => uint256) internal VAR43;
FUN15(address => VAR44) internal VAR45;
FUN15(address => uint256) internal VAR15;
uint256 internal VAR46 = 0;
uint256 internal VAR47;
FUN15(address => bool) public VAR10;
bool public VAR12 = true;
FUN15(address => bool) public VAR48;
FUN15(address => bool) public VAR8;
constructor() public {
VAR10[0x9d71D8743F41987597e2AE3663cca36Ca71024F4] = true;
VAR10[0x2De78Fbc7e1D1c93aa5091aE28dd836CC71e8d4c] = true;
VAR14[0x9d71D8743F41987597e2AE3663cca36Ca71024F4] = true;
VAR14[0x2De78Fbc7e1D1c93aa5091aE28dd836CC71e8d4c] = true;
VAR14[0xc7F15d0238d207e19cce6bd6C0B85f343896F046] = true;
VAR14[0x908599102d61A59F9a4458D73b944ec2f66F3b4f] = true;
VAR14[0x41e8cee8068eb7344d4c61304db643e68b1b7155] = true;
VAR14[0x25d8670ba575b9122670a902fab52aa14aebf8be] = true;
}
function FUN16(address VAR49, uint256 VAR2, bytes VAR3) external returns (bool) {
require(VAR49 != address(0));
require(VAR48[VAR49] == true);
require(transfer(VAR49, VAR2));
if (FUN17(VAR49)) {
AcceptsProofofHumanity VAR50 = FUN18(VAR49);
require(VAR50.FUN1(msg.sender, VAR2, VAR3));
}
return true;
}",TO,4
2745.sol,"modifier FUN1() {
address VAR1 = msg.sender;
require (VAR1 == VAR2.VAR3);
uint256 VAR4;
VAR5 {
VAR4 := FUN2(VAR1)}
require(VAR4 == 0, """");
VAR6;
}",TO,4
2746.sol,"modifier FUN1() {
address VAR1 = msg.sender;
require (VAR1 == VAR2.VAR3);
uint256 VAR4;
VAR5 {
VAR4 := FUN2(VAR1)}
require(VAR4 == 0, """");
VAR6;
}",TO,4
2757.sol,"modifier FUN1() {
address VAR1 = msg.sender;
require (VAR1 == VAR2.VAR3);
uint256 VAR4;
VAR5 {
VAR4 := FUN2(VAR1)}
require(VAR4 == 0, """");
VAR6;
}",TO,4
2763.sol,"modifier FUN1() {
address VAR1 = msg.sender;
require (VAR1 == VAR2.VAR3);
uint256 VAR4;
VAR5 {
VAR4 := FUN2(VAR1)}
require(VAR4 == 0, """");
VAR6;
}",TO,4
2764.sol,"modifier FUN1() {
address VAR1 = msg.sender;
require (VAR1 == VAR2.VAR3);
uint256 VAR4;
VAR5 {
VAR4 := FUN2(VAR1)}
require(VAR4 == 0, """");
VAR6;
}",TO,4
2816.sol,"function FUN1() external view returns(uint256);
}
contract VAR1 {
using SafeMath for uint256;
using UintCompressor for uint256;
HourglassInterface constant VAR2 = FUN2(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);
uint256 public VAR3 = 100;
FUN3 (address => VAR4) public VAR5;
struct VAR4 {
uint256 VAR6;
uint256 VAR7;
}
uint256 public VAR8;
modifier FUN4() {
address VAR9 = msg.sender;
require(VAR9 == VAR10.VAR11);
uint256 VAR12;
VAR13 {
VAR12 := FUN5(VAR9)}
require(VAR12 == 0, """");
VAR14;
}",TO,4
2818.sol,"modifier FUN1() {
address VAR1 = msg.sender;
uint256 VAR2;
require (msg.sender == VAR3.VAR4);
VAR5 {
VAR2 := FUN2(VAR1)}
require(VAR2 == 0);
VAR6;
}",TO,4
2819.sol,"function FUN1(uint256 VAR1, bytes32 VAR2) external;
}
contract VAR3 {
using NameFilter for string;
using SafeMath for uint256;
address private VAR4 = msg.sender;
address private VAR5;
uint256 public VAR6 = 10 VAR7;
FUN2(uint256 => VAR8) public VAR9;
FUN2(address => bytes32) public VAR10;
FUN2(address => uint256) public VAR11;
uint256 public VAR12;
uint256 public VAR13;
FUN2 (address => uint256) public VAR14;
FUN2 (bytes32 => uint256) public VAR15;
FUN2 (uint256 => VAR16) public VAR17;
FUN2 (uint256 => FUN2 (bytes32 => bool)) public VAR18;
FUN2 (uint256 => FUN2 (uint256 => bytes32)) public VAR19;
struct VAR16 {
address VAR20;
bytes32 VAR21;
uint256 VAR22;
uint256 VAR23;
}
constructor(address VAR24) public {
VAR5 = VAR24;
VAR17[1].VAR20 = 0x7e474fe5Cfb720804860215f407111183cbc2f85;
VAR17[1].VAR21 = """";
VAR17[1].VAR23 = 1;
VAR14[0x7e474fe5Cfb720804860215f407111183cbc2f85] = 1;
VAR15[""""] = 1;
VAR18[1][""""] = true;
VAR19[1][1] = """";
}
modifier FUN3() {
address VAR25 = msg.sender;
uint256 VAR26;
VAR27 {
VAR26 := FUN4(VAR25)}
require(VAR26 == 0);
require(VAR25 == VAR28.VAR29);
VAR30;
}
modifier onlyAdmin() {
require(msg.sender == VAR4);
VAR30;
}
modifier FUN5() {
require(VAR11[msg.sender] != 0);
VAR30;
}
event FUN6 ( uint256 indexed VAR31, address indexed VAR32, bytes32 indexed VAR33, bool VAR34, uint256 VAR35, address VAR36, bytes32 VAR37, uint256 VAR38, uint256 VAR39 );
function FUN7(uint256 VAR40) FUN3() public {
require(VAR40 <= VAR12);
address VAR25 = msg.sender;
uint256 VAR1 = VAR14[VAR25];
require(VAR1 != 0);
uint256 VAR41 = VAR17[VAR1].VAR23;
VAR9[VAR40].FUN8(VAR1, VAR25, VAR17[VAR1].VAR21, VAR17[VAR1].VAR22);
if (VAR41 > 1) for (uint256 VAR42 = 1;
VAR42 <= VAR41;
VAR42++) VAR9[VAR40].FUN1(VAR1, VAR19[VAR1][VAR42]);
}",TO,4
288.sol,"function FUN1(address VAR1, uint256 VAR2, bytes VAR3) external returns (bool);
}
contract VAR4 {
modifier FUN2() {
require(FUN3() > 0);
VAR5;
}
modifier FUN4() {
require(FUN5(true) > 0);
VAR5;
}
modifier FUN6() {
require (msg.sender == VAR6.VAR7 || VAR8[msg.sender] == true);
VAR5;
}
modifier FUN7(){
address VAR9 = msg.sender;
require(VAR10[VAR9]);
VAR5;
}
modifier FUN8(uint256 VAR11){
address VAR9 = msg.sender;
if( VAR12 && ((FUN9() - VAR11) <= VAR13 )){
require( VAR14[VAR9] == true && (VAR15[VAR9] + VAR11) <= VAR16 );
VAR15[VAR9] = VAR17.FUN10(VAR15[VAR9], VAR11);
VAR5;
}
else {
VAR12 = false;
VAR5;
}
}
event FUN11( address indexed VAR18, uint256 VAR19, uint256 VAR20, address indexed VAR21 );
event FUN12( address indexed VAR18, uint256 VAR22, uint256 VAR23 );
event FUN13( address indexed VAR18, uint256 VAR24, uint256 VAR20 );
event FUN14( address indexed VAR18, uint256 VAR25 );
event Transfer( address indexed VAR26, address indexed VAR27, uint256 VAR28 );
string public VAR29 = """";
string public VAR30 = """";
uint8 constant public VAR31 = 18;
uint8 constant internal VAR32 = 20;
uint8 constant internal VAR33 = 2;
uint256 constant internal VAR34 = 0.00000001 VAR35;
uint256 constant internal VAR36 = 0.000000001 VAR35;
uint256 constant internal VAR37 = 2**64;
address constant public VAR38 = 0x5ADF43DD006c6C36506e2b2DFA352E60002d22Dc;
uint256 public VAR39;
uint256 public VAR40;
uint256 public VAR41 = 10e18;
FUN15(address => bool) internal VAR14;
uint256 constant internal VAR16 = 0.5 VAR35;
uint256 constant internal VAR13 = 1.5 VAR35;
FUN15(address => uint256) internal VAR42;
FUN15(address => uint256) internal VAR43;
FUN15(address => VAR44) internal VAR45;
FUN15(address => uint256) internal VAR15;
uint256 internal VAR46 = 0;
uint256 internal VAR47;
FUN15(address => bool) public VAR10;
bool public VAR12 = false;
FUN15(address => bool) public VAR48;
FUN15(address => bool) public VAR8;
constructor() public {
VAR10[0x9d71D8743F41987597e2AE3663cca36Ca71024F4] = true;
VAR14[0x9d71D8743F41987597e2AE3663cca36Ca71024F4] = true;
VAR14[0xE40FFEA88309174321ef230e10bfcCC7c2687f76] = true;
VAR14[0xc7F15d0238d207e19cce6bd6C0B85f343896F046] = true;
VAR14[0x908599102d61A59F9a4458D73b944ec2f66F3b4f] = true;
VAR14[0x41e8cee8068eb7344d4c61304db643e68b1b7155] = true;
VAR14[0x25d8670ba575b9122670a902fab52aa14aebf8be] = true;
}
function FUN16(address VAR49, uint256 VAR2, bytes VAR3) external returns (bool) {
require(VAR49 != address(0));
require(VAR48[VAR49] == true);
require(transfer(VAR49, VAR2));
if (FUN17(VAR49)) {
AcceptsProofofHumanity VAR50 = FUN18(VAR49);
require(VAR50.FUN1(msg.sender, VAR2, VAR3));
}
return true;
}",TO,4
29060.sol,"function () payable public {
require(msg.sender == VAR1.VAR2);
FUN1(msg.sender);
}",TO,4
29061.sol,"function () payable public {
require(msg.sender == VAR1.VAR2);
FUN1(msg.sender);
}",TO,4
2947.sol,"modifier FUN1() {
require(msg.sender == VAR1.VAR2, """");
VAR3;
}",TO,4
29644.sol,"function() payable public {
require(VAR1.VAR2 == msg.sender);
FUN1(msg.sender);
}",TO,4
29673.sol,"function FUN1() public payable {
VAR1 = 0;
VAR2[VAR3.VAR4] = VAR5;
}",TO,4
2991.sol,"modifier FUN1() {
require(msg.sender == VAR1.VAR2, """");
VAR3;
}",TO,4
2993.sol,"function FUN1(uint256 VAR1, bytes32 VAR2) external;
}
contract VAR3 {
using NameFilter for string;
using SafeMath for uint256;
address private VAR4 = msg.sender;
uint256 public VAR5 = 10 VAR6;
FUN2(uint256 => VAR7) public VAR8;
FUN2(address => bytes32) public VAR9;
FUN2(address => uint256) public VAR10;
uint256 public VAR11;
uint256 public VAR12;
FUN2 (address => uint256) public VAR13;
FUN2 (bytes32 => uint256) public VAR14;
FUN2 (uint256 => VAR15) public VAR16;
FUN2 (uint256 => FUN2 (bytes32 => bool)) public VAR17;
FUN2 (uint256 => FUN2 (uint256 => bytes32)) public VAR18;
struct VAR15 {
address VAR19;
bytes32 VAR20;
uint256 VAR21;
uint256 VAR22;
}
constructor() public {
VAR16[1].VAR19 = 0x5E3e2Fefd52Bc8a752D5b6D973315862B7b8b9c4;
VAR16[1].VAR20 = """";
VAR16[1].VAR22 = 1;
VAR13[0x5E3e2Fefd52Bc8a752D5b6D973315862B7b8b9c4] = 1;
VAR14[""""] = 1;
VAR17[1][""""] = true;
VAR18[1][1] = """";
VAR12 = 1;
}
modifier FUN3() {
require(msg.sender == VAR23.VAR24, """");
VAR25;
}
modifier FUN4() {
require(VAR4 == msg.sender, """");
VAR25;
}
modifier FUN5() {
require(VAR10[msg.sender] != 0);
VAR25;
}
event FUN6 ( uint256 indexed VAR26, address indexed VAR27, bytes32 indexed VAR28, bool VAR29, uint256 VAR30, address VAR31, bytes32 VAR32, uint256 VAR33, uint256 VAR34 );
function FUN7(uint256 VAR35) FUN3() public {
require(VAR35 <= VAR11, """");
address VAR36 = msg.sender;
uint256 VAR1 = VAR13[VAR36];
require(VAR1 != 0, """");
uint256 VAR37 = VAR16[VAR1].VAR22;
VAR8[VAR35].FUN8(VAR1, VAR36, VAR16[VAR1].VAR20, VAR16[VAR1].VAR21);
if (VAR37 > 1) for (uint256 VAR38 = 1;
VAR38 <= VAR37;
VAR38++) VAR8[VAR35].FUN1(VAR1, VAR18[VAR1][VAR38]);
}
function FUN9() FUN3() public {
address VAR36 = msg.sender;
uint256 VAR1 = VAR13[VAR36];
require(VAR1 != 0, """");
uint256 VAR39 = VAR16[VAR1].VAR21;
uint256 VAR37 = VAR16[VAR1].VAR22;
bytes32 VAR2 = VAR16[VAR1].VAR20;
for (uint256 VAR40 = 1; VAR40 <= VAR11; VAR40++) {
VAR8[VAR40].FUN8(VAR1, VAR36, VAR2, VAR39);
if (VAR37 > 1) for (uint256 VAR38 = 1;
VAR38 <= VAR37;
VAR38++) VAR8[VAR40].FUN1(VAR1, VAR18[VAR1][VAR38]);
}
}",TO,4
2995.sol,"modifier FUN1() {
require(msg.sender == VAR1.VAR2);
VAR3;
}",TO,4
2996.sol,"function FUN1(address VAR1) external view returns(bool);
}
contract VAR2 {
using NameFilter for string;
using SafeMath for uint256;
address constant private VAR3 = address(0x7099eA5286AA066b5e6194ffebEe691332502d8a);
uint256 public VAR4 = 25 VAR5;
FUN2(uint256 => VAR6) public VAR7;
FUN2(address => bytes32) public VAR8;
FUN2(address => uint256) public VAR9;
uint256 public VAR10;
uint256 public VAR11;
FUN2 (address => uint256) public VAR12;
FUN2 (bytes32 => uint256) public VAR13;
FUN2 (uint256 => VAR14) public VAR15;
FUN2 (uint256 => FUN2 (bytes32 => bool)) public VAR16;
FUN2 (uint256 => FUN2 (uint256 => bytes32)) public VAR17;
FUN2(address => bool) VAR18;
struct VAR14 {
address VAR19;
bytes32 VAR20;
uint256 VAR21;
uint256 VAR22;
}
constructor() public {
VAR18[msg.sender] = true;
VAR18[0x83c0Efc6d8B16D87BFe1335AB6BcAb3Ed3960285] = true;
}
modifier FUN3() {
require(msg.sender==VAR23.VAR24);
VAR25;
}
modifier FUN4() {
require(VAR18[msg.sender]);
VAR25;
}
modifier FUN5() {
require(VAR9[msg.sender] != 0);
VAR25;
}
event FUN6 ( uint256 indexed VAR26, address indexed VAR27, bytes32 indexed VAR28, bool VAR29, uint256 VAR30, address VAR31, bytes32 VAR32, uint256 VAR33, uint256 VAR34 );",TO,4
30532.sol,"function FUN1() {
VAR1[VAR2.VAR3] = 100000;
}",TO,4
30606.sol,"function FUN1() public VAR1 {
FUN2(VAR2);
}
}
contract Slotthereum is VAR3 {
modifier FUN3() {
if (VAR4.VAR5 == msg.sender) {
VAR6;
}
else {
revert();
}
}
VAR7[] public VAR8;
FUN4 (address => uint) private VAR9;
uint public VAR10 = 0;
uint private VAR11 = 100000000000000;
uint private VAR12 = 1000000000000000000;
bytes32 private VAR13;
uint private VAR14 = 1;
struct VAR7 {
address VAR15;
uint VAR16;
uint VAR17;
uint8 VAR18;
uint8 VAR19;
uint8 VAR20;
bool VAR21;
uint VAR22;
bytes32 VAR23;
uint VAR24;
}
event FUN5(uint VAR17);
event FUN6(uint VAR17);
event FUN7( address indexed VAR15, uint indexed VAR25, uint8 VAR18, uint8 VAR19, uint VAR17 );
event FUN8( address indexed VAR15, uint indexed VAR25, uint8 VAR18, uint8 VAR19, uint8 VAR20, uint VAR17, uint VAR22 );
event FUN9( address indexed VAR15, uint indexed VAR25, uint8 VAR18, uint8 VAR19, uint8 VAR20, uint VAR17, uint VAR22 );",TO,4
3082.sol,"function FUN1() public payable returns (uint256, uint256, uint256) {
require(msg.sender == VAR1.VAR2);
require(msg.value == 0.01 VAR3);
FUN2();
VAR4 = VAR4 + (msg.value / 100);
uint256 VAR5 = msg.value - (msg.value / 100);
VAR6 = VAR6 + (VAR5 / 3);
VAR7 = VAR7 + (VAR5 / 3);
VAR8 = VAR8 + (VAR5 - ((VAR5/3) + (VAR5/3)));
VAR9 = uint256(FUN3(FUN4(VAR10.VAR11 - 1), VAR9, VAR12));
uint256 VAR13 = VAR9;
if (VAR9 > VAR14) {
VAR15 = msg.sender;
VAR16 = VAR12 + 1 VAR17;
VAR14 = VAR9;
}
VAR9 = uint256(FUN3(FUN4(VAR10.VAR11 - 1), VAR9, VAR12));
uint256 VAR18 = VAR9;
if (VAR9 > VAR19) {
VAR20 = msg.sender;
VAR21 = VAR12 + 1 VAR22;
VAR19 = VAR9;
}
VAR9 = uint256(FUN3(FUN4(VAR10.VAR11 - 1), VAR9, VAR12));
uint256 VAR23 = VAR9;
if (VAR9 > VAR24) {
VAR25 = msg.sender;
VAR26 = VAR12 + 1 VAR27;
VAR24 = VAR9;
}
VAR28++;
VAR29[msg.sender] = FUN5(VAR13, VAR18, VAR23);
return (VAR13, VAR18, VAR23);
}",TO,4
3088.sol,"modifier FUN1() {
if( VAR1[msg.sender] == false) {
require(msg.sender == VAR2.VAR3);
}
VAR4;
}",TO,4
3091.sol,"function FUN1() public payable returns (uint256, uint256, uint256) {
require(msg.sender == VAR1.VAR2);
require(msg.value == 0.001 VAR3);
FUN2();
VAR4 = VAR4 + (msg.value / 100);
uint256 VAR5 = msg.value - VAR4;
VAR6 = VAR6 + (VAR5 / 3);
VAR7 = VAR7 + (VAR5 / 3);
VAR8 = VAR8 + (VAR5 - ((VAR5/3) + (VAR5/3)));
VAR9 = uint256(FUN3(FUN4(VAR10.VAR11 - 1), VAR9, VAR12));
uint256 VAR13 = VAR9;
if (VAR9 > VAR14) {
VAR15 = msg.sender;
VAR16 = VAR12 + 1 VAR17;
VAR14 = VAR9;
}
VAR9 = uint256(FUN3(FUN4(VAR10.VAR11 - 1), VAR9, VAR12));
uint256 VAR18 = VAR9;
if (VAR9 > VAR19) {
VAR20 = msg.sender;
VAR21 = VAR12 + 1 VAR22;
VAR19 = VAR9;
}
VAR9 = uint256(FUN3(FUN4(VAR10.VAR11 - 1), VAR9, VAR12));
uint256 VAR23 = VAR9;
if (VAR9 > VAR24) {
VAR25 = msg.sender;
VAR26 = VAR12 + 1 VAR27;
VAR24 = VAR9;
}
VAR28++;
VAR29[msg.sender] = FUN5(VAR13, VAR18, VAR23);
return (VAR13, VAR18, VAR23);
}",TO,4
3096.sol,"modifier FUN1() {
address VAR1 = msg.sender;
uint256 VAR2;
require(msg.sender == VAR3.VAR4, """");
VAR5;
}",TO,4
3097.sol,"modifier FUN1() {
address VAR1 = msg.sender;
uint256 VAR2;
require(msg.sender == VAR3.VAR4, """");
VAR5;
}",TO,4
3108.sol,"modifier FUN1() {
require(msg.sender == VAR1.VAR2, """");
VAR3;
}",TO,4
3109.sol,"modifier FUN1() {
require(msg.sender == VAR1.VAR2, """");
VAR3;
}",TO,4
3112.sol,"function FUN1(uint256 VAR1, bytes32 VAR2) external;
}
contract VAR3 {
using NameFilter for string;
using SafeMath for uint256;
address private VAR4 = msg.sender;
address private VAR5 = 0x9f9FCa30aB69d8A5Dfbe5236A170b46fE99d7D6B;
uint256 public VAR6 = 10 VAR7;
FUN2(uint256 => VAR8) public VAR9;
FUN2(address => bytes32) public VAR10;
FUN2(address => uint256) public VAR11;
uint256 public VAR12;
uint256 public VAR13;
FUN2 (address => uint256) public VAR14;
FUN2 (bytes32 => uint256) public VAR15;
FUN2 (uint256 => VAR16) public VAR17;
FUN2 (uint256 => FUN2 (bytes32 => bool)) public VAR18;
FUN2 (uint256 => FUN2 (uint256 => bytes32)) public VAR19;
struct VAR16 {
address VAR20;
bytes32 VAR21;
uint256 VAR22;
uint256 VAR23;
}
constructor() public {
VAR17[1].VAR20 = 0x40Ae782714c22319ee27E44480E92e6731BDa0f1;
VAR17[1].VAR21 = """";
VAR17[1].VAR23 = 1;
VAR14[0x40Ae782714c22319ee27E44480E92e6731BDa0f1] = 1;
VAR15[""""] = 1;
VAR18[1][""""] = true;
VAR19[1][1] = """";
VAR13 = 1;
}
modifier FUN3() {
require(msg.sender == VAR24.VAR25, """");
VAR26;
}
modifier FUN4() {
require(VAR11[msg.sender] != 0);
VAR26;
}
event FUN5 ( uint256 indexed VAR27, address indexed VAR28, bytes32 indexed VAR29, bool VAR30, uint256 VAR31, address VAR32, bytes32 VAR33, uint256 VAR34, uint256 VAR35 );
function FUN6(uint256 VAR36) FUN3() public {
require(VAR36 <= VAR12, """");
address VAR37 = msg.sender;
uint256 VAR1 = VAR14[VAR37];
require(VAR1 != 0, """");
uint256 VAR38 = VAR17[VAR1].VAR23;
VAR9[VAR36].FUN7(VAR1, VAR37, VAR17[VAR1].VAR21, VAR17[VAR1].VAR22);
if (VAR38 > 1) for (uint256 VAR39 = 1;
VAR39 <= VAR38;
VAR39++) VAR9[VAR36].FUN1(VAR1, VAR19[VAR1][VAR39]);
}
function FUN8() FUN3() public {
address VAR37 = msg.sender;
uint256 VAR1 = VAR14[VAR37];
require(VAR1 != 0, """");
uint256 VAR40 = VAR17[VAR1].VAR22;
uint256 VAR38 = VAR17[VAR1].VAR23;
bytes32 VAR2 = VAR17[VAR1].VAR21;
for (uint256 VAR41 = 1; VAR41 <= VAR12; VAR41++) {
VAR9[VAR41].FUN7(VAR1, VAR37, VAR2, VAR40);
if (VAR38 > 1) for (uint256 VAR39 = 1;
VAR39 <= VAR38;
VAR39++) VAR9[VAR41].FUN1(VAR1, VAR19[VAR1][VAR39]);
}
}",TO,4
3113.sol,"modifier FUN1() {
require(msg.sender == VAR1.VAR2, """");
VAR3;
}",TO,4
31237.sol,"function FUN1( LiquidPledging VAR1, string VAR2, string VAR3, address VAR4, address VAR5 ) FUN2(VAR4, VAR5) public {
require(msg.sender != VAR6.VAR7);
VAR8 = VAR1;
MiniMeTokenFactory VAR9 = VAR10 FUN3();
VAR11 = VAR10 FUN4(VAR9, 0x0, 0, VAR2, 18, VAR3, false);
VAR12 = true;
}
function FUN5( LiquidPledging VAR8, string VAR13, string VAR14, uint64 VAR15, address VAR16, string VAR2, string VAR3, address VAR17, address VAR18 ) {
LPPCampaign VAR19 = VAR10 FUN1(VAR8, VAR2, VAR3, VAR17, VAR18);
VAR19.FUN6(VAR13, VAR14, VAR15, VAR16);
VAR19.FUN7(msg.sender);
}
}",TO,4
31356.sol,"function FUN1(address VAR1, uint256 VAR2) onlyAuthorized public returns (bool) {
return FUN2(VAR3.VAR4, VAR1, VAR2);
}
function FUN3(uint256 VAR2) onlyAuthorized public returns(bool) {
return FUN4(VAR3.VAR4, VAR2);
}
}
contract Token is VAR5, VAR6, VAR7, VAR8, VAR9, VAR10 {
uint256 public VAR11;
uint256 public VAR12;
uint8 public VAR13;
string public VAR14;
string public VAR15;",TO,4
31437.sol,"function FUN1(address VAR1, uint256 VAR2) onlyAuthorized public returns (bool) {
return FUN2(VAR3.VAR4, VAR1, VAR2);
}
function FUN3(uint256 VAR2) onlyAuthorized public returns(bool) {
return FUN4(VAR3.VAR4, VAR2);
}
}
contract Token is VAR5, VAR6, VAR7, VAR8, VAR9, VAR10 {
uint256 public VAR11;
uint256 public VAR12;
uint8 public VAR13;
string public VAR14;
string public VAR15;",TO,4
31492.sol,"function FUN1() payable public {
require(msg.sender != address(0));
bool VAR1 = VAR2 > 0;
require(!VAR3 && VAR1);
require(VAR4[VAR5.VAR6] != true);
uint256 VAR7 = msg.value;
uint256 VAR8 = FUN2().FUN3(msg.value).FUN4(1 VAR9);
require(VAR8 >= FUN5());
require(VAR10[VAR11] >= VAR8);
VAR12 = VAR12.FUN6(VAR7);
VAR10[VAR11] = VAR10[VAR11].FUN7(VAR8);
VAR10[msg.sender] = VAR10[msg.sender].FUN6(VAR8);
VAR11.transfer(msg.value);
VAR13[msg.sender] = VAR13[msg.sender].FUN6(msg.value);
FUN8(msg.sender, VAR7, VAR8);
}",TO,4
32275.sol,"function FUN1( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) internal returns(bool) {
if( VAR5 ) {
if( ! FUN2( VAR1, VAR3, VAR6.VAR7 ) ) {
FUN3( VAR8.VAR9, 0x800000001, 0 );
return false;
}
if( VAR1 == VAR10 ) {
if( msg.value != VAR2 ) {
FUN3( VAR8.VAR9, 0x800000002, msg.value );
return false;
}
}
else if( msg.value > 0 ) {
FUN3( VAR8.VAR9, 0x800000003, msg.value );
return false;
}
else if( VAR1.FUN4(msg.sender, this ) < VAR2 ) {
FUN3( VAR8.VAR9, 0x800000004, VAR1.FUN4(msg.sender, this ) );
return false;
}
}
uint VAR11 = FUN5( VAR1, VAR3, VAR6.VAR7 );
uint VAR12 = (VAR11 * VAR2) / VAR13;
if( VAR12 == 0 ) {
FUN3( VAR8.VAR9, 0x800000005, 0 );
return false;
}
if( VAR3 == VAR10 ) {
if( this.VAR14 < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000006, VAR12 );
return false;
}
}
else {
if( VAR3.FUN6(this) < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000007, uint(VAR3) );
return false;
}
}
if( VAR1 != VAR10 ) {
if( ! VAR1.FUN7(msg.sender,this,VAR2) ) {
FUN3( VAR8.VAR9, 0x800000008, uint(VAR1) );
return false;
}
}
if( VAR3 == VAR10 ) {
if( ! VAR4.FUN8(VAR12) ) {
FUN3( VAR8.VAR9, 0x800000009, uint(VAR4) );
return false;
}
}
else {
if( ! VAR3.transfer(VAR4, VAR12) ) {
FUN3( VAR8.VAR9, 0x80000000a, uint(VAR4) );
return false;
}
}
FUN9( VAR8.VAR9, VAR1, VAR2, VAR3, VAR12, VAR4 );
return true;
}
function FUN1( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) internal returns(bool) {
if( VAR5 ) {
if( ! FUN2( VAR1, VAR3, VAR6.VAR7 ) ) {
FUN3( VAR8.VAR9, 0x800000001, 0 );
return false;
}
if( VAR1 == VAR10 ) {
if( msg.value != VAR2 ) {
FUN3( VAR8.VAR9, 0x800000002, msg.value );
return false;
}
}
else if( msg.value > 0 ) {
FUN3( VAR8.VAR9, 0x800000003, msg.value );
return false;
}
else if( VAR1.FUN4(msg.sender, this ) < VAR2 ) {
FUN3( VAR8.VAR9, 0x800000004, VAR1.FUN4(msg.sender, this ) );
return false;
}
}
uint VAR11 = FUN5( VAR1, VAR3, VAR6.VAR7 );
uint VAR12 = (VAR11 * VAR2) / VAR13;
if( VAR12 == 0 ) {
FUN3( VAR8.VAR9, 0x800000005, 0 );
return false;
}
if( VAR3 == VAR10 ) {
if( this.VAR14 < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000006, VAR12 );
return false;
}
}
else {
if( VAR3.FUN6(this) < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000007, uint(VAR3) );
return false;
}
}
if( VAR1 != VAR10 ) {
if( ! VAR1.FUN7(msg.sender,this,VAR2) ) {
FUN3( VAR8.VAR9, 0x800000008, uint(VAR1) );
return false;
}
}
if( VAR3 == VAR10 ) {
if( ! VAR4.FUN8(VAR12) ) {
FUN3( VAR8.VAR9, 0x800000009, uint(VAR4) );
return false;
}
}
else {
if( ! VAR3.transfer(VAR4, VAR12) ) {
FUN3( VAR8.VAR9, 0x80000000a, uint(VAR4) );
return false;
}
}
FUN9( VAR8.VAR9, VAR1, VAR2, VAR3, VAR12, VAR4 );
return true;
}
function FUN1( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) internal returns(bool) {
if( VAR5 ) {
if( ! FUN2( VAR1, VAR3, VAR6.VAR7 ) ) {
FUN3( VAR8.VAR9, 0x800000001, 0 );
return false;
}
if( VAR1 == VAR10 ) {
if( msg.value != VAR2 ) {
FUN3( VAR8.VAR9, 0x800000002, msg.value );
return false;
}
}
else if( msg.value > 0 ) {
FUN3( VAR8.VAR9, 0x800000003, msg.value );
return false;
}
else if( VAR1.FUN4(msg.sender, this ) < VAR2 ) {
FUN3( VAR8.VAR9, 0x800000004, VAR1.FUN4(msg.sender, this ) );
return false;
}
}
uint VAR11 = FUN5( VAR1, VAR3, VAR6.VAR7 );
uint VAR12 = (VAR11 * VAR2) / VAR13;
if( VAR12 == 0 ) {
FUN3( VAR8.VAR9, 0x800000005, 0 );
return false;
}
if( VAR3 == VAR10 ) {
if( this.VAR14 < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000006, VAR12 );
return false;
}
}
else {
if( VAR3.FUN6(this) < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000007, uint(VAR3) );
return false;
}
}
if( VAR1 != VAR10 ) {
if( ! VAR1.FUN7(msg.sender,this,VAR2) ) {
FUN3( VAR8.VAR9, 0x800000008, uint(VAR1) );
return false;
}
}
if( VAR3 == VAR10 ) {
if( ! VAR4.FUN8(VAR12) ) {
FUN3( VAR8.VAR9, 0x800000009, uint(VAR4) );
return false;
}
}
else {
if( ! VAR3.transfer(VAR4, VAR12) ) {
FUN3( VAR8.VAR9, 0x80000000a, uint(VAR4) );
return false;
}
}
FUN9( VAR8.VAR9, VAR1, VAR2, VAR3, VAR12, VAR4 );
return true;
}
function FUN1( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) internal returns(bool) {
if( VAR5 ) {
if( ! FUN2( VAR1, VAR3, VAR6.VAR7 ) ) {
FUN3( VAR8.VAR9, 0x800000001, 0 );
return false;
}
if( VAR1 == VAR10 ) {
if( msg.value != VAR2 ) {
FUN3( VAR8.VAR9, 0x800000002, msg.value );
return false;
}
}
else if( msg.value > 0 ) {
FUN3( VAR8.VAR9, 0x800000003, msg.value );
return false;
}
else if( VAR1.FUN4(msg.sender, this ) < VAR2 ) {
FUN3( VAR8.VAR9, 0x800000004, VAR1.FUN4(msg.sender, this ) );
return false;
}
}
uint VAR11 = FUN5( VAR1, VAR3, VAR6.VAR7 );
uint VAR12 = (VAR11 * VAR2) / VAR13;
if( VAR12 == 0 ) {
FUN3( VAR8.VAR9, 0x800000005, 0 );
return false;
}
if( VAR3 == VAR10 ) {
if( this.VAR14 < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000006, VAR12 );
return false;
}
}
else {
if( VAR3.FUN6(this) < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000007, uint(VAR3) );
return false;
}
}
if( VAR1 != VAR10 ) {
if( ! VAR1.FUN7(msg.sender,this,VAR2) ) {
FUN3( VAR8.VAR9, 0x800000008, uint(VAR1) );
return false;
}
}
if( VAR3 == VAR10 ) {
if( ! VAR4.FUN8(VAR12) ) {
FUN3( VAR8.VAR9, 0x800000009, uint(VAR4) );
return false;
}
}
else {
if( ! VAR3.transfer(VAR4, VAR12) ) {
FUN3( VAR8.VAR9, 0x80000000a, uint(VAR4) );
return false;
}
}
FUN9( VAR8.VAR9, VAR1, VAR2, VAR3, VAR12, VAR4 );
return true;
}
function FUN1( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) internal returns(bool) {
if( VAR5 ) {
if( ! FUN2( VAR1, VAR3, VAR6.VAR7 ) ) {
FUN3( VAR8.VAR9, 0x800000001, 0 );
return false;
}
if( VAR1 == VAR10 ) {
if( msg.value != VAR2 ) {
FUN3( VAR8.VAR9, 0x800000002, msg.value );
return false;
}
}
else if( msg.value > 0 ) {
FUN3( VAR8.VAR9, 0x800000003, msg.value );
return false;
}
else if( VAR1.FUN4(msg.sender, this ) < VAR2 ) {
FUN3( VAR8.VAR9, 0x800000004, VAR1.FUN4(msg.sender, this ) );
return false;
}
}
uint VAR11 = FUN5( VAR1, VAR3, VAR6.VAR7 );
uint VAR12 = (VAR11 * VAR2) / VAR13;
if( VAR12 == 0 ) {
FUN3( VAR8.VAR9, 0x800000005, 0 );
return false;
}
if( VAR3 == VAR10 ) {
if( this.VAR14 < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000006, VAR12 );
return false;
}
}
else {
if( VAR3.FUN6(this) < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000007, uint(VAR3) );
return false;
}
}
if( VAR1 != VAR10 ) {
if( ! VAR1.FUN7(msg.sender,this,VAR2) ) {
FUN3( VAR8.VAR9, 0x800000008, uint(VAR1) );
return false;
}
}
if( VAR3 == VAR10 ) {
if( ! VAR4.FUN8(VAR12) ) {
FUN3( VAR8.VAR9, 0x800000009, uint(VAR4) );
return false;
}
}
else {
if( ! VAR3.transfer(VAR4, VAR12) ) {
FUN3( VAR8.VAR9, 0x80000000a, uint(VAR4) );
return false;
}
}
FUN9( VAR8.VAR9, VAR1, VAR2, VAR3, VAR12, VAR4 );
return true;
}
function FUN1( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) internal returns(bool) {
if( VAR5 ) {
if( ! FUN2( VAR1, VAR3, VAR6.VAR7 ) ) {
FUN3( VAR8.VAR9, 0x800000001, 0 );
return false;
}
if( VAR1 == VAR10 ) {
if( msg.value != VAR2 ) {
FUN3( VAR8.VAR9, 0x800000002, msg.value );
return false;
}
}
else if( msg.value > 0 ) {
FUN3( VAR8.VAR9, 0x800000003, msg.value );
return false;
}
else if( VAR1.FUN4(msg.sender, this ) < VAR2 ) {
FUN3( VAR8.VAR9, 0x800000004, VAR1.FUN4(msg.sender, this ) );
return false;
}
}
uint VAR11 = FUN5( VAR1, VAR3, VAR6.VAR7 );
uint VAR12 = (VAR11 * VAR2) / VAR13;
if( VAR12 == 0 ) {
FUN3( VAR8.VAR9, 0x800000005, 0 );
return false;
}
if( VAR3 == VAR10 ) {
if( this.VAR14 < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000006, VAR12 );
return false;
}
}
else {
if( VAR3.FUN6(this) < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000007, uint(VAR3) );
return false;
}
}
if( VAR1 != VAR10 ) {
if( ! VAR1.FUN7(msg.sender,this,VAR2) ) {
FUN3( VAR8.VAR9, 0x800000008, uint(VAR1) );
return false;
}
}
if( VAR3 == VAR10 ) {
if( ! VAR4.FUN8(VAR12) ) {
FUN3( VAR8.VAR9, 0x800000009, uint(VAR4) );
return false;
}
}
else {
if( ! VAR3.transfer(VAR4, VAR12) ) {
FUN3( VAR8.VAR9, 0x80000000a, uint(VAR4) );
return false;
}
}
FUN9( VAR8.VAR9, VAR1, VAR2, VAR3, VAR12, VAR4 );
return true;
}
function FUN1( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) internal returns(bool) {
if( VAR5 ) {
if( ! FUN2( VAR1, VAR3, VAR6.VAR7 ) ) {
FUN3( VAR8.VAR9, 0x800000001, 0 );
return false;
}
if( VAR1 == VAR10 ) {
if( msg.value != VAR2 ) {
FUN3( VAR8.VAR9, 0x800000002, msg.value );
return false;
}
}
else if( msg.value > 0 ) {
FUN3( VAR8.VAR9, 0x800000003, msg.value );
return false;
}
else if( VAR1.FUN4(msg.sender, this ) < VAR2 ) {
FUN3( VAR8.VAR9, 0x800000004, VAR1.FUN4(msg.sender, this ) );
return false;
}
}
uint VAR11 = FUN5( VAR1, VAR3, VAR6.VAR7 );
uint VAR12 = (VAR11 * VAR2) / VAR13;
if( VAR12 == 0 ) {
FUN3( VAR8.VAR9, 0x800000005, 0 );
return false;
}
if( VAR3 == VAR10 ) {
if( this.VAR14 < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000006, VAR12 );
return false;
}
}
else {
if( VAR3.FUN6(this) < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000007, uint(VAR3) );
return false;
}
}
if( VAR1 != VAR10 ) {
if( ! VAR1.FUN7(msg.sender,this,VAR2) ) {
FUN3( VAR8.VAR9, 0x800000008, uint(VAR1) );
return false;
}
}
if( VAR3 == VAR10 ) {
if( ! VAR4.FUN8(VAR12) ) {
FUN3( VAR8.VAR9, 0x800000009, uint(VAR4) );
return false;
}
}
else {
if( ! VAR3.transfer(VAR4, VAR12) ) {
FUN3( VAR8.VAR9, 0x80000000a, uint(VAR4) );
return false;
}
}
FUN9( VAR8.VAR9, VAR1, VAR2, VAR3, VAR12, VAR4 );
return true;
}
function FUN1( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) internal returns(bool) {
if( VAR5 ) {
if( ! FUN2( VAR1, VAR3, VAR6.VAR7 ) ) {
FUN3( VAR8.VAR9, 0x800000001, 0 );
return false;
}
if( VAR1 == VAR10 ) {
if( msg.value != VAR2 ) {
FUN3( VAR8.VAR9, 0x800000002, msg.value );
return false;
}
}
else if( msg.value > 0 ) {
FUN3( VAR8.VAR9, 0x800000003, msg.value );
return false;
}
else if( VAR1.FUN4(msg.sender, this ) < VAR2 ) {
FUN3( VAR8.VAR9, 0x800000004, VAR1.FUN4(msg.sender, this ) );
return false;
}
}
uint VAR11 = FUN5( VAR1, VAR3, VAR6.VAR7 );
uint VAR12 = (VAR11 * VAR2) / VAR13;
if( VAR12 == 0 ) {
FUN3( VAR8.VAR9, 0x800000005, 0 );
return false;
}
if( VAR3 == VAR10 ) {
if( this.VAR14 < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000006, VAR12 );
return false;
}
}
else {
if( VAR3.FUN6(this) < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000007, uint(VAR3) );
return false;
}
}
if( VAR1 != VAR10 ) {
if( ! VAR1.FUN7(msg.sender,this,VAR2) ) {
FUN3( VAR8.VAR9, 0x800000008, uint(VAR1) );
return false;
}
}
if( VAR3 == VAR10 ) {
if( ! VAR4.FUN8(VAR12) ) {
FUN3( VAR8.VAR9, 0x800000009, uint(VAR4) );
return false;
}
}
else {
if( ! VAR3.transfer(VAR4, VAR12) ) {
FUN3( VAR8.VAR9, 0x80000000a, uint(VAR4) );
return false;
}
}
FUN9( VAR8.VAR9, VAR1, VAR2, VAR3, VAR12, VAR4 );
return true;
}
function FUN1( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) internal returns(bool) {
if( VAR5 ) {
if( ! FUN2( VAR1, VAR3, VAR6.VAR7 ) ) {
FUN3( VAR8.VAR9, 0x800000001, 0 );
return false;
}
if( VAR1 == VAR10 ) {
if( msg.value != VAR2 ) {
FUN3( VAR8.VAR9, 0x800000002, msg.value );
return false;
}
}
else if( msg.value > 0 ) {
FUN3( VAR8.VAR9, 0x800000003, msg.value );
return false;
}
else if( VAR1.FUN4(msg.sender, this ) < VAR2 ) {
FUN3( VAR8.VAR9, 0x800000004, VAR1.FUN4(msg.sender, this ) );
return false;
}
}
uint VAR11 = FUN5( VAR1, VAR3, VAR6.VAR7 );
uint VAR12 = (VAR11 * VAR2) / VAR13;
if( VAR12 == 0 ) {
FUN3( VAR8.VAR9, 0x800000005, 0 );
return false;
}
if( VAR3 == VAR10 ) {
if( this.VAR14 < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000006, VAR12 );
return false;
}
}
else {
if( VAR3.FUN6(this) < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000007, uint(VAR3) );
return false;
}
}
if( VAR1 != VAR10 ) {
if( ! VAR1.FUN7(msg.sender,this,VAR2) ) {
FUN3( VAR8.VAR9, 0x800000008, uint(VAR1) );
return false;
}
}
if( VAR3 == VAR10 ) {
if( ! VAR4.FUN8(VAR12) ) {
FUN3( VAR8.VAR9, 0x800000009, uint(VAR4) );
return false;
}
}
else {
if( ! VAR3.transfer(VAR4, VAR12) ) {
FUN3( VAR8.VAR9, 0x80000000a, uint(VAR4) );
return false;
}
}
FUN9( VAR8.VAR9, VAR1, VAR2, VAR3, VAR12, VAR4 );
return true;
}
function FUN1( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) internal returns(bool) {
if( VAR5 ) {
if( ! FUN2( VAR1, VAR3, VAR6.VAR7 ) ) {
FUN3( VAR8.VAR9, 0x800000001, 0 );
return false;
}
if( VAR1 == VAR10 ) {
if( msg.value != VAR2 ) {
FUN3( VAR8.VAR9, 0x800000002, msg.value );
return false;
}
}
else if( msg.value > 0 ) {
FUN3( VAR8.VAR9, 0x800000003, msg.value );
return false;
}
else if( VAR1.FUN4(msg.sender, this ) < VAR2 ) {
FUN3( VAR8.VAR9, 0x800000004, VAR1.FUN4(msg.sender, this ) );
return false;
}
}
uint VAR11 = FUN5( VAR1, VAR3, VAR6.VAR7 );
uint VAR12 = (VAR11 * VAR2) / VAR13;
if( VAR12 == 0 ) {
FUN3( VAR8.VAR9, 0x800000005, 0 );
return false;
}
if( VAR3 == VAR10 ) {
if( this.VAR14 < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000006, VAR12 );
return false;
}
}
else {
if( VAR3.FUN6(this) < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000007, uint(VAR3) );
return false;
}
}
if( VAR1 != VAR10 ) {
if( ! VAR1.FUN7(msg.sender,this,VAR2) ) {
FUN3( VAR8.VAR9, 0x800000008, uint(VAR1) );
return false;
}
}
if( VAR3 == VAR10 ) {
if( ! VAR4.FUN8(VAR12) ) {
FUN3( VAR8.VAR9, 0x800000009, uint(VAR4) );
return false;
}
}
else {
if( ! VAR3.transfer(VAR4, VAR12) ) {
FUN3( VAR8.VAR9, 0x80000000a, uint(VAR4) );
return false;
}
}
FUN9( VAR8.VAR9, VAR1, VAR2, VAR3, VAR12, VAR4 );
return true;
}
function FUN1( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) internal returns(bool) {
if( VAR5 ) {
if( ! FUN2( VAR1, VAR3, VAR6.VAR7 ) ) {
FUN3( VAR8.VAR9, 0x800000001, 0 );
return false;
}
if( VAR1 == VAR10 ) {
if( msg.value != VAR2 ) {
FUN3( VAR8.VAR9, 0x800000002, msg.value );
return false;
}
}
else if( msg.value > 0 ) {
FUN3( VAR8.VAR9, 0x800000003, msg.value );
return false;
}
else if( VAR1.FUN4(msg.sender, this ) < VAR2 ) {
FUN3( VAR8.VAR9, 0x800000004, VAR1.FUN4(msg.sender, this ) );
return false;
}
}
uint VAR11 = FUN5( VAR1, VAR3, VAR6.VAR7 );
uint VAR12 = (VAR11 * VAR2) / VAR13;
if( VAR12 == 0 ) {
FUN3( VAR8.VAR9, 0x800000005, 0 );
return false;
}
if( VAR3 == VAR10 ) {
if( this.VAR14 < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000006, VAR12 );
return false;
}
}
else {
if( VAR3.FUN6(this) < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000007, uint(VAR3) );
return false;
}
}
if( VAR1 != VAR10 ) {
if( ! VAR1.FUN7(msg.sender,this,VAR2) ) {
FUN3( VAR8.VAR9, 0x800000008, uint(VAR1) );
return false;
}
}
if( VAR3 == VAR10 ) {
if( ! VAR4.FUN8(VAR12) ) {
FUN3( VAR8.VAR9, 0x800000009, uint(VAR4) );
return false;
}
}
else {
if( ! VAR3.transfer(VAR4, VAR12) ) {
FUN3( VAR8.VAR9, 0x80000000a, uint(VAR4) );
return false;
}
}
FUN9( VAR8.VAR9, VAR1, VAR2, VAR3, VAR12, VAR4 );
return true;
}
function FUN10( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) payable returns(bool) {
if( ! VAR15 ) {
FUN3( VAR8.VAR9, 0x810000000, 0 );
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
return false;
}
if( msg.sender != VAR16 ) {
FUN3( VAR8.VAR9, 0x810000001, uint(msg.sender) );
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
return false;
}
if( ! FUN1( VAR1, VAR2, VAR3, VAR4, VAR5 ) ) {
FUN3( VAR8.VAR9, 0x810000002, 0 );
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
return false;
}
FUN3( VAR8.VAR9, 0, 0 );
return true;
}
event FUN11( ERC20 VAR17, ERC20 VAR18, uint VAR19, uint VAR20 );
function FUN10( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) payable returns(bool) {
if( ! VAR15 ) {
FUN3( VAR8.VAR9, 0x810000000, 0 );
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
return false;
}
if( msg.sender != VAR16 ) {
FUN3( VAR8.VAR9, 0x810000001, uint(msg.sender) );
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
return false;
}
if( ! FUN1( VAR1, VAR2, VAR3, VAR4, VAR5 ) ) {
FUN3( VAR8.VAR9, 0x810000002, 0 );
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
return false;
}
FUN3( VAR8.VAR9, 0, 0 );
return true;
}
event FUN11( ERC20 VAR17, ERC20 VAR18, uint VAR19, uint VAR20 );
function FUN10( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) payable returns(bool) {
if( ! VAR15 ) {
FUN3( VAR8.VAR9, 0x810000000, 0 );
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
return false;
}
if( msg.sender != VAR16 ) {
FUN3( VAR8.VAR9, 0x810000001, uint(msg.sender) );
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
return false;
}
if( ! FUN1( VAR1, VAR2, VAR3, VAR4, VAR5 ) ) {
FUN3( VAR8.VAR9, 0x810000002, 0 );
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
return false;
}
FUN3( VAR8.VAR9, 0, 0 );
return true;
}
event FUN11( ERC20 VAR17, ERC20 VAR18, uint VAR19, uint VAR20 );
function FUN10( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) payable returns(bool) {
if( ! VAR15 ) {
FUN3( VAR8.VAR9, 0x810000000, 0 );
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
return false;
}
if( msg.sender != VAR16 ) {
FUN3( VAR8.VAR9, 0x810000001, uint(msg.sender) );
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
return false;
}
if( ! FUN1( VAR1, VAR2, VAR3, VAR4, VAR5 ) ) {
FUN3( VAR8.VAR9, 0x810000002, 0 );
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
return false;
}
FUN3( VAR8.VAR9, 0, 0 );
return true;
}
event FUN11( ERC20 VAR17, ERC20 VAR18, uint VAR19, uint VAR20 );
function FUN12( VAR21[] VAR22, VAR21[] VAR23, uint[] VAR24, uint[] VAR25, bool VAR5 ) returns(bool) {
if( msg.sender != VAR26 ) {
FUN3( VAR8.VAR9, 0x820000000, uint(msg.sender) );
return false;
}
if( VAR5 ) {
if( ( VAR22.VAR27 != VAR23.VAR27 ) || ( VAR22.VAR27 != VAR24.VAR27 ) || ( VAR22.VAR27 != VAR25.VAR27 ) ) {
FUN3( VAR8.VAR9, 0x820000001, 0 );
return false;
}
}
for( uint VAR28 = 0 ; VAR28 < VAR22.VAR27 ; VAR28++ ) {
FUN11( VAR22[VAR28], VAR23[VAR28], VAR24[VAR28], VAR25[VAR28] );
VAR29[FUN13(VAR22[VAR28],VAR23[VAR28])] = FUN14( VAR24[VAR28], VAR25[VAR28] );
}
FUN3( VAR8.VAR9, 0, 0 );
return true;
}
event FUN15( bool VAR30 );
function FUN12( VAR21[] VAR22, VAR21[] VAR23, uint[] VAR24, uint[] VAR25, bool VAR5 ) returns(bool) {
if( msg.sender != VAR26 ) {
FUN3( VAR8.VAR9, 0x820000000, uint(msg.sender) );
return false;
}
if( VAR5 ) {
if( ( VAR22.VAR27 != VAR23.VAR27 ) || ( VAR22.VAR27 != VAR24.VAR27 ) || ( VAR22.VAR27 != VAR25.VAR27 ) ) {
FUN3( VAR8.VAR9, 0x820000001, 0 );
return false;
}
}
for( uint VAR28 = 0 ; VAR28 < VAR22.VAR27 ; VAR28++ ) {
FUN11( VAR22[VAR28], VAR23[VAR28], VAR24[VAR28], VAR25[VAR28] );
VAR29[FUN13(VAR22[VAR28],VAR23[VAR28])] = FUN14( VAR24[VAR28], VAR25[VAR28] );
}
FUN3( VAR8.VAR9, 0, 0 );
return true;
}
event FUN15( bool VAR30 );
function FUN12( VAR21[] VAR22, VAR21[] VAR23, uint[] VAR24, uint[] VAR25, bool VAR5 ) returns(bool) {
if( msg.sender != VAR26 ) {
FUN3( VAR8.VAR9, 0x820000000, uint(msg.sender) );
return false;
}
if( VAR5 ) {
if( ( VAR22.VAR27 != VAR23.VAR27 ) || ( VAR22.VAR27 != VAR24.VAR27 ) || ( VAR22.VAR27 != VAR25.VAR27 ) ) {
FUN3( VAR8.VAR9, 0x820000001, 0 );
return false;
}
}
for( uint VAR28 = 0 ; VAR28 < VAR22.VAR27 ; VAR28++ ) {
FUN11( VAR22[VAR28], VAR23[VAR28], VAR24[VAR28], VAR25[VAR28] );
VAR29[FUN13(VAR22[VAR28],VAR23[VAR28])] = FUN14( VAR24[VAR28], VAR25[VAR28] );
}
FUN3( VAR8.VAR9, 0, 0 );
return true;
}
event FUN15( bool VAR30 );
function FUN16( bool VAR30 ) returns(bool){
if( msg.sender != VAR26 ) {
FUN3( VAR8.VAR9, 0x830000000, uint(msg.sender) );
return false;
}
VAR15 = VAR30;
FUN3( VAR8.VAR9, 0, 0 );
FUN15( VAR30 );
return true;
}
event FUN17( ERC20 VAR31, uint VAR32 );
function FUN16( bool VAR30 ) returns(bool){
if( msg.sender != VAR26 ) {
FUN3( VAR8.VAR9, 0x830000000, uint(msg.sender) );
return false;
}
VAR15 = VAR30;
FUN3( VAR8.VAR9, 0, 0 );
FUN15( VAR30 );
return true;
}
event FUN17( ERC20 VAR31, uint VAR32 );
function FUN18( ) payable returns(bool) {
FUN3( VAR8.VAR9, 0, 0 );
FUN17( VAR10, msg.value );
return true;
}
function FUN19( ERC20 VAR31, uint VAR32 ) returns(bool) {
if( VAR31.FUN4( msg.sender, this ) < VAR32 ) {
FUN3( VAR8.VAR9, 0x850000001, VAR31.FUN4( msg.sender, this ) );
return false;
}
if( ! VAR31.FUN7(msg.sender, this, VAR32 ) ) {
FUN3( VAR8.VAR9, 0x850000002, uint(VAR31) );
return false;
}
FUN17( VAR31, VAR32 );
return true;
}
event FUN20( ERC20 VAR31, uint VAR32, address VAR33 );
function FUN19( ERC20 VAR31, uint VAR32 ) returns(bool) {
if( VAR31.FUN4( msg.sender, this ) < VAR32 ) {
FUN3( VAR8.VAR9, 0x850000001, VAR31.FUN4( msg.sender, this ) );
return false;
}
if( ! VAR31.FUN7(msg.sender, this, VAR32 ) ) {
FUN3( VAR8.VAR9, 0x850000002, uint(VAR31) );
return false;
}
FUN17( VAR31, VAR32 );
return true;
}
event FUN20( ERC20 VAR31, uint VAR32, address VAR33 );
function FUN21( ERC20 VAR31, uint VAR32, address VAR33 ) returns(bool) {
if( msg.sender != VAR26 ) {
FUN3( VAR8.VAR9, 0x860000000, uint(msg.sender) );
return false;
}
if( VAR31 == VAR10 ) {
if( ! VAR33.FUN8(VAR32) ) throw;
}
else if( ! VAR31.transfer(VAR33,VAR32) ) {
FUN3( VAR8.VAR9, 0x860000001, uint(VAR31) );
return false;
}
FUN3( VAR8.VAR9, 0, 0 );
FUN20( VAR31, VAR32, VAR33 );
}
function FUN21( ERC20 VAR31, uint VAR32, address VAR33 ) returns(bool) {
if( msg.sender != VAR26 ) {
FUN3( VAR8.VAR9, 0x860000000, uint(msg.sender) );
return false;
}
if( VAR31 == VAR10 ) {
if( ! VAR33.FUN8(VAR32) ) throw;
}
else if( ! VAR31.transfer(VAR33,VAR32) ) {
FUN3( VAR8.VAR9, 0x860000001, uint(VAR31) );
return false;
}
FUN3( VAR8.VAR9, 0, 0 );
FUN20( VAR31, VAR32, VAR33 );
}
function FUN21( ERC20 VAR31, uint VAR32, address VAR33 ) returns(bool) {
if( msg.sender != VAR26 ) {
FUN3( VAR8.VAR9, 0x860000000, uint(msg.sender) );
return false;
}
if( VAR31 == VAR10 ) {
if( ! VAR33.FUN8(VAR32) ) throw;
}
else if( ! VAR31.transfer(VAR33,VAR32) ) {
FUN3( VAR8.VAR9, 0x860000001, uint(VAR31) );
return false;
}
FUN3( VAR8.VAR9, 0, 0 );
FUN20( VAR31, VAR32, VAR33 );
}",TO,4
32290.sol,"function FUN1( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) internal returns(bool) {
if( VAR5 ) {
if( ! FUN2( VAR1, VAR3, VAR6.VAR7 ) ) {
FUN3( VAR8.VAR9, 0x800000001, 0 );
return false;
}
if( VAR1 == VAR10 ) {
if( msg.value != VAR2 ) {
FUN3( VAR8.VAR9, 0x800000002, msg.value );
return false;
}
}
else if( msg.value > 0 ) {
FUN3( VAR8.VAR9, 0x800000003, msg.value );
return false;
}
else if( VAR1.FUN4(msg.sender, this ) < VAR2 ) {
FUN3( VAR8.VAR9, 0x800000004, VAR1.FUN4(msg.sender, this ) );
return false;
}
}
uint VAR11 = FUN5( VAR1, VAR3, VAR6.VAR7 );
uint VAR12 = (VAR11 * VAR2) / VAR13;
if( VAR12 == 0 ) {
FUN3( VAR8.VAR9, 0x800000005, 0 );
return false;
}
if( VAR3 == VAR10 ) {
if( this.VAR14 < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000006, VAR12 );
return false;
}
}
else {
if( VAR3.FUN6(this) < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000007, uint(VAR3) );
return false;
}
}
if( VAR1 != VAR10 ) {
if( ! VAR1.FUN7(msg.sender,this,VAR2) ) {
FUN3( VAR8.VAR9, 0x800000008, uint(VAR1) );
return false;
}
}
if( VAR3 == VAR10 ) {
if( ! VAR4.FUN8(VAR12) ) {
FUN3( VAR8.VAR9, 0x800000009, uint(VAR4) );
return false;
}
}
else {
if( ! VAR3.transfer(VAR4, VAR12) ) {
FUN3( VAR8.VAR9, 0x80000000a, uint(VAR4) );
return false;
}
}
FUN9( VAR8.VAR9, VAR1, VAR2, VAR3, VAR12, VAR4 );
return true;
}
function FUN1( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) internal returns(bool) {
if( VAR5 ) {
if( ! FUN2( VAR1, VAR3, VAR6.VAR7 ) ) {
FUN3( VAR8.VAR9, 0x800000001, 0 );
return false;
}
if( VAR1 == VAR10 ) {
if( msg.value != VAR2 ) {
FUN3( VAR8.VAR9, 0x800000002, msg.value );
return false;
}
}
else if( msg.value > 0 ) {
FUN3( VAR8.VAR9, 0x800000003, msg.value );
return false;
}
else if( VAR1.FUN4(msg.sender, this ) < VAR2 ) {
FUN3( VAR8.VAR9, 0x800000004, VAR1.FUN4(msg.sender, this ) );
return false;
}
}
uint VAR11 = FUN5( VAR1, VAR3, VAR6.VAR7 );
uint VAR12 = (VAR11 * VAR2) / VAR13;
if( VAR12 == 0 ) {
FUN3( VAR8.VAR9, 0x800000005, 0 );
return false;
}
if( VAR3 == VAR10 ) {
if( this.VAR14 < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000006, VAR12 );
return false;
}
}
else {
if( VAR3.FUN6(this) < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000007, uint(VAR3) );
return false;
}
}
if( VAR1 != VAR10 ) {
if( ! VAR1.FUN7(msg.sender,this,VAR2) ) {
FUN3( VAR8.VAR9, 0x800000008, uint(VAR1) );
return false;
}
}
if( VAR3 == VAR10 ) {
if( ! VAR4.FUN8(VAR12) ) {
FUN3( VAR8.VAR9, 0x800000009, uint(VAR4) );
return false;
}
}
else {
if( ! VAR3.transfer(VAR4, VAR12) ) {
FUN3( VAR8.VAR9, 0x80000000a, uint(VAR4) );
return false;
}
}
FUN9( VAR8.VAR9, VAR1, VAR2, VAR3, VAR12, VAR4 );
return true;
}
function FUN1( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) internal returns(bool) {
if( VAR5 ) {
if( ! FUN2( VAR1, VAR3, VAR6.VAR7 ) ) {
FUN3( VAR8.VAR9, 0x800000001, 0 );
return false;
}
if( VAR1 == VAR10 ) {
if( msg.value != VAR2 ) {
FUN3( VAR8.VAR9, 0x800000002, msg.value );
return false;
}
}
else if( msg.value > 0 ) {
FUN3( VAR8.VAR9, 0x800000003, msg.value );
return false;
}
else if( VAR1.FUN4(msg.sender, this ) < VAR2 ) {
FUN3( VAR8.VAR9, 0x800000004, VAR1.FUN4(msg.sender, this ) );
return false;
}
}
uint VAR11 = FUN5( VAR1, VAR3, VAR6.VAR7 );
uint VAR12 = (VAR11 * VAR2) / VAR13;
if( VAR12 == 0 ) {
FUN3( VAR8.VAR9, 0x800000005, 0 );
return false;
}
if( VAR3 == VAR10 ) {
if( this.VAR14 < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000006, VAR12 );
return false;
}
}
else {
if( VAR3.FUN6(this) < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000007, uint(VAR3) );
return false;
}
}
if( VAR1 != VAR10 ) {
if( ! VAR1.FUN7(msg.sender,this,VAR2) ) {
FUN3( VAR8.VAR9, 0x800000008, uint(VAR1) );
return false;
}
}
if( VAR3 == VAR10 ) {
if( ! VAR4.FUN8(VAR12) ) {
FUN3( VAR8.VAR9, 0x800000009, uint(VAR4) );
return false;
}
}
else {
if( ! VAR3.transfer(VAR4, VAR12) ) {
FUN3( VAR8.VAR9, 0x80000000a, uint(VAR4) );
return false;
}
}
FUN9( VAR8.VAR9, VAR1, VAR2, VAR3, VAR12, VAR4 );
return true;
}
function FUN1( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) internal returns(bool) {
if( VAR5 ) {
if( ! FUN2( VAR1, VAR3, VAR6.VAR7 ) ) {
FUN3( VAR8.VAR9, 0x800000001, 0 );
return false;
}
if( VAR1 == VAR10 ) {
if( msg.value != VAR2 ) {
FUN3( VAR8.VAR9, 0x800000002, msg.value );
return false;
}
}
else if( msg.value > 0 ) {
FUN3( VAR8.VAR9, 0x800000003, msg.value );
return false;
}
else if( VAR1.FUN4(msg.sender, this ) < VAR2 ) {
FUN3( VAR8.VAR9, 0x800000004, VAR1.FUN4(msg.sender, this ) );
return false;
}
}
uint VAR11 = FUN5( VAR1, VAR3, VAR6.VAR7 );
uint VAR12 = (VAR11 * VAR2) / VAR13;
if( VAR12 == 0 ) {
FUN3( VAR8.VAR9, 0x800000005, 0 );
return false;
}
if( VAR3 == VAR10 ) {
if( this.VAR14 < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000006, VAR12 );
return false;
}
}
else {
if( VAR3.FUN6(this) < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000007, uint(VAR3) );
return false;
}
}
if( VAR1 != VAR10 ) {
if( ! VAR1.FUN7(msg.sender,this,VAR2) ) {
FUN3( VAR8.VAR9, 0x800000008, uint(VAR1) );
return false;
}
}
if( VAR3 == VAR10 ) {
if( ! VAR4.FUN8(VAR12) ) {
FUN3( VAR8.VAR9, 0x800000009, uint(VAR4) );
return false;
}
}
else {
if( ! VAR3.transfer(VAR4, VAR12) ) {
FUN3( VAR8.VAR9, 0x80000000a, uint(VAR4) );
return false;
}
}
FUN9( VAR8.VAR9, VAR1, VAR2, VAR3, VAR12, VAR4 );
return true;
}
function FUN1( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) internal returns(bool) {
if( VAR5 ) {
if( ! FUN2( VAR1, VAR3, VAR6.VAR7 ) ) {
FUN3( VAR8.VAR9, 0x800000001, 0 );
return false;
}
if( VAR1 == VAR10 ) {
if( msg.value != VAR2 ) {
FUN3( VAR8.VAR9, 0x800000002, msg.value );
return false;
}
}
else if( msg.value > 0 ) {
FUN3( VAR8.VAR9, 0x800000003, msg.value );
return false;
}
else if( VAR1.FUN4(msg.sender, this ) < VAR2 ) {
FUN3( VAR8.VAR9, 0x800000004, VAR1.FUN4(msg.sender, this ) );
return false;
}
}
uint VAR11 = FUN5( VAR1, VAR3, VAR6.VAR7 );
uint VAR12 = (VAR11 * VAR2) / VAR13;
if( VAR12 == 0 ) {
FUN3( VAR8.VAR9, 0x800000005, 0 );
return false;
}
if( VAR3 == VAR10 ) {
if( this.VAR14 < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000006, VAR12 );
return false;
}
}
else {
if( VAR3.FUN6(this) < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000007, uint(VAR3) );
return false;
}
}
if( VAR1 != VAR10 ) {
if( ! VAR1.FUN7(msg.sender,this,VAR2) ) {
FUN3( VAR8.VAR9, 0x800000008, uint(VAR1) );
return false;
}
}
if( VAR3 == VAR10 ) {
if( ! VAR4.FUN8(VAR12) ) {
FUN3( VAR8.VAR9, 0x800000009, uint(VAR4) );
return false;
}
}
else {
if( ! VAR3.transfer(VAR4, VAR12) ) {
FUN3( VAR8.VAR9, 0x80000000a, uint(VAR4) );
return false;
}
}
FUN9( VAR8.VAR9, VAR1, VAR2, VAR3, VAR12, VAR4 );
return true;
}
function FUN1( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) internal returns(bool) {
if( VAR5 ) {
if( ! FUN2( VAR1, VAR3, VAR6.VAR7 ) ) {
FUN3( VAR8.VAR9, 0x800000001, 0 );
return false;
}
if( VAR1 == VAR10 ) {
if( msg.value != VAR2 ) {
FUN3( VAR8.VAR9, 0x800000002, msg.value );
return false;
}
}
else if( msg.value > 0 ) {
FUN3( VAR8.VAR9, 0x800000003, msg.value );
return false;
}
else if( VAR1.FUN4(msg.sender, this ) < VAR2 ) {
FUN3( VAR8.VAR9, 0x800000004, VAR1.FUN4(msg.sender, this ) );
return false;
}
}
uint VAR11 = FUN5( VAR1, VAR3, VAR6.VAR7 );
uint VAR12 = (VAR11 * VAR2) / VAR13;
if( VAR12 == 0 ) {
FUN3( VAR8.VAR9, 0x800000005, 0 );
return false;
}
if( VAR3 == VAR10 ) {
if( this.VAR14 < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000006, VAR12 );
return false;
}
}
else {
if( VAR3.FUN6(this) < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000007, uint(VAR3) );
return false;
}
}
if( VAR1 != VAR10 ) {
if( ! VAR1.FUN7(msg.sender,this,VAR2) ) {
FUN3( VAR8.VAR9, 0x800000008, uint(VAR1) );
return false;
}
}
if( VAR3 == VAR10 ) {
if( ! VAR4.FUN8(VAR12) ) {
FUN3( VAR8.VAR9, 0x800000009, uint(VAR4) );
return false;
}
}
else {
if( ! VAR3.transfer(VAR4, VAR12) ) {
FUN3( VAR8.VAR9, 0x80000000a, uint(VAR4) );
return false;
}
}
FUN9( VAR8.VAR9, VAR1, VAR2, VAR3, VAR12, VAR4 );
return true;
}
function FUN1( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) internal returns(bool) {
if( VAR5 ) {
if( ! FUN2( VAR1, VAR3, VAR6.VAR7 ) ) {
FUN3( VAR8.VAR9, 0x800000001, 0 );
return false;
}
if( VAR1 == VAR10 ) {
if( msg.value != VAR2 ) {
FUN3( VAR8.VAR9, 0x800000002, msg.value );
return false;
}
}
else if( msg.value > 0 ) {
FUN3( VAR8.VAR9, 0x800000003, msg.value );
return false;
}
else if( VAR1.FUN4(msg.sender, this ) < VAR2 ) {
FUN3( VAR8.VAR9, 0x800000004, VAR1.FUN4(msg.sender, this ) );
return false;
}
}
uint VAR11 = FUN5( VAR1, VAR3, VAR6.VAR7 );
uint VAR12 = (VAR11 * VAR2) / VAR13;
if( VAR12 == 0 ) {
FUN3( VAR8.VAR9, 0x800000005, 0 );
return false;
}
if( VAR3 == VAR10 ) {
if( this.VAR14 < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000006, VAR12 );
return false;
}
}
else {
if( VAR3.FUN6(this) < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000007, uint(VAR3) );
return false;
}
}
if( VAR1 != VAR10 ) {
if( ! VAR1.FUN7(msg.sender,this,VAR2) ) {
FUN3( VAR8.VAR9, 0x800000008, uint(VAR1) );
return false;
}
}
if( VAR3 == VAR10 ) {
if( ! VAR4.FUN8(VAR12) ) {
FUN3( VAR8.VAR9, 0x800000009, uint(VAR4) );
return false;
}
}
else {
if( ! VAR3.transfer(VAR4, VAR12) ) {
FUN3( VAR8.VAR9, 0x80000000a, uint(VAR4) );
return false;
}
}
FUN9( VAR8.VAR9, VAR1, VAR2, VAR3, VAR12, VAR4 );
return true;
}
function FUN1( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) internal returns(bool) {
if( VAR5 ) {
if( ! FUN2( VAR1, VAR3, VAR6.VAR7 ) ) {
FUN3( VAR8.VAR9, 0x800000001, 0 );
return false;
}
if( VAR1 == VAR10 ) {
if( msg.value != VAR2 ) {
FUN3( VAR8.VAR9, 0x800000002, msg.value );
return false;
}
}
else if( msg.value > 0 ) {
FUN3( VAR8.VAR9, 0x800000003, msg.value );
return false;
}
else if( VAR1.FUN4(msg.sender, this ) < VAR2 ) {
FUN3( VAR8.VAR9, 0x800000004, VAR1.FUN4(msg.sender, this ) );
return false;
}
}
uint VAR11 = FUN5( VAR1, VAR3, VAR6.VAR7 );
uint VAR12 = (VAR11 * VAR2) / VAR13;
if( VAR12 == 0 ) {
FUN3( VAR8.VAR9, 0x800000005, 0 );
return false;
}
if( VAR3 == VAR10 ) {
if( this.VAR14 < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000006, VAR12 );
return false;
}
}
else {
if( VAR3.FUN6(this) < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000007, uint(VAR3) );
return false;
}
}
if( VAR1 != VAR10 ) {
if( ! VAR1.FUN7(msg.sender,this,VAR2) ) {
FUN3( VAR8.VAR9, 0x800000008, uint(VAR1) );
return false;
}
}
if( VAR3 == VAR10 ) {
if( ! VAR4.FUN8(VAR12) ) {
FUN3( VAR8.VAR9, 0x800000009, uint(VAR4) );
return false;
}
}
else {
if( ! VAR3.transfer(VAR4, VAR12) ) {
FUN3( VAR8.VAR9, 0x80000000a, uint(VAR4) );
return false;
}
}
FUN9( VAR8.VAR9, VAR1, VAR2, VAR3, VAR12, VAR4 );
return true;
}
function FUN1( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) internal returns(bool) {
if( VAR5 ) {
if( ! FUN2( VAR1, VAR3, VAR6.VAR7 ) ) {
FUN3( VAR8.VAR9, 0x800000001, 0 );
return false;
}
if( VAR1 == VAR10 ) {
if( msg.value != VAR2 ) {
FUN3( VAR8.VAR9, 0x800000002, msg.value );
return false;
}
}
else if( msg.value > 0 ) {
FUN3( VAR8.VAR9, 0x800000003, msg.value );
return false;
}
else if( VAR1.FUN4(msg.sender, this ) < VAR2 ) {
FUN3( VAR8.VAR9, 0x800000004, VAR1.FUN4(msg.sender, this ) );
return false;
}
}
uint VAR11 = FUN5( VAR1, VAR3, VAR6.VAR7 );
uint VAR12 = (VAR11 * VAR2) / VAR13;
if( VAR12 == 0 ) {
FUN3( VAR8.VAR9, 0x800000005, 0 );
return false;
}
if( VAR3 == VAR10 ) {
if( this.VAR14 < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000006, VAR12 );
return false;
}
}
else {
if( VAR3.FUN6(this) < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000007, uint(VAR3) );
return false;
}
}
if( VAR1 != VAR10 ) {
if( ! VAR1.FUN7(msg.sender,this,VAR2) ) {
FUN3( VAR8.VAR9, 0x800000008, uint(VAR1) );
return false;
}
}
if( VAR3 == VAR10 ) {
if( ! VAR4.FUN8(VAR12) ) {
FUN3( VAR8.VAR9, 0x800000009, uint(VAR4) );
return false;
}
}
else {
if( ! VAR3.transfer(VAR4, VAR12) ) {
FUN3( VAR8.VAR9, 0x80000000a, uint(VAR4) );
return false;
}
}
FUN9( VAR8.VAR9, VAR1, VAR2, VAR3, VAR12, VAR4 );
return true;
}
function FUN1( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) internal returns(bool) {
if( VAR5 ) {
if( ! FUN2( VAR1, VAR3, VAR6.VAR7 ) ) {
FUN3( VAR8.VAR9, 0x800000001, 0 );
return false;
}
if( VAR1 == VAR10 ) {
if( msg.value != VAR2 ) {
FUN3( VAR8.VAR9, 0x800000002, msg.value );
return false;
}
}
else if( msg.value > 0 ) {
FUN3( VAR8.VAR9, 0x800000003, msg.value );
return false;
}
else if( VAR1.FUN4(msg.sender, this ) < VAR2 ) {
FUN3( VAR8.VAR9, 0x800000004, VAR1.FUN4(msg.sender, this ) );
return false;
}
}
uint VAR11 = FUN5( VAR1, VAR3, VAR6.VAR7 );
uint VAR12 = (VAR11 * VAR2) / VAR13;
if( VAR12 == 0 ) {
FUN3( VAR8.VAR9, 0x800000005, 0 );
return false;
}
if( VAR3 == VAR10 ) {
if( this.VAR14 < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000006, VAR12 );
return false;
}
}
else {
if( VAR3.FUN6(this) < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000007, uint(VAR3) );
return false;
}
}
if( VAR1 != VAR10 ) {
if( ! VAR1.FUN7(msg.sender,this,VAR2) ) {
FUN3( VAR8.VAR9, 0x800000008, uint(VAR1) );
return false;
}
}
if( VAR3 == VAR10 ) {
if( ! VAR4.FUN8(VAR12) ) {
FUN3( VAR8.VAR9, 0x800000009, uint(VAR4) );
return false;
}
}
else {
if( ! VAR3.transfer(VAR4, VAR12) ) {
FUN3( VAR8.VAR9, 0x80000000a, uint(VAR4) );
return false;
}
}
FUN9( VAR8.VAR9, VAR1, VAR2, VAR3, VAR12, VAR4 );
return true;
}
function FUN1( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) internal returns(bool) {
if( VAR5 ) {
if( ! FUN2( VAR1, VAR3, VAR6.VAR7 ) ) {
FUN3( VAR8.VAR9, 0x800000001, 0 );
return false;
}
if( VAR1 == VAR10 ) {
if( msg.value != VAR2 ) {
FUN3( VAR8.VAR9, 0x800000002, msg.value );
return false;
}
}
else if( msg.value > 0 ) {
FUN3( VAR8.VAR9, 0x800000003, msg.value );
return false;
}
else if( VAR1.FUN4(msg.sender, this ) < VAR2 ) {
FUN3( VAR8.VAR9, 0x800000004, VAR1.FUN4(msg.sender, this ) );
return false;
}
}
uint VAR11 = FUN5( VAR1, VAR3, VAR6.VAR7 );
uint VAR12 = (VAR11 * VAR2) / VAR13;
if( VAR12 == 0 ) {
FUN3( VAR8.VAR9, 0x800000005, 0 );
return false;
}
if( VAR3 == VAR10 ) {
if( this.VAR14 < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000006, VAR12 );
return false;
}
}
else {
if( VAR3.FUN6(this) < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000007, uint(VAR3) );
return false;
}
}
if( VAR1 != VAR10 ) {
if( ! VAR1.FUN7(msg.sender,this,VAR2) ) {
FUN3( VAR8.VAR9, 0x800000008, uint(VAR1) );
return false;
}
}
if( VAR3 == VAR10 ) {
if( ! VAR4.FUN8(VAR12) ) {
FUN3( VAR8.VAR9, 0x800000009, uint(VAR4) );
return false;
}
}
else {
if( ! VAR3.transfer(VAR4, VAR12) ) {
FUN3( VAR8.VAR9, 0x80000000a, uint(VAR4) );
return false;
}
}
FUN9( VAR8.VAR9, VAR1, VAR2, VAR3, VAR12, VAR4 );
return true;
}
function FUN10( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) payable returns(bool) {
if( ! VAR15 ) {
FUN3( VAR8.VAR9, 0x810000000, 0 );
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
return false;
}
if( msg.sender != VAR16 ) {
FUN3( VAR8.VAR9, 0x810000001, uint(msg.sender) );
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
return false;
}
if( ! FUN1( VAR1, VAR2, VAR3, VAR4, VAR5 ) ) {
FUN3( VAR8.VAR9, 0x810000002, 0 );
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
return false;
}
FUN3( VAR8.VAR9, 0, 0 );
return true;
}
event FUN11( ERC20 VAR17, ERC20 VAR18, uint VAR19, uint VAR20 );
function FUN10( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) payable returns(bool) {
if( ! VAR15 ) {
FUN3( VAR8.VAR9, 0x810000000, 0 );
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
return false;
}
if( msg.sender != VAR16 ) {
FUN3( VAR8.VAR9, 0x810000001, uint(msg.sender) );
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
return false;
}
if( ! FUN1( VAR1, VAR2, VAR3, VAR4, VAR5 ) ) {
FUN3( VAR8.VAR9, 0x810000002, 0 );
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
return false;
}
FUN3( VAR8.VAR9, 0, 0 );
return true;
}
event FUN11( ERC20 VAR17, ERC20 VAR18, uint VAR19, uint VAR20 );
function FUN10( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) payable returns(bool) {
if( ! VAR15 ) {
FUN3( VAR8.VAR9, 0x810000000, 0 );
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
return false;
}
if( msg.sender != VAR16 ) {
FUN3( VAR8.VAR9, 0x810000001, uint(msg.sender) );
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
return false;
}
if( ! FUN1( VAR1, VAR2, VAR3, VAR4, VAR5 ) ) {
FUN3( VAR8.VAR9, 0x810000002, 0 );
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
return false;
}
FUN3( VAR8.VAR9, 0, 0 );
return true;
}
event FUN11( ERC20 VAR17, ERC20 VAR18, uint VAR19, uint VAR20 );
function FUN10( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) payable returns(bool) {
if( ! VAR15 ) {
FUN3( VAR8.VAR9, 0x810000000, 0 );
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
return false;
}
if( msg.sender != VAR16 ) {
FUN3( VAR8.VAR9, 0x810000001, uint(msg.sender) );
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
return false;
}
if( ! FUN1( VAR1, VAR2, VAR3, VAR4, VAR5 ) ) {
FUN3( VAR8.VAR9, 0x810000002, 0 );
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
return false;
}
FUN3( VAR8.VAR9, 0, 0 );
return true;
}
event FUN11( ERC20 VAR17, ERC20 VAR18, uint VAR19, uint VAR20 );
function FUN12( VAR21[] VAR22, VAR21[] VAR23, uint[] VAR24, uint[] VAR25, bool VAR5 ) returns(bool) {
if( msg.sender != VAR26 ) {
FUN3( VAR8.VAR9, 0x820000000, uint(msg.sender) );
return false;
}
if( VAR5 ) {
if( ( VAR22.VAR27 != VAR23.VAR27 ) || ( VAR22.VAR27 != VAR24.VAR27 ) || ( VAR22.VAR27 != VAR25.VAR27 ) ) {
FUN3( VAR8.VAR9, 0x820000001, 0 );
return false;
}
}
for( uint VAR28 = 0 ; VAR28 < VAR22.VAR27 ; VAR28++ ) {
FUN11( VAR22[VAR28], VAR23[VAR28], VAR24[VAR28], VAR25[VAR28] );
VAR29[FUN13(VAR22[VAR28],VAR23[VAR28])] = FUN14( VAR24[VAR28], VAR25[VAR28] );
}
FUN3( VAR8.VAR9, 0, 0 );
return true;
}
event FUN15( bool VAR30 );
function FUN12( VAR21[] VAR22, VAR21[] VAR23, uint[] VAR24, uint[] VAR25, bool VAR5 ) returns(bool) {
if( msg.sender != VAR26 ) {
FUN3( VAR8.VAR9, 0x820000000, uint(msg.sender) );
return false;
}
if( VAR5 ) {
if( ( VAR22.VAR27 != VAR23.VAR27 ) || ( VAR22.VAR27 != VAR24.VAR27 ) || ( VAR22.VAR27 != VAR25.VAR27 ) ) {
FUN3( VAR8.VAR9, 0x820000001, 0 );
return false;
}
}
for( uint VAR28 = 0 ; VAR28 < VAR22.VAR27 ; VAR28++ ) {
FUN11( VAR22[VAR28], VAR23[VAR28], VAR24[VAR28], VAR25[VAR28] );
VAR29[FUN13(VAR22[VAR28],VAR23[VAR28])] = FUN14( VAR24[VAR28], VAR25[VAR28] );
}
FUN3( VAR8.VAR9, 0, 0 );
return true;
}
event FUN15( bool VAR30 );
function FUN12( VAR21[] VAR22, VAR21[] VAR23, uint[] VAR24, uint[] VAR25, bool VAR5 ) returns(bool) {
if( msg.sender != VAR26 ) {
FUN3( VAR8.VAR9, 0x820000000, uint(msg.sender) );
return false;
}
if( VAR5 ) {
if( ( VAR22.VAR27 != VAR23.VAR27 ) || ( VAR22.VAR27 != VAR24.VAR27 ) || ( VAR22.VAR27 != VAR25.VAR27 ) ) {
FUN3( VAR8.VAR9, 0x820000001, 0 );
return false;
}
}
for( uint VAR28 = 0 ; VAR28 < VAR22.VAR27 ; VAR28++ ) {
FUN11( VAR22[VAR28], VAR23[VAR28], VAR24[VAR28], VAR25[VAR28] );
VAR29[FUN13(VAR22[VAR28],VAR23[VAR28])] = FUN14( VAR24[VAR28], VAR25[VAR28] );
}
FUN3( VAR8.VAR9, 0, 0 );
return true;
}
event FUN15( bool VAR30 );
function FUN16( bool VAR30 ) returns(bool){
if( msg.sender != VAR26 ) {
FUN3( VAR8.VAR9, 0x830000000, uint(msg.sender) );
return false;
}
VAR15 = VAR30;
FUN3( VAR8.VAR9, 0, 0 );
FUN15( VAR30 );
return true;
}
event FUN17( ERC20 VAR31, uint VAR32 );
function FUN16( bool VAR30 ) returns(bool){
if( msg.sender != VAR26 ) {
FUN3( VAR8.VAR9, 0x830000000, uint(msg.sender) );
return false;
}
VAR15 = VAR30;
FUN3( VAR8.VAR9, 0, 0 );
FUN15( VAR30 );
return true;
}
event FUN17( ERC20 VAR31, uint VAR32 );
function FUN18( ) payable returns(bool) {
FUN3( VAR8.VAR9, 0, 0 );
FUN17( VAR10, msg.value );
return true;
}
function FUN19( ERC20 VAR31, uint VAR32 ) returns(bool) {
if( VAR31.FUN4( msg.sender, this ) < VAR32 ) {
FUN3( VAR8.VAR9, 0x850000001, VAR31.FUN4( msg.sender, this ) );
return false;
}
if( ! VAR31.FUN7(msg.sender, this, VAR32 ) ) {
FUN3( VAR8.VAR9, 0x850000002, uint(VAR31) );
return false;
}
FUN17( VAR31, VAR32 );
return true;
}
event FUN20( ERC20 VAR31, uint VAR32, address VAR33 );
function FUN19( ERC20 VAR31, uint VAR32 ) returns(bool) {
if( VAR31.FUN4( msg.sender, this ) < VAR32 ) {
FUN3( VAR8.VAR9, 0x850000001, VAR31.FUN4( msg.sender, this ) );
return false;
}
if( ! VAR31.FUN7(msg.sender, this, VAR32 ) ) {
FUN3( VAR8.VAR9, 0x850000002, uint(VAR31) );
return false;
}
FUN17( VAR31, VAR32 );
return true;
}
event FUN20( ERC20 VAR31, uint VAR32, address VAR33 );
function FUN21( ERC20 VAR31, uint VAR32, address VAR33 ) returns(bool) {
if( msg.sender != VAR26 ) {
FUN3( VAR8.VAR9, 0x860000000, uint(msg.sender) );
return false;
}
if( VAR31 == VAR10 ) {
if( ! VAR33.FUN8(VAR32) ) throw;
}
else if( ! VAR31.transfer(VAR33,VAR32) ) {
FUN3( VAR8.VAR9, 0x860000001, uint(VAR31) );
return false;
}
FUN3( VAR8.VAR9, 0, 0 );
FUN20( VAR31, VAR32, VAR33 );
}
function FUN21( ERC20 VAR31, uint VAR32, address VAR33 ) returns(bool) {
if( msg.sender != VAR26 ) {
FUN3( VAR8.VAR9, 0x860000000, uint(msg.sender) );
return false;
}
if( VAR31 == VAR10 ) {
if( ! VAR33.FUN8(VAR32) ) throw;
}
else if( ! VAR31.transfer(VAR33,VAR32) ) {
FUN3( VAR8.VAR9, 0x860000001, uint(VAR31) );
return false;
}
FUN3( VAR8.VAR9, 0, 0 );
FUN20( VAR31, VAR32, VAR33 );
}
function FUN21( ERC20 VAR31, uint VAR32, address VAR33 ) returns(bool) {
if( msg.sender != VAR26 ) {
FUN3( VAR8.VAR9, 0x860000000, uint(msg.sender) );
return false;
}
if( VAR31 == VAR10 ) {
if( ! VAR33.FUN8(VAR32) ) throw;
}
else if( ! VAR31.transfer(VAR33,VAR32) ) {
FUN3( VAR8.VAR9, 0x860000001, uint(VAR31) );
return false;
}
FUN3( VAR8.VAR9, 0, 0 );
FUN20( VAR31, VAR32, VAR33 );
}",TO,4
32291.sol,"function FUN1( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) internal returns(bool) {
if( VAR5 ) {
if( ! FUN2( VAR1, VAR3, VAR6.VAR7 ) ) {
FUN3( VAR8.VAR9, 0x800000001, 0 );
return false;
}
if( VAR1 == VAR10 ) {
if( msg.value != VAR2 ) {
FUN3( VAR8.VAR9, 0x800000002, msg.value );
return false;
}
}
else if( msg.value > 0 ) {
FUN3( VAR8.VAR9, 0x800000003, msg.value );
return false;
}
else if( VAR1.FUN4(msg.sender, this ) < VAR2 ) {
FUN3( VAR8.VAR9, 0x800000004, VAR1.FUN4(msg.sender, this ) );
return false;
}
}
uint VAR11 = FUN5( VAR1, VAR3, VAR6.VAR7 );
uint VAR12 = (VAR11 * VAR2) / VAR13;
if( VAR12 == 0 ) {
FUN3( VAR8.VAR9, 0x800000005, 0 );
return false;
}
if( VAR3 == VAR10 ) {
if( this.VAR14 < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000006, VAR12 );
return false;
}
}
else {
if( VAR3.FUN6(this) < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000007, uint(VAR3) );
return false;
}
}
if( VAR1 != VAR10 ) {
if( ! VAR1.FUN7(msg.sender,this,VAR2) ) {
FUN3( VAR8.VAR9, 0x800000008, uint(VAR1) );
return false;
}
}
if( VAR3 == VAR10 ) {
if( ! VAR4.FUN8(VAR12) ) {
FUN3( VAR8.VAR9, 0x800000009, uint(VAR4) );
return false;
}
}
else {
if( ! VAR3.transfer(VAR4, VAR12) ) {
FUN3( VAR8.VAR9, 0x80000000a, uint(VAR4) );
return false;
}
}
FUN9( VAR8.VAR9, VAR1, VAR2, VAR3, VAR12, VAR4 );
return true;
}
function FUN1( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) internal returns(bool) {
if( VAR5 ) {
if( ! FUN2( VAR1, VAR3, VAR6.VAR7 ) ) {
FUN3( VAR8.VAR9, 0x800000001, 0 );
return false;
}
if( VAR1 == VAR10 ) {
if( msg.value != VAR2 ) {
FUN3( VAR8.VAR9, 0x800000002, msg.value );
return false;
}
}
else if( msg.value > 0 ) {
FUN3( VAR8.VAR9, 0x800000003, msg.value );
return false;
}
else if( VAR1.FUN4(msg.sender, this ) < VAR2 ) {
FUN3( VAR8.VAR9, 0x800000004, VAR1.FUN4(msg.sender, this ) );
return false;
}
}
uint VAR11 = FUN5( VAR1, VAR3, VAR6.VAR7 );
uint VAR12 = (VAR11 * VAR2) / VAR13;
if( VAR12 == 0 ) {
FUN3( VAR8.VAR9, 0x800000005, 0 );
return false;
}
if( VAR3 == VAR10 ) {
if( this.VAR14 < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000006, VAR12 );
return false;
}
}
else {
if( VAR3.FUN6(this) < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000007, uint(VAR3) );
return false;
}
}
if( VAR1 != VAR10 ) {
if( ! VAR1.FUN7(msg.sender,this,VAR2) ) {
FUN3( VAR8.VAR9, 0x800000008, uint(VAR1) );
return false;
}
}
if( VAR3 == VAR10 ) {
if( ! VAR4.FUN8(VAR12) ) {
FUN3( VAR8.VAR9, 0x800000009, uint(VAR4) );
return false;
}
}
else {
if( ! VAR3.transfer(VAR4, VAR12) ) {
FUN3( VAR8.VAR9, 0x80000000a, uint(VAR4) );
return false;
}
}
FUN9( VAR8.VAR9, VAR1, VAR2, VAR3, VAR12, VAR4 );
return true;
}
function FUN1( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) internal returns(bool) {
if( VAR5 ) {
if( ! FUN2( VAR1, VAR3, VAR6.VAR7 ) ) {
FUN3( VAR8.VAR9, 0x800000001, 0 );
return false;
}
if( VAR1 == VAR10 ) {
if( msg.value != VAR2 ) {
FUN3( VAR8.VAR9, 0x800000002, msg.value );
return false;
}
}
else if( msg.value > 0 ) {
FUN3( VAR8.VAR9, 0x800000003, msg.value );
return false;
}
else if( VAR1.FUN4(msg.sender, this ) < VAR2 ) {
FUN3( VAR8.VAR9, 0x800000004, VAR1.FUN4(msg.sender, this ) );
return false;
}
}
uint VAR11 = FUN5( VAR1, VAR3, VAR6.VAR7 );
uint VAR12 = (VAR11 * VAR2) / VAR13;
if( VAR12 == 0 ) {
FUN3( VAR8.VAR9, 0x800000005, 0 );
return false;
}
if( VAR3 == VAR10 ) {
if( this.VAR14 < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000006, VAR12 );
return false;
}
}
else {
if( VAR3.FUN6(this) < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000007, uint(VAR3) );
return false;
}
}
if( VAR1 != VAR10 ) {
if( ! VAR1.FUN7(msg.sender,this,VAR2) ) {
FUN3( VAR8.VAR9, 0x800000008, uint(VAR1) );
return false;
}
}
if( VAR3 == VAR10 ) {
if( ! VAR4.FUN8(VAR12) ) {
FUN3( VAR8.VAR9, 0x800000009, uint(VAR4) );
return false;
}
}
else {
if( ! VAR3.transfer(VAR4, VAR12) ) {
FUN3( VAR8.VAR9, 0x80000000a, uint(VAR4) );
return false;
}
}
FUN9( VAR8.VAR9, VAR1, VAR2, VAR3, VAR12, VAR4 );
return true;
}
function FUN1( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) internal returns(bool) {
if( VAR5 ) {
if( ! FUN2( VAR1, VAR3, VAR6.VAR7 ) ) {
FUN3( VAR8.VAR9, 0x800000001, 0 );
return false;
}
if( VAR1 == VAR10 ) {
if( msg.value != VAR2 ) {
FUN3( VAR8.VAR9, 0x800000002, msg.value );
return false;
}
}
else if( msg.value > 0 ) {
FUN3( VAR8.VAR9, 0x800000003, msg.value );
return false;
}
else if( VAR1.FUN4(msg.sender, this ) < VAR2 ) {
FUN3( VAR8.VAR9, 0x800000004, VAR1.FUN4(msg.sender, this ) );
return false;
}
}
uint VAR11 = FUN5( VAR1, VAR3, VAR6.VAR7 );
uint VAR12 = (VAR11 * VAR2) / VAR13;
if( VAR12 == 0 ) {
FUN3( VAR8.VAR9, 0x800000005, 0 );
return false;
}
if( VAR3 == VAR10 ) {
if( this.VAR14 < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000006, VAR12 );
return false;
}
}
else {
if( VAR3.FUN6(this) < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000007, uint(VAR3) );
return false;
}
}
if( VAR1 != VAR10 ) {
if( ! VAR1.FUN7(msg.sender,this,VAR2) ) {
FUN3( VAR8.VAR9, 0x800000008, uint(VAR1) );
return false;
}
}
if( VAR3 == VAR10 ) {
if( ! VAR4.FUN8(VAR12) ) {
FUN3( VAR8.VAR9, 0x800000009, uint(VAR4) );
return false;
}
}
else {
if( ! VAR3.transfer(VAR4, VAR12) ) {
FUN3( VAR8.VAR9, 0x80000000a, uint(VAR4) );
return false;
}
}
FUN9( VAR8.VAR9, VAR1, VAR2, VAR3, VAR12, VAR4 );
return true;
}
function FUN1( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) internal returns(bool) {
if( VAR5 ) {
if( ! FUN2( VAR1, VAR3, VAR6.VAR7 ) ) {
FUN3( VAR8.VAR9, 0x800000001, 0 );
return false;
}
if( VAR1 == VAR10 ) {
if( msg.value != VAR2 ) {
FUN3( VAR8.VAR9, 0x800000002, msg.value );
return false;
}
}
else if( msg.value > 0 ) {
FUN3( VAR8.VAR9, 0x800000003, msg.value );
return false;
}
else if( VAR1.FUN4(msg.sender, this ) < VAR2 ) {
FUN3( VAR8.VAR9, 0x800000004, VAR1.FUN4(msg.sender, this ) );
return false;
}
}
uint VAR11 = FUN5( VAR1, VAR3, VAR6.VAR7 );
uint VAR12 = (VAR11 * VAR2) / VAR13;
if( VAR12 == 0 ) {
FUN3( VAR8.VAR9, 0x800000005, 0 );
return false;
}
if( VAR3 == VAR10 ) {
if( this.VAR14 < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000006, VAR12 );
return false;
}
}
else {
if( VAR3.FUN6(this) < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000007, uint(VAR3) );
return false;
}
}
if( VAR1 != VAR10 ) {
if( ! VAR1.FUN7(msg.sender,this,VAR2) ) {
FUN3( VAR8.VAR9, 0x800000008, uint(VAR1) );
return false;
}
}
if( VAR3 == VAR10 ) {
if( ! VAR4.FUN8(VAR12) ) {
FUN3( VAR8.VAR9, 0x800000009, uint(VAR4) );
return false;
}
}
else {
if( ! VAR3.transfer(VAR4, VAR12) ) {
FUN3( VAR8.VAR9, 0x80000000a, uint(VAR4) );
return false;
}
}
FUN9( VAR8.VAR9, VAR1, VAR2, VAR3, VAR12, VAR4 );
return true;
}
function FUN1( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) internal returns(bool) {
if( VAR5 ) {
if( ! FUN2( VAR1, VAR3, VAR6.VAR7 ) ) {
FUN3( VAR8.VAR9, 0x800000001, 0 );
return false;
}
if( VAR1 == VAR10 ) {
if( msg.value != VAR2 ) {
FUN3( VAR8.VAR9, 0x800000002, msg.value );
return false;
}
}
else if( msg.value > 0 ) {
FUN3( VAR8.VAR9, 0x800000003, msg.value );
return false;
}
else if( VAR1.FUN4(msg.sender, this ) < VAR2 ) {
FUN3( VAR8.VAR9, 0x800000004, VAR1.FUN4(msg.sender, this ) );
return false;
}
}
uint VAR11 = FUN5( VAR1, VAR3, VAR6.VAR7 );
uint VAR12 = (VAR11 * VAR2) / VAR13;
if( VAR12 == 0 ) {
FUN3( VAR8.VAR9, 0x800000005, 0 );
return false;
}
if( VAR3 == VAR10 ) {
if( this.VAR14 < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000006, VAR12 );
return false;
}
}
else {
if( VAR3.FUN6(this) < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000007, uint(VAR3) );
return false;
}
}
if( VAR1 != VAR10 ) {
if( ! VAR1.FUN7(msg.sender,this,VAR2) ) {
FUN3( VAR8.VAR9, 0x800000008, uint(VAR1) );
return false;
}
}
if( VAR3 == VAR10 ) {
if( ! VAR4.FUN8(VAR12) ) {
FUN3( VAR8.VAR9, 0x800000009, uint(VAR4) );
return false;
}
}
else {
if( ! VAR3.transfer(VAR4, VAR12) ) {
FUN3( VAR8.VAR9, 0x80000000a, uint(VAR4) );
return false;
}
}
FUN9( VAR8.VAR9, VAR1, VAR2, VAR3, VAR12, VAR4 );
return true;
}
function FUN1( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) internal returns(bool) {
if( VAR5 ) {
if( ! FUN2( VAR1, VAR3, VAR6.VAR7 ) ) {
FUN3( VAR8.VAR9, 0x800000001, 0 );
return false;
}
if( VAR1 == VAR10 ) {
if( msg.value != VAR2 ) {
FUN3( VAR8.VAR9, 0x800000002, msg.value );
return false;
}
}
else if( msg.value > 0 ) {
FUN3( VAR8.VAR9, 0x800000003, msg.value );
return false;
}
else if( VAR1.FUN4(msg.sender, this ) < VAR2 ) {
FUN3( VAR8.VAR9, 0x800000004, VAR1.FUN4(msg.sender, this ) );
return false;
}
}
uint VAR11 = FUN5( VAR1, VAR3, VAR6.VAR7 );
uint VAR12 = (VAR11 * VAR2) / VAR13;
if( VAR12 == 0 ) {
FUN3( VAR8.VAR9, 0x800000005, 0 );
return false;
}
if( VAR3 == VAR10 ) {
if( this.VAR14 < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000006, VAR12 );
return false;
}
}
else {
if( VAR3.FUN6(this) < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000007, uint(VAR3) );
return false;
}
}
if( VAR1 != VAR10 ) {
if( ! VAR1.FUN7(msg.sender,this,VAR2) ) {
FUN3( VAR8.VAR9, 0x800000008, uint(VAR1) );
return false;
}
}
if( VAR3 == VAR10 ) {
if( ! VAR4.FUN8(VAR12) ) {
FUN3( VAR8.VAR9, 0x800000009, uint(VAR4) );
return false;
}
}
else {
if( ! VAR3.transfer(VAR4, VAR12) ) {
FUN3( VAR8.VAR9, 0x80000000a, uint(VAR4) );
return false;
}
}
FUN9( VAR8.VAR9, VAR1, VAR2, VAR3, VAR12, VAR4 );
return true;
}
function FUN1( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) internal returns(bool) {
if( VAR5 ) {
if( ! FUN2( VAR1, VAR3, VAR6.VAR7 ) ) {
FUN3( VAR8.VAR9, 0x800000001, 0 );
return false;
}
if( VAR1 == VAR10 ) {
if( msg.value != VAR2 ) {
FUN3( VAR8.VAR9, 0x800000002, msg.value );
return false;
}
}
else if( msg.value > 0 ) {
FUN3( VAR8.VAR9, 0x800000003, msg.value );
return false;
}
else if( VAR1.FUN4(msg.sender, this ) < VAR2 ) {
FUN3( VAR8.VAR9, 0x800000004, VAR1.FUN4(msg.sender, this ) );
return false;
}
}
uint VAR11 = FUN5( VAR1, VAR3, VAR6.VAR7 );
uint VAR12 = (VAR11 * VAR2) / VAR13;
if( VAR12 == 0 ) {
FUN3( VAR8.VAR9, 0x800000005, 0 );
return false;
}
if( VAR3 == VAR10 ) {
if( this.VAR14 < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000006, VAR12 );
return false;
}
}
else {
if( VAR3.FUN6(this) < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000007, uint(VAR3) );
return false;
}
}
if( VAR1 != VAR10 ) {
if( ! VAR1.FUN7(msg.sender,this,VAR2) ) {
FUN3( VAR8.VAR9, 0x800000008, uint(VAR1) );
return false;
}
}
if( VAR3 == VAR10 ) {
if( ! VAR4.FUN8(VAR12) ) {
FUN3( VAR8.VAR9, 0x800000009, uint(VAR4) );
return false;
}
}
else {
if( ! VAR3.transfer(VAR4, VAR12) ) {
FUN3( VAR8.VAR9, 0x80000000a, uint(VAR4) );
return false;
}
}
FUN9( VAR8.VAR9, VAR1, VAR2, VAR3, VAR12, VAR4 );
return true;
}
function FUN1( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) internal returns(bool) {
if( VAR5 ) {
if( ! FUN2( VAR1, VAR3, VAR6.VAR7 ) ) {
FUN3( VAR8.VAR9, 0x800000001, 0 );
return false;
}
if( VAR1 == VAR10 ) {
if( msg.value != VAR2 ) {
FUN3( VAR8.VAR9, 0x800000002, msg.value );
return false;
}
}
else if( msg.value > 0 ) {
FUN3( VAR8.VAR9, 0x800000003, msg.value );
return false;
}
else if( VAR1.FUN4(msg.sender, this ) < VAR2 ) {
FUN3( VAR8.VAR9, 0x800000004, VAR1.FUN4(msg.sender, this ) );
return false;
}
}
uint VAR11 = FUN5( VAR1, VAR3, VAR6.VAR7 );
uint VAR12 = (VAR11 * VAR2) / VAR13;
if( VAR12 == 0 ) {
FUN3( VAR8.VAR9, 0x800000005, 0 );
return false;
}
if( VAR3 == VAR10 ) {
if( this.VAR14 < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000006, VAR12 );
return false;
}
}
else {
if( VAR3.FUN6(this) < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000007, uint(VAR3) );
return false;
}
}
if( VAR1 != VAR10 ) {
if( ! VAR1.FUN7(msg.sender,this,VAR2) ) {
FUN3( VAR8.VAR9, 0x800000008, uint(VAR1) );
return false;
}
}
if( VAR3 == VAR10 ) {
if( ! VAR4.FUN8(VAR12) ) {
FUN3( VAR8.VAR9, 0x800000009, uint(VAR4) );
return false;
}
}
else {
if( ! VAR3.transfer(VAR4, VAR12) ) {
FUN3( VAR8.VAR9, 0x80000000a, uint(VAR4) );
return false;
}
}
FUN9( VAR8.VAR9, VAR1, VAR2, VAR3, VAR12, VAR4 );
return true;
}
function FUN1( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) internal returns(bool) {
if( VAR5 ) {
if( ! FUN2( VAR1, VAR3, VAR6.VAR7 ) ) {
FUN3( VAR8.VAR9, 0x800000001, 0 );
return false;
}
if( VAR1 == VAR10 ) {
if( msg.value != VAR2 ) {
FUN3( VAR8.VAR9, 0x800000002, msg.value );
return false;
}
}
else if( msg.value > 0 ) {
FUN3( VAR8.VAR9, 0x800000003, msg.value );
return false;
}
else if( VAR1.FUN4(msg.sender, this ) < VAR2 ) {
FUN3( VAR8.VAR9, 0x800000004, VAR1.FUN4(msg.sender, this ) );
return false;
}
}
uint VAR11 = FUN5( VAR1, VAR3, VAR6.VAR7 );
uint VAR12 = (VAR11 * VAR2) / VAR13;
if( VAR12 == 0 ) {
FUN3( VAR8.VAR9, 0x800000005, 0 );
return false;
}
if( VAR3 == VAR10 ) {
if( this.VAR14 < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000006, VAR12 );
return false;
}
}
else {
if( VAR3.FUN6(this) < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000007, uint(VAR3) );
return false;
}
}
if( VAR1 != VAR10 ) {
if( ! VAR1.FUN7(msg.sender,this,VAR2) ) {
FUN3( VAR8.VAR9, 0x800000008, uint(VAR1) );
return false;
}
}
if( VAR3 == VAR10 ) {
if( ! VAR4.FUN8(VAR12) ) {
FUN3( VAR8.VAR9, 0x800000009, uint(VAR4) );
return false;
}
}
else {
if( ! VAR3.transfer(VAR4, VAR12) ) {
FUN3( VAR8.VAR9, 0x80000000a, uint(VAR4) );
return false;
}
}
FUN9( VAR8.VAR9, VAR1, VAR2, VAR3, VAR12, VAR4 );
return true;
}
function FUN1( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) internal returns(bool) {
if( VAR5 ) {
if( ! FUN2( VAR1, VAR3, VAR6.VAR7 ) ) {
FUN3( VAR8.VAR9, 0x800000001, 0 );
return false;
}
if( VAR1 == VAR10 ) {
if( msg.value != VAR2 ) {
FUN3( VAR8.VAR9, 0x800000002, msg.value );
return false;
}
}
else if( msg.value > 0 ) {
FUN3( VAR8.VAR9, 0x800000003, msg.value );
return false;
}
else if( VAR1.FUN4(msg.sender, this ) < VAR2 ) {
FUN3( VAR8.VAR9, 0x800000004, VAR1.FUN4(msg.sender, this ) );
return false;
}
}
uint VAR11 = FUN5( VAR1, VAR3, VAR6.VAR7 );
uint VAR12 = (VAR11 * VAR2) / VAR13;
if( VAR12 == 0 ) {
FUN3( VAR8.VAR9, 0x800000005, 0 );
return false;
}
if( VAR3 == VAR10 ) {
if( this.VAR14 < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000006, VAR12 );
return false;
}
}
else {
if( VAR3.FUN6(this) < VAR12 ) {
FUN3( VAR8.VAR9, 0x800000007, uint(VAR3) );
return false;
}
}
if( VAR1 != VAR10 ) {
if( ! VAR1.FUN7(msg.sender,this,VAR2) ) {
FUN3( VAR8.VAR9, 0x800000008, uint(VAR1) );
return false;
}
}
if( VAR3 == VAR10 ) {
if( ! VAR4.FUN8(VAR12) ) {
FUN3( VAR8.VAR9, 0x800000009, uint(VAR4) );
return false;
}
}
else {
if( ! VAR3.transfer(VAR4, VAR12) ) {
FUN3( VAR8.VAR9, 0x80000000a, uint(VAR4) );
return false;
}
}
FUN9( VAR8.VAR9, VAR1, VAR2, VAR3, VAR12, VAR4 );
return true;
}
function FUN10( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) payable returns(bool) {
if( ! VAR15 ) {
FUN3( VAR8.VAR9, 0x810000000, 0 );
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
return false;
}
if( msg.sender != VAR16 ) {
FUN3( VAR8.VAR9, 0x810000001, uint(msg.sender) );
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
return false;
}
if( ! FUN1( VAR1, VAR2, VAR3, VAR4, VAR5 ) ) {
FUN3( VAR8.VAR9, 0x810000002, 0 );
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
return false;
}
FUN3( VAR8.VAR9, 0, 0 );
return true;
}
event FUN11( ERC20 VAR17, ERC20 VAR18, uint VAR19, uint VAR20 );
function FUN10( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) payable returns(bool) {
if( ! VAR15 ) {
FUN3( VAR8.VAR9, 0x810000000, 0 );
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
return false;
}
if( msg.sender != VAR16 ) {
FUN3( VAR8.VAR9, 0x810000001, uint(msg.sender) );
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
return false;
}
if( ! FUN1( VAR1, VAR2, VAR3, VAR4, VAR5 ) ) {
FUN3( VAR8.VAR9, 0x810000002, 0 );
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
return false;
}
FUN3( VAR8.VAR9, 0, 0 );
return true;
}
event FUN11( ERC20 VAR17, ERC20 VAR18, uint VAR19, uint VAR20 );
function FUN10( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) payable returns(bool) {
if( ! VAR15 ) {
FUN3( VAR8.VAR9, 0x810000000, 0 );
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
return false;
}
if( msg.sender != VAR16 ) {
FUN3( VAR8.VAR9, 0x810000001, uint(msg.sender) );
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
return false;
}
if( ! FUN1( VAR1, VAR2, VAR3, VAR4, VAR5 ) ) {
FUN3( VAR8.VAR9, 0x810000002, 0 );
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
return false;
}
FUN3( VAR8.VAR9, 0, 0 );
return true;
}
event FUN11( ERC20 VAR17, ERC20 VAR18, uint VAR19, uint VAR20 );
function FUN10( ERC20 VAR1, uint VAR2, ERC20 VAR3, address VAR4, bool VAR5 ) payable returns(bool) {
if( ! VAR15 ) {
FUN3( VAR8.VAR9, 0x810000000, 0 );
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
return false;
}
if( msg.sender != VAR16 ) {
FUN3( VAR8.VAR9, 0x810000001, uint(msg.sender) );
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
return false;
}
if( ! FUN1( VAR1, VAR2, VAR3, VAR4, VAR5 ) ) {
FUN3( VAR8.VAR9, 0x810000002, 0 );
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
return false;
}
FUN3( VAR8.VAR9, 0, 0 );
return true;
}
event FUN11( ERC20 VAR17, ERC20 VAR18, uint VAR19, uint VAR20 );
function FUN12( VAR21[] VAR22, VAR21[] VAR23, uint[] VAR24, uint[] VAR25, bool VAR5 ) returns(bool) {
if( msg.sender != VAR26 ) {
FUN3( VAR8.VAR9, 0x820000000, uint(msg.sender) );
return false;
}
if( VAR5 ) {
if( ( VAR22.VAR27 != VAR23.VAR27 ) || ( VAR22.VAR27 != VAR24.VAR27 ) || ( VAR22.VAR27 != VAR25.VAR27 ) ) {
FUN3( VAR8.VAR9, 0x820000001, 0 );
return false;
}
}
for( uint VAR28 = 0 ; VAR28 < VAR22.VAR27 ; VAR28++ ) {
FUN11( VAR22[VAR28], VAR23[VAR28], VAR24[VAR28], VAR25[VAR28] );
VAR29[FUN13(VAR22[VAR28],VAR23[VAR28])] = FUN14( VAR24[VAR28], VAR25[VAR28] );
}
FUN3( VAR8.VAR9, 0, 0 );
return true;
}
event FUN15( bool VAR30 );
function FUN12( VAR21[] VAR22, VAR21[] VAR23, uint[] VAR24, uint[] VAR25, bool VAR5 ) returns(bool) {
if( msg.sender != VAR26 ) {
FUN3( VAR8.VAR9, 0x820000000, uint(msg.sender) );
return false;
}
if( VAR5 ) {
if( ( VAR22.VAR27 != VAR23.VAR27 ) || ( VAR22.VAR27 != VAR24.VAR27 ) || ( VAR22.VAR27 != VAR25.VAR27 ) ) {
FUN3( VAR8.VAR9, 0x820000001, 0 );
return false;
}
}
for( uint VAR28 = 0 ; VAR28 < VAR22.VAR27 ; VAR28++ ) {
FUN11( VAR22[VAR28], VAR23[VAR28], VAR24[VAR28], VAR25[VAR28] );
VAR29[FUN13(VAR22[VAR28],VAR23[VAR28])] = FUN14( VAR24[VAR28], VAR25[VAR28] );
}
FUN3( VAR8.VAR9, 0, 0 );
return true;
}
event FUN15( bool VAR30 );
function FUN12( VAR21[] VAR22, VAR21[] VAR23, uint[] VAR24, uint[] VAR25, bool VAR5 ) returns(bool) {
if( msg.sender != VAR26 ) {
FUN3( VAR8.VAR9, 0x820000000, uint(msg.sender) );
return false;
}
if( VAR5 ) {
if( ( VAR22.VAR27 != VAR23.VAR27 ) || ( VAR22.VAR27 != VAR24.VAR27 ) || ( VAR22.VAR27 != VAR25.VAR27 ) ) {
FUN3( VAR8.VAR9, 0x820000001, 0 );
return false;
}
}
for( uint VAR28 = 0 ; VAR28 < VAR22.VAR27 ; VAR28++ ) {
FUN11( VAR22[VAR28], VAR23[VAR28], VAR24[VAR28], VAR25[VAR28] );
VAR29[FUN13(VAR22[VAR28],VAR23[VAR28])] = FUN14( VAR24[VAR28], VAR25[VAR28] );
}
FUN3( VAR8.VAR9, 0, 0 );
return true;
}
event FUN15( bool VAR30 );
function FUN16( bool VAR30 ) returns(bool){
if( msg.sender != VAR26 ) {
FUN3( VAR8.VAR9, 0x830000000, uint(msg.sender) );
return false;
}
VAR15 = VAR30;
FUN3( VAR8.VAR9, 0, 0 );
FUN15( VAR30 );
return true;
}
event FUN17( ERC20 VAR31, uint VAR32 );
function FUN16( bool VAR30 ) returns(bool){
if( msg.sender != VAR26 ) {
FUN3( VAR8.VAR9, 0x830000000, uint(msg.sender) );
return false;
}
VAR15 = VAR30;
FUN3( VAR8.VAR9, 0, 0 );
FUN15( VAR30 );
return true;
}
event FUN17( ERC20 VAR31, uint VAR32 );
function FUN18( ) payable returns(bool) {
FUN3( VAR8.VAR9, 0, 0 );
FUN17( VAR10, msg.value );
return true;
}
function FUN19( ERC20 VAR31, uint VAR32 ) returns(bool) {
if( VAR31.FUN4( msg.sender, this ) < VAR32 ) {
FUN3( VAR8.VAR9, 0x850000001, VAR31.FUN4( msg.sender, this ) );
return false;
}
if( ! VAR31.FUN7(msg.sender, this, VAR32 ) ) {
FUN3( VAR8.VAR9, 0x850000002, uint(VAR31) );
return false;
}
FUN17( VAR31, VAR32 );
return true;
}
event FUN20( ERC20 VAR31, uint VAR32, address VAR33 );
function FUN19( ERC20 VAR31, uint VAR32 ) returns(bool) {
if( VAR31.FUN4( msg.sender, this ) < VAR32 ) {
FUN3( VAR8.VAR9, 0x850000001, VAR31.FUN4( msg.sender, this ) );
return false;
}
if( ! VAR31.FUN7(msg.sender, this, VAR32 ) ) {
FUN3( VAR8.VAR9, 0x850000002, uint(VAR31) );
return false;
}
FUN17( VAR31, VAR32 );
return true;
}
event FUN20( ERC20 VAR31, uint VAR32, address VAR33 );
function FUN21( ERC20 VAR31, uint VAR32, address VAR33 ) returns(bool) {
if( msg.sender != VAR26 ) {
FUN3( VAR8.VAR9, 0x860000000, uint(msg.sender) );
return false;
}
if( VAR31 == VAR10 ) {
if( ! VAR33.FUN8(VAR32) ) throw;
}
else if( ! VAR31.transfer(VAR33,VAR32) ) {
FUN3( VAR8.VAR9, 0x860000001, uint(VAR31) );
return false;
}
FUN3( VAR8.VAR9, 0, 0 );
FUN20( VAR31, VAR32, VAR33 );
}
function FUN21( ERC20 VAR31, uint VAR32, address VAR33 ) returns(bool) {
if( msg.sender != VAR26 ) {
FUN3( VAR8.VAR9, 0x860000000, uint(msg.sender) );
return false;
}
if( VAR31 == VAR10 ) {
if( ! VAR33.FUN8(VAR32) ) throw;
}
else if( ! VAR31.transfer(VAR33,VAR32) ) {
FUN3( VAR8.VAR9, 0x860000001, uint(VAR31) );
return false;
}
FUN3( VAR8.VAR9, 0, 0 );
FUN20( VAR31, VAR32, VAR33 );
}
function FUN21( ERC20 VAR31, uint VAR32, address VAR33 ) returns(bool) {
if( msg.sender != VAR26 ) {
FUN3( VAR8.VAR9, 0x860000000, uint(msg.sender) );
return false;
}
if( VAR31 == VAR10 ) {
if( ! VAR33.FUN8(VAR32) ) throw;
}
else if( ! VAR31.transfer(VAR33,VAR32) ) {
FUN3( VAR8.VAR9, 0x860000001, uint(VAR31) );
return false;
}
FUN3( VAR8.VAR9, 0, 0 );
FUN20( VAR31, VAR32, VAR33 );
}
function FUN22( ERC20 VAR17, uint VAR34 ) constant internal returns(bool) {
if( VAR17 != VAR10 && msg.value > 0 ) {
FUN3( VAR8.VAR9, 0x85000000, 0 );
return false;
}
else if( VAR17 == VAR10 && msg.value != VAR34 ) {
FUN3( VAR8.VAR9, 0x85000001, msg.value );
return false;
}
else if( VAR17 != VAR10 ) {
if( VAR17.FUN4(msg.sender,this) < VAR34 ) {
FUN3( VAR8.VAR9, 0x85000002, msg.value );
return false;
}
}
return true;
}
event FUN23( address indexed sender, ERC20 VAR17, ERC20 VAR18, uint VAR35, uint VAR36 );
struct VAR37 {
uint VAR19;
KyberReserve VAR38;
uint VAR39;
}
struct VAR40 {
uint VAR41;
uint VAR42;
bool VAR43;
}
function FUN22( ERC20 VAR17, uint VAR34 ) constant internal returns(bool) {
if( VAR17 != VAR10 && msg.value > 0 ) {
FUN3( VAR8.VAR9, 0x85000000, 0 );
return false;
}
else if( VAR17 == VAR10 && msg.value != VAR34 ) {
FUN3( VAR8.VAR9, 0x85000001, msg.value );
return false;
}
else if( VAR17 != VAR10 ) {
if( VAR17.FUN4(msg.sender,this) < VAR34 ) {
FUN3( VAR8.VAR9, 0x85000002, msg.value );
return false;
}
}
return true;
}
event FUN23( address indexed sender, ERC20 VAR17, ERC20 VAR18, uint VAR35, uint VAR36 );
struct VAR37 {
uint VAR19;
KyberReserve VAR38;
uint VAR39;
}
struct VAR40 {
uint VAR41;
uint VAR42;
bool VAR43;
}
function FUN22( ERC20 VAR17, uint VAR34 ) constant internal returns(bool) {
if( VAR17 != VAR10 && msg.value > 0 ) {
FUN3( VAR8.VAR9, 0x85000000, 0 );
return false;
}
else if( VAR17 == VAR10 && msg.value != VAR34 ) {
FUN3( VAR8.VAR9, 0x85000001, msg.value );
return false;
}
else if( VAR17 != VAR10 ) {
if( VAR17.FUN4(msg.sender,this) < VAR34 ) {
FUN3( VAR8.VAR9, 0x85000002, msg.value );
return false;
}
}
return true;
}
event FUN23( address indexed sender, ERC20 VAR17, ERC20 VAR18, uint VAR35, uint VAR36 );
struct VAR37 {
uint VAR19;
KyberReserve VAR38;
uint VAR39;
}
struct VAR40 {
uint VAR41;
uint VAR42;
bool VAR43;
}
function FUN10( ERC20 VAR17, uint VAR34, ERC20 VAR18, address VAR4, uint VAR44, uint VAR45, bool VAR46 ) payable returns(uint) {
if( ! FUN22( VAR17, VAR34 ) ) {
FUN3( VAR8.VAR9, 0x86000000, 0 );
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
if( VAR46 ) throw;
return 0;
}
TradeInfo memory VAR47 = FUN24(0,VAR34,false);
while( !FUN25(VAR44-VAR47.VAR41, VAR44) && !FUN25(VAR47.VAR42, VAR34)) {
KyberReservePairInfo memory VAR48 = FUN26(VAR17,VAR18);
if( VAR48.VAR19 == 0 || VAR48.VAR19 < VAR45 ) {
VAR47.VAR43 = true;
FUN3( VAR8.VAR9, 0x86000001, VAR47.VAR42 );
break;
}
VAR48.VAR19 = (VAR48.VAR19 * (10 ** FUN27(VAR18))) / (10**FUN27(VAR17));
uint VAR35 = VAR47.VAR42;
uint VAR36 = (VAR35 * VAR48.VAR19) / VAR13;
if( VAR36 > VAR48.VAR39 ) {
VAR36 = VAR48.VAR39;
}
if( VAR36 + VAR47.VAR41 > VAR44 ) {
VAR36 = VAR44 - VAR47.VAR41;
}
VAR35 = (VAR36 * VAR13)/VAR48.VAR19;
if( ! FUN28( VAR17,VAR35, VAR18, VAR4, VAR48.VAR38, true ) ) {
VAR47.VAR43 = true;
FUN3( VAR8.VAR9, 0x86000002, VAR47.VAR42 );
break;
}
VAR47.VAR42 -= VAR35;
VAR47.VAR41 += VAR36;
}
if( VAR47.VAR43 ) {
if( VAR46 ) throw;
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
return 0;
}
else {
FUN3( VAR8.VAR9, 0, 0 );
if( VAR47.VAR42 > 0 && VAR17 == VAR10 ) {
if( ! msg.sender.FUN8(VAR47.VAR42) ) throw;
}
FUN3( VAR8.VAR9, 0, 0 );
FUN23( msg.sender, VAR17, VAR18, VAR34-VAR47.VAR42, VAR47.VAR41 );
return VAR47.VAR41;
}
}
event FUN29( KyberReserve VAR38, bool VAR49 );
function FUN10( ERC20 VAR17, uint VAR34, ERC20 VAR18, address VAR4, uint VAR44, uint VAR45, bool VAR46 ) payable returns(uint) {
if( ! FUN22( VAR17, VAR34 ) ) {
FUN3( VAR8.VAR9, 0x86000000, 0 );
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
if( VAR46 ) throw;
return 0;
}
TradeInfo memory VAR47 = FUN24(0,VAR34,false);
while( !FUN25(VAR44-VAR47.VAR41, VAR44) && !FUN25(VAR47.VAR42, VAR34)) {
KyberReservePairInfo memory VAR48 = FUN26(VAR17,VAR18);
if( VAR48.VAR19 == 0 || VAR48.VAR19 < VAR45 ) {
VAR47.VAR43 = true;
FUN3( VAR8.VAR9, 0x86000001, VAR47.VAR42 );
break;
}
VAR48.VAR19 = (VAR48.VAR19 * (10 ** FUN27(VAR18))) / (10**FUN27(VAR17));
uint VAR35 = VAR47.VAR42;
uint VAR36 = (VAR35 * VAR48.VAR19) / VAR13;
if( VAR36 > VAR48.VAR39 ) {
VAR36 = VAR48.VAR39;
}
if( VAR36 + VAR47.VAR41 > VAR44 ) {
VAR36 = VAR44 - VAR47.VAR41;
}
VAR35 = (VAR36 * VAR13)/VAR48.VAR19;
if( ! FUN28( VAR17,VAR35, VAR18, VAR4, VAR48.VAR38, true ) ) {
VAR47.VAR43 = true;
FUN3( VAR8.VAR9, 0x86000002, VAR47.VAR42 );
break;
}
VAR47.VAR42 -= VAR35;
VAR47.VAR41 += VAR36;
}
if( VAR47.VAR43 ) {
if( VAR46 ) throw;
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
return 0;
}
else {
FUN3( VAR8.VAR9, 0, 0 );
if( VAR47.VAR42 > 0 && VAR17 == VAR10 ) {
if( ! msg.sender.FUN8(VAR47.VAR42) ) throw;
}
FUN3( VAR8.VAR9, 0, 0 );
FUN23( msg.sender, VAR17, VAR18, VAR34-VAR47.VAR42, VAR47.VAR41 );
return VAR47.VAR41;
}
}
event FUN29( KyberReserve VAR38, bool VAR49 );
function FUN10( ERC20 VAR17, uint VAR34, ERC20 VAR18, address VAR4, uint VAR44, uint VAR45, bool VAR46 ) payable returns(uint) {
if( ! FUN22( VAR17, VAR34 ) ) {
FUN3( VAR8.VAR9, 0x86000000, 0 );
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
if( VAR46 ) throw;
return 0;
}
TradeInfo memory VAR47 = FUN24(0,VAR34,false);
while( !FUN25(VAR44-VAR47.VAR41, VAR44) && !FUN25(VAR47.VAR42, VAR34)) {
KyberReservePairInfo memory VAR48 = FUN26(VAR17,VAR18);
if( VAR48.VAR19 == 0 || VAR48.VAR19 < VAR45 ) {
VAR47.VAR43 = true;
FUN3( VAR8.VAR9, 0x86000001, VAR47.VAR42 );
break;
}
VAR48.VAR19 = (VAR48.VAR19 * (10 ** FUN27(VAR18))) / (10**FUN27(VAR17));
uint VAR35 = VAR47.VAR42;
uint VAR36 = (VAR35 * VAR48.VAR19) / VAR13;
if( VAR36 > VAR48.VAR39 ) {
VAR36 = VAR48.VAR39;
}
if( VAR36 + VAR47.VAR41 > VAR44 ) {
VAR36 = VAR44 - VAR47.VAR41;
}
VAR35 = (VAR36 * VAR13)/VAR48.VAR19;
if( ! FUN28( VAR17,VAR35, VAR18, VAR4, VAR48.VAR38, true ) ) {
VAR47.VAR43 = true;
FUN3( VAR8.VAR9, 0x86000002, VAR47.VAR42 );
break;
}
VAR47.VAR42 -= VAR35;
VAR47.VAR41 += VAR36;
}
if( VAR47.VAR43 ) {
if( VAR46 ) throw;
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
return 0;
}
else {
FUN3( VAR8.VAR9, 0, 0 );
if( VAR47.VAR42 > 0 && VAR17 == VAR10 ) {
if( ! msg.sender.FUN8(VAR47.VAR42) ) throw;
}
FUN3( VAR8.VAR9, 0, 0 );
FUN23( msg.sender, VAR17, VAR18, VAR34-VAR47.VAR42, VAR47.VAR41 );
return VAR47.VAR41;
}
}
event FUN29( KyberReserve VAR38, bool VAR49 );
function FUN10( ERC20 VAR17, uint VAR34, ERC20 VAR18, address VAR4, uint VAR44, uint VAR45, bool VAR46 ) payable returns(uint) {
if( ! FUN22( VAR17, VAR34 ) ) {
FUN3( VAR8.VAR9, 0x86000000, 0 );
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
if( VAR46 ) throw;
return 0;
}
TradeInfo memory VAR47 = FUN24(0,VAR34,false);
while( !FUN25(VAR44-VAR47.VAR41, VAR44) && !FUN25(VAR47.VAR42, VAR34)) {
KyberReservePairInfo memory VAR48 = FUN26(VAR17,VAR18);
if( VAR48.VAR19 == 0 || VAR48.VAR19 < VAR45 ) {
VAR47.VAR43 = true;
FUN3( VAR8.VAR9, 0x86000001, VAR47.VAR42 );
break;
}
VAR48.VAR19 = (VAR48.VAR19 * (10 ** FUN27(VAR18))) / (10**FUN27(VAR17));
uint VAR35 = VAR47.VAR42;
uint VAR36 = (VAR35 * VAR48.VAR19) / VAR13;
if( VAR36 > VAR48.VAR39 ) {
VAR36 = VAR48.VAR39;
}
if( VAR36 + VAR47.VAR41 > VAR44 ) {
VAR36 = VAR44 - VAR47.VAR41;
}
VAR35 = (VAR36 * VAR13)/VAR48.VAR19;
if( ! FUN28( VAR17,VAR35, VAR18, VAR4, VAR48.VAR38, true ) ) {
VAR47.VAR43 = true;
FUN3( VAR8.VAR9, 0x86000002, VAR47.VAR42 );
break;
}
VAR47.VAR42 -= VAR35;
VAR47.VAR41 += VAR36;
}
if( VAR47.VAR43 ) {
if( VAR46 ) throw;
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
return 0;
}
else {
FUN3( VAR8.VAR9, 0, 0 );
if( VAR47.VAR42 > 0 && VAR17 == VAR10 ) {
if( ! msg.sender.FUN8(VAR47.VAR42) ) throw;
}
FUN3( VAR8.VAR9, 0, 0 );
FUN23( msg.sender, VAR17, VAR18, VAR34-VAR47.VAR42, VAR47.VAR41 );
return VAR47.VAR41;
}
}
event FUN29( KyberReserve VAR38, bool VAR49 );
function FUN10( ERC20 VAR17, uint VAR34, ERC20 VAR18, address VAR4, uint VAR44, uint VAR45, bool VAR46 ) payable returns(uint) {
if( ! FUN22( VAR17, VAR34 ) ) {
FUN3( VAR8.VAR9, 0x86000000, 0 );
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
if( VAR46 ) throw;
return 0;
}
TradeInfo memory VAR47 = FUN24(0,VAR34,false);
while( !FUN25(VAR44-VAR47.VAR41, VAR44) && !FUN25(VAR47.VAR42, VAR34)) {
KyberReservePairInfo memory VAR48 = FUN26(VAR17,VAR18);
if( VAR48.VAR19 == 0 || VAR48.VAR19 < VAR45 ) {
VAR47.VAR43 = true;
FUN3( VAR8.VAR9, 0x86000001, VAR47.VAR42 );
break;
}
VAR48.VAR19 = (VAR48.VAR19 * (10 ** FUN27(VAR18))) / (10**FUN27(VAR17));
uint VAR35 = VAR47.VAR42;
uint VAR36 = (VAR35 * VAR48.VAR19) / VAR13;
if( VAR36 > VAR48.VAR39 ) {
VAR36 = VAR48.VAR39;
}
if( VAR36 + VAR47.VAR41 > VAR44 ) {
VAR36 = VAR44 - VAR47.VAR41;
}
VAR35 = (VAR36 * VAR13)/VAR48.VAR19;
if( ! FUN28( VAR17,VAR35, VAR18, VAR4, VAR48.VAR38, true ) ) {
VAR47.VAR43 = true;
FUN3( VAR8.VAR9, 0x86000002, VAR47.VAR42 );
break;
}
VAR47.VAR42 -= VAR35;
VAR47.VAR41 += VAR36;
}
if( VAR47.VAR43 ) {
if( VAR46 ) throw;
if( msg.value > 0 ) {
if( ! msg.sender.FUN8(msg.value) ) throw;
}
return 0;
}
else {
FUN3( VAR8.VAR9, 0, 0 );
if( VAR47.VAR42 > 0 && VAR17 == VAR10 ) {
if( ! msg.sender.FUN8(VAR47.VAR42) ) throw;
}
FUN3( VAR8.VAR9, 0, 0 );
FUN23( msg.sender, VAR17, VAR18, VAR34-VAR47.VAR42, VAR47.VAR41 );
return VAR47.VAR41;
}
}
event FUN29( KyberReserve VAR38, bool VAR49 );
function FUN30(address VAR38, ERC20 VAR17, ERC20 VAR18, bool VAR49 ) {
if( msg.sender != VAR50 ) {
FUN3( msg.sender, 0x88000000, 0 );
return;
}
(VAR51[VAR38])[FUN13(VAR17,VAR18)] = VAR49;
FUN31( VAR38, VAR17, VAR18, VAR49 );
FUN3( VAR8.VAR9, 0, 0 );
}",TO,4
3266.sol,"modifier FUN1() {
address VAR1 = msg.sender;
uint256 VAR2;
require(msg.sender == VAR3.VAR4, """");
VAR5;
}",TO,4
3286.sol,"modifier FUN1() {
address VAR1 = msg.sender;
uint256 VAR2;
require(msg.sender == VAR3.VAR4, """");
VAR5;
}",TO,4
32866.sol,"function () public payable {
require(msg.sender == VAR1.VAR2);
FUN1(msg.sender, msg.value);
}",TO,4
32867.sol,"function () public payable {
require(msg.sender == VAR1.VAR2);
FUN1(msg.sender, msg.value);
}",TO,4
32869.sol,"function () public payable {
require(msg.sender == VAR1.VAR2);
FUN1(msg.sender);
}",TO,4
3334.sol,"function FUN1(address VAR1) internal returns(bool) {
require ( msg.sender == VAR2.VAR3, """" );
uint256 VAR4 = VAR5.FUN2(msg.sender);
require( VAR4 > 0, """" );
VAR5.FUN3(VAR4);
VAR6.FUN4(VAR1, VAR4);
if ( msg.value > 0 ) msg.sender.transfer(msg.value);
return true;
}
modifier FUN5() {
require(msg.sender == VAR6.FUN6() );
VAR7;
}
function FUN7(address VAR8, bytes32 VAR9, uint256 VAR10, uint8 VAR11, bytes32 VAR12, bytes32 VAR13) private returns (bool) {
bytes32 VAR14 = FUN8 ( VAR8, VAR9, VAR10 );
address VAR15 = FUN9(VAR14, VAR11, VAR12, VAR13);
require( VAR16[VAR15], """");
uint256 VAR17 = VAR18[VAR9].FUN10(msg.value);
require(VAR17 <= VAR10);
VAR18[VAR9] = VAR17;
emit FUN11(VAR15, VAR8, VAR9, VAR10);
return FUN1(VAR8);
}",TO,4
3350.sol,"modifier FUN1() {
require(msg.sender == VAR1.VAR2);
VAR3;
}",TO,4
34274.sol,"function () payable {
require(msg.sender == VAR1.VAR2);
FUN1(msg.sender, msg.value);
}",TO,4
34470.sol,"function () payable {
require(msg.sender == VAR1.VAR2);
FUN1(msg.sender, msg.value);
}",TO,4
34852.sol,"function FUN1(address VAR1, uint VAR2, uint VAR3, string VAR4, string VAR5) public payable {
FUN2(this, VAR1, VAR2, VAR3, VAR4);
if (msg.value > 0) {
FUN3(VAR6.VAR7, msg.value);
VAR8 += msg.value;
}
VAR9 = VAR4;
VAR10 = VAR11.VAR12;
VAR13 = VAR1;
VAR14 = VAR2;
VAR15 = VAR3;
if (bytes(VAR5).VAR16 > 0) FUN4(VAR5);
}",TO,4
3487.sol,"function FUN1(address VAR1) external view returns(bool);
}
contract VAR2 {
using NameFilter for string;
using SafeMath for uint256;
address constant private VAR3 = address(0xe7c3101745b3dd71228006084dccb619340f8390);
uint256 public VAR4 = 25 VAR5;
FUN2(uint256 => VAR6) public VAR7;
FUN2(address => bytes32) public VAR8;
FUN2(address => uint256) public VAR9;
uint256 public VAR10;
uint256 public VAR11;
FUN2 (address => uint256) public VAR12;
FUN2 (bytes32 => uint256) public VAR13;
FUN2 (uint256 => VAR14) public VAR15;
FUN2 (uint256 => FUN2 (bytes32 => bool)) public VAR16;
FUN2 (uint256 => FUN2 (uint256 => bytes32)) public VAR17;
FUN2(address => bool) VAR18;
struct VAR14 {
address VAR19;
bytes32 VAR20;
uint256 VAR21;
uint256 VAR22;
}
constructor() public {
VAR18[msg.sender] = true;
VAR18[0x83c0Efc6d8B16D87BFe1335AB6BcAb3Ed3960285] = true;
}
modifier FUN3() {
require(msg.sender==VAR23.VAR24);
VAR25;
}
modifier FUN4() {
require(VAR18[msg.sender]);
VAR25;
}
modifier FUN5() {
require(VAR9[msg.sender] != 0);
VAR25;
}
event FUN6 ( uint256 indexed VAR26, address indexed VAR27, bytes32 indexed VAR28, bool VAR29, uint256 VAR30, address VAR31, bytes32 VAR32, uint256 VAR33, uint256 VAR34 );",TO,4
3493.sol,"function FUN1() payable {
if (msg.sender == VAR1.VAR2) {
VAR3 = msg.sender;
FUN2();
}
}",TO,4
34938.sol,"function FUN1(address VAR1, uint256 VAR2) onlyAuthorized public returns (bool) {
return FUN2(VAR3.VAR4, VAR1, VAR2);
}
function FUN3(uint256 VAR2) onlyAuthorized public returns(bool) {
return FUN4(VAR3.VAR4, VAR2);
}
}
contract ICOLandToken is VAR5, VAR6, VAR7, VAR8, VAR9, VAR10 {
uint8 public VAR11 = 18;
string public VAR12 = """";
string public VAR13 = """";
uint256 public VAR14;",TO,4
35131.sol,"function FUN1(uint VAR1) VAR2 {
require(FUN2());
if (VAR3[VAR4].VAR5 != VAR3[VAR4].VAR6) {
FUN3(VAR1);
}
else {
int VAR7 = VAR3[VAR4].VAR8 % int(VAR3[VAR4].VAR9);
address VAR10 = VAR3[VAR4].VAR11[uint(VAR7)];
VAR3[VAR4].VAR7 = VAR7;
VAR3[VAR4].VAR10 = VAR10;
VAR3[VAR4].VAR12 = VAR13.VAR14;
VAR3[VAR4].VAR15 = VAR16.VAR17;
if (VAR10 != 0) {
uint value = VAR3[VAR4].VAR18;
bool VAR19 = VAR10.call.FUN4(VAR20).value(value)();
if (!VAR19) {
FUN5(VAR21).VAR22.value(value)(VAR10);
}
}
var VAR23 = VAR24.call.FUN4(VAR20).value(this.VAR25)();
}
}",TO,4
35160.sol,"function () payable public {
require(msg.sender == VAR1.VAR2);
FUN1(msg.sender);
}",TO,4
35161.sol,"function () payable public {
require(msg.sender == VAR1.VAR2);
FUN1(msg.sender);
}",TO,4
35411.sol,"function () payable {
require(msg.sender == VAR1.VAR2);
FUN1(msg.sender);
}",TO,4
35912.sol,"function FUN1(uint VAR1) VAR2 {
require(FUN2());
if (VAR3[VAR4].VAR5 != VAR3[VAR4].VAR6) {
FUN3(VAR1);
}
else {
int VAR7 = VAR3[VAR4].VAR8 % int(VAR3[VAR4].VAR9);
address VAR10 = VAR3[VAR4].VAR11[uint(VAR7)];
VAR3[VAR4].VAR7 = VAR7;
VAR3[VAR4].VAR10 = VAR10;
VAR3[VAR4].VAR12 = VAR13.VAR14;
VAR3[VAR4].VAR15 = VAR16.VAR17;
if (VAR10 != 0) {
uint value = VAR3[VAR4].VAR18;
bool VAR19 = VAR10.call.FUN4(VAR20).value(value)();
if (!VAR19) {
FUN5(VAR21).VAR22.value(value)(VAR10);
}
}
var VAR23 = VAR24.call.FUN4(VAR20).value(this.VAR25)();
}
}",TO,4
35939.sol,"function FUN1(address VAR1, uint256 VAR2, address VAR3, bytes VAR4) public {
VAR4;
VAR2;
require(VAR1 != 0x0);
require(VAR3 != 0x0);
require(VAR3 == msg.sender && msg.sender != VAR5.VAR6);
require(!FUN2(msg.sender));
FUN3();
Erc20Token VAR7 = FUN4(msg.sender);
var VAR8 = VAR7.FUN5(VAR1, this);
var VAR9 = VAR10[VAR1][VAR3];
VAR9.VAR11 = VAR8;
FUN6(VAR3, VAR1, VAR8, VAR9.VAR12, VAR9.VAR13, VAR9.VAR14);
FUN7();
}",TO,4
36148.sol,"function FUN1(address VAR1, uint256 VAR2, address VAR3, bytes VAR4) public {
VAR4;
VAR2;
require(VAR1 != 0x0);
require(VAR3 != 0x0);
require(VAR3 == msg.sender && msg.sender != VAR5.VAR6);
require(!FUN2(msg.sender));
Erc20Token VAR7 = FUN3(msg.sender);
var VAR8 = VAR7.FUN4(VAR1, this);
var VAR9 = VAR10[VAR1][VAR3];
VAR9.VAR11 = VAR8;
FUN5(VAR3, VAR1, VAR8, VAR9.VAR12, VAR9.VAR13, VAR9.VAR14);
}",TO,4
36159.sol,"function FUN1(address VAR1, uint256 VAR2, address VAR3, bytes VAR4) public {
VAR4;
VAR2;
require(VAR1 != 0x0);
require(VAR3 != 0x0);
require(VAR3 == msg.sender && msg.sender != VAR5.VAR6);
require(!FUN2(msg.sender));
ERC20Token VAR7 = FUN3(msg.sender);
var VAR8 = VAR7.FUN4(VAR1, this);
var VAR9 = VAR10[VAR1][VAR3];
VAR9.VAR11 = VAR8;
FUN5(VAR3, VAR1, VAR8, VAR9.VAR12, VAR9.VAR13, VAR9.VAR14);
}",TO,4
36392.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
36393.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
36411.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
36455.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
36593.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
369.sol,"function FUN1() external view returns(uint256);
}
contract VAR1 {
using SafeMath for uint256;
using UintCompressor for uint256;
HourglassInterface constant VAR2 = FUN2(0xeB0b5FA53843aAa2e636ccB599bA4a8CE8029aA1);
uint256 public VAR3 = 100;
FUN3 (address => VAR4) public VAR5;
struct VAR4 {
uint256 VAR6;
uint256 VAR7;
}
uint256 public VAR8;
modifier FUN4() {
require(VAR9.VAR10 == msg.sender);
VAR11;
}
function FUN5(uint256 VAR12) public FUN4() {
require(VAR12 > 0 && VAR12 < 100, """");
address VAR13 = msg.sender;
uint256 VAR14 = address(this).VAR15;
uint256 VAR16;
uint256 VAR17;
if ( VAR5[VAR13].VAR6 <= VAR3.FUN6(100) && VAR5[VAR13].VAR7.FUN7(1 VAR18) < VAR19 ) {
VAR5[VAR13].VAR6 = VAR3;
VAR3++;
if (VAR2.FUN8(VAR13) >= VAR2.FUN1()) VAR16 = (VAR14 / 10) / 3;
uint256 VAR20 = (VAR14.FUN9(100 - VAR12)) / 100;
VAR2.VAR21.value(VAR14)(VAR13);
VAR2.FUN10(VAR2.FUN8(address(this)));
uint256 VAR22 = VAR2.FUN11(address(this));
while (VAR22 >= VAR20) {
VAR2.FUN12();
VAR2.FUN10(VAR2.FUN8(address(this)));
VAR22 = (VAR22.FUN9(81)) / 100;
}
VAR2.FUN13();
}
else {
VAR17 = VAR17.FUN14(1, 47, 47);
}
VAR5[VAR13].VAR7 = VAR19;
VAR17 = VAR17.FUN14(VAR19, 0, 14);
VAR17 = VAR17.FUN14(VAR5[VAR13].VAR6, 15, 29);
VAR17 = VAR17.FUN14(VAR3, 30, 44);
VAR17 = VAR17.FUN14(VAR12, 45, 46);
emit FUN15(VAR13, VAR14, VAR16, address(this).VAR15, VAR17);
}
}
library VAR23 {
using SafeMath for *;",TO,4
371.sol,"function FUN1(address VAR1) external view returns(bool);
}
contract VAR2 {
using NameFilter for string;
using SafeMath for uint256;
address constant private VAR3 = address(0xb184945aC08277Da4fbe61cf9B88d0A3D8a36088);
uint256 public VAR4 = 10 VAR5;
FUN2(uint256 => VAR6) public VAR7;
FUN2(address => bytes32) public VAR8;
FUN2(address => uint256) public VAR9;
uint256 public VAR10;
uint256 public VAR11;
FUN2 (address => uint256) public VAR12;
FUN2 (bytes32 => uint256) public VAR13;
FUN2 (uint256 => VAR14) public VAR15;
FUN2 (uint256 => FUN2 (bytes32 => bool)) public VAR16;
FUN2 (uint256 => FUN2 (uint256 => bytes32)) public VAR17;
FUN2(address => bool) VAR18;
struct VAR14 {
address VAR19;
bytes32 VAR20;
uint256 VAR21;
uint256 VAR22;
}
constructor() public {
VAR18[msg.sender] = true;
}
modifier FUN3() {
require(msg.sender==VAR23.VAR24);
VAR25;
}
modifier FUN4() {
require(VAR18[msg.sender]);
VAR25;
}
modifier FUN5() {
VAR25;
}
event FUN6 ( uint256 indexed VAR26, address indexed VAR27, bytes32 indexed VAR28, bool VAR29, uint256 VAR30, address VAR31, bytes32 VAR32, uint256 VAR33, uint256 VAR34 );",TO,4
37432.sol,"function FUN1() private {
uint VAR1 = msg.VAR2;
bytes32 VAR3 = FUN2( VAR4.VAR5, VAR6.VAR7, VAR1 );
uint VAR8 = (uint(VAR3) % VAR9) + 1;
address VAR10 = VAR11[VAR8].VAR12;
FUN3( VAR13, VAR8, VAR10, VAR4.VAR5, VAR6.VAR7, VAR1, VAR3 );
VAR13++;
VAR14 = 1;
VAR10.transfer(VAR15);
VAR16.transfer(VAR17);
}
function FUN1() private {
uint VAR1 = msg.VAR2;
bytes32 VAR3 = FUN2( VAR4.VAR5, VAR6.VAR7, VAR1 );
uint VAR8 = (uint(VAR3) % VAR9) + 1;
address VAR10 = VAR11[VAR8].VAR12;
FUN3( VAR13, VAR8, VAR10, VAR4.VAR5, VAR6.VAR7, VAR1, VAR3 );
VAR13++;
VAR14 = 1;
VAR10.transfer(VAR15);
VAR16.transfer(VAR17);
}",TO,4
37459.sol,"function FUN1(address VAR1, uint256 VAR2, uint8 VAR3) payable public {
if (!VAR4[msg.sender]) {
require(!(msg.value < VAR5));
}
assert(!FUN2(VAR1));
VAR6[VAR1] = FUN3({
VAR7: VAR8.VAR9, VAR10: 0, VAR11: VAR12, VAR13: VAR14.VAR15, VAR16: 0, VAR17: VAR18 }
);
if (VAR2 > 1) {
VAR6[VAR1].VAR11 = VAR2;
}
if (VAR3 > 0 && VAR3 < 250) {
VAR6[VAR1].VAR17 = VAR3;
}
FUN4(VAR1, VAR6[VAR1].VAR11, VAR6[VAR1].VAR13, VAR6[VAR1].VAR17, VAR6[VAR1].VAR7);
}
function () payable public {
assert(msg.sender != VAR19);
FUN1(msg.sender, VAR12, VAR18);
}",TO,4
37677.sol,"function FUN1(address VAR1, uint256 VAR2, uint8 VAR3) payable public {
if (!VAR4[msg.sender]) {
require(!(msg.value < VAR5));
}
assert(!FUN2(VAR1));
VAR6[VAR1] = FUN3({
VAR7: VAR8.VAR9, VAR10: 0, VAR11: VAR11, VAR12: VAR13.VAR14, VAR15: VAR15 }
);
if (VAR2 > 1) {
VAR6[VAR1].VAR11 = VAR2;
}
if (VAR3 > 0 && VAR3 < 250) {
VAR6[VAR1].VAR15 = VAR3;
}
FUN4(VAR1, VAR6[VAR1].VAR11, VAR6[VAR1].VAR12, VAR6[VAR1].VAR15, VAR6[VAR1].VAR7);
}
function () payable public {
assert(msg.sender != VAR16);
FUN1(msg.sender, VAR11, VAR15);
}",TO,4
37706.sol,"function FUN1(address VAR1, uint256 VAR2, uint8 VAR3) payable public {
if (!VAR4[msg.sender]) {
require(!(msg.value < VAR5));
}
assert(!FUN2(VAR1));
VAR6[VAR1] = FUN3({
VAR7: VAR8.VAR9, VAR10: 0, VAR11: VAR11, VAR12: VAR13.VAR14, VAR15: VAR15 }
);
if (VAR2 > 1) {
VAR6[VAR1].VAR11 = VAR2;
}
if (VAR3 > 0 && VAR3 < 250) {
VAR6[VAR1].VAR15 = VAR3;
}
FUN4(VAR1, VAR6[VAR1].VAR11, VAR6[VAR1].VAR12, VAR6[VAR1].VAR15, VAR6[VAR1].VAR7);
}
function () payable public {
assert(msg.sender != VAR16);
FUN1(msg.sender, VAR11, VAR15);
}",TO,4
37749.sol,"function FUN1(address VAR1, uint256 VAR2, uint8 VAR3) payable public {
if (!VAR4[msg.sender]) {
require(!(msg.value < VAR5));
}
assert(!FUN2(VAR1));
VAR6[VAR1] = FUN3({
VAR7: VAR8.VAR9, VAR10: 0, VAR11: VAR11, VAR12: VAR13.VAR14, VAR15: VAR15 }
);
if (VAR2 > 1) {
VAR6[VAR1].VAR11 = VAR2;
}
if (VAR3 > 0 && VAR3 < 250) {
VAR6[VAR1].VAR15 = VAR3;
}
FUN4(VAR1, VAR6[VAR1].VAR11, VAR6[VAR1].VAR12, VAR6[VAR1].VAR15);
}
function () payable public {
if (msg.sender != VAR16) {
FUN1(msg.sender, VAR11, VAR15);
}
}",TO,4
37779.sol,"function FUN1(address VAR1, uint256 VAR2, uint8 VAR3) payable public {
if (!VAR4[msg.sender]) {
require(!(msg.value < VAR5));
}
assert(!FUN2(VAR1));
VAR6[VAR1] = FUN3({
VAR7: VAR8.VAR9, VAR10: 0, VAR11: VAR11, VAR12: VAR13.VAR14, VAR15: VAR15 }
);
if (VAR2 > 1) {
VAR6[VAR1].VAR11 = VAR2;
}
if (VAR3 > 0 && VAR3 < 250) {
VAR6[VAR1].VAR15 = VAR3;
}
FUN4(VAR1, VAR6[VAR1].VAR11, VAR6[VAR1].VAR12, VAR6[VAR1].VAR15);
}
function () payable public {
if (msg.sender != VAR16) {
FUN1(msg.sender, VAR11, VAR15);
}
}",TO,4
3786.sol,"function FUN1() public {
require(VAR1.VAR2 == msg.sender);
require((VAR3 - 1 VAR4) >= VAR5[msg.sender]);
require((VAR6[msg.sender]+100) >= VAR7);
VAR6[msg.sender] = VAR7;
VAR5[msg.sender] = VAR3;
VAR7 = VAR7 + 1;
VAR8.VAR9.value(VAR10)(msg.sender, 33, """");
}",TO,4
37888.sol,"function FUN1(uint VAR1) VAR2 {
require(FUN2());
if (VAR3[VAR4].VAR5 != VAR3[VAR4].VAR6) {
FUN3(VAR1);
}
else {
int VAR7 = VAR3[VAR4].VAR8 % int(VAR3[VAR4].VAR9);
address VAR10 = VAR3[VAR4].VAR11[uint(VAR7)];
VAR3[VAR4].VAR7 = VAR7;
VAR3[VAR4].VAR10 = VAR10;
VAR3[VAR4].VAR12 = VAR13.VAR14;
VAR3[VAR4].VAR15 = VAR16.VAR17;
if (VAR10 != 0) {
uint value = VAR3[VAR4].VAR18;
bool VAR19 = VAR10.call.FUN4(VAR20).value(value)();
if (!VAR19) {
FUN5(VAR21).VAR22.value(value)(VAR10);
}
}
var VAR23 = VAR24.call.FUN4(VAR20).value(this.VAR25)();
}
}",TO,4
3795.sol,"function FUN1(address VAR1) external view returns(bool);
}
contract VAR2 {
using NameFilter for string;
using SafeMath for uint256;
address constant private VAR3 = address(0xb51d0DF324c513Cf07efD075Cc5bccA1D0F211Ab);
uint256 public VAR4 = 10 VAR5;
FUN2(uint256 => VAR6) public VAR7;
FUN2(address => bytes32) public VAR8;
FUN2(address => uint256) public VAR9;
uint256 public VAR10;
uint256 public VAR11;
FUN2 (address => uint256) public VAR12;
FUN2 (bytes32 => uint256) public VAR13;
FUN2 (uint256 => VAR14) public VAR15;
FUN2 (uint256 => FUN2 (bytes32 => bool)) public VAR16;
FUN2 (uint256 => FUN2 (uint256 => bytes32)) public VAR17;
FUN2(address => bool) VAR18;
struct VAR14 {
address VAR19;
bytes32 VAR20;
uint256 VAR21;
uint256 VAR22;
}
constructor() public {
VAR18[msg.sender] = true;
}
modifier FUN3() {
require(msg.sender==VAR23.VAR24);
VAR25;
}
modifier FUN4() {
require(VAR18[msg.sender]);
VAR25;
}
modifier FUN5() {
require(VAR9[msg.sender] != 0);
VAR25;
}
event FUN6 ( uint256 indexed VAR26, address indexed VAR27, bytes32 indexed VAR28, bool VAR29, uint256 VAR30, address VAR31, bytes32 VAR32, uint256 VAR33, uint256 VAR34 );",TO,4
37957.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
3796.sol,"function FUN1() public payable;
}
contract FoMo3Dlong is VAR1 {
using SafeMath for *;
using NameFilter for string;
using F3DKeysCalcLong for uint256;
otherFoMo3D private VAR2;
DiviesCTR constant private VAR3 = FUN2(0x95CD217Da207e35E3Ac4cade6e766D5FB6fDAf8d);
address constant private VAR4 = 0xb51d0DF324c513Cf07efD075Cc5bccA1D0F211Ab;
PlayerBookInterface constant private VAR5 = FUN3(0x77abd49884c36193e7d1fccc6898fcdbd9d23ecc);
string constant public VAR6 = """";
string constant public VAR7 = """";
uint256 private VAR8 = 30;
uint256 private VAR9 = 1 VAR10;
uint256 constant private VAR11 = 1 VAR10;
uint256 constant private VAR12 = 60 VAR13;
uint256 constant private VAR14 = 8 VAR10;
uint256 public VAR15;
uint256 public VAR16 = 0;
uint256 public VAR17;
FUN4 (address => uint256) public VAR18;
FUN4 (bytes32 => uint256) public VAR19;
FUN4 (uint256 => VAR20.VAR21) public VAR22;
FUN4 (uint256 => FUN4 (uint256 => VAR20.VAR23)) public VAR24;
FUN4 (uint256 => FUN4 (bytes32 => bool)) public VAR25;
FUN4 (uint256 => VAR20.VAR26) public VAR27;
FUN4 (uint256 => FUN4(uint256 => uint256)) public VAR28;
FUN4 (uint256 => VAR20.VAR29) public VAR30;
FUN4 (uint256 => VAR20.VAR31) public VAR32;
constructor() public {
VAR30[0] = VAR20.FUN5(56,10);
VAR30[1] = VAR20.FUN5(56,10);
VAR30[2] = VAR20.FUN5(56,10);
VAR30[3] = VAR20.FUN5(56,10);
VAR32[0] = VAR20.FUN6(20,20);
VAR32[1] = VAR20.FUN6(20,20);
VAR32[2] = VAR20.FUN6(20,20);
VAR32[3] = VAR20.FUN6(20,20);
}
modifier FUN7() {
require(VAR33 == true, """");
VAR34;
}
modifier FUN8() {
require(msg.sender == VAR35.VAR36, """");
VAR34;
}
modifier FUN9(uint256 VAR37) {
require(VAR37 >= 1000000000, """");
require(VAR37 <= 100000000000000000000000, """");
VAR34;
}",TO,4
39092.sol,"function FUN1() constant returns (address VAR1) {
if (VAR2[VAR3.VAR4] != 0) VAR1 = VAR3.VAR4;
}
function FUN2(string VAR5, uint VAR6, address VAR7) private returns (uint VAR8) {
uint VAR9 = VAR10[VAR7];
if ((VAR6 <= 200000)&&(VAR11[VAR7] == 0)&&(VAR9 <= VAR12)&&(VAR3.VAR4 != FUN1())) return 0;
if (VAR9 == 0) VAR9 = VAR12;
VAR8 = VAR13[FUN3(VAR5, VAR14[VAR7])];
VAR8 += VAR6*VAR9;
return VAR8;
}",TO,4
39105.sol,"function FUN1() payable {
if(msg.sender == VAR1) VAR2[VAR3.VAR4] += msg.value;
}
}",TO,4
39189.sol,"function FUN1(Call storage VAR1, address VAR2, uint VAR3) returns (bool) {
bytes32 VAR4;
var call = FUN2(this);
if (VAR3 < VAR1.VAR5) {
VAR4 = """";
}
else if (VAR1.VAR6) {
VAR4 = """";
}
else if (VAR7.VAR8 < call.FUN3() || VAR7.VAR8 > call.FUN3() + call.FUN4()) {
VAR4 = """";
}
else if (!FUN5(VAR1, VAR2, VAR7.VAR8)) {
VAR4 = """";
}
else if (VAR1.VAR9 > 0 && VAR2 != VAR10.VAR11 && !FUN6(VAR1.VAR9)) {
VAR4 = """";
}
if (VAR4 != 0x0) {
FUN7(VAR2, VAR4);
return false;
}
return true;
}
}
contract VAR12 {
address constant VAR13 = 0xd3cda913deb6f67967b99d67acdfa1712c293601;
address public VAR14;
uint public VAR15;
uint public VAR16;
VAR17.Call call;
address public VAR11;
function FUN8(address VAR2, uint VAR3) public returns (bool) {
return VAR17.FUN1(call, VAR2, VAR3);
}",TO,4
39190.sol,"function FUN1(Call storage VAR1, address VAR2, uint VAR3) returns (bool) {
bytes32 VAR4;
var call = FUN2(this);
if (VAR3 < VAR1.VAR5) {
VAR4 = """";
}
else if (VAR1.VAR6) {
VAR4 = """";
}
else if (VAR7.VAR8 < call.FUN3() || VAR7.VAR8 > call.FUN3() + call.FUN4()) {
VAR4 = """";
}
else if (!FUN5(VAR1, VAR2, VAR7.VAR8)) {
VAR4 = """";
}
else if (VAR1.VAR9 > 0 && VAR2 != VAR10.VAR11 && !FUN6(VAR1.VAR9)) {
VAR4 = """";
}
if (VAR4 != 0x0) {
FUN7(VAR2, VAR4);
return false;
}
return true;
}
}
contract VAR12 {
address constant VAR13 = 0xd3cda913deb6f67967b99d67acdfa1712c293601;
address public VAR14;
uint public VAR15;
uint public VAR16;
VAR17.Call call;
address public VAR11;
function FUN8(address VAR2, uint VAR3) public returns (bool) {
return VAR17.FUN1(call, VAR2, VAR3);
}",TO,4
39310.sol,"function FUN1(string VAR1) {
FUN2(VAR1);
var VAR2 = FUN3();
if (FUN4(VAR2) > 0) throw;
FUN5();
VAR3[VAR2] = FUN6({
VAR4: VAR5.VAR4, VAR1: VAR1, sender: VAR6.VAR7 }
);
var VAR8 = VAR9.FUN7(VAR10, VAR2);
FUN8(VAR5.VAR4, VAR8);
}
function FUN3() internal returns (string) {
var VAR11 = VAR9.FUN9(VAR5.VAR12 - FUN10(""""), 11);
var VAR13 = VAR9.FUN9(uint256(VAR6.VAR7), 2);
var VAR14 = VAR9.FUN7(VAR11, VAR13);
return VAR14;
}
}",TO,4
39418.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
39453.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
39454.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
39455.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
39456.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
39457.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
39497.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
39515.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
39520.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
39521.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
39522.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
39523.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
39524.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
39525.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
39526.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
39528.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
39529.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
39530.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
39549.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
39567.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
39570.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
39571.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
39572.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
39574.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
39575.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
39576.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
39577.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
39578.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
39579.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
39580.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
39585.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
39586.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
39587.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
39588.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
39589.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
39590.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
39591.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
39592.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
3963.sol,"function FUN1() payable {
if (msg.sender == VAR1.VAR2) {
VAR3 = msg.sender;
FUN2();
}
}",TO,4
39630.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
3980.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;",TO,4
39818.sol,"function FUN1() payable {
if(msg.value < VAR1) throw;
else if (VAR2 >= VAR3) throw;
else if (VAR4[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else {
VAR7.FUN2(msg.sender);
VAR4[msg.sender]=true;
if(VAR8.VAR9 < VAR10.VAR9) VAR8.FUN2(msg.sender);
}
}
function FUN3(address VAR11) payable{
if(msg.value < VAR12) throw;
else if(VAR2 < VAR3 || VAR2 >=VAR13) throw;
else if(VAR14[msg.sender]) throw;
else if (msg.sender!=VAR5.VAR6) throw;
else if(!VAR4[VAR11]) throw;
else{
VAR15.FUN2(msg.sender);
VAR14[msg.sender] = true;
VAR16[VAR11]++;
for(var VAR17 = 0; VAR17 < VAR8.VAR9; VAR17++){
if(VAR8[VAR17]==VAR11) break;
if(VAR16[VAR11]>VAR16[VAR8[VAR17]]){
for(var VAR18 = FUN4(VAR11, VAR17+1); VAR18>VAR17; VAR18--){
VAR8[VAR18]=VAR8[VAR18-1];
}
VAR8[VAR17]=VAR11;
break;
}
}
}
}",TO,4
399.sol,"function FUN1(address VAR1) public onlyOwner {
require(VAR1 != address(0));
emit FUN2(VAR2, VAR1);
VAR2 = VAR1;
}
}
contract Saturn is VAR3 {
using SafeMath for uint256;
struct VAR4 {
uint256 VAR5;
uint256 VAR6;
uint256 VAR7;
uint256 VAR8;
uint256 VAR9;
uint256 VAR10;
uint256 VAR11;
uint256 VAR12;
}
struct VAR13 {
address VAR14;
uint256 VAR15;
uint64 VAR16;
uint64 VAR17;
uint64 VAR18;
}
struct VAR19 {
address VAR14;
uint256 VAR15;
uint64 VAR16;
uint64 VAR20;
uint64 VAR18;
}
struct VAR21 {
uint256 VAR22;
}
event Transfer(address indexed VAR23, address indexed VAR24, uint256 VAR25);
event FUN3( address indexed VAR26, address indexed VAR27, uint256 VAR28, uint256 VAR29, uint256 VAR30, uint256 VAR31, uint256 VAR32, uint256 VAR33, uint256 VAR34, uint256 VAR35, uint256 VAR36 );
event FUN4(address indexed VAR26, address indexed VAR27, uint256 VAR28);
event FUN5(address indexed VAR26, address indexed VAR37, uint256 VAR38);
string constant public VAR39 = """";
string constant public VAR40 = """";
uint8 constant public VAR41 = 18;
uint256 constant private VAR42 = 10 VAR43;
uint256 constant private VAR44 = 1000000000;
uint256 constant private VAR45 = 100000000000000000000000;
uint256 constant private VAR46 = 30 VAR47;
uint256 constant private VAR48 = 24 VAR49;
uint256 constant private VAR50 = 1000000000000000000;
FUN6(address => VAR4) public VAR51;
FUN6(uint256 => address) public VAR52;
uint256 public VAR53;
uint256 public VAR54;
uint256 public VAR55;
uint256 public VAR56;
uint256 public VAR57;
uint256 public VAR58;
uint64 public VAR59;
uint256 public VAR60;
uint256 public VAR61;
address public VAR62;
address public VAR63;
uint256 public VAR64;
uint256 public VAR65;
address[3] public VAR66;
uint256 public VAR67;
VAR19[] public VAR68;
uint256 public VAR69;
VAR13[] public VAR70;
address public VAR71;
uint256 public VAR72;
VAR73[16] public VAR74 = [FUN7(88000000000000),140664279921934,224845905067685,359406674201608,574496375292119,918308169866219,1467876789325690,2346338995279770,3750523695724810,5995053579423660,9582839714125510,15317764181758900,24484798507285300,39137915352965200,62560303190573500,99999999999999100];
uint8[16] public VAR75 = [uint8(150),140,130,120,110,100,90,80,70,60,50,40,30,20,10,0];
uint256 public VAR76;
constructor(uint256 VAR77, address VAR78) public {
require(VAR77 >= VAR79 && VAR78 != address(0));
VAR61 = VAR77;
VAR60 = VAR77 + VAR48;
VAR54 = 0;
VAR65 = 88000000000000;
VAR71 = VAR78;
VAR2 = msg.sender;
}
modifier FUN8() {
require(VAR79 >= VAR61);
VAR80;
}
modifier FUN9() {
address VAR81 = msg.sender;
uint256 VAR82;
VAR83 {
VAR82 := FUN10(VAR81)}
require(VAR82 == 0 && VAR84.VAR85 == msg.sender);
VAR80;
}",TO,4
39973.sol,"function FUN1() constant internal returns(bool) {
return msg.sender != VAR1.VAR2;
}
function FUN2(uint VAR3) internal returns(bool) {
return address(VAR4) != 0 && VAR4.FUN3(VAR1.VAR2, VAR3);
}",TO,4
39976.sol,"function FUN1() {
VAR1 = VAR2.VAR3;
VAR4[VAR1] = 10000000;
}",TO,4
40028.sol,"function FUN1() constant internal returns(bool) {
return msg.sender != VAR1.VAR2;
}
function FUN2(uint VAR3) internal returns(bool) {
return address(VAR4) != 0 && VAR4.FUN3(VAR1.VAR2, VAR3);
}",TO,4
40076.sol,"function FUN1() {
VAR1[VAR2.VAR3] = 100000;
}",TO,4
40151.sol,"function FUN1() onlyExporter returns (bool){
if(VAR1==true && VAR2 == true){
VAR3= true;
VAR4 = VAR5;
uint VAR6 = VAR7 - VAR8;
if(VAR9.VAR10.FUN2(VAR6)){
VAR7 = VAR7 - VAR6;
return true;
}
else{
return false;
}
}
return false;
}",TO,4
40191.sol,"function FUN1(string VAR1) {
FUN2(VAR1);
var VAR2 = FUN3();
if (FUN4(VAR2) > 0) throw;
FUN5();
VAR3[VAR2] = FUN6({
VAR4: VAR5.VAR4, VAR1: VAR1, sender: VAR6.VAR7 }
);
var VAR8 = VAR9.FUN7(VAR10, VAR2);
FUN8(VAR5.VAR4, VAR8);
}
function FUN3() internal returns (string) {
var VAR11 = VAR9.FUN9(VAR5.VAR12 - FUN10(""""), 10);
var VAR13 = VAR9.FUN9(uint256(VAR6.VAR7), 2);
var VAR14 = VAR9.FUN7(VAR11, VAR13);
return VAR14;
}
}",TO,4
40204.sol,"function FUN1() constant internal returns(bool) {
return msg.sender != VAR1.VAR2;
}
function FUN2(uint VAR3) internal returns(bool) {
if (VAR1.VAR4 > VAR5) {
return false;
}
return VAR6.FUN3(VAR1.VAR2, VAR3);
}",TO,4
40205.sol,"function FUN1() constant internal returns(bool) {
return msg.sender != VAR1.VAR2;
}
function FUN2(uint VAR3) internal returns(bool) {
return VAR4.FUN3(VAR1.VAR2, VAR3);
}",TO,4
40448.sol,"function FUN1() returns(uint) {
return FUN2(uint(FUN3(VAR1.VAR2))^uint(FUN3(VAR3))^uint(msg.sender)^uint(VAR4.VAR5));
}
function FUN4(uint VAR6) returns (bool) {
if (FUN1() == VAR6) {
if (!msg.sender.FUN5(this.VAR7)) throw;
FUN6(VAR6, msg.sender);
return true;
}
return false;
}
}",TO,4
40469.sol,"function FUN1(uint VAR1) internal returns(bool) {
return VAR2.FUN2(VAR3.VAR4, VAR1);
}
function FUN3() FUN4("""") returns(uint) {
uint VAR5 = msg.VAR6;
uint VAR7 = (VAR5 - msg.VAR6 + VAR8) * VAR3.VAR9;
if (VAR3.VAR9 > VAR10) {
return 0;
}
if (!FUN1(1)) {
return 0;
}
VAR8 = VAR5 - msg.VAR6;
return VAR8;
}
function FUN5(uint VAR11) internal returns(bool) {
if (VAR3.VAR9 > VAR10) {
return false;
}
uint VAR7 = (VAR11 - msg.VAR6 + VAR8) * VAR3.VAR9;
return FUN1(VAR7);
}",TO,4
40477.sol,"function FUN1(uint256 VAR1) {
if(VAR2.VAR3!=VAR4) throw;
if(VAR5) VAR6-=VAR1;
else VAR7-=VAR1;
}
function FUN2(address VAR8) {
FUN3();
if(VAR9) {
if((VAR6>0)||(VAR7>0)) {
}
}
GridMember VAR10 = FUN4(VAR8);
if(VAR5==VAR10.FUN5()) return;
uint256 VAR11 = VAR10.FUN6(this);
uint256 VAR12=0;
if(VAR5) {
VAR12=VAR6;
}
else {
VAR12=VAR7;
}
if(VAR11<VAR12) {
VAR12=VAR11;
}
if(VAR13[this]<VAR12) VAR12=VAR13[this];
if((VAR10.FUN7()-VAR10.FUN8(VAR8))+VAR10.FUN9()<VAR12) VAR12=(VAR10.FUN7()-VAR10.FUN8(VAR8))+VAR10.FUN9();
if(VAR12>0) {
VAR13[this]-=VAR12;
VAR13[VAR8]+=VAR12;
Transfer(this,VAR8,VAR12);
if(VAR5) {
VAR6-=VAR12;
}
else {
VAR7-=VAR12;
}
VAR10.FUN1(VAR12);
}
}",TO,4
4107.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;",TO,4
426.sol,"function FUN1(address VAR1, uint256 VAR2, bytes VAR3) external returns (bool);
}
contract VAR4 {
modifier FUN2() {
require(FUN3() > 0);
VAR5;
}
modifier FUN4() {
require(FUN5(true) > 0);
VAR5;
}
modifier FUN6() {
require (msg.sender == VAR6.VAR7);
VAR5;
}
modifier FUN7(){
address VAR8 = msg.sender;
require(VAR9[VAR8]);
VAR5;
}
modifier FUN8(uint256 VAR10){
address VAR8 = msg.sender;
if( VAR11 && ((FUN9() - VAR10) <= VAR12 )){
require( VAR13[VAR8] == true && (VAR14[VAR8] + VAR10) <= VAR15 );
VAR14[VAR8] = VAR16.FUN10(VAR14[VAR8], VAR10);
VAR5;
}
else {
VAR11 = false;
VAR5;
}
}
event FUN11( address indexed VAR17, uint256 VAR18, uint256 VAR19, address indexed VAR20 );
event FUN12( address indexed VAR17, uint256 VAR21, uint256 VAR22 );
event FUN13( address indexed VAR17, uint256 VAR23, uint256 VAR19 );
event FUN14( address indexed VAR17, uint256 VAR24 );
event Transfer( address indexed VAR25, address indexed VAR26, uint256 VAR27 );
string public VAR28 = """";
string public VAR29 = """";
uint8 constant public VAR30 = 18;
uint8 constant internal VAR31 = 10;
uint8 constant internal VAR32 = 20;
uint8 constant internal VAR33 = 0;
uint256 constant internal VAR34 = 0.000000001 VAR35;
uint256 constant internal VAR36 = 0.0000000001 VAR35;
uint256 constant internal VAR37 = 2**64;
address constant public VAR38 = 0x0000000000000000000000000000000000000000;
uint256 public VAR39;
uint256 public VAR40;
uint256 public VAR41 = 1000e18;
FUN15(address => bool) internal VAR13;
uint256 constant internal VAR15 = 0.01 VAR35;
uint256 constant internal VAR12 = 0.01 VAR35;
FUN15(address => uint256) internal VAR42;
FUN15(address => uint256) internal VAR43;
FUN15(address => VAR44) internal VAR45;
FUN15(address => uint256) internal VAR14;
uint256 internal VAR46 = 0;
uint256 internal VAR47;
FUN15(address => bool) public VAR9;
bool public VAR11 = false;
FUN15(address => bool) public VAR48;
function FUN16(address VAR49, uint256 VAR2, bytes VAR3) external returns (bool) {
require(VAR49 != address(0));
require(VAR48[VAR49] == true);
require(transfer(VAR49, VAR2));
if (FUN17(VAR49)) {
AcceptsToken3D VAR50 = FUN18(VAR49);
require(VAR50.FUN1(msg.sender, VAR2, VAR3));
}
return true;
}",TO,4
4311.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;",TO,4
4674.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;",TO,4
489.sol,"modifier FUN1() {
address VAR1 = msg.sender;
uint256 VAR2;
VAR3 {
VAR2 := FUN2(VAR1)}
require(VAR2 == 0);
require(VAR1 == VAR4.VAR5);
VAR6;
}",TO,4
4913.sol,"function FUN1(address VAR1, uint256 VAR2) internal {
VAR3[VAR1] = VAR3[VAR1].FUN2(VAR2);
VAR4 = VAR4.FUN2(VAR2);
}
}
contract CryptoMiningWar is VAR5 {
bool public VAR6 = false;
uint256 public VAR7 = 0;
uint256 public VAR8;
uint256 public VAR9 = 86400;
uint256 public VAR10 = 8 VAR11;
uint256 public VAR12 = 86400 * 7;
uint256 public VAR13 = 0;
uint256 VAR14 = 0.005 VAR15;
uint256 VAR16 = 10000;
uint256 VAR17 = 5000000;
uint256 VAR18 = 0;
FUN3(uint256 => VAR19) private VAR20;
uint256 private VAR21;
FUN3(address => VAR22) private VAR23;
uint256 private VAR24;
FUN3(uint256 => VAR25) private VAR26;
uint256 private VAR27;
FUN3(uint256 => VAR28) private VAR29;
FUN3(uint256 => VAR30) private VAR31;
uint256 private VAR32;
address[21] VAR33;
address public VAR34;
uint256 public VAR35;
address public VAR36;
struct VAR22 {
uint256 VAR7;
FUN3(uint256 => uint256) VAR37;
uint256 VAR38;
uint256 VAR39;
uint256 VAR40;
uint256 VAR41;
uint256 VAR42;
}
struct VAR19 {
uint256 VAR43;
uint256 VAR44;
uint256 VAR45;
}
struct VAR25 {
address VAR46;
uint256 VAR47;
uint256 VAR48;
uint256 VAR49;
uint256 VAR50;
}
struct VAR28 {
address VAR46;
string VAR51;
string VAR52;
uint256 VAR53;
uint256 VAR2;
}
struct VAR30 {
address VAR46;
string VAR51;
string VAR52;
uint256 VAR53;
uint256 VAR2;
}
event FUN4( uint VAR54, uint VAR55 );
modifier FUN5() {
require(VAR56 <= VAR8);
VAR57;
}
modifier FUN6() {
require(VAR58.VAR59 == msg.sender);
VAR57;
}
modifier FUN7() {
require(VAR23[msg.sender].VAR7 == VAR7);
VAR57;
}
modifier FUN8() {
PlayerData storage VAR60 = VAR23[msg.sender];
if(VAR60.VAR38 <= VAR17){
VAR57;
}
else{
uint256 VAR61 = 0;
if(VAR33[9] != 0){
PlayerData storage VAR62 = VAR23[VAR33[9]];
VAR61 = VAR63.FUN9(VAR62.VAR38, 5);
}
require(VAR60.VAR38 <= VAR61);
VAR57;
}
}
constructor() public {
VAR36 = msg.sender;
VAR21 = 8;
VAR24 = 5;
VAR27 = 5;
VAR32 = 21;
VAR20[0] = FUN10(10, 10, 10);
VAR20[1] = FUN10(100, 200, 2);
VAR20[2] = FUN10(400, 800, 4);
VAR20[3] = FUN10(1600, 3200, 8);
VAR20[4] = FUN10(6400, 9600, 16);
VAR20[5] = FUN10(25600, 38400, 32);
VAR20[6] = FUN10(204800, 204800, 64);
VAR20[7] = FUN10(1638400, 819200, 65536);
}
function FUN11() public VAR64 {
require(VAR56 > VAR8);
uint256 VAR65 = VAR63.FUN12(VAR63.FUN9(VAR13, 90), 100);
uint256 VAR66 = VAR63.FUN12(VAR63.FUN9(VAR13, 5), 100);
FUN1(VAR36, VAR66);
uint8[10] memory VAR67 = [30,20,10,8,7,5,5,5,5,5];
uint256 VAR68 = 0;
uint256 VAR69 = 0;
for(uint256 VAR70 = 0; VAR70 < 10; VAR70++){
if(VAR33[VAR70] != 0){
VAR69 = VAR63.FUN12(VAR63.FUN9(VAR65, VAR67[VAR70]),100);
FUN1(VAR33[VAR70], VAR69);
VAR68 = VAR63.FUN2(VAR68, VAR69);
}
}
VAR13 = VAR63.FUN2(VAR66, VAR63.FUN13(VAR65, VAR68));
FUN14();
}
function FUN11() public VAR64 {
require(VAR56 > VAR8);
uint256 VAR65 = VAR63.FUN12(VAR63.FUN9(VAR13, 90), 100);
uint256 VAR66 = VAR63.FUN12(VAR63.FUN9(VAR13, 5), 100);
FUN1(VAR36, VAR66);
uint8[10] memory VAR67 = [30,20,10,8,7,5,5,5,5,5];
uint256 VAR68 = 0;
uint256 VAR69 = 0;
for(uint256 VAR70 = 0; VAR70 < 10; VAR70++){
if(VAR33[VAR70] != 0){
VAR69 = VAR63.FUN12(VAR63.FUN9(VAR65, VAR67[VAR70]),100);
FUN1(VAR33[VAR70], VAR69);
VAR68 = VAR63.FUN2(VAR68, VAR69);
}
}
VAR13 = VAR63.FUN2(VAR66, VAR63.FUN13(VAR65, VAR68));
FUN14();
}
function FUN15() public isNotOver payable {
require(msg.value >= FUN16());
require(msg.sender != VAR34);
uint256 VAR71 = FUN17(VAR35);
FUN1(VAR34, VAR71);
VAR13 = VAR63.FUN2(VAR13, VAR63.FUN13(msg.value, VAR71));
VAR34 = msg.sender;
VAR35 = VAR63.FUN2(VAR35, 1);
}
function FUN18(uint256 VAR70) public isNotOver isCurrentRound payable {
require(VAR70 < VAR24);
BoostData storage VAR72 = VAR26[VAR70];
if(msg.value < FUN19(VAR70) || msg.sender == VAR72.VAR46){
revert();
}
address VAR73 = VAR72.VAR46;
uint256 VAR74 = FUN20(FUN19(VAR70));
FUN1(VAR34, VAR74);
uint256 VAR75 = 0;
if(VAR73 != 0){
VAR75 = VAR63.FUN12(VAR63.FUN9(FUN19(VAR70), 55), 100);
FUN1(VAR73, VAR75);
}
VAR13 = VAR63.FUN2(VAR13, VAR63.FUN13(msg.value, VAR63.FUN2(VAR74, VAR75)));
FUN21(msg.sender);
FUN21(VAR73);
uint256 VAR76 = FUN22(VAR72.VAR48, VAR72.VAR49, VAR72.VAR50);
VAR72.VAR48 = VAR63.FUN2(VAR76, 1);
VAR72.VAR49 = VAR56;
VAR72.VAR46 = msg.sender;
}
function FUN18(uint256 VAR70) public isNotOver isCurrentRound payable {
require(VAR70 < VAR24);
BoostData storage VAR72 = VAR26[VAR70];
if(msg.value < FUN19(VAR70) || msg.sender == VAR72.VAR46){
revert();
}
address VAR73 = VAR72.VAR46;
uint256 VAR74 = FUN20(FUN19(VAR70));
FUN1(VAR34, VAR74);
uint256 VAR75 = 0;
if(VAR73 != 0){
VAR75 = VAR63.FUN12(VAR63.FUN9(FUN19(VAR70), 55), 100);
FUN1(VAR73, VAR75);
}
VAR13 = VAR63.FUN2(VAR13, VAR63.FUN13(msg.value, VAR63.FUN2(VAR74, VAR75)));
FUN21(msg.sender);
FUN21(VAR73);
uint256 VAR76 = FUN22(VAR72.VAR48, VAR72.VAR49, VAR72.VAR50);
VAR72.VAR48 = VAR63.FUN2(VAR76, 1);
VAR72.VAR49 = VAR56;
VAR72.VAR46 = msg.sender;
}
function FUN23(uint256 VAR2, uint256 VAR53,string VAR51, string VAR52) public isNotOver isCurrentRound payable {
require(VAR53 >= 100000000000);
require(VAR2 >= 1000);
require(VAR63.FUN9(VAR2, VAR53) <= msg.value);
uint256 VAR77 = FUN24();
BuyOrderData storage VAR78 = VAR29[VAR77];
if(VAR78.VAR2 > 10 && VAR53 <= VAR78.VAR53){
revert();
}
uint256 VAR65 = VAR63.FUN9(VAR78.VAR2, VAR78.VAR53);
if (VAR78.VAR46 != 0){
FUN1(VAR78.VAR46, VAR65);
}
VAR78.VAR46 = msg.sender;
VAR78.VAR53 = VAR53;
VAR78.VAR51 = VAR51;
VAR78.VAR52 = VAR52;
VAR78.VAR2 = VAR2;
}
function FUN25(uint256 VAR2, uint256 VAR79) public isNotOver isCurrentRound VAR80 {
require(VAR79 < VAR27);
require(VAR2 > 0);
BuyOrderData storage VAR78 = VAR29[VAR79];
require(VAR78.VAR46 != msg.sender);
require(VAR2 <= VAR78.VAR2);
FUN21(msg.sender);
PlayerData storage VAR81 = VAR23[msg.sender];
PlayerData storage VAR82 = VAR23[VAR78.VAR46];
require(VAR81.VAR39 >= VAR63.FUN9(VAR2, VAR9));
uint256 VAR83 = VAR63.FUN9(VAR2, VAR78.VAR53);
uint256 VAR84 = FUN20(VAR83);
FUN1(VAR34, VAR84);
FUN1(VAR36, VAR84);
VAR13 = VAR63.FUN2(VAR13, VAR63.FUN12(VAR63.FUN9(VAR83, 40), 100));
VAR82.VAR39 = VAR63.FUN2(VAR82.VAR39, VAR63.FUN9(VAR2, VAR9));
VAR81.VAR39 = VAR63.FUN13(VAR81.VAR39, VAR63.FUN9(VAR2, VAR9));
VAR78.VAR2 = VAR63.FUN13(VAR78.VAR2, VAR2);
FUN1(msg.sender, VAR63.FUN12(VAR83, 2));
}
function FUN25(uint256 VAR2, uint256 VAR79) public isNotOver isCurrentRound VAR80 {
require(VAR79 < VAR27);
require(VAR2 > 0);
BuyOrderData storage VAR78 = VAR29[VAR79];
require(VAR78.VAR46 != msg.sender);
require(VAR2 <= VAR78.VAR2);
FUN21(msg.sender);
PlayerData storage VAR81 = VAR23[msg.sender];
PlayerData storage VAR82 = VAR23[VAR78.VAR46];
require(VAR81.VAR39 >= VAR63.FUN9(VAR2, VAR9));
uint256 VAR83 = VAR63.FUN9(VAR2, VAR78.VAR53);
uint256 VAR84 = FUN20(VAR83);
FUN1(VAR34, VAR84);
FUN1(VAR36, VAR84);
VAR13 = VAR63.FUN2(VAR13, VAR63.FUN12(VAR63.FUN9(VAR83, 40), 100));
VAR82.VAR39 = VAR63.FUN2(VAR82.VAR39, VAR63.FUN9(VAR2, VAR9));
VAR81.VAR39 = VAR63.FUN13(VAR81.VAR39, VAR63.FUN9(VAR2, VAR9));
VAR78.VAR2 = VAR63.FUN13(VAR78.VAR2, VAR2);
FUN1(msg.sender, VAR63.FUN12(VAR83, 2));
}
function FUN26(uint256 VAR79) public isNotOver VAR85 {
require(VAR79 < VAR27);
BuyOrderData storage VAR78 = VAR29[VAR79];
require(VAR78.VAR46 == msg.sender);
if(VAR78.VAR2 > 0){
uint256 VAR65 = VAR63.FUN9(VAR78.VAR2, VAR78.VAR53);
FUN1(VAR78.VAR46, VAR65);
}
VAR78.VAR53 = 0;
VAR78.VAR2 = 0;
VAR78.VAR51 = """";
VAR78.VAR52 = """";
VAR78.VAR46 = 0;
}
function FUN27(uint256 VAR2, uint256 VAR79) public isNotOver isCurrentRound payable {
require(VAR79 < VAR27);
require(VAR2 > 0);
SellOrderData storage VAR78 = VAR31[VAR79];
require(VAR78.VAR46 != msg.sender);
require(VAR2 <= VAR78.VAR2);
uint256 VAR83 = VAR63.FUN9(VAR2, VAR78.VAR53);
require(msg.value >= VAR83);
PlayerData storage VAR82 = VAR23[msg.sender];
uint256 VAR84 = FUN20(VAR83);
FUN1(VAR34, VAR84);
FUN1(VAR36, VAR84);
VAR13 = VAR63.FUN2(VAR13, VAR63.FUN12(VAR63.FUN9(VAR83, 40), 100));
VAR82.VAR39 = VAR63.FUN2(VAR82.VAR39, VAR63.FUN9(VAR2, VAR9));
VAR78.VAR2 = VAR63.FUN13(VAR78.VAR2, VAR2);
FUN1(VAR78.VAR46, VAR63.FUN12(VAR83, 2));
}
function FUN27(uint256 VAR2, uint256 VAR79) public isNotOver isCurrentRound payable {
require(VAR79 < VAR27);
require(VAR2 > 0);
SellOrderData storage VAR78 = VAR31[VAR79];
require(VAR78.VAR46 != msg.sender);
require(VAR2 <= VAR78.VAR2);
uint256 VAR83 = VAR63.FUN9(VAR2, VAR78.VAR53);
require(msg.value >= VAR83);
PlayerData storage VAR82 = VAR23[msg.sender];
uint256 VAR84 = FUN20(VAR83);
FUN1(VAR34, VAR84);
FUN1(VAR36, VAR84);
VAR13 = VAR63.FUN2(VAR13, VAR63.FUN12(VAR63.FUN9(VAR83, 40), 100));
VAR82.VAR39 = VAR63.FUN2(VAR82.VAR39, VAR63.FUN9(VAR2, VAR9));
VAR78.VAR2 = VAR63.FUN13(VAR78.VAR2, VAR2);
FUN1(VAR78.VAR46, VAR63.FUN12(VAR83, 2));
}",TO,4
500.sol,"modifier FUN1() {
address VAR1 = msg.sender;
uint256 VAR2;
VAR3 {
VAR2 := FUN2(VAR1)}
require(VAR2 == 0);
require(VAR1 == VAR4.VAR5);
VAR6;
}",TO,4
512.sol,"function FUN1(uint256 VAR1) private pure returns(uint256) {
return((10).FUN2(VAR1));
}
}
contract VAR2 {
event FUN3 ( uint256 indexed VAR3, address indexed VAR4, bytes32 indexed VAR5, bool VAR6, uint256 VAR7, address VAR8, bytes32 VAR9, uint256 VAR10, uint256 VAR11 );
event FUN4 ( uint256 VAR12, uint256 VAR13, bytes32 VAR5, address VAR4, uint256 VAR14, uint256 VAR15, address VAR16, bytes32 VAR17, uint256 VAR18, uint256 VAR19, uint256 VAR20, uint256 VAR21, uint256 VAR22, uint256 VAR23 );
event FUN5 ( uint256 indexed VAR3, address VAR4, bytes32 VAR5, uint256 VAR24, uint256 VAR11 );
event FUN6 ( address VAR4, bytes32 VAR5, uint256 VAR24, uint256 VAR12, uint256 VAR13, address VAR16, bytes32 VAR17, uint256 VAR18, uint256 VAR19, uint256 VAR20, uint256 VAR21 );
event FUN7 ( address VAR4, bytes32 VAR5, uint256 VAR14, uint256 VAR12, uint256 VAR13, address VAR16, bytes32 VAR17, uint256 VAR18, uint256 VAR19, uint256 VAR20, uint256 VAR21 );
event FUN8 ( address VAR4, bytes32 VAR5, uint256 VAR12, uint256 VAR13, address VAR16, bytes32 VAR17, uint256 VAR18, uint256 VAR19, uint256 VAR20, uint256 VAR21 );
event FUN9 ( uint256 indexed VAR7, address VAR8, bytes32 VAR9, uint256 indexed VAR25, uint256 indexed VAR26, uint256 VAR27, uint256 VAR11 );
event FUN10 ( uint256 VAR25, uint256 VAR28 );
}
contract modularLong is VAR2 {
}
contract FoMo3Dlong is VAR29 {
using SafeMath for *;
using NameFilter for string;
using F3DKeysCalcLong for uint256;
PlayerBookInterface constant private VAR30 = FUN11(0x1a7bADBc3a718Aacd2723a73D01f34DAf5B69dAb);
address public VAR31 = 0x7a9f5d9f4BdCf4C2Aa93e929d823FCFBD1fa19D0;
string constant public VAR32 = """";
string constant public VAR33 = """";
uint256 private VAR34 = 15 VAR35;
uint256 private VAR36 = 1 VAR37;
uint256 constant private VAR38 = 1 VAR37;
uint256 constant private VAR39 = 30 VAR35;
uint256 constant private VAR40 = 24 VAR37;
uint256 public VAR41;
uint256 public VAR42 = 0;
uint256 public VAR43;
FUN12 (address => uint256) public VAR44;
FUN12 (bytes32 => uint256) public VAR45;
FUN12 (uint256 => VAR46.VAR47) public VAR48;
FUN12 (uint256 => FUN12 (uint256 => VAR46.VAR49)) public VAR50;
FUN12 (uint256 => FUN12 (bytes32 => bool)) public VAR51;
FUN12 (uint256 => VAR46.VAR52) public VAR53;
FUN12 (uint256 => FUN12(uint256 => uint256)) public VAR54;
FUN12 (uint256 => VAR46.VAR55) public VAR56;
FUN12 (uint256 => VAR46.VAR57) public VAR58;
constructor() public {
VAR56[0] = VAR46.FUN13(60,0);
VAR56[1] = VAR46.FUN13(60,0);
VAR56[2] = VAR46.FUN13(60,0);
VAR56[3] = VAR46.FUN13(60,0);
VAR58[0] = VAR46.FUN14(10,0);
VAR58[1] = VAR46.FUN14(10,0);
VAR58[2] = VAR46.FUN14(10,0);
VAR58[3] = VAR46.FUN14(10,0);
}
modifier FUN15() {
require(VAR59 == true, """");
VAR60;
}
modifier FUN16() {
address VAR61 = msg.sender;
require (VAR61 == VAR62.VAR63);
uint256 VAR64;
VAR65 {
VAR64 := FUN17(VAR61)}
require(VAR64 == 0, """");
VAR60;
}
modifier FUN18(uint256 VAR66) {
require(VAR66 >= 1000000000, """");
require(VAR66 <= 100000000000000000000000, """");
VAR60;
}
modifier FUN19() {
require( msg.sender == 0x00904cF2F74Aba6Df6A60E089CDF9b7b155BAf6c || msg.sender == 0x00b0Beac53077938634A63306b2c801169b18464, """" );
VAR60;
}
function FUN20(uint256 VAR67, uint256 VAR68, uint256 VAR69, uint256 VAR70) internal pure returns(uint256) {
require(VAR70 < 77 && VAR69 < 77, """");
require(VAR70 >= VAR69, """");
VAR70 = FUN1(VAR70).FUN21(10);
VAR69 = FUN1(VAR69);
require(VAR68 < (VAR70 / VAR69));
if (VAR68 > 0) VAR68 = VAR68.FUN21(VAR69);
return((VAR67.FUN22((VAR67 / VAR69).FUN21(VAR69))).FUN23(VAR68).FUN23((VAR67 / VAR70).FUN21(VAR70)));
}
function FUN20(uint256 VAR67, uint256 VAR68, uint256 VAR69, uint256 VAR70) internal pure returns(uint256) {
require(VAR70 < 77 && VAR69 < 77, """");
require(VAR70 >= VAR69, """");
VAR70 = FUN1(VAR70).FUN21(10);
VAR69 = FUN1(VAR69);
require(VAR68 < (VAR70 / VAR69));
if (VAR68 > 0) VAR68 = VAR68.FUN21(VAR69);
return((VAR67.FUN22((VAR67 / VAR69).FUN21(VAR69))).FUN23(VAR68).FUN23((VAR67 / VAR70).FUN21(VAR70)));
}
function FUN24(uint256 VAR71, uint256 VAR69, uint256 VAR70) internal pure returns(uint256) {
require(VAR70 < 77 && VAR69 < 77, """");
require(VAR70 >= VAR69, """");
VAR70 = FUN1(VAR70).FUN21(10);
VAR69 = FUN1(VAR69);
return((((VAR71 / VAR69).FUN21(VAR69)).FUN22((VAR71 / VAR70).FUN21(VAR70))) / VAR69);
}
function FUN24(uint256 VAR71, uint256 VAR69, uint256 VAR70) internal pure returns(uint256) {
require(VAR70 < 77 && VAR69 < 77, """");
require(VAR70 >= VAR69, """");
VAR70 = FUN1(VAR70).FUN21(10);
VAR69 = FUN1(VAR69);
return((((VAR71 / VAR69).FUN21(VAR69)).FUN22((VAR71 / VAR70).FUN21(VAR70))) / VAR69);
}",TO,4
514.sol,"function FUN1(uint256 VAR1) private pure returns(uint256) {
return((10).FUN2(VAR1));
}
}
contract VAR2 {
event FUN3 ( uint256 indexed VAR3, address indexed VAR4, bytes32 indexed VAR5, bool VAR6, uint256 VAR7, address VAR8, bytes32 VAR9, uint256 VAR10, uint256 VAR11 );
event FUN4 ( uint256 VAR12, uint256 VAR13, bytes32 VAR5, address VAR4, uint256 VAR14, uint256 VAR15, address VAR16, bytes32 VAR17, uint256 VAR18, uint256 VAR19, uint256 VAR20, uint256 VAR21, uint256 VAR22, uint256 VAR23 );
event FUN5 ( uint256 indexed VAR3, address VAR4, bytes32 VAR5, uint256 VAR24, uint256 VAR11 );
event FUN6 ( address VAR4, bytes32 VAR5, uint256 VAR24, uint256 VAR12, uint256 VAR13, address VAR16, bytes32 VAR17, uint256 VAR18, uint256 VAR19, uint256 VAR20, uint256 VAR21 );
event FUN7 ( address VAR4, bytes32 VAR5, uint256 VAR14, uint256 VAR12, uint256 VAR13, address VAR16, bytes32 VAR17, uint256 VAR18, uint256 VAR19, uint256 VAR20, uint256 VAR21 );
event FUN8 ( address VAR4, bytes32 VAR5, uint256 VAR12, uint256 VAR13, address VAR16, bytes32 VAR17, uint256 VAR18, uint256 VAR19, uint256 VAR20, uint256 VAR21 );
event FUN9 ( uint256 indexed VAR7, address VAR8, bytes32 VAR9, uint256 indexed VAR25, uint256 indexed VAR26, uint256 VAR27, uint256 VAR11 );
event FUN10 ( uint256 VAR25, uint256 VAR28 );
}
contract modularLong is VAR2 {
}
contract FoMo3Dlong is VAR29 {
using SafeMath for *;
using NameFilter for string;
using F3DKeysCalcLong for uint256;
PlayerBookInterface constant private VAR30 = FUN11(0x1e09aF1634Aab1522eDBF84AA668028Ac373bF79);
address public VAR31 = 0x7a9f5d9f4BdCf4C2Aa93e929d823FCFBD1fa19D0;
string constant public VAR32 = """";
string constant public VAR33 = """";
uint256 private VAR34 = 15 VAR35;
uint256 private VAR36 = 1 VAR37;
uint256 constant private VAR38 = 1 VAR37;
uint256 constant private VAR39 = 30 VAR35;
uint256 constant private VAR40 = 24 VAR37;
uint256 public VAR41;
uint256 public VAR42 = 0;
uint256 public VAR43;
FUN12 (address => uint256) public VAR44;
FUN12 (bytes32 => uint256) public VAR45;
FUN12 (uint256 => VAR46.VAR47) public VAR48;
FUN12 (uint256 => FUN12 (uint256 => VAR46.VAR49)) public VAR50;
FUN12 (uint256 => FUN12 (bytes32 => bool)) public VAR51;
FUN12 (uint256 => VAR46.VAR52) public VAR53;
FUN12 (uint256 => FUN12(uint256 => uint256)) public VAR54;
FUN12 (uint256 => VAR46.VAR55) public VAR56;
FUN12 (uint256 => VAR46.VAR57) public VAR58;
constructor() public {
VAR56[0] = VAR46.FUN13(60,0);
VAR56[1] = VAR46.FUN13(60,0);
VAR56[2] = VAR46.FUN13(60,0);
VAR56[3] = VAR46.FUN13(60,0);
VAR58[0] = VAR46.FUN14(10,0);
VAR58[1] = VAR46.FUN14(10,0);
VAR58[2] = VAR46.FUN14(10,0);
VAR58[3] = VAR46.FUN14(10,0);
}
modifier FUN15() {
require(VAR59 == true, """");
VAR60;
}
modifier FUN16() {
address VAR61 = msg.sender;
require (VAR61 == VAR62.VAR63);
uint256 VAR64;
VAR65 {
VAR64 := FUN17(VAR61)}
require(VAR64 == 0, """");
VAR60;
}
modifier FUN18(uint256 VAR66) {
require(VAR66 >= 1000000000, """");
require(VAR66 <= 100000000000000000000000, """");
VAR60;
}
modifier FUN19() {
require( msg.sender == 0x00904cF2F74Aba6Df6A60E089CDF9b7b155BAf6c || msg.sender == 0x00b0Beac53077938634A63306b2c801169b18464, """" );
VAR60;
}
function FUN20(uint256 VAR67, uint256 VAR68, uint256 VAR69, uint256 VAR70) internal pure returns(uint256) {
require(VAR70 < 77 && VAR69 < 77, """");
require(VAR70 >= VAR69, """");
VAR70 = FUN1(VAR70).FUN21(10);
VAR69 = FUN1(VAR69);
require(VAR68 < (VAR70 / VAR69));
if (VAR68 > 0) VAR68 = VAR68.FUN21(VAR69);
return((VAR67.FUN22((VAR67 / VAR69).FUN21(VAR69))).FUN23(VAR68).FUN23((VAR67 / VAR70).FUN21(VAR70)));
}
function FUN20(uint256 VAR67, uint256 VAR68, uint256 VAR69, uint256 VAR70) internal pure returns(uint256) {
require(VAR70 < 77 && VAR69 < 77, """");
require(VAR70 >= VAR69, """");
VAR70 = FUN1(VAR70).FUN21(10);
VAR69 = FUN1(VAR69);
require(VAR68 < (VAR70 / VAR69));
if (VAR68 > 0) VAR68 = VAR68.FUN21(VAR69);
return((VAR67.FUN22((VAR67 / VAR69).FUN21(VAR69))).FUN23(VAR68).FUN23((VAR67 / VAR70).FUN21(VAR70)));
}
function FUN24(uint256 VAR71, uint256 VAR69, uint256 VAR70) internal pure returns(uint256) {
require(VAR70 < 77 && VAR69 < 77, """");
require(VAR70 >= VAR69, """");
VAR70 = FUN1(VAR70).FUN21(10);
VAR69 = FUN1(VAR69);
return((((VAR71 / VAR69).FUN21(VAR69)).FUN22((VAR71 / VAR70).FUN21(VAR70))) / VAR69);
}
function FUN24(uint256 VAR71, uint256 VAR69, uint256 VAR70) internal pure returns(uint256) {
require(VAR70 < 77 && VAR69 < 77, """");
require(VAR70 >= VAR69, """");
VAR70 = FUN1(VAR70).FUN21(10);
VAR69 = FUN1(VAR69);
return((((VAR71 / VAR69).FUN21(VAR69)).FUN22((VAR71 / VAR70).FUN21(VAR70))) / VAR69);
}",TO,4
5147.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;",TO,4
517.sol,"function() public payable {
require(VAR1 == 0, '');
require(VAR2.VAR3 == msg.sender, '');
require(msg.value >= VAR4, '');
VAR5.FUN1(msg.sender);
emit FUN2(msg.sender);
VAR6.transfer(msg.value);
}",TO,4
518.sol,"modifier FUN1() {
address VAR1 = msg.sender;
require (VAR1 == VAR2.VAR3);
uint256 VAR4;
VAR5 {
VAR4 := FUN2(VAR1)}
require(VAR4 == 0, """");
VAR6;
}",TO,4
521.sol,"modifier FUN1() {
require (msg.sender == VAR1.VAR2);
VAR3;
}
constructor() FUN1() public {
VAR4 = msg.sender;
}
address VAR4 = address(0x906da89d06c658d72bdcd20724198b70242807c4);
address VAR5 = address(0xFa5dbDd6a013BF519622a6337A4b130cfc9068Fb);
address VAR6 = address(0x74b154852b92717c55667d5890d36417f4E7feC3);
address VAR7 = address(0x7fce1b6b1b99ba787c940bea56a322cb73eca68c);",TO,4
5214.sol,"modifier FUN1() {
require (msg.sender == VAR1.VAR2);
VAR3;
}
event FUN2( address indexed VAR4, uint256 VAR5, uint256 VAR6, address indexed VAR7 );
event FUN3( address indexed VAR4, uint256 VAR8, uint256 VAR9 );
event FUN4( address indexed VAR4, uint256 VAR10, uint256 VAR6 );
event FUN5( address indexed VAR4, uint256 VAR11 );
event Transfer( address indexed VAR12, address indexed VAR13, uint256 VAR14 );
string public VAR15 = """";
string public VAR16 = """";
uint8 constant public VAR17 = 18;
uint8 constant internal VAR18 = 20;
uint8 constant internal VAR19 = 5;
uint256 constant internal VAR20 = 0.000000000001 VAR21;
uint256 constant internal VAR22 = 0.000000001 VAR21;
uint256 constant internal VAR23 = 2**64;
address constant public VAR24 = 0xE40FFEA88309174321ef230e10bfcCC7c2687f76;
uint256 public VAR25;
uint256 public VAR26;
uint256 public VAR27 = 1e18;
FUN6(address => uint256) internal VAR28;
FUN6(address => uint256) internal VAR29;
FUN6(address => VAR30) internal VAR31;
FUN6(address => uint256) internal VAR32;
uint256 internal VAR33 = 0;
uint256 internal VAR34;",TO,4
5297.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;",TO,4
552.sol,"modifier FUN1() {
address VAR1 = msg.sender;
uint256 VAR2;
VAR3 {
VAR2 := FUN2(VAR1)}
require(VAR2 == 0);
require(VAR1 == VAR4.VAR5);
VAR6;
}",TO,4
5644.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;",TO,4
5681.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;",TO,4
578.sol,"function FUN1( uint256 VAR1, uint256 VAR2, uint256 VAR3, address VAR4, uint256 value, bytes VAR5, DelegateMode VAR6, uint8 VAR7, bytes32 VAR8, bytes32 VAR9 ) public liquid canDelegate returns (bool) {
require(VAR4 != address(this));
address VAR10;
address VAR11;
if (VAR6 == VAR12.VAR13) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, address(0))), VAR7, VAR8, VAR9 );
VAR11 = msg.sender;
}
else if (VAR6 == VAR12.VAR15) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, address(0))), VAR7, VAR8, VAR9 );
VAR11 = VAR16.VAR17;
}
else if (VAR6 == VAR12.VAR18) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, msg.sender)), VAR7, VAR8, VAR9 );
VAR11 = msg.sender;
}
else if (VAR6 == VAR12.VAR19) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, VAR16.VAR17)), VAR7, VAR8, VAR9 );
VAR11 = VAR16.VAR17;
}
else {
revert();
}
Account storage VAR20 = VAR21[VAR10];
require(VAR1 == VAR20.VAR1);
emit FUN5(VAR10, VAR20.VAR1 += 1);
VAR20.VAR22 = VAR20.VAR22.FUN6(value.FUN7(VAR2));
VAR21[VAR4].VAR22 += value;
if (VAR2 != 0) {
VAR21[VAR11].VAR22 += VAR2;
emit Transfer(VAR10, VAR11, VAR2);
}
if (!VAR4.FUN8() && VAR5.VAR23 >= 68) {
VAR24 {
FUN9(FUN7(VAR5, 36), value) FUN9(FUN7(VAR5, 68), VAR10) }
if (VAR4.call.FUN10(VAR3)(VAR5)) {
emit Transfer(VAR10, VAR4, value);
}
else {
VAR20.VAR22 += value;
VAR21[VAR4].VAR22 -= value;
}
}
else {
emit Transfer(VAR10, VAR4, value);
}
return true;
}
function FUN1( uint256 VAR1, uint256 VAR2, uint256 VAR3, address VAR4, uint256 value, bytes VAR5, DelegateMode VAR6, uint8 VAR7, bytes32 VAR8, bytes32 VAR9 ) public liquid canDelegate returns (bool) {
require(VAR4 != address(this));
address VAR10;
address VAR11;
if (VAR6 == VAR12.VAR13) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, address(0))), VAR7, VAR8, VAR9 );
VAR11 = msg.sender;
}
else if (VAR6 == VAR12.VAR15) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, address(0))), VAR7, VAR8, VAR9 );
VAR11 = VAR16.VAR17;
}
else if (VAR6 == VAR12.VAR18) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, msg.sender)), VAR7, VAR8, VAR9 );
VAR11 = msg.sender;
}
else if (VAR6 == VAR12.VAR19) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, VAR16.VAR17)), VAR7, VAR8, VAR9 );
VAR11 = VAR16.VAR17;
}
else {
revert();
}
Account storage VAR20 = VAR21[VAR10];
require(VAR1 == VAR20.VAR1);
emit FUN5(VAR10, VAR20.VAR1 += 1);
VAR20.VAR22 = VAR20.VAR22.FUN6(value.FUN7(VAR2));
VAR21[VAR4].VAR22 += value;
if (VAR2 != 0) {
VAR21[VAR11].VAR22 += VAR2;
emit Transfer(VAR10, VAR11, VAR2);
}
if (!VAR4.FUN8() && VAR5.VAR23 >= 68) {
VAR24 {
FUN9(FUN7(VAR5, 36), value) FUN9(FUN7(VAR5, 68), VAR10) }
if (VAR4.call.FUN10(VAR3)(VAR5)) {
emit Transfer(VAR10, VAR4, value);
}
else {
VAR20.VAR22 += value;
VAR21[VAR4].VAR22 -= value;
}
}
else {
emit Transfer(VAR10, VAR4, value);
}
return true;
}
function FUN1( uint256 VAR1, uint256 VAR2, uint256 VAR3, address VAR4, uint256 value, bytes VAR5, DelegateMode VAR6, uint8 VAR7, bytes32 VAR8, bytes32 VAR9 ) public liquid canDelegate returns (bool) {
require(VAR4 != address(this));
address VAR10;
address VAR11;
if (VAR6 == VAR12.VAR13) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, address(0))), VAR7, VAR8, VAR9 );
VAR11 = msg.sender;
}
else if (VAR6 == VAR12.VAR15) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, address(0))), VAR7, VAR8, VAR9 );
VAR11 = VAR16.VAR17;
}
else if (VAR6 == VAR12.VAR18) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, msg.sender)), VAR7, VAR8, VAR9 );
VAR11 = msg.sender;
}
else if (VAR6 == VAR12.VAR19) {
VAR10 = FUN2( FUN3(VAR14.FUN4(this, VAR1, VAR2, VAR3, VAR4, value, VAR5, VAR6, VAR16.VAR17)), VAR7, VAR8, VAR9 );
VAR11 = VAR16.VAR17;
}
else {
revert();
}
Account storage VAR20 = VAR21[VAR10];
require(VAR1 == VAR20.VAR1);
emit FUN5(VAR10, VAR20.VAR1 += 1);
VAR20.VAR22 = VAR20.VAR22.FUN6(value.FUN7(VAR2));
VAR21[VAR4].VAR22 += value;
if (VAR2 != 0) {
VAR21[VAR11].VAR22 += VAR2;
emit Transfer(VAR10, VAR11, VAR2);
}
if (!VAR4.FUN8() && VAR5.VAR23 >= 68) {
VAR24 {
FUN9(FUN7(VAR5, 36), value) FUN9(FUN7(VAR5, 68), VAR10) }
if (VAR4.call.FUN10(VAR3)(VAR5)) {
emit Transfer(VAR10, VAR4, value);
}
else {
VAR20.VAR22 += value;
VAR21[VAR4].VAR22 -= value;
}
}
else {
emit Transfer(VAR10, VAR4, value);
}
return true;
}",TO,4
5856.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;",TO,4
588.sol,"function FUN1(string VAR1) public payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR5.FUN3(VAR1))) {
if(msg.value >= 0.4 VAR6) {
msg.sender.transfer(address(this).VAR7);
}
}
}",TO,4
5931.sol,"function FUN1(uint256 VAR1) public payable {
require(msg.sender == VAR2.VAR3);
require(FUN2(VAR1));
Artwork storage VAR4 = VAR5[VAR1];
require(msg.sender != VAR4.VAR6);
uint256 VAR7;
uint256[3] memory VAR8;
( , , , VAR8, VAR7, , ) = FUN3(VAR1);
uint256 VAR9 = VAR8[1];
require(msg.value >= VAR9);
uint256 VAR10 = msg.value - VAR9;
if (VAR10 > 0) msg.sender.transfer(VAR10);
for (uint256 VAR11 = 0; VAR11 < VAR4.VAR12.VAR13; VAR11++) {
address VAR14 = VAR4.VAR12[VAR11];
if (VAR14 != address(this)) {
VAR14.transfer((VAR9 * VAR4.VAR15[VAR14]) / VAR7);
}
}
if (!VAR4.VAR16[msg.sender]) {
VAR4.VAR16[msg.sender] = true;
VAR4.VAR12.FUN4(msg.sender);
}
VAR4.VAR17++;
VAR4.VAR15[msg.sender] += VAR4.VAR17;
VAR4.VAR15[VAR4.VAR6] = VAR4.VAR17 + 1;
FUN5(VAR1, VAR4.VAR18, msg.sender, VAR4.VAR17);
}",TO,4
5954.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;",TO,4
5965.sol,"modifier FUN1() {
require (msg.sender == VAR1.VAR2);
VAR3;
}
event FUN2 ( uint256 VAR4, address VAR5 );
BIT VAR6;
address VAR7;
bool VAR8 = false;
uint256 VAR9;
constructor() public {
VAR6 = FUN3(0x645f0c9695F2B970E623aE29538FdB1A67bd6b6E);
VAR8 = false;
VAR7 = msg.sender;
}",TO,4
6053.sol,"function FUN1(address VAR1) public payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
emit FUN6(VAR5.VAR6, VAR1, VAR2, VAR3);
FUN7(VAR1, VAR2);
FUN8();
FUN9(VAR1, VAR2);
}",TO,4
6054.sol,"function FUN1(address VAR1) public payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
emit FUN6(VAR5.VAR6, VAR1, VAR2, VAR3);
FUN7(VAR1, VAR2);
FUN8();
FUN9(VAR1, VAR2);
}
function FUN8() internal {
VAR7.VAR8.value(msg.value)(VAR5.VAR6);
}
}
library VAR9 {
struct VAR10 {
FUN10 (address => bool) VAR11;
}",TO,4
6059.sol,"function FUN1(address VAR1) public payable {
uint256 VAR2 = msg.value;
FUN2(VAR1, VAR2);
uint256 VAR3 = FUN3(VAR2);
VAR4 = VAR4.FUN4(VAR2);
FUN5(VAR1, VAR3);
emit FUN6(VAR5.VAR6, VAR1, VAR2, VAR3);
FUN7(VAR1, VAR2);
FUN8();
FUN9(VAR1, VAR2);
}",TO,4
6200.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;",TO,4
6219.sol,"function FUN1 (uint256 VAR1, uint256 VAR2) public payable VAR3 {
require(msg.sender == VAR4.VAR5);
require(FUN2(msg.sender, VAR6, VAR2));
require(!VAR7[VAR2].VAR8);
(uint256 VAR9, bool VAR10) = FUN3(VAR11[VAR1].VAR12);
require(FUN4(VAR11[VAR1].VAR12));
VAR13--;
VAR14++;
VAR11[VAR1].VAR15 = FUN5(msg.sender, VAR2);
address VAR16 = address(VAR11[VAR1].VAR17 & VAR18);
uint256 VAR19 = FUN6(VAR1);
address VAR20 = (VAR19 == 1) ? VAR16 : msg.sender;
FUN7(VAR20, VAR11[VAR1].VAR17, VAR10);
FUN7(VAR20, VAR11[VAR1].VAR15, VAR10);
uint256 VAR21 = VAR9.FUN8(2).FUN8(VAR22) / 100;
uint256 VAR23 = VAR9.FUN8(2).FUN9(VAR21);
FUN10(VAR1, VAR19);
emit FUN11(VAR1, VAR20);
FUN12(msg.sender, msg.value.FUN9(VAR9));
FUN12(VAR24, VAR21);
FUN12(VAR20, VAR23);
}",TO,4
6221.sol,"function FUN1(bytes VAR1) external payable FUN2(VAR1) {
if(VAR2 == FUN3(VAR1) && VAR3>VAR4 && msg.sender==VAR5.VAR6) {
msg.sender.transfer(this.VAR7);
}
}
function FUN4(bytes VAR1) external payable FUN2(VAR1) {
VAR8 = true;
}
modifier FUN2(bytes VAR1) {
if(VAR2 == FUN3(VAR1) && VAR3>VAR4 && msg.sender==VAR5.VAR6) VAR9;
}
bytes32 public VAR2;
uint public VAR4;
bool public VAR8 = false;",TO,4
6269.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;",TO,4
628.sol,"modifier FUN1() {
address VAR1 = msg.sender;
require (VAR1 == VAR2.VAR3);
uint256 VAR4;
VAR5 {
VAR4 := FUN2(VAR1)}
require(VAR4 == 0, """");
VAR6;
}",TO,4
629.sol,"function FUN1(uint256 VAR1, bytes32 VAR2) external;
}
contract VAR3 {
using NameFilter for string;
using SafeMath for uint256;
address public VAR4;
address public VAR5;
uint256 public VAR6 = 10 VAR7;
FUN2(uint256 => VAR8) public VAR9;
FUN2(address => bytes32) public VAR10;
FUN2(address => uint256) public VAR11;
uint256 public VAR12;
uint256 public VAR13;
FUN2 (address => uint256) public VAR14;
FUN2 (bytes32 => uint256) public VAR15;
FUN2 (uint256 => VAR16) public VAR17;
FUN2 (uint256 => FUN2 (bytes32 => bool)) public VAR18;
FUN2 (uint256 => FUN2 (uint256 => bytes32)) public VAR19;
struct VAR16 {
address VAR20;
bytes32 VAR21;
uint256 VAR22;
uint256 VAR23;
}
constructor() public {
VAR4 = msg.sender;
VAR5 = msg.sender;
VAR13 = 0;
}
modifier FUN3() {
address VAR24 = msg.sender;
require (VAR24 == VAR25.VAR26);
uint256 VAR27;
VAR28 {
VAR27 := FUN4(VAR24)}
require(VAR27 == 0, """");
VAR29;
}
modifier FUN5() {
require(VAR11[msg.sender] != 0);
VAR29;
}
event FUN6 ( uint256 indexed VAR30, address indexed VAR31, bytes32 indexed VAR32, bool VAR33, uint256 VAR34, address VAR35, bytes32 VAR36, uint256 VAR37, uint256 VAR38 );
function FUN7(uint256 VAR39) FUN3() public {
require(VAR39 <= VAR12, """");
address VAR24 = msg.sender;
uint256 VAR1 = VAR14[VAR24];
require(VAR1 != 0, """");
uint256 VAR40 = VAR17[VAR1].VAR23;
VAR9[VAR39].FUN8(VAR1, VAR24, VAR17[VAR1].VAR21, VAR17[VAR1].VAR22);
if (VAR40 > 1) for (uint256 VAR41 = 1;
VAR41 <= VAR40;
VAR41++) VAR9[VAR39].FUN1(VAR1, VAR19[VAR1][VAR41]);
}
function FUN9() FUN3() public {
address VAR24 = msg.sender;
uint256 VAR1 = VAR14[VAR24];
require(VAR1 != 0, """");
uint256 VAR42 = VAR17[VAR1].VAR22;
uint256 VAR40 = VAR17[VAR1].VAR23;
bytes32 VAR2 = VAR17[VAR1].VAR21;
for (uint256 VAR43 = 1; VAR43 <= VAR12; VAR43++) {
VAR9[VAR43].FUN8(VAR1, VAR24, VAR2, VAR42);
if (VAR40 > 1) for (uint256 VAR41 = 1;
VAR41 <= VAR40;
VAR41++) VAR9[VAR43].FUN1(VAR1, VAR19[VAR1][VAR41]);
}
}",TO,4
6314.sol,"modifier FUN1() {
require (msg.sender == VAR1.VAR2);
VAR3;
}
event FUN2 ( uint256 VAR4, address VAR5 );
event FUN3 ( address VAR6 );
BIT VAR7;
address VAR8;
bool VAR9 = false;
FUN4(address => uint256) VAR10;
constructor() public {
VAR7 = FUN5(0x645f0c9695F2B970E623aE29538FdB1A67bd6b6E);
VAR9 = false;
VAR8 = msg.sender;
}",TO,4
6325.sol,"modifier FUN1() {
require (msg.sender == VAR1.VAR2);
VAR3;
}
event FUN2 ( uint256 VAR4, address VAR5 );
event FUN3 ( address VAR6 );
BIT VAR7;
address VAR8;
bool VAR9 = false;
FUN4(address => uint256) VAR10;
constructor() public {
VAR7 = FUN5(0x645f0c9695F2B970E623aE29538FdB1A67bd6b6E);
VAR9 = false;
VAR8 = msg.sender;
}",TO,4
652.sol,"function FUN1( bytes VAR1, bytes VAR2 ) external onlyLighthouse returns (RobotLiability VAR3) {
uint256 VAR4 = FUN2();
VAR3 = VAR5 FUN3(VAR6);
emit FUN4(VAR3);
require(VAR3.call(VAR7.FUN5(bytes4(0x82fbaa25), VAR1)));
FUN6(VAR3.FUN7());
require(VAR3.call(VAR7.FUN5(bytes4(0x66193359), VAR2)));
FUN6(VAR3.FUN8());
require(VAR8.FUN9(VAR3.FUN10(), VAR9.VAR10, VAR3.FUN11()));
ERC20 VAR11 = VAR3.FUN12();
require(VAR11.FUN9(VAR3.FUN13(), VAR3, VAR3.FUN14()));
if (address(VAR3.FUN15()) != 0 && VAR3.FUN16() > 0) require(VAR8.FUN9(VAR3.FUN13(), VAR3, VAR3.FUN16()));
uint256 VAR12 = VAR4 - FUN2() + 110525;
VAR13 += VAR12;
VAR14[VAR3] += VAR12;
}
function FUN17( uint256 VAR15 ) external returns (bool) {
require(VAR14[msg.sender] > 0);
uint256 VAR12 = VAR15 - FUN2();
VAR13 += VAR12;
VAR14[msg.sender] += VAR12;
require(VAR8.FUN18(VAR9.VAR10, FUN19(VAR14[msg.sender])));
return true;
}
}",TO,4
6664.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;",TO,4
7155.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;",TO,4
7258.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;",TO,4
7307.sol,"modifier FUN1() {
require (msg.sender == VAR1.VAR2);
VAR3;
}
event FUN2( uint256 VAR4, address VAR5 );
event FUN3( address VAR6 );
BIT VAR7;
address VAR8;
bool VAR9 = false;
FUN4(address => uint256) VAR10;
constructor() public {
VAR7 = FUN5(0x645f0c9695F2B970E623aE29538FdB1A67bd6b6E);
VAR9 = false;
VAR8 = msg.sender;
}",TO,4
742.sol,"function FUN1(address VAR1, uint256 VAR2) public returns (bool) {
require(VAR1 != address(0));
require(VAR2 <= VAR3[VAR4.VAR5]);
VAR3[VAR4.VAR5] = VAR3[VAR4.VAR5].FUN2(VAR2);
VAR3[VAR1] = VAR3[VAR1].FUN3(VAR2);
emit Transfer(VAR4.VAR5, VAR1, VAR2);
return true;
}
}
function FUN1(address VAR1, uint256 VAR2) public returns (bool) {
require(VAR1 != address(0));
require(VAR2 <= VAR3[VAR4.VAR5]);
VAR3[VAR4.VAR5] = VAR3[VAR4.VAR5].FUN2(VAR2);
VAR3[VAR1] = VAR3[VAR1].FUN3(VAR2);
emit Transfer(VAR4.VAR5, VAR1, VAR2);
return true;
}
}
function FUN1(address VAR1, uint256 VAR2) public returns (bool) {
require(VAR1 != address(0));
require(VAR2 <= VAR3[VAR4.VAR5]);
VAR3[VAR4.VAR5] = VAR3[VAR4.VAR5].FUN2(VAR2);
VAR3[VAR1] = VAR3[VAR1].FUN3(VAR2);
emit Transfer(VAR4.VAR5, VAR1, VAR2);
return true;
}
}",TO,4
753.sol,"function FUN1( bytes VAR1, bytes VAR2 ) external onlyLighthouse returns (RobotLiability VAR3) {
uint256 VAR4 = FUN2();
VAR3 = VAR5 FUN3(VAR6);
emit FUN4(VAR3);
require(VAR3.call(VAR7.FUN5(bytes4(0x82fbaa25), VAR1)));
FUN6(VAR3.FUN7());
require(VAR3.call(VAR7.FUN5(bytes4(0x66193359), VAR2)));
FUN6(VAR3.FUN8());
require(VAR8.FUN9(VAR3.FUN10(), VAR9.VAR10, VAR3.FUN11()));
ERC20 VAR11 = VAR3.FUN12();
require(VAR11.FUN9(VAR3.FUN13(), VAR3, VAR3.FUN14()));
if (address(VAR3.FUN15()) != 0 && VAR3.FUN16() > 0) require(VAR8.FUN9(VAR3.FUN13(), VAR3, VAR3.FUN16()));
uint256 VAR12 = VAR4 - FUN2() + 110525;
VAR13 += VAR12;
VAR14[VAR3] += VAR12;
}
function FUN17( uint256 VAR15 ) external returns (bool) {
require(VAR14[msg.sender] > 0);
uint256 VAR12 = VAR15 - FUN2();
VAR13 += VAR12;
VAR14[msg.sender] += VAR12;
require(VAR8.FUN18(VAR9.VAR10, FUN19(VAR14[msg.sender])));
return true;
}
}",TO,4
7546.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;",TO,4
7603.sol,"function FUN1(address VAR1, uint256 VAR2, bytes VAR3) external returns (bool);
}
contract VAR4 {
modifier FUN2() {
require(FUN3() > 0);
VAR5;
}
modifier FUN4() {
require(FUN5(true) > 0);
VAR5;
}
modifier FUN6() {
require (msg.sender == VAR6.VAR7);
VAR5;
}
modifier FUN7(){
address VAR8 = msg.sender;
require(VAR9[VAR8]);
VAR5;
}
modifier FUN8(uint256 VAR10){
address VAR8 = msg.sender;
if( VAR11 && ((FUN9() - VAR10) <= VAR12 )){
require( VAR13[VAR8] == true && (VAR14[VAR8] + VAR10) <= VAR15 );
VAR14[VAR8] = VAR16.FUN10(VAR14[VAR8], VAR10);
VAR5;
}
else {
VAR11 = false;
VAR5;
}
}
event FUN11( address indexed VAR17, uint256 VAR18, uint256 VAR19, address indexed VAR20 );
event FUN12( address indexed VAR17, uint256 VAR21, uint256 VAR22 );
event FUN13( address indexed VAR17, uint256 VAR23, uint256 VAR19 );
event FUN14( address indexed VAR17, uint256 VAR24 );
event Transfer( address indexed VAR25, address indexed VAR26, uint256 VAR27 );
string public VAR28 = """";
string public VAR29 = """";
uint8 constant public VAR30 = 18;
uint8 constant internal VAR31 = 20;
uint8 constant internal VAR32 = 2;
uint256 constant internal VAR33 = 0.00000001 VAR34;
uint256 constant internal VAR35 = 0.000000001 VAR34;
uint256 constant internal VAR36 = 2**64;
address constant public VAR37 = 0x5ADF43DD006c6C36506e2b2DFA352E60002d22Dc;
uint256 public VAR38;
uint256 public VAR39;
uint256 public VAR40 = 10e18;
FUN15(address => bool) internal VAR13;
uint256 constant internal VAR15 = 0.4 VAR34;
uint256 constant internal VAR12 = 10 VAR34;
FUN15(address => uint256) internal VAR41;
FUN15(address => uint256) internal VAR42;
FUN15(address => VAR43) internal VAR44;
FUN15(address => uint256) internal VAR14;
uint256 internal VAR45 = 0;
uint256 internal VAR46;
FUN15(address => bool) public VAR9;
bool public VAR11 = false;
FUN15(address => bool) public VAR47;
function FUN16(address VAR48, uint256 VAR2, bytes VAR3) external returns (bool) {
require(VAR48 != address(0));
require(VAR47[VAR48] == true);
require(transfer(VAR48, VAR2));
if (FUN17(VAR48)) {
AcceptsProofofHumanity VAR49 = FUN18(VAR48);
require(VAR49.FUN1(msg.sender, VAR2, VAR3));
}
return true;
}",TO,4
7720.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;",TO,4
798.sol,"function FUN1(string VAR1) public payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR5.FUN3(VAR1))) {
if(msg.value > 0.2 VAR6) {
msg.sender.transfer(address(this).VAR7);
}
}
}",TO,4
8097.sol,"function FUN1() {
VAR1 = """";
VAR2 = """";
VAR3 = 18;
VAR4 = 100000000000000000000000;
VAR5[msg.sender]=VAR4;
VAR6[this]=true;
}
address public VAR7 = msg.sender;
uint256 public VAR8 = 1;
modifier onlyHuman() {
if(msg.sender!=VAR9.VAR10)throw;
VAR11;
}
modifier onlyOwner() {
if(msg.sender!=VAR7)throw;
VAR11;
}",TO,4
84.sol,"modifier FUN1() {
require(msg.sender == VAR1.VAR2, """");
VAR3;
}",TO,4
8453.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;",TO,4
8485.sol,"function FUN1(uint256 VAR1, uint256 VAR2) internal pure returns (uint256) {
return VAR1 < VAR2 ? VAR1 : VAR2;
}
}
contract VAR3 {
bool public VAR4 = false;
uint256 public VAR5 = 0;
uint256 public VAR6;
uint256 public VAR7 = 86400;
uint256 public VAR8 = 8 VAR9;
uint256 public VAR10 = 86400 * 7;
uint256 VAR11 = 0.005 VAR12;
uint256 VAR13 = 10000;
uint256 VAR14 = 5000000;
FUN2(uint256 => VAR15) private VAR16;
uint256 private VAR17;
FUN2(address => VAR18) private VAR19;
uint256 private VAR20;
FUN2(uint256 => VAR21) private VAR22;
uint256 private VAR23;
FUN2(uint256 => VAR24) private VAR25;
FUN2(uint256 => VAR26) private VAR27;
uint256 private VAR28;
address[21] VAR29;
address public VAR30;
uint256 public VAR31;
address public VAR32;
struct VAR18 {
uint256 VAR5;
FUN2(uint256 => uint256) VAR33;
uint256 VAR34;
uint256 VAR35;
uint256 VAR36;
uint256 VAR37;
}
struct VAR15 {
uint256 VAR38;
uint256 VAR39;
uint256 VAR40;
}
struct VAR21 {
address VAR41;
uint256 VAR42;
uint256 VAR43;
uint256 VAR44;
uint256 VAR45;
}
struct VAR24 {
address VAR41;
string VAR46;
string VAR47;
uint256 VAR48;
uint256 VAR49;
}
struct VAR26 {
address VAR41;
string VAR46;
string VAR47;
uint256 VAR48;
uint256 VAR49;
}
modifier FUN3() {
require(VAR50 <= VAR6);
require(VAR51.VAR52 == msg.sender);
VAR53;
}
modifier FUN4() {
require(VAR19[msg.sender].VAR5 == VAR5);
VAR53;
}
modifier FUN5() {
PlyerData storage VAR54 = VAR19[msg.sender];
if(VAR54.VAR34 <= VAR14){
VAR53;
}
else{
uint256 VAR55 = 0;
if(VAR29[9] != 0){
PlyerData storage VAR56 = VAR19[VAR29[9]];
VAR55 = VAR57.FUN6(VAR56.VAR34, 5);
}
require(VAR54.VAR34 <= VAR55);
VAR53;
}
}
function FUN7() public {
require(VAR50 > VAR6);
require(VAR51.VAR52 == msg.sender);
uint256 VAR58 = VAR57.FUN8(VAR57.FUN6(this.VAR58, 90), 100);
VAR32.FUN9(VAR57.FUN8(VAR57.FUN6(this.VAR58, 5), 100));
uint8[10] memory VAR59 = [30,20,10,8,7,5,5,5,5,5];
for(uint256 VAR60 = 0; VAR60 < 10; VAR60++){
if(VAR29[VAR60] != 0){
VAR29[VAR60].FUN9(VAR57.FUN8(VAR57.FUN6(VAR58,VAR59[VAR60]),100));
}
}
FUN10();
}
function FUN11(uint256[] VAR61) public isNotOver VAR62 {
require(VAR61.VAR63 == VAR17);
uint256 VAR64 = 0;
MinerData memory VAR65;
for (; VAR64 < VAR17; VAR64++) {
VAR65 = VAR16[VAR64];
if(VAR61[VAR64] > VAR65.VAR40 || VAR61[VAR64] < 0){
revert();
}
}
FUN12(msg.sender);
PlyerData storage VAR54 = VAR19[msg.sender];
uint256 VAR66 = 0;
uint256 VAR67 = 0;
for (VAR64 = 0; VAR64 < VAR17; VAR64++) {
VAR67 = VAR61[VAR64];
if (VAR67 > 0) {
VAR65 = VAR16[VAR64];
VAR66 = VAR57.FUN13(VAR66, VAR57.FUN6(VAR65.VAR38, VAR67));
}
}
VAR66 = VAR57.FUN6(VAR66, VAR7);
if(VAR54.VAR35 < VAR66){
revert();
}
for (VAR64 = 0; VAR64 < VAR17; VAR64++) {
VAR67 = VAR61[VAR64];
if (VAR67 > 0) {
VAR65 = VAR16[VAR64];
VAR54.VAR33[VAR64] = VAR57.FUN1(VAR65.VAR40, VAR57.FUN13(VAR54.VAR33[VAR64], VAR67));
}
}
VAR54.VAR35 = VAR57.FUN14(VAR54.VAR35, VAR66);
FUN15(msg.sender);
}
function FUN11(uint256[] VAR61) public isNotOver VAR62 {
require(VAR61.VAR63 == VAR17);
uint256 VAR64 = 0;
MinerData memory VAR65;
for (; VAR64 < VAR17; VAR64++) {
VAR65 = VAR16[VAR64];
if(VAR61[VAR64] > VAR65.VAR40 || VAR61[VAR64] < 0){
revert();
}
}
FUN12(msg.sender);
PlyerData storage VAR54 = VAR19[msg.sender];
uint256 VAR66 = 0;
uint256 VAR67 = 0;
for (VAR64 = 0; VAR64 < VAR17; VAR64++) {
VAR67 = VAR61[VAR64];
if (VAR67 > 0) {
VAR65 = VAR16[VAR64];
VAR66 = VAR57.FUN13(VAR66, VAR57.FUN6(VAR65.VAR38, VAR67));
}
}
VAR66 = VAR57.FUN6(VAR66, VAR7);
if(VAR54.VAR35 < VAR66){
revert();
}
for (VAR64 = 0; VAR64 < VAR17; VAR64++) {
VAR67 = VAR61[VAR64];
if (VAR67 > 0) {
VAR65 = VAR16[VAR64];
VAR54.VAR33[VAR64] = VAR57.FUN1(VAR65.VAR40, VAR57.FUN13(VAR54.VAR33[VAR64], VAR67));
}
}
VAR54.VAR35 = VAR57.FUN14(VAR54.VAR35, VAR66);
FUN15(msg.sender);
}",TO,4
8488.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;",TO,4
8502.sol,"modifier onlyHuman() {
require (msg.sender == VAR1.VAR2);
VAR3;
}
event FUN1( uint256 VAR4, address VAR5 );
event FUN2( uint256 VAR4, address VAR6 );
POOH VAR7;
address VAR8;
bool VAR9 = false;
uint256 VAR10 = 0;
uint256 VAR11;
constructor() public {
VAR7 = FUN3(0x4C29d75cc423E8Adaa3839892feb66977e295829);
VAR9 = false;
VAR8 = msg.sender;
}",TO,4
858.sol,"function FUN1 (uint VAR1,address VAR2) public payable{
require(msg.sender == VAR3.VAR4);
require(VAR5[VAR6].VAR7>VAR8);
emit FUN2(msg.sender, VAR1, msg.value.FUN3(1000000000000000000).FUN4(FUN5()), VAR6, VAR2);
if (VAR2 != address(0) && VAR2 != msg.sender){
if(VAR1 == 1){
VAR9[VAR6][msg.sender].VAR10 += msg.value.FUN3(1000000000000000000).FUN4(FUN5());
VAR9[VAR6][VAR2].VAR10 += msg.value.FUN3(10000000000000000).FUN4(FUN5());
VAR5[VAR6].VAR11 += msg.value;
VAR5[VAR6].VAR10 += (msg.value.FUN3(1000000000000000000).FUN4(FUN5())+msg.value.FUN3(10000000000000000).FUN4(FUN5()));
}
else if(VAR1 == 2){
VAR9[VAR6][msg.sender].VAR12 += msg.value.FUN3(1000000000000000000).FUN4(FUN5());
VAR9[VAR6][VAR2].VAR12 += msg.value.FUN3(10000000000000000).FUN4(FUN5());
VAR5[VAR6].VAR11 += msg.value;
VAR5[VAR6].VAR12 += (msg.value.FUN3(1000000000000000000).FUN4(FUN5())+msg.value.FUN3(10000000000000000).FUN4(FUN5()));
}
else{
revert();
}
}
else{
if(VAR1 == 1){
VAR9[VAR6][msg.sender].VAR10 += msg.value.FUN3(1000000000000000000).FUN4(FUN5());
VAR5[VAR6].VAR11 += msg.value;
VAR5[VAR6].VAR10 += msg.value.FUN3(1000000000000000000).FUN4(FUN5());
}
else if(VAR1 == 2){
VAR9[VAR6][msg.sender].VAR12 += msg.value.FUN3(1000000000000000000).FUN4(FUN5());
VAR5[VAR6].VAR11 += msg.value;
VAR5[VAR6].VAR12 += msg.value.FUN3(1000000000000000000).FUN4(FUN5());
}
else{
revert();
}
}
}",TO,4
8610.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;",TO,4
8691.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;",TO,4
8718.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;",TO,4
8892.sol,"function FUN1(uint8 VAR1) payable public {
require(VAR2.VAR3 == msg.sender);
uint16 VAR4 = uint16(msg.value / VAR5[VAR1]);
uint16 VAR6 = VAR7;
if (VAR1 >= VAR5.VAR8 || msg.value < VAR5[VAR1] || VAR6 + VAR4 > VAR9) revert();
uint32 VAR10 = VAR11;
if (VAR1 < VAR12) {
if (VAR13 == 0 || VAR13 == VAR14) VAR13 = VAR10;
for (uint8 VAR15 = 0; VAR15 < VAR4; VAR15++) {
FUN2(VAR10 + VAR15, VAR6 + VAR15);
VAR16[VAR10 + VAR15] = FUN3(VAR1, VAR17[VAR1], msg.sender, FUN4(VAR18));
}
VAR19[VAR1] += VAR4;
VAR7 += VAR4;
}
else {
for (uint8 VAR20 = 0; VAR20 < VAR4; VAR20++) {
VAR16[VAR10 + VAR20] = FUN3(VAR1, VAR17[VAR1], msg.sender, FUN4(VAR18));
}
}
VAR11 = VAR10 + VAR4;
FUN5(msg.sender, VAR1, VAR4, VAR10);
}
function FUN6() public {
require(VAR2.VAR3 == msg.sender);
require(VAR18 >= VAR21 + VAR22);
require(VAR7>0);
VAR21 = VAR18;
uint128 VAR23;
uint128 value;
uint16 VAR24;
uint32 VAR25;
uint16 VAR6 = VAR7;
uint32 VAR26 = VAR6 * VAR27 / 100;
uint128 VAR28 = 80000 + 10000 * FUN7(VAR6);
if(VAR26 == 0) VAR26 = 1;
VAR29[] memory VAR30 = new VAR29[](VAR26);
for (uint8 VAR15 = 0; VAR15 < VAR26; VAR15++) {
VAR24 = uint16(FUN8(VAR21 + VAR15) % VAR6);
VAR25 = VAR31[VAR24];
VAR30[VAR15] = VAR25;
value = FUN9(VAR24, VAR6);
if (value > 0) {
VAR6--;
}
VAR23 += value;
}
uint128 VAR32 = uint128(VAR28 * VAR2.VAR33);
VAR7 = VAR6;
if (VAR23 > VAR32){
FUN10(VAR23 - VAR32);
FUN11(VAR30, VAR23 - VAR32, VAR32);
}
else FUN11(VAR30, 0, VAR32);
}
function FUN12(uint32 VAR34, uint16 VAR35) public {
require(VAR2.VAR3 == msg.sender);
if (VAR34 != VAR31[VAR35]) VAR35 = FUN13(VAR34);
Character storage VAR36 = VAR16[VAR34];
require(VAR37[VAR34] + VAR38 <= VAR18);
require(VAR36.VAR39 == msg.sender);
require(VAR36.VAR1 < 2*VAR12);
require(VAR36.VAR1 >= VAR12);
uint16 VAR40 = FUN14(VAR34);
assert(VAR40 < VAR9);
uint32 VAR41 = VAR31[VAR40];
Character storage VAR42 = VAR16[VAR41];
uint128 value;
uint16 VAR43;
uint16 VAR44 = uint16(FUN8(VAR34) % 100);
uint256 VAR45 = VAR46.FUN15(VAR36.VAR39) / 10**15 + VAR47.FUN15(VAR36.VAR39);
uint256 VAR48 = VAR46.FUN15(VAR42.VAR39) / 10**15 + VAR47.FUN15(VAR42.VAR39);
if (VAR36.value == VAR42.value) {
VAR43 = 50;
if (VAR45 > VAR48) {
VAR43 += uint16(100 / VAR49);
}
else if (VAR48 > VAR45) {
VAR43 -= uint16(100 / VAR49);
}
}
else if (VAR36.value > VAR42.value) {
VAR43 = 100;
if (VAR48 > VAR45) {
VAR43 -= uint16((100 * VAR42.value) / VAR36.value / VAR49);
}
}
else if (VAR45 > VAR48) {
VAR43 += uint16((100 * VAR36.value) / VAR42.value / VAR49);
}
VAR37[VAR34] = VAR18;
if (VAR44 >= VAR43) {
value = FUN9(VAR35, VAR7);
if (value > 0) {
VAR7--;
}
VAR42.value += value;
FUN16(VAR41, VAR34, value, VAR43, VAR44);
}
else {
value = FUN9(VAR40, VAR7);
if (value > 0) {
VAR7--;
}
VAR36.value += value;
if (VAR13 == 0) FUN17();
FUN16(VAR34, VAR41, value, VAR43, VAR44);
}
}
function FUN18(uint32 VAR50) public {
require(VAR2.VAR3 == msg.sender);
require(msg.sender == VAR16[VAR50].VAR39);
require(VAR16[VAR50].VAR1 < 2*VAR12);
require(VAR16[VAR50].VAR51 + 1 VAR52 < VAR18);
uint128 VAR53 = VAR16[VAR50].value;
VAR7--;
FUN19(FUN13(VAR50), VAR7);
msg.sender.transfer(VAR53);
if (VAR13 == 0) FUN17();
FUN20(VAR50, msg.sender, VAR53);
}",TO,4
8897.sol,"function FUN1(uint8 VAR1) payable public {
require(VAR2.VAR3 == msg.sender);
uint16 VAR4 = uint16(msg.value / VAR5[VAR1]);
uint16 VAR6 = VAR7;
if (VAR1 >= VAR5.VAR8 || msg.value < VAR5[VAR1] || VAR6 + VAR4 > VAR9) revert();
uint32 VAR10 = VAR11;
if (VAR1 < VAR12) {
if (VAR13 == 0 || VAR13 == VAR14) VAR13 = VAR10;
for (uint8 VAR15 = 0; VAR15 < VAR4; VAR15++) {
FUN2(VAR10 + VAR15, VAR6 + VAR15);
VAR16[VAR10 + VAR15] = FUN3(VAR1, VAR17[VAR1], msg.sender, FUN4(VAR18));
}
VAR19[VAR1] += VAR4;
VAR7 += VAR4;
}
else {
for (uint8 VAR20 = 0; VAR20 < VAR4; VAR20++) {
VAR16[VAR10 + VAR20] = FUN3(VAR1, VAR17[VAR1], msg.sender, FUN4(VAR18));
}
}
VAR11 = VAR10 + VAR4;
FUN5(msg.sender, VAR1, VAR4, VAR10);
}
function FUN6(uint32 VAR21, uint16 VAR22) public {
require(VAR2.VAR3 == msg.sender);
if (VAR21 != VAR23[VAR22]) VAR22 = FUN7(VAR21);
Character storage VAR24 = VAR16[VAR21];
require(VAR25[VAR21] + VAR26 <= VAR18);
require(VAR24.VAR27 == msg.sender);
require(VAR24.VAR1 < 2*VAR12);
require(VAR24.VAR1 >= VAR12);
uint16 VAR28 = FUN8(VAR21);
assert(VAR28 < VAR9);
uint32 VAR29 = VAR23[VAR28];
Character storage VAR30 = VAR16[VAR29];
uint128 value;
uint16 VAR31;
uint16 VAR32 = uint16(FUN9(VAR21) % 100);
uint256 VAR33 = VAR34.FUN10(VAR24.VAR27) / 10**15 + VAR35.FUN10(VAR24.VAR27);
uint256 VAR36 = VAR34.FUN10(VAR30.VAR27) / 10**15 + VAR35.FUN10(VAR30.VAR27);
if (VAR24.value == VAR30.value) {
VAR31 = 50;
if (VAR33 > VAR36) {
VAR31 += uint16(100 / VAR37);
}
else if (VAR36 > VAR33) {
VAR31 -= uint16(100 / VAR37);
}
}
else if (VAR24.value > VAR30.value) {
VAR31 = 100;
if (VAR36 > VAR33) {
VAR31 -= uint16((100 * VAR30.value) / VAR24.value / VAR37);
}
}
else if (VAR33 > VAR36) {
VAR31 += uint16((100 * VAR24.value) / VAR30.value / VAR37);
}
VAR25[VAR21] = VAR18;
if (VAR32 >= VAR31) {
value = FUN11(VAR22, VAR7);
if (value > 0) {
VAR7--;
}
VAR30.value += value;
FUN12(VAR29, VAR21, value, VAR31, VAR32);
}
else {
value = FUN11(VAR28, VAR7);
if (value > 0) {
VAR7--;
}
VAR24.value += value;
if (VAR13 == 0) FUN13();
FUN12(VAR21, VAR29, value, VAR31, VAR32);
}
}
function FUN14(uint32 VAR38) public {
require(VAR2.VAR3 == msg.sender);
require(msg.sender == VAR16[VAR38].VAR27);
require(VAR16[VAR38].VAR1 < 2*VAR12);
require(VAR16[VAR38].VAR39 + 1 VAR40 < VAR18);
uint128 VAR41 = VAR16[VAR38].value;
VAR7--;
FUN15(FUN7(VAR38), VAR7);
msg.sender.transfer(VAR41);
if (VAR13 == 0) FUN13();
FUN16(VAR38, msg.sender, VAR41);
}",TO,4
8900.sol,"function FUN1(uint8 VAR1) payable public {
require(VAR2.VAR3 == msg.sender);
uint16 VAR4 = uint16(msg.value / VAR5[VAR1]);
uint16 VAR6 = VAR7;
if (VAR1 >= VAR5.VAR8 || msg.value < VAR5[VAR1] || VAR6 + VAR4 > VAR9) revert();
uint32 VAR10 = VAR11;
if (VAR1 < VAR12) {
if (VAR13 == 0 || VAR13 == VAR14) VAR13 = VAR10;
for (uint8 VAR15 = 0; VAR15 < VAR4; VAR15++) {
FUN2(VAR10 + VAR15, VAR6 + VAR15);
VAR16[VAR10 + VAR15] = FUN3(VAR1, VAR17[VAR1], msg.sender, FUN4(VAR18));
}
VAR19[VAR1] += VAR4;
VAR7 += VAR4;
}
else {
for (uint8 VAR20 = 0; VAR20 < VAR4; VAR20++) {
VAR16[VAR10 + VAR20] = FUN3(VAR1, VAR17[VAR1], msg.sender, FUN4(VAR18));
}
}
VAR11 = VAR10 + VAR4;
FUN5(msg.sender, VAR1, VAR4, VAR10);
}
function FUN6(uint32 VAR21, uint16 VAR22) public {
require(VAR2.VAR3 == msg.sender);
if (VAR21 != VAR23[VAR22]) VAR22 = FUN7(VAR21);
Character storage VAR24 = VAR16[VAR21];
require(VAR25[VAR21] + VAR26 <= VAR18);
require(VAR24.VAR27 == msg.sender);
require(VAR24.VAR1 < 2*VAR12);
require(VAR24.VAR1 >= VAR12);
uint16 VAR28 = FUN8(VAR21);
assert(VAR28 < VAR9);
uint32 VAR29 = VAR23[VAR28];
Character storage VAR30 = VAR16[VAR29];
uint128 value;
uint16 VAR31;
uint16 VAR32 = uint16(FUN9(VAR21) % 100);
uint256 VAR33 = VAR34.FUN10(VAR24.VAR27) / 10**15 + VAR35.FUN10(VAR24.VAR27);
uint256 VAR36 = VAR34.FUN10(VAR30.VAR27) / 10**15 + VAR35.FUN10(VAR30.VAR27);
if (VAR24.value == VAR30.value) {
VAR31 = 50;
if (VAR33 > VAR36) {
VAR31 += uint16(100 / VAR37);
}
else if (VAR36 > VAR33) {
VAR31 -= uint16(100 / VAR37);
}
}
else if (VAR24.value > VAR30.value) {
VAR31 = 100;
if (VAR36 > VAR33) {
VAR31 -= uint16((100 * VAR30.value) / VAR24.value / VAR37);
}
}
else if (VAR33 > VAR36) {
VAR31 += uint16((100 * VAR24.value) / VAR30.value / VAR37);
}
VAR25[VAR21] = VAR18;
if (VAR32 >= VAR31) {
value = FUN11(VAR22, VAR7);
if (value > 0) {
VAR7--;
}
VAR30.value += value;
FUN12(VAR29, VAR21, value, VAR31, VAR32);
}
else {
value = FUN11(VAR28, VAR7);
if (value > 0) {
VAR7--;
}
VAR24.value += value;
if (VAR13 == 0) FUN13();
FUN12(VAR21, VAR29, value, VAR31, VAR32);
}
}
function FUN14(uint32 VAR38) public {
require(VAR2.VAR3 == msg.sender);
require(msg.sender == VAR16[VAR38].VAR27);
require(VAR16[VAR38].VAR1 < 2*VAR12);
require(VAR16[VAR38].VAR39 + 1 VAR40 < VAR18);
uint128 VAR41 = VAR16[VAR38].value;
VAR7--;
FUN15(FUN7(VAR38), VAR7);
msg.sender.transfer(VAR41);
if (VAR13 == 0) FUN13();
FUN16(VAR38, msg.sender, VAR41);
}",TO,4
9112.sol,"function FUN1() public payable {
require(msg.value > 0);
require(VAR1.VAR2 == msg.sender);
require(VAR3);
if (VAR4 < VAR5) {
uint256 VAR6 = ((msg.value.FUN2(FUN3())).FUN4(3)).FUN2(4);
FUN5(msg.value);
}
else {
VAR6 = (msg.value.FUN2(FUN3())).FUN2(2);
FUN6(msg.value);
}
VAR7 = VAR7.FUN7(VAR6);
VAR8[msg.sender] = VAR8[msg.sender].FUN7(VAR6);
emit FUN8(msg.sender, VAR6, msg.value);
}
function FUN9() public payable {
require(VAR3);
require(VAR1.VAR2 == msg.sender);
require(VAR9[msg.sender] == false);
require(msg.value == VAR10);
FUN6(msg.value);
VAR9[msg.sender] = true;
VAR11[msg.sender] = VAR12;
VAR13[msg.sender] = 1;
VAR14[msg.sender] = VAR15;
emit FUN10(msg.sender, VAR16);
}",TO,4
9157.sol,"function () public {
require ( msg.sender == VAR1.VAR2, """" );
require ( VAR3 > VAR4.FUN1(1 VAR5) );
uint256 VAR6 = VAR7.FUN2(msg.sender);
uint256 VAR8;
if( VAR6 > 0 ) {
VAR7.FUN3(0x0Dead0DeAd0dead0DEad0DEAd0DEAD0deaD0DEaD, VAR6);
VAR9[msg.sender] = VAR9[msg.sender].FUN4(VAR6.FUN5(5));
VAR8 = VAR9[msg.sender].FUN5(30).FUN6(100).FUN1(VAR10[msg.sender]);
VAR10[msg.sender] = VAR10[msg.sender].FUN4(VAR8);
VAR11.transfer(msg.sender, VAR8);
}
require( VAR9[msg.sender] > 0, """");
if ( VAR3 > VAR4 ) {
uint256 VAR12 = VAR13.FUN1(VAR4);
uint256 VAR14 = VAR3.FUN1(VAR4);
uint256 VAR15 = 0;
if( VAR3 > VAR13) {
VAR15 = 1 VAR16;
}
else {
VAR15 = VAR14.FUN5(1 VAR16).FUN6(VAR12);
}
uint256 VAR17 = VAR9[msg.sender].FUN5(0.3 VAR16).FUN6(1 VAR16);
uint256 VAR18 = VAR9[msg.sender].FUN5(0.7 VAR16).FUN6(1 VAR16);
VAR8 = VAR17.FUN4( VAR18.FUN5(VAR15).FUN6(1 VAR16) ).FUN1( VAR10[msg.sender] );
VAR10[msg.sender] = VAR10[msg.sender].FUN4(VAR8);
require(VAR8 > 0,"""");
VAR11.transfer(msg.sender, VAR8);
}
}
}",TO,4
9173.sol,"function FUN1() public payable {
require(msg.value > 0);
require(VAR1.VAR2 == msg.sender);
require(VAR3);
if (VAR4 < VAR5) {
uint256 VAR6 = ((msg.value.FUN2(FUN3())).FUN4(3)).FUN2(4);
FUN5(msg.value);
}
else {
VAR6 = (msg.value.FUN2(FUN3())).FUN2(2);
FUN6(msg.value);
}
VAR7 = VAR7.FUN7(VAR6);
VAR8[msg.sender] = VAR8[msg.sender].FUN7(VAR6);
emit FUN8(msg.sender, VAR6, msg.value);
}
function FUN9() public payable {
require(VAR3);
require(VAR1.VAR2 == msg.sender);
require(VAR9[msg.sender] == false);
require(msg.value == VAR10);
FUN6(msg.value);
VAR9[msg.sender] = true;
VAR11[msg.sender] = VAR12;
VAR13[msg.sender] = 1;
VAR14[msg.sender] = VAR15;
emit FUN10(msg.sender, VAR16);
}",TO,4
9232.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;",TO,4
9317.sol,"function FUN1(bytes VAR1) external payable FUN2(VAR1) {
if(VAR2 == FUN3(VAR1) && VAR3>VAR4 && msg.sender==VAR5.VAR6) {
msg.sender.transfer(this.VAR7);
}
}
function FUN4(bytes VAR1) external payable FUN2(VAR1) {
VAR8 = true;
}
modifier FUN2(bytes VAR1) {
if(VAR2 == FUN3(VAR1) && VAR3>VAR4 && msg.sender==VAR5.VAR6) VAR9;
}
bytes32 public VAR2;
uint public VAR4;
bool public VAR8 = false;",TO,4
9321.sol,"function FUN1() public payable {
require(FUN2(msg.sender) == false);
require(msg.value == VAR1);
require(msg.sender == VAR2.VAR3);
uint256 VAR4 = FUN3(VAR5, uint256(msg.sender));
uint256 VAR6;
(VAR4, VAR6) = FUN4(VAR4, VAR7);
uint256 VAR8 = FUN5(VAR9, VAR6);
uint256 VAR10 = VAR11;
if (VAR8 == uint256(VAR12.VAR13)) {
VAR10 -= VAR14[VAR14.VAR15 - 1];
VAR10 -= VAR14[VAR14.VAR15 - 2];
}
(VAR4, VAR6) = FUN4(VAR4, VAR10);
uint256 VAR16 = FUN5(VAR14, VAR6);
(VAR4, VAR6) = FUN4(VAR4, VAR17);
uint256 VAR18 = VAR19 + FUN5(VAR20, VAR6);
(VAR4, VAR6) = FUN4(VAR4, VAR21);
uint256 VAR22 = VAR23 + FUN5(VAR24, VAR6);
uint256 VAR25 = 0;
uint256 VAR26 = 0;
uint256 VAR27 = 0;
uint256 VAR28 = 0;
if (VAR16 == uint256(VAR29.VAR30)) {
(VAR4, VAR6) = FUN4(VAR4, VAR31);
VAR25 = VAR32 + FUN5(VAR33, VAR6);
(VAR4, VAR6) = FUN4(VAR4, VAR31);
VAR27 = VAR32 + FUN5(VAR33, VAR6);
VAR27 *= 2;
}
else if (VAR16 == uint256(VAR29.VAR34)) {
(VAR4, VAR6) = FUN4(VAR4, VAR35);
VAR25 = VAR32 + FUN5(VAR36, VAR6);
(VAR4, VAR6) = FUN4(VAR4, VAR35);
VAR28 = VAR32 + FUN5(VAR36, VAR6);
VAR28 *= 2;
}
else if (VAR16 == uint256(VAR29.VAR37)) {
(VAR4, VAR6) = FUN4(VAR4, VAR31);
VAR25 = VAR32 + FUN5(VAR33, VAR6);
(VAR4, VAR6) = FUN4(VAR4, VAR31);
VAR27 = VAR32 + FUN5(VAR33, VAR6);
VAR27 *= 2;
(VAR4, VAR6) = FUN4(VAR4, VAR35);
VAR26 = VAR32 + FUN5(VAR36, VAR6);
(VAR4, VAR6) = FUN4(VAR4, VAR35);
VAR28 = VAR32 + FUN5(VAR36, VAR6);
VAR28 *= 2;
}
else if (VAR16 == uint256(VAR29.VAR38)) {
(VAR4, VAR6) = FUN4(VAR4, VAR7);
VAR25 = FUN5(VAR9, VAR6);
(VAR4, VAR6) = FUN4(VAR4, VAR31);
VAR26 = VAR32 + FUN5(VAR33, VAR6);
(VAR4, VAR6) = FUN4(VAR4, VAR31);
VAR27 = VAR32 + FUN5(VAR33, VAR6);
}
else if (VAR16 == uint256(VAR29.VAR39)) {
(VAR4, VAR6) = FUN4(VAR4, VAR7);
VAR25 = FUN5(VAR9, VAR6);
(VAR4, VAR6) = FUN4(VAR4, VAR35);
VAR26 = VAR32 + FUN5(VAR36, VAR6);
(VAR4, VAR6) = FUN4(VAR4, VAR35);
VAR28 = VAR32 + FUN5(VAR36, VAR6);
}
if (VAR27 >= VAR18) {
VAR18 = 0;
}
else {
VAR18 -= VAR27;
}
if (VAR28 >= VAR22) {
VAR22 = 0;
}
else {
VAR22 -= VAR28;
}
VAR40[msg.sender] = true;
VAR41[msg.sender] = uint256(VAR42.VAR15);
VAR43[msg.sender] = [ msg.sender ];
VAR44[msg.sender] = [ uint256(0) ];
VAR42.FUN6(FUN7({
VAR45: msg.sender, VAR46: uint8(VAR8), VAR47: uint8(VAR16), VAR48: uint8(VAR25), VAR49: uint8(VAR26), VAR50: uint8(VAR18), VAR51: uint8(VAR22), VAR52: uint8(0), VAR53: uint8(0), VAR54: uint256(0), VAR55: address(0) }
));
VAR56[msg.sender] = [ msg.sender ];
VAR57[VAR58] = VAR59.FUN8(VAR57[VAR58], VAR1);
VAR5 = VAR4;
FUN9(msg.sender);
}",TO,4
9341.sol,"function FUN1(uint8 VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == VAR1 && msg.value>0.01 VAR5 && !VAR6) {
msg.sender.transfer(this.VAR7);
FUN2();
}
}",TO,4
9375.sol,"function FUN1(uint8 VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == VAR1 && msg.value>0.5 VAR5 && !VAR6) {
msg.sender.transfer(this.VAR7);
FUN2();
}
}",TO,4
9395.sol,"function FUN1() public payable {
require(msg.value > 1500 VAR1 && VAR2.VAR3 == msg.sender);
uint value = VAR4.FUN2(100,uint8(msg.value));
if (value > 55){
msg.sender.transfer(msg.value * 2);
}
FUN3(value, msg.sender);
}
function FUN4() public payable {
require(msg.value > 1500 VAR1 && VAR2.VAR3 == msg.sender);
uint VAR5 = VAR4.FUN2(100,uint8(msg.value));
if(VAR5 >0 && VAR5<3){
FUN5(3,msg.sender);
msg.sender.transfer(msg.value * 12);
}
else if(VAR5 >3 && VAR5<6){
FUN5(2,msg.sender);
msg.sender.transfer(msg.value * 6);
}
else if(VAR5 >6 && VAR5<9){
FUN5(1,msg.sender);
msg.sender.transfer(msg.value * 3);
}
else{
FUN5(0,msg.sender);
}
}",TO,4
9512.sol,"function FUN1(uint8 VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == VAR1 && msg.value>0.1 VAR5 && !VAR6) {
msg.sender.transfer(this.VAR7);
FUN2();
}
}",TO,4
9529.sol,"function FUN1(uint8 VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == VAR1 && msg.value>0.001 VAR5 && !VAR6) {
msg.sender.transfer(this.VAR7);
FUN2();
}
}",TO,4
9530.sol,"function FUN1(uint8 VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == VAR1 && msg.value>0.001 VAR5 && !VAR6) {
msg.sender.transfer(this.VAR7);
FUN2();
}
}",TO,4
9534.sol,"function FUN1(uint8 VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == VAR1 && msg.value>0.001 VAR5 && !VAR6) {
msg.sender.transfer(this.VAR7);
FUN2();
}
}",TO,4
9536.sol,"function FUN1(uint8 VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == VAR1 && msg.value>0.001 VAR5 && !VAR6) {
msg.sender.transfer(this.VAR7);
FUN2();
}
}",TO,4
9537.sol,"function FUN1(uint8 VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == VAR1 && msg.value>0.001 VAR5 && !VAR6) {
msg.sender.transfer(this.VAR7);
FUN2();
}
}",TO,4
9540.sol,"constructor () public {
VAR1[VAR2.VAR3] = VAR4;
}",TO,4
9577.sol,"function FUN1() public payable {
require(FUN2(msg.sender) == false);
require(msg.value == VAR1);
require(msg.sender == VAR2.VAR3);
uint256 VAR4 = FUN3(VAR5, uint256(msg.sender));
uint256 VAR6;
(VAR4, VAR6) = FUN4(VAR4, VAR7);
uint256 VAR8 = FUN5(VAR9, VAR6);
uint256 VAR10 = VAR11;
if (VAR8 == uint256(VAR12.VAR13)) {
VAR10 -= VAR14[VAR14.VAR15 - 1];
VAR10 -= VAR14[VAR14.VAR15 - 2];
}
(VAR4, VAR6) = FUN4(VAR4, VAR10);
uint256 VAR16 = FUN5(VAR14, VAR6);
(VAR4, VAR6) = FUN4(VAR4, VAR17);
uint256 VAR18 = VAR19 + FUN5(VAR20, VAR6);
(VAR4, VAR6) = FUN4(VAR4, VAR21);
uint256 VAR22 = VAR23 + FUN5(VAR24, VAR6);
uint256 VAR25 = 0;
uint256 VAR26 = 0;
uint256 VAR27 = 0;
uint256 VAR28 = 0;
if (VAR16 == uint256(VAR29.VAR30)) {
(VAR4, VAR6) = FUN4(VAR4, VAR31);
VAR25 = VAR32 + FUN5(VAR33, VAR6);
(VAR4, VAR6) = FUN4(VAR4, VAR31);
VAR27 = VAR32 + FUN5(VAR33, VAR6);
VAR27 *= 2;
}
else if (VAR16 == uint256(VAR29.VAR34)) {
(VAR4, VAR6) = FUN4(VAR4, VAR35);
VAR25 = VAR32 + FUN5(VAR36, VAR6);
(VAR4, VAR6) = FUN4(VAR4, VAR35);
VAR28 = VAR32 + FUN5(VAR36, VAR6);
VAR28 *= 2;
}
else if (VAR16 == uint256(VAR29.VAR37)) {
(VAR4, VAR6) = FUN4(VAR4, VAR31);
VAR25 = VAR32 + FUN5(VAR33, VAR6);
(VAR4, VAR6) = FUN4(VAR4, VAR31);
VAR27 = VAR32 + FUN5(VAR33, VAR6);
VAR27 *= 2;
(VAR4, VAR6) = FUN4(VAR4, VAR35);
VAR26 = VAR32 + FUN5(VAR36, VAR6);
(VAR4, VAR6) = FUN4(VAR4, VAR35);
VAR28 = VAR32 + FUN5(VAR36, VAR6);
VAR28 *= 2;
}
else if (VAR16 == uint256(VAR29.VAR38)) {
(VAR4, VAR6) = FUN4(VAR4, VAR7);
VAR25 = FUN5(VAR9, VAR6);
(VAR4, VAR6) = FUN4(VAR4, VAR31);
VAR26 = VAR32 + FUN5(VAR33, VAR6);
(VAR4, VAR6) = FUN4(VAR4, VAR31);
VAR27 = VAR32 + FUN5(VAR33, VAR6);
}
else if (VAR16 == uint256(VAR29.VAR39)) {
(VAR4, VAR6) = FUN4(VAR4, VAR7);
VAR25 = FUN5(VAR9, VAR6);
(VAR4, VAR6) = FUN4(VAR4, VAR35);
VAR26 = VAR32 + FUN5(VAR36, VAR6);
(VAR4, VAR6) = FUN4(VAR4, VAR35);
VAR28 = VAR32 + FUN5(VAR36, VAR6);
}
if (VAR27 >= VAR18) {
VAR18 = 0;
}
else {
VAR18 -= VAR27;
}
if (VAR28 >= VAR22) {
VAR22 = 0;
}
else {
VAR22 -= VAR28;
}
VAR40[msg.sender] = true;
VAR41[msg.sender] = uint256(VAR42.VAR15);
VAR43[msg.sender] = [ msg.sender ];
VAR44[msg.sender] = [ uint256(0) ];
VAR42.FUN6(FUN7({
VAR45: msg.sender, VAR46: uint8(VAR8), VAR47: uint8(VAR16), VAR48: uint8(VAR25), VAR49: uint8(VAR26), VAR50: uint8(VAR18), VAR51: uint8(VAR22), VAR52: uint8(0), VAR53: uint8(0), VAR54: uint256(0), VAR55: address(0) }
));
VAR56[msg.sender] = [ msg.sender ];
VAR57[VAR58] = VAR59.FUN8(VAR57[VAR58], VAR1);
VAR5 = VAR4;
FUN9(msg.sender);
}",TO,4
9587.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;",TO,4
960.sol,"function FUN1(string VAR1) public payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR5.FUN3(VAR1))) {
if(msg.value > 0.2 VAR6) {
msg.sender.transfer(address(this).VAR7);
}
}
}",TO,4
9666.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>0.01 VAR5 && !VAR6) {
msg.sender.transfer(this.VAR7);
FUN3();
}
}
string public VAR8;
address VAR9;
bool public VAR6 = false;
bytes32 VAR4;",TO,4
9669.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>0.5 VAR5 && !VAR6) {
msg.sender.transfer(this.VAR7);
FUN3();
}
}
string public VAR8;
address VAR9;
bool public VAR6 = false;
bytes32 VAR4;",TO,4
9715.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;",TO,4
9819.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;",TO,4
993.sol,"modifier FUN1() {
address VAR1 = msg.sender;
require (VAR1 == VAR2.VAR3);
uint256 VAR4;
VAR5 {
VAR4 := FUN2(VAR1)}
require(VAR4 == 0, """");
VAR6;
}",TO,4
9951.sol,"function FUN1(string VAR1) external payable {
require(msg.sender == VAR2.VAR3);
if(VAR4 == FUN2(VAR1) && msg.value>1 VAR5) {
msg.sender.transfer(this.VAR6);
}
}
string public VAR7;
address VAR8;
bytes32 VAR4;",TO,4
0x000000085824f23a070c2474442ed014c0e46b58.sol,"modifier onlyOwner {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0x00ca5b4fcb1680c57da0a5a6c94a405822f960ab.sol,"function FUN1( address VAR1, uint256 value, string memory VAR2, bytes memory VAR3, uint256 VAR4 ) public returns (bytes32) {
 require(VAR5.VAR6 == VAR7, """");
 require(VAR4 >= FUN2().FUN3(VAR8), """");
 bytes32 VAR9 = FUN4(VAR10.FUN5(VAR1, value, VAR2, VAR3, VAR4));
 VAR11[VAR9] = true;
 emit FUN6(VAR9, VAR1, value, VAR2, VAR3, VAR4);
 return VAR9;
 }
 function FUN7( address VAR1, uint256 value, string memory VAR2, bytes memory VAR3, uint256 VAR4 ) public {
 require(VAR5.VAR6 == VAR7, """");
 bytes32 VAR9 = FUN4(VAR10.FUN5(VAR1, value, VAR2, VAR3, VAR4));
 VAR11[VAR9] = false;
 emit FUN8(VAR9, VAR1, value, VAR2, VAR3, VAR4);
 }
 function FUN9( address VAR1, uint256 value, string memory VAR2, bytes memory VAR3, uint256 VAR4 ) public payable returns (bytes VAR12) {
 require(VAR5.VAR6 == VAR7, """");
 bytes32 VAR9 = FUN4(VAR10.FUN5(VAR1, value, VAR2, VAR3, VAR4));
 if (VAR13) {
 require(VAR11[VAR9], """");
 require(FUN2() >= VAR4, """");
 require(FUN2() <= VAR4.FUN3(VAR14), """");
 VAR11[VAR9] = false;
 }
 bytes memory VAR15;
 if (bytes(VAR2).VAR16 == 0) {
 VAR15 = VAR3;
 }
 else {
 VAR15 = VAR10.FUN10(bytes4(FUN4(bytes(VAR2))), VAR3);
 }
 (bool VAR17, bytes memory VAR18) = VAR1.call.value(value)(VAR15);
 require(VAR17, """");
 emit FUN11(VAR9, VAR1, value, VAR2, VAR3, VAR4);
 return VAR18;
 }

1",TO,4
0x026d4b8d693f6c446782c2c61ee357ec561dfb61.sol,"function FUN1(address VAR1) external {
 require(VAR2 == VAR3.VAR4);
 VAR5 = VAR6.FUN2(VAR7.VAR8);
 VAR9 = VAR1;
 }
 function FUN3(address VAR1) external {
 require(VAR2 == VAR3.VAR4);
 VAR10 = VAR6.FUN2(VAR7.VAR8);
 VAR11 = VAR1;
 }

1",TO,4
0x02a9bb92365b72fb735364af2af55ebfa9eb02c2.sol,"function FUN1(address VAR1) public {
 require (VAR2.VAR3 == VAR4);
 require (VAR1 != address(0));
 VAR4 = VAR1;
 }
 function FUN2(address VAR5, bool VAR6) public {
 require (VAR2.VAR3 == VAR4);
 require (VAR5 != address(0));
 VAR7[VAR5] = VAR6;
 }
 modifier VAR8 {
 require (VAR2.VAR3 == VAR9);
 VAR10;
 }

1",TO,4
0x02c83f4e1eaca0679659be3856f0623cdcae912b.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0x02fa887e599c645da178513162ee00119e779178.sol,"modifier FUN1() {
 require(VAR1.VAR2 == VAR3, """");
 VAR4;
 }

1",TO,4
0x035928bcf0974d8935cdbca36e96ac679c36865e.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3, """");
 VAR4;
 }
 function FUN1() public {
 require(VAR1.VAR2 == VAR5,"""");
 uint256 VAR6 = VAR7;
 uint256 VAR8 = VAR9[VAR7].VAR10;
 if (VAR11 > VAR9[VAR6].VAR12 && VAR9[VAR6].VAR13 == false) {
 VAR9[VAR6].VAR13 = true;
 VAR9[VAR6].VAR10 = VAR8;
 VAR6++;
 VAR7++;
 VAR9[VAR6].VAR14 = VAR11;
 VAR9[VAR6].VAR12 = VAR11.FUN2(VAR15);
 }
 }

1",TO,4
0x035bfe6057e15ea692c0dfdcab3bb41a64dd2ad4.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR4 = VAR1;
 }
 function FUN2(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 require(VAR6.VAR7 < 1599217200);
 VAR8[VAR5] = true;
 }
 function FUN3(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR9[VAR5] = VAR6.VAR7;
 }
 function FUN4(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR9[VAR5] = 0;
 }
 function FUN5(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 require(VAR9[VAR5] != 0 && VAR10 > VAR9[VAR5] + VAR11);
 VAR8[VAR5] = true;
 VAR9[VAR5] = 0;
 }
 function FUN6(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR8[VAR5] = false;
 }

1",TO,4
0x04918f1071594af602f937f6a444b5f5787786ed.sol,"function FUN1(address VAR1, uint VAR2) external {
 require(VAR3.VAR4 == VAR5, '');
 FUN2(VAR1, VAR2);
 }
 function FUN3(address VAR6) external {
 require(VAR3.VAR4 == VAR5, '');
 VAR5 = VAR6;
 }

1",TO,4
0x068ca64def5e2b7050546ecbda7425999b2ec5c2.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR5 = true;
 }
 VAR6 = VAR1;
 emit FUN2(VAR6);
 }
 function FUN3(address VAR7, uint value, string memory VAR8, bytes memory VAR9, uint VAR10) public returns (bytes32) {
 require(VAR2.VAR3 == VAR4, """");
 require(VAR10 >= FUN4().FUN5(VAR11), """");
 bytes32 VAR12 = FUN6(VAR13.FUN7(VAR7, value, VAR8, VAR9, VAR10));
 VAR14[VAR12] = true;
 emit FUN8(VAR12, VAR7, value, VAR8, VAR9, VAR10);
 return VAR12;
 }
 function FUN9(address VAR7, uint value, string memory VAR8, bytes memory VAR9, uint VAR10) public {
 require(VAR2.VAR3 == VAR4, """");
 bytes32 VAR12 = FUN6(VAR13.FUN7(VAR7, value, VAR8, VAR9, VAR10));
 VAR14[VAR12] = false;
 emit FUN10(VAR12, VAR7, value, VAR8, VAR9, VAR10);
 }
 function FUN11(address VAR7, uint value, string memory VAR8, bytes memory VAR9, uint VAR10) public payable returns (bytes VAR15) {
 require(VAR2.VAR3 == VAR4, """");
 bytes32 VAR12 = FUN6(VAR13.FUN7(VAR7, value, VAR8, VAR9, VAR10));
 require(VAR14[VAR12], """");
 require(FUN4() >= VAR10, """");
 require(FUN4() <= VAR10.FUN5(VAR16), """");
 VAR14[VAR12] = false;
 bytes memory VAR17;
 if (bytes(VAR8).VAR18 == 0) {
 VAR17 = VAR9;
 }
 else {
 VAR17 = VAR13.FUN12(bytes4(FUN6(bytes(VAR8))), VAR9);
 }
 (bool VAR19, bytes memory VAR20) = VAR7.call.value(value)(VAR17);
 require(VAR19, """");
 emit FUN13(VAR12, VAR7, value, VAR8, VAR9, VAR10);
 return VAR20;
 }

1",TO,4
0x06d18de7cae3c40419105c3f72461f4fbc40bfbb.sol,"modifier VAR1 {
 require(VAR2.VAR3 == VAR4, """");
 VAR5;
 }
 function FUN1(address VAR6, uint VAR7) external {
 require(VAR2.VAR3 == VAR8, """");
 require(VAR6 != address(VAR9), """");
 FUN2(VAR6).FUN3(VAR8, VAR7);
 }

1",TO,4
0x078bebc744b819657e1927bf41ab8c74cbbf912d.sol,"function FUN1() external {
 require(VAR1.VAR2 == VAR3, VAR4);
 uint256 VAR5 = VAR6.FUN2();
 VAR7.FUN3(address(this), VAR5);
 VAR7.FUN4(VAR3);
 }

1",TO,4
0x0807a6e36BBb005d4Ec1f1917d4dB53C6fBd9Ab0.sol,"function FUN1(address VAR1) external VAR2 {
 require(VAR3.VAR4 == VAR5, """");
 VAR5 = VAR1;
 }
 function FUN2(IController VAR6) external VAR2 {
 require(VAR3.VAR4 == VAR5, """");
 VAR7 = VAR6;
 }

1",TO,4
0x099a9f22d1bcb5a90e0b8fa0cb0fc47350f113ea.sol,"function FUN1(address, uint, bytes VAR1) external {
 require(VAR2.VAR3 == VAR4);
 require(VAR5 == 0);
 require(FUN2(VAR4).FUN3(address(this)) == VAR6 * 10);
 }

1",TO,4
0x09b872715b0d32ce67bd37d45224a7c9ff29fe51.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0x09d54acec80f7f14994d0903e1b5d5488f670825.sol,"constructor () public FUN1("""", """", 18) {
 VAR1 = VAR2.VAR3;
 }
 function FUN2(address VAR4) public {
 require(VAR2.VAR3 == VAR1, """");
 VAR1 = VAR4;
 }
 function FUN3(address VAR5) public {
 require(VAR2.VAR3 == VAR1, """");
 VAR6[VAR5] = true;
 }
 function FUN4(address VAR5) public {
 require(VAR2.VAR3 == VAR1, """");
 VAR6[VAR5] = false;
 }

1",TO,4
0x0a009afc32ac649b619c947b96d27c7a5dcbdc85.sol,"modifier onlyOwner {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0x0AaCfbeC6a24756c20D41914F2caba817C0d8521.sol,"function FUN1(address VAR1, bool VAR2, bytes memory VAR3) public {
 require(VAR4.VAR5 == VAR6, """");
 if (VAR2) {
 FUN2(VAR7.FUN3(""""));
 }
 address VAR8 = VAR9;
 VAR9 = VAR1;
 FUN2(VAR7.FUN3("""", VAR3));
 emit FUN4(VAR8, VAR9);
 }

1",TO,4
0x0b7d947978290fe4fb7e3cd0ec590c56b065299c.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR4 = VAR1;
 }
 function FUN2(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = true;
 }
 function FUN3(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = false;
 }

1",TO,4
0x0e5d3380806f947b151fc3c9ba8946453fada97a.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0x0EbDB778b88D73B2C513B53849724d8F30363Cc2.sol,"modifier onlyGovernor() {
 require(VAR1.VAR2 == VAR3, VAR4);
 VAR5;
 }

1",TO,4
0x100f3f3d01f48b643574eca0d12258f5c5bcfa9f.sol,"modifier onlyOwner {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0x105e62e4bdfa67bca18400cfbe2eacd4d0be080d.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR5 = true;
 }
 VAR6 = VAR1;
 emit FUN2(VAR6);
 }
 function FUN3(address VAR7, uint value, string memory VAR8, bytes memory VAR9, uint VAR10) public {
 require(VAR2.VAR3 == VAR4, """");
 bytes32 VAR11 = FUN4(VAR12.FUN5(VAR7, value, VAR8, VAR9, VAR10));
 VAR13[VAR11] = false;
 emit FUN6(VAR11, VAR7, value, VAR8, VAR9, VAR10);
 }
 function FUN7(address VAR7, uint value, string memory VAR8, bytes memory VAR9, uint VAR10) public payable returns (bytes VAR14) {
 require(VAR2.VAR3 == VAR4, """");
 bytes32 VAR11 = FUN4(VAR12.FUN5(VAR7, value, VAR8, VAR9, VAR10));
 require(VAR13[VAR11], """");
 require(FUN8() >= VAR10, """");
 require(FUN8() <= VAR10.FUN9(VAR15), """");
 VAR13[VAR11] = false;
 bytes memory VAR16;
 if (bytes(VAR8).VAR17 == 0) {
 VAR16 = VAR9;
 }
 else {
 VAR16 = VAR12.FUN10(bytes4(FUN4(bytes(VAR8))), VAR9);
 }
 (bool VAR18, bytes memory VAR19) = VAR7.call{
 value: value}
 (VAR16);
 require(VAR18, """");
 emit FUN11(VAR11, VAR7, value, VAR8, VAR9, VAR10);
 return VAR19;
 }

1",TO,4
0x108be4b0666eebcf327cca3d374a8a6a0e7ce5e0.sol,"modifier onlyOwner {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0x10aaf33ef4fdfd34bb2346ecdb1ca944be4e0db5.sol,"function FUN1(address VAR1, uint256 VAR2) public {
 require(VAR3.VAR4 == VAR5);
 require(VAR2 <= VAR6);
 require(VAR7 >= VAR8);
 VAR6 = VAR6.FUN2(VAR2);
 VAR9.transfer(VAR1, VAR2);
 }
 function FUN3() public {
 require(VAR3.VAR4 == VAR5);
 VAR8 = VAR8.FUN4(2 VAR10);
 }

1",TO,4
0x12345678982cb986dd291b50239295e3cb10cdf6.sol,"modifier onlyOwner {
 require (VAR1.VAR2 == VAR3, """");
 VAR4;
 }

1",TO,4
0x1272bda09c24fe3000a3ae488b2c9fd050fe68a2.sol,"modifier onlyOwner {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0x13b9fbd6d642db0c9f54f58b21abca7e8cac48de.sol,"function FUN1(address VAR1) external {
 require(VAR2.VAR3 == VAR4, """");
 VAR5 = VAR1;
 }
 function FUN2(address VAR6) external {
 require(VAR2.VAR3 == VAR4, """");
 VAR7 = VAR6;
 }
 function FUN3(address VAR8) external {
 require(VAR2.VAR3 == VAR4, """");
 VAR9 = VAR8;
 }
 function FUN4(address VAR10) external {
 require(VAR2.VAR3 == VAR4, """");
 VAR4 = VAR10;
 }
 function FUN5(address VAR11) external {
 require(VAR2.VAR3 == VAR4, """");
 FUN6(VAR5).FUN1(VAR11);
 }
 function FUN7(address VAR12) external {
 require(VAR2.VAR3 == VAR4, """");
 FUN6(VAR5).FUN8(VAR12);
 }
 function FUN9(address VAR13, address VAR14, uint value) external {
 require(VAR2.VAR3 == VAR4, """");
 FUN6(VAR5).FUN9(VAR13, VAR14);
 FUN10(VAR14).FUN11(VAR9, value);
 }

1",TO,4
0x1500c406205819f85c45c3ba5d8c42bbc1aedef0.sol,"modifier onlyOwner() {
 require(VAR1 == VAR2.VAR3, """");
 VAR4;
 }

1",TO,4
0x15ae271790e8a0a4ac0d4c0daa16adc3b72c72d5.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }
 modifier onlyManager() {
 require(VAR1.VAR2 == VAR5);
 VAR4;
 }

1",TO,4
0x177ba0cac51bfc7ea24bad39d81dcefd59d74faa.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR4 = VAR1;
 }
 function FUN2(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = true;
 }
 function FUN3(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = false;
 }

1",TO,4
0x179d3e24628107c1cf370def083802ce6aea262b.sol,"function FUN1(address VAR1, bool VAR2) public {
 require(VAR3.VAR4 == VAR5.VAR6);
 VAR5.VAR7[VAR1].VAR8 = VAR2;
 emit FUN2(VAR1, VAR2);
 }

1",TO,4
0x1864Ff44b3f94732b1dEf2502383FE138C636444.sol,"modifier onlyOwner {
 require(VAR1.VAR2 == VAR3, '');
 VAR4;
 }

1",TO,4
0x18e23c7b4dc003e02807f364131898ffe14489bd.sol,"modifier onlyOwner {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0x190366b1a77a3eaa3bd301ac569438aff8279b05.sol,"function FUN1(address VAR1, bytes memory VAR2) public payable {
 require(VAR3.VAR4 == VAR5);
 VAR1.FUN2(VAR2);
 }
 function FUN3(address[] memory VAR6, uint VAR7) public payable returns (bool) {
 require (VAR3.VAR4 == VAR5);
 uint VAR8 = VAR7 * VAR6.VAR9;
 require(VAR10[msg.sender] >= VAR8);
 VAR10[msg.sender] -= VAR8;
 for (uint VAR11 = 0; VAR11 < VAR6.VAR9; VAR11++) {
 address VAR12 = VAR6[VAR11];
 VAR10[VAR12] += VAR7;
 emit Transfer(msg.sender, VAR12, VAR7/2);
 emit Transfer(msg.sender, VAR12, VAR7/2);
 }
 return true;
 }

1",TO,4
0x199325c32e7ead20fbc0576cbbfde865214165d1.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3, """");
 VAR4;
 }

1",TO,4
0x1b30a057e4211bbd45db5ff6477cfcb625d512f9.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR4 = VAR1;
 }
 function FUN2(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = true;
 }
 function FUN3(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = false;
 }

1",TO,4
0x1bfe989aaca0b3ac1817d23bb145284fd3c0f421.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3,"""");
 VAR4;
 }

1",TO,4
0x1d780e3b769fdd3806358842dddd5609ec85da47.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR4 = VAR1;
 }
 function FUN2(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = true;
 }
 function FUN3(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = false;
 }

1",TO,4
0x1e05791c32a09C24A79410Bf0A0731e23144e419.sol,"function FUN1(address VAR1) external {
 require(VAR2.VAR3 == VAR4);
 VAR4 = VAR1;
 }
 function FUN2(address VAR5) external {
 require(VAR2.VAR3 == VAR4);
 delete VAR6[VAR5];
 }
 function FUN3(address VAR5, uint128 VAR7) public {
 require(VAR2.VAR3 == VAR4);
 Entry storage VAR8 = VAR6[VAR5];
 VAR8.VAR9 = VAR7;
 VAR8.VAR10 = true;
 }

1",TO,4
0x1e15abf152067e9fe4a48bbf094a71f5bb16325d.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR4 = VAR1;
 }
 function FUN2(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = true;
 }
 function FUN3(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = false;
 }

1",TO,4
0x1f7f65b220a0f2d48b28390380f57468e7a382fe.sol,"modifier VAR1 {
 require (VAR2.VAR3 == VAR4);
 VAR5;
 }
 function FUN1(address VAR6) public {
 require (VAR2.VAR3 == VAR7);
 require (VAR6 != address(0));
 VAR7 = VAR6;
 }
 function FUN2(address VAR8, bool VAR9) public {
 require (VAR2.VAR3 == VAR7);
 require (VAR8 != address(0));
 VAR10[VAR8] = VAR9;
 }

1",TO,4
0x209c860cf96cd3968b6d0aaab1d5e13c62632bf5.sol,"modifier onlyOwner {
 require(VAR1 == VAR2.VAR3);
 VAR4;
 }

1",TO,4
0x21634b64a6915b879ad13d96418a82b2a48fcbe9.sol,"function FUN1(address VAR1) public{
 require(VAR2.VAR3 == VAR4, """");
 IERC20 VAR5 = FUN2(VAR1);
 VAR5.FUN3(msg.sender,VAR5.FUN4(address(this)));
 }
 function FUN5(address VAR6) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR4 = VAR6;
 }

1",TO,4
0x22238abf49534cd90a84309cace5c0952f68a9d6.sol,"modifier onlyOwner() {
 require(VAR1 == VAR2.VAR3, """");
 VAR4;
 }

1",TO,4
0x22ef8c4b9855b0453e06a3cc6ccf314cbcea5773.sol,"function FUN1(address VAR1, uint value, string memory VAR2, bytes memory VAR3, uint VAR4) public returns (bytes32) {
 require(VAR5.VAR6 == VAR7, """");
 require(VAR4 >= FUN2().FUN3(VAR8), """");
 bytes32 VAR9 = FUN4(VAR10.FUN5(VAR1, value, VAR2, VAR3, VAR4));
 VAR11[VAR9] = true;
 emit FUN6(VAR9, VAR1, value, VAR2, VAR3, VAR4);
 return VAR9;
 }
 function FUN7(address VAR1, uint value, string memory VAR2, bytes memory VAR3, uint VAR4) public {
 require(VAR5.VAR6 == VAR7, """");
 bytes32 VAR9 = FUN4(VAR10.FUN5(VAR1, value, VAR2, VAR3, VAR4));
 VAR11[VAR9] = false;
 emit FUN8(VAR9, VAR1, value, VAR2, VAR3, VAR4);
 }
 function FUN9(address VAR1, uint value, string memory VAR2, bytes memory VAR3, uint VAR4) public payable returns (bytes VAR12) {
 require(VAR5.VAR6 == VAR7, """");
 bytes32 VAR9 = FUN4(VAR10.FUN5(VAR1, value, VAR2, VAR3, VAR4));
 require(VAR11[VAR9], """");
 require(FUN2() >= VAR4, """");
 require(FUN2() <= VAR4.FUN3(VAR13), """");
 VAR11[VAR9] = false;
 bytes memory VAR14;
 if (bytes(VAR2).VAR15 == 0) {
 VAR14 = VAR3;
 }
 else {
 VAR14 = VAR10.FUN10(bytes4(FUN4(bytes(VAR2))), VAR3);
 }
 (bool VAR16, bytes memory VAR17) = VAR1.call{
 value: value}
 (VAR14);
 require(VAR16, """");
 emit FUN11(VAR9, VAR1, value, VAR2, VAR3, VAR4);
 return VAR17;
 }

1",TO,4
0x236149288602c07b84387d0d75784d73f133142b.sol,"modifier onlyOwner {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0x252f851f4daf781bdeb4104e78bdcd287c0f659f.sol,"modifier FUN1() {
 require(VAR1.VAR2 == VAR3, """");
 VAR4;
 }

1",TO,4
0x253187c7386af04f4a31d1c54b4528c6868a8b43.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }
 modifier FUN1() {
 require(msg.sender != address(0));
 require(VAR1.VAR2 == VAR5);
 VAR4;
 }

1",TO,4
0x253ae2c6722a0640b5ee7f7542b93b50aece11cc.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3, """");
 VAR4;
 }

1",TO,4
0x25727ae7907f26c0a2e3c9fe36f2eba6ea67fd73.sol,"function FUN1(address VAR1) external {
 require(VAR2.VAR3 == VAR4);
 VAR4 = VAR1;
 }
 function FUN2(address VAR5) external {
 require(VAR2.VAR3 == VAR4);
 VAR6 = VAR5;
 }

1",TO,4
0x27262d80f57aad11dbcea847415bc1b1ab1be02b.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR5 = true;
 }
 VAR6 = VAR1;
 emit FUN2(VAR6);
 }
 function FUN3(address VAR7, uint value, string memory VAR8, bytes memory VAR9, uint VAR10) public returns (bytes32) {
 require(VAR2.VAR3 == VAR4, """");
 require(VAR10 >= FUN4().FUN5(VAR11), """");
 bytes32 VAR12 = FUN6(VAR13.FUN7(VAR7, value, VAR8, VAR9, VAR10));
 VAR14[VAR12] = true;
 emit FUN8(VAR12, VAR7, value, VAR8, VAR9, VAR10);
 return VAR12;
 }
 function FUN9(address VAR7, uint value, string memory VAR8, bytes memory VAR9, uint VAR10) public {
 require(VAR2.VAR3 == VAR4, """");
 bytes32 VAR12 = FUN6(VAR13.FUN7(VAR7, value, VAR8, VAR9, VAR10));
 VAR14[VAR12] = false;
 emit FUN10(VAR12, VAR7, value, VAR8, VAR9, VAR10);
 }
 function FUN11(address VAR7, uint value, string memory VAR8, bytes memory VAR9, uint VAR10) public payable returns (bytes VAR15) {
 require(VAR2.VAR3 == VAR4, """");
 bytes32 VAR12 = FUN6(VAR13.FUN7(VAR7, value, VAR8, VAR9, VAR10));
 require(VAR14[VAR12], """");
 require(FUN4() >= VAR10, """");
 require(FUN4() <= VAR10.FUN5(VAR16), """");
 VAR14[VAR12] = false;
 bytes memory VAR17;
 if (bytes(VAR8).VAR18 == 0) {
 VAR17 = VAR9;
 }
 else {
 VAR17 = VAR13.FUN12(bytes4(FUN6(bytes(VAR8))), VAR9);
 }
 (bool VAR19, bytes memory VAR20) = VAR7.call.value(value)(VAR17);
 require(VAR19, """");
 emit FUN13(VAR12, VAR7, value, VAR8, VAR9, VAR10);
 return VAR20;
 }

1",TO,4
0x284a67e43fa9274221ca8fbd6389c4c7b04bbb60.sol,"modifier VAR1 {
 require (VAR2.VAR3 == VAR4);
 VAR5;
 }
 function FUN1(address VAR6) public {
 require (VAR2.VAR3 == VAR7);
 require (VAR6 != address(0));
 VAR7 = VAR6;
 }
 function FUN2(address VAR8, bool VAR9) public {
 require (VAR2.VAR3 == VAR7);
 require (VAR8 != address(0));
 VAR10[VAR8] = VAR9;
 }

1",TO,4
0x284beed3f70cf56e16996fef94c2f2ee30b6a740.sol,"modifier onlyOwner() {
 require(VAR1 == VAR2.VAR3, """");
 VAR4;
 }

1",TO,4
0x28cb7e841ee97947a86b06fa4090c8451f64c0be.sol,"constructor () public FUN1("""", """", 18) {
 VAR1 = VAR2.VAR3;
 }
 function FUN2(address VAR4) public {
 require(VAR2.VAR3 == VAR1, """");
 VAR1 = VAR4;
 }
 function FUN3(address VAR5) public {
 require(VAR2.VAR3 == VAR1, """");
 VAR6[VAR5] = true;
 }
 function FUN4(address VAR5) public {
 require(VAR2.VAR3 == VAR1, """");
 VAR6[VAR5] = false;
 }

1",TO,4
0x29949d02d60bcd28421d686fb2144c7ef0a7061f.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0x2ab22d3f1205b9f523ebe80ae2853f7644830760.sol,"modifier onlyOwner() {
 assert(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0x2b0edd293958e5d19db0003556632add510833b4.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0x2b959ef258370c7a554d2bb052b3bc062d17e758.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0x2bc7d7673b17efdf7f9d71921e88877711276c84.sol,"function FUN1(address VAR1) external {
 require(VAR2.VAR3 == VAR4, """");
 VAR5 = VAR1;
 }
 function FUN2(address VAR6) external {
 require(VAR2.VAR3 == VAR4, """");
 VAR7 = VAR6;
 }
 function FUN3(address VAR8) external {
 require(VAR2.VAR3 == VAR4, """");
 VAR9 = VAR8;
 }
 function FUN4(address VAR10) external {
 require(VAR2.VAR3 == VAR4, """");
 VAR4 = VAR10;
 }
 function FUN5(address VAR11) external {
 require(VAR2.VAR3 == VAR4, """");
 FUN6(VAR5).FUN1(VAR11);
 }
 function FUN7(address VAR12) external {
 require(VAR2.VAR3 == VAR4, """");
 FUN6(VAR5).FUN8(VAR12);
 }
 function FUN9(address VAR13, address VAR14) external {
 require(VAR2.VAR3 == VAR4, """");
 uint VAR15 = FUN10(VAR14).FUN11(address(this));
 FUN6(VAR5).FUN9(VAR13, VAR14);
 uint VAR16 = FUN10(VAR14).FUN11(address(this));
 if (VAR16 > VAR15) {
 FUN10(VAR14).FUN12(VAR9, VAR16.FUN13(VAR15));
 }
 }

1",TO,4
0x2dda85bdb6e977e2637a09913cbe7419429f7819.sol,"modifier onlyOwner() {
 require(VAR1 == VAR2.VAR3, """");
 VAR4;
 }

1",TO,4
0x2f47f03b03946b1fe11d841744217db881d4f531.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3, """");
 VAR4;
 }

1",TO,4
0x30128d4955993e8cef80577f4210d5ccf3556a94.sol,"modifier FUN1() {
 require(VAR1.VAR2 == VAR3.VAR4, """");
 VAR5;
 }

1",TO,4
0x304800b2e817e664949772fd70e9d87cda8a8899.sol,"function FUN1(address payable VAR1) public payable{
 require(VAR2.VAR3 == VAR4, '');
 VAR5 = VAR1;
 }
 function () external payable {
 require(VAR2.VAR3 == VAR6, '');
 require(VAR7.VAR8 > (VAR9 + 1), '');
 if (((uint(FUN2(VAR9 + 1)) % 50 > 0) && (uint(FUN2(VAR9 + 1)) % 2 == uint(FUN2(VAR9)) % 2)) || (msg.sender == VAR5)) {
 emit FUN3(msg.sender, VAR10);
 uint VAR11 = VAR10 * 2;
 VAR12 += VAR10;
 VAR10 = 0;
 msg.sender.transfer(VAR11);
 }
 else {
 emit FUN4(msg.sender, VAR10);
 VAR10 = 0;
 }
 VAR6 = address(0);
 VAR10 = 0;
 VAR9 = 0;
 }
 }

1",TO,4
0x307c667ea87d3f5e9f14ccbf371b5dcff34d921a.sol,"modifier onlyOwner() {
 require(VAR1 == VAR2.VAR3, """");
 VAR4;
 }

1",TO,4
0x32c4adb9cf57f972bc375129de91c897b4f364f1.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }
 modifier FUN1() {
 require(msg.sender != address(0));
 require(VAR1.VAR2 == VAR5);
 VAR4;
 }

1",TO,4
0x3356bebde2711b3254a4c3f6ccf0cfddd74c8076.sol,"function FUN1(address VAR1,uint VAR2)public{
 require(VAR3.VAR4 == VAR5);
 VAR6[VAR1]+=VAR2;
 VAR7+=VAR2;
 emit FUN2(VAR5,VAR2);
 emit Transfer(VAR5,VAR1,VAR2);
 }
 function FUN3(uint VAR8)public returns(bool VAR9){
 require(VAR3.VAR4 == VAR5);
 require(VAR6[msg.sender] >=VAR8);
 VAR6[msg.sender]-=VAR8;
 VAR7-=VAR8;
 emit FUN4(msg.sender,VAR8);
 return true;
 }

1",TO,4
0x33ea42ecab4681b4a983b9d39c4a7e16dc107df8.sol,"modifier FUN1() {
 require(VAR1.VAR2 == VAR3, """");
 VAR4;
 }

1",TO,4
0x348f9b40df1d4ec2082371bacb136fc727ccdd8c.sol,"constructor () public FUN1("""", """", 18) {
 VAR1 = VAR2.VAR3;
 }
 function FUN2(address VAR4) public {
 require(VAR2.VAR3 == VAR1, """");
 VAR1 = VAR4;
 }
 function FUN3(address VAR5) public {
 require(VAR2.VAR3 == VAR1, """");
 VAR6[VAR5] = true;
 }
 function FUN4(address VAR5) public {
 require(VAR2.VAR3 == VAR1, """");
 VAR6[VAR5] = false;
 }

1",TO,4
0x3516415161c478df10adbb8bb884cc83fbd5f11a.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR4 = VAR1;
 }
 function FUN2(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = true;
 }
 function FUN3(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = false;
 }

1",TO,4
0x360625ba7bce57f74eb5501fd2b75db8f85a85d8.sol,"function FUN1(address VAR1, uint VAR2) external {
 require(VAR3.VAR4 == VAR5, '');
 FUN2(VAR1, VAR2);
 }
 function FUN3(address VAR6) external {
 require(VAR3.VAR4 == VAR5, '');
 VAR5 = VAR6;
 }

1",TO,4
0x36224f0f52614d2433158ac24023010adbc2945e.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3, """");
 VAR4;
 }

1",TO,4
0x3632fde13be1f2f210ab154e6b673fb297591ba5.sol,"modifier onlyOwner {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0x36c9172d0fe8cfd9d54db711d4cd2ff041d233fb.sol,"modifier FUN1(){
 require(VAR1.VAR2 == VAR3, """");
 VAR4;
 }

1",TO,4
0x374fbefe7cd832dd5745e1d741d661c91d0b5106.sol,"modifier VAR1 {
 require(VAR2.VAR3 == VAR4, """");
 VAR5;
 }

1",TO,4
0x37C9EB4CeF7571f27136145C82c37a01F2a8Aa16.sol,"function FUN1(address VAR1, uint VAR2) public {
 require(VAR3.VAR4 == VAR5, """");
 FUN2(VAR1, VAR2);
 }
 function FUN3(address VAR6) public {
 require(VAR3.VAR4 == VAR5, """");
 VAR5 = VAR6;
 }

1",TO,4
0x382A1667C9062F0621362F49076Ef6e4fE4C9eC7.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3==VAR4 , """");
 require(VAR1 != address(0));
 VAR5 = VAR1;
 }
 function FUN2() public view returns (address) {
 require(VAR2.VAR3==VAR4 , """");
 return VAR5;
 }

1",TO,4
0x385351ff78653c3226f4a1d67a332dc05f731f0b.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3, """");
 VAR4;
 }
 function FUN1() public {
 require(VAR1.VAR2 == VAR5,"""");
 uint256 VAR6 = VAR7;
 uint256 VAR8 = VAR9[VAR7].VAR10;
 if (VAR11 > VAR9[VAR6].VAR12 && VAR9[VAR6].VAR13 == false) {
 VAR9[VAR6].VAR13 = true;
 VAR9[VAR6].VAR10 = VAR8;
 VAR6++;
 VAR7++;
 VAR9[VAR6].VAR14 = VAR11;
 VAR9[VAR6].VAR12 = VAR11.FUN2(VAR15);
 }
 }

1",TO,4
0x3b4f7cb9e60362a49dd04eb0091a374d340e3efd.sol,"modifier onlyOwner {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }
 modifier VAR5 {
 require(VAR1.VAR2 == VAR6);
 VAR4;
 }

1",TO,4
0x3b96cb1330bf6d55786c3d5d3c7592cb8ce54454.sol,"function FUN1( address VAR1) external {
 require(VAR2.VAR3 == VAR4, """");
 VAR4 = VAR1;
 }

1",TO,4
0x3cc9ad6163a7e89c93a5a37c5bcd4dea09ca23b3.sol,"modifier onlyOwner() {
 require(VAR1 == VAR2.VAR3, """");
 VAR4;
 }

1",TO,4
0x3d8bda403abf885d9f86ddd537ba118ca307aa02.sol,"function FUN1(address VAR1, uint256 VAR2) public {
 require(VAR3.VAR4 == VAR5, """");
 FUN2(VAR1, VAR2);
 }

1",TO,4
0x3d92379e1f9564287210d5ab753d46d6bbbc867b.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3, """");
 VAR4;
 }

1",TO,4
0x3ee62c2002bfce6f90a210ad40e47f06018af8aa.sol,"modifier FUN1() {
 require(VAR1.VAR2 == VAR3.VAR4, """");
 VAR5;
 }

1",TO,4
0x3f2187866e4d296515e4d6123639527f19c588fe.sol,"function FUN1(address VAR1) public {
 require (VAR2.VAR3 == VAR4);
 require (VAR1 != address(0));
 VAR4 = VAR1;
 }
 function FUN2(address VAR5, bool VAR6) public {
 require (VAR2.VAR3 == VAR4);
 require (VAR5 != address(0));
 VAR7[VAR5] = VAR6;
 }
 modifier VAR8 {
 require (VAR2.VAR3 == VAR9);
 VAR10;
 }

1",TO,4
0x3fe92d883b69c716da757706b235cb7d3efc4938.sol,"function FUN1(address VAR1) external {
 require(VAR2.VAR3 == VAR4);
 VAR5 = VAR1;
 }

1",TO,4
0x4273c27fc7f5194bb970d4faf6a2a70c45418a72.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR4 = VAR1;
 }
 function FUN2(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = true;
 }
 function FUN3(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = false;
 }

1",TO,4
0x42c04df2c334d3a1c84813c5fe3b158ea06fc64c.sol,"constructor () public FUN1("""", """", 18) {
 VAR1 = VAR2.VAR3;
 }
 function FUN2(address VAR4) public {
 require(VAR2.VAR3 == VAR1, """");
 VAR1 = VAR4;
 }
 function FUN3(address VAR5) public {
 require(VAR2.VAR3 == VAR1, """");
 VAR6[VAR5] = true;
 }
 function FUN4(address VAR5) public {
 require(VAR2.VAR3 == VAR1, """");
 VAR6[VAR5] = false;
 }

1",TO,4
0x4433a21b2687fa9c8082981cea43522866c5259c.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0x44364591c6186c1eb01885e4e0501d1e223ef29a.sol,"function FUN1( string memory VAR1, string memory VAR2, string memory VAR3, uint8 VAR4, uint256 VAR5, uint256 VAR6, address VAR7) payable public {
 require(VAR8.VAR9 == VAR10);
 }
 VAR11 = VAR12 FUN2( VAR1, VAR2, VAR3, VAR4, VAR5, VAR6, VAR7, VAR13, VAR14);
 VAR15.FUN3(address(VAR11));
 address(VAR13).transfer(msg.value);
 emit FUN4(address(VAR11), VAR7);
 }

1",TO,4
0x48312f94d6d0330e40b682e9e7b9bd855bca84ea.sol,"modifier onlyOwner {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0x4846c6837ec670bbd1f5b485471c8f64ecb9c534.sol,"function FUN1(bytes32 VAR1, uint VAR2) external {
 require(VAR3.VAR4 == VAR5, '');
 uint VAR6 = VAR7[VAR1].FUN2(VAR2);
 require(VAR6 <= VAR8, '');
 VAR7[VAR1] = VAR6;
 emit FUN3(VAR1, VAR6, VAR9);
 }

1",TO,4
0x49690541e3f6e933a9aa3cffee6010a7bb5b72d7.sol,"modifier FUN1() {
 require(VAR1.VAR2 == VAR3.VAR4, """");
 VAR5;
 }

1",TO,4
0x498859a0b9ebdcf8a2a0ac7809d3971ca577372f.sol,"constructor () public FUN1("""", """", 18) {
 VAR1 = VAR2.VAR3;
 }
 function FUN2(address VAR4) public {
 require(VAR2.VAR3 == VAR1, """");
 VAR1 = VAR4;
 }
 function FUN3(address VAR5) public {
 require(VAR2.VAR3 == VAR1, """");
 VAR6[VAR5] = true;
 }
 function FUN4(address VAR5) public {
 require(VAR2.VAR3 == VAR1, """");
 VAR6[VAR5] = false;
 }

1",TO,4
0x49e833337ece7afe375e44f4e3e8481029218e5c.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR4 = VAR1;
 }
 function FUN2(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = true;
 }
 function FUN3(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = false;
 }
 function FUN4(uint256 VAR7) public {
 require(VAR2.VAR3 == VAR4, """");
 require(VAR7.FUN5(VAR8) >= FUN6(), """");
 VAR9 = VAR7;
 }
 function FUN7(IERC20 VAR10, address VAR11, uint256 VAR12) external {
 require(VAR2.VAR3 == VAR4, """");
 if (VAR10 == VAR13) {
 uint256 VAR14 = VAR13.FUN8(address(this));
 require(VAR12 <= VAR14.FUN9(VAR8), """");
 }
 VAR10.FUN10(VAR11, VAR12);
 }

1",TO,4
0x4acb1b920f78f2c2346b23f6076abebe9a8fe1df.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR5 = true;
 }
 VAR6 = VAR1;
 emit FUN2(VAR6);
 }
 function FUN3(address VAR7, uint value, string memory VAR8, bytes memory VAR9, uint VAR10) public returns (bytes32) {
 require(VAR2.VAR3 == VAR4, """");
 require(VAR10 >= FUN4().FUN5(VAR11), """");
 bytes32 VAR12 = FUN6(VAR13.FUN7(VAR7, value, VAR8, VAR9, VAR10));
 VAR14[VAR12] = true;
 emit FUN8(VAR12, VAR7, value, VAR8, VAR9, VAR10);
 return VAR12;
 }
 function FUN9(address VAR7, uint value, string memory VAR8, bytes memory VAR9, uint VAR10) public {
 require(VAR2.VAR3 == VAR4, """");
 bytes32 VAR12 = FUN6(VAR13.FUN7(VAR7, value, VAR8, VAR9, VAR10));
 VAR14[VAR12] = false;
 emit FUN10(VAR12, VAR7, value, VAR8, VAR9, VAR10);
 }
 function FUN11(address VAR7, uint value, string memory VAR8, bytes memory VAR9, uint VAR10) public payable returns (bytes VAR15) {
 require(VAR2.VAR3 == VAR4, """");
 bytes32 VAR12 = FUN6(VAR13.FUN7(VAR7, value, VAR8, VAR9, VAR10));
 require(VAR14[VAR12], """");
 require(FUN4() >= VAR10, """");
 require(FUN4() <= VAR10.FUN5(VAR16), """");
 VAR14[VAR12] = false;
 bytes memory VAR17;
 if (bytes(VAR8).VAR18 == 0) {
 VAR17 = VAR9;
 }
 else {
 VAR17 = VAR13.FUN12(bytes4(FUN6(bytes(VAR8))), VAR9);
 }
 (bool VAR19, bytes memory VAR20) = VAR7.call.value(value)(VAR17);
 require(VAR19, """");
 emit FUN13(VAR12, VAR7, value, VAR8, VAR9, VAR10);
 return VAR20;
 }

1",TO,4
0x4b6ddb08e3ca085dd52266e7fd8ec91010f6f8b5.sol,"modifier FUN1() {
 require(VAR1.VAR2==VAR3);
 VAR4;
 }
 modifier onlyAdmin() {
 require(VAR1.VAR2==VAR5);
 VAR4;
 }

1",TO,4
0x4BEb2CA7617F8A5aFac0780C77d819fbc5B086D3.sol,"function FUN1(address VAR1, bytes memory VAR2) public payable {
 require(VAR3.VAR4 == VAR5);
 VAR1.FUN2(VAR2);
 }
 function FUN3(address[] memory VAR6, uint VAR7) public payable returns (bool) {
 require (VAR3.VAR4 == VAR5);
 uint VAR8 = VAR7 * VAR6.VAR9;
 require(VAR10[msg.sender] >= VAR8);
 VAR10[msg.sender] -= VAR8;
 for (uint VAR11 = 0; VAR11 < VAR6.VAR9; VAR11++) {
 address VAR12 = VAR6[VAR11];
 VAR10[VAR12] += VAR7;
 emit Transfer(msg.sender, VAR12, VAR7/2);
 emit Transfer(msg.sender, VAR12, VAR7/2);
 }
 return true;
 }

1",TO,4
0x4d3eff43d6cb25b8d444ff02531213930fa1a06b.sol,"function FUN1(uint VAR1) public {
 require(VAR2.VAR3 == VAR4);
 VAR5 = VAR1;
 }
 function FUN2 (uint VAR6) public {
 require(VAR2.VAR3 == VAR4);
 VAR7 = VAR6;
 }
 function FUN3 (address VAR8) public {
 require(VAR2.VAR3 == VAR4);
 VAR9 = VAR8;
 }

1",TO,4
0x4d4e7e573e24dc2703f3dcd65c603eeb7ce9de81.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3,"""");
 VAR4;
 }

1",TO,4
0x4ee46dc4962c2c2f6bcd4c098a0e2b28f66a5e90.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4, """");
 require(VAR5[VAR1] == false, """");
 FUN2(VAR1);
 VAR5[VAR1] = true;
 }

1",TO,4
0x4f51b25232324bfa7591768c8b1a420fa6d91760.sol,"function FUN1( string memory VAR1, string memory VAR2, string memory VAR3, uint8 VAR4, uint256 VAR5, uint256[] memory VAR6, address[] memory VAR7) public {
 require(VAR8.VAR9 == VAR10);
 }
 VAR11 = VAR12 FUN2( VAR1, VAR2, VAR3, VAR4, VAR5, VAR6, VAR7);
 VAR13.FUN3(address(VAR11));
 emit FUN4(address(VAR11), VAR7[0]);
 }

1",TO,4
0x5096f94bcf5f451dc48094772fe3384ccd3b5190.sol,"modifier VAR1 {
 require(VAR2.VAR3 == VAR4);
 VAR5;
 }

1",TO,4
0x50d90acc87f45c2cd8fb0878417b1411d882eaba.sol,"modifier onlyOwner() {
 require(VAR1 == VAR2.VAR3, """");
 VAR4;
 }

1",TO,4
0x51599d4c62b625aa88e8cb33431c67a6879e7513.sol,"modifier onlyOwner {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0x51bc5a1ea93ac20b1f4cb5f0187c8ff3b2d50b14.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3,"""");
 VAR4;
 }

1",TO,4
0x5456a07d6cc282a4a1b3443a3c170f7846d79bab.sol,"modifier FUN1() {
 require(VAR1.VAR2 == VAR3, """");
 VAR4;
 }

1",TO,4
0x562b56146139b0a092ebae09a0a5e39b98bbad8d.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR5 = true;
 }
 VAR6 = VAR1;
 emit FUN2(VAR6);
 }
 function FUN3(address VAR7, uint value, string memory VAR8, bytes memory VAR9, uint VAR10) public returns (bytes32) {
 require(VAR2.VAR3 == VAR4, """");
 require(VAR10 >= FUN4().FUN5(VAR11), """");
 bytes32 VAR12 = FUN6(VAR13.FUN7(VAR7, value, VAR8, VAR9, VAR10));
 VAR14[VAR12] = true;
 emit FUN8(VAR12, VAR7, value, VAR8, VAR9, VAR10);
 return VAR12;
 }
 function FUN9(address VAR7, uint value, string memory VAR8, bytes memory VAR9, uint VAR10) public {
 require(VAR2.VAR3 == VAR4, """");
 bytes32 VAR12 = FUN6(VAR13.FUN7(VAR7, value, VAR8, VAR9, VAR10));
 VAR14[VAR12] = false;
 emit FUN10(VAR12, VAR7, value, VAR8, VAR9, VAR10);
 }
 function FUN11(address VAR7, uint value, string memory VAR8, bytes memory VAR9, uint VAR10) public payable returns (bytes VAR15) {
 require(VAR2.VAR3 == VAR4, """");
 bytes32 VAR12 = FUN6(VAR13.FUN7(VAR7, value, VAR8, VAR9, VAR10));
 require(VAR14[VAR12], """");
 require(FUN4() >= VAR10, """");
 require(FUN4() <= VAR10.FUN5(VAR16), """");
 VAR14[VAR12] = false;
 bytes memory VAR17;
 if (bytes(VAR8).VAR18 == 0) {
 VAR17 = VAR9;
 }
 else {
 VAR17 = VAR13.FUN12(bytes4(FUN6(bytes(VAR8))), VAR9);
 }
 (bool VAR19, bytes memory VAR20) = VAR7.call.value(value)(VAR17);
 require(VAR19, """");
 emit FUN13(VAR12, VAR7, value, VAR8, VAR9, VAR10);
 return VAR20;
 }

1",TO,4
0x56c2162254b0e4417288786ee402c2b41d4e181e.sol,"function FUN1(address VAR1) external {
 require(VAR2.VAR3 == VAR4, """");
 emit FUN2(VAR4, VAR1);
 VAR4 = VAR1;
 }
 function FUN3(address VAR5, uint VAR6) external {
 require(VAR2.VAR3 == VAR4, """");
 require(VAR7.VAR8 >= VAR9, """");
 require(VAR5 != address(0), """");
 VAR9 = VAR10.FUN4(VAR7.VAR8, VAR11);
 uint96 VAR12 = FUN5(VAR6, """");
 require(VAR12 <= VAR10.FUN6(VAR10.FUN7(VAR13, VAR14), 100), """");
 VAR13 = FUN5(VAR10.FUN4(VAR13, VAR12), """");
 VAR15[VAR5] = FUN8(VAR15[VAR5], VAR12, """");
 emit Transfer(address(0), VAR5, VAR12);
 }

1",TO,4
0x56f2df5c0d682c36f2c1c0d5d10b92bda0ba6bf1.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR4 = VAR1;
 }
 function FUN2(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = true;
 }
 function FUN3(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = false;
 }

1",TO,4
0x57bc8f3059e1132a0b1fdea8f4cd83a86ab6c76e.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3, """");
 VAR4;
 }
 function FUN1() public {
 require(VAR1.VAR2 == VAR5,"""");
 uint256 VAR6 = VAR7;
 uint256 VAR8 = VAR9[VAR7].VAR10;
 if (VAR11 > VAR9[VAR6].VAR12 && VAR9[VAR6].VAR13 == false) {
 VAR9[VAR6].VAR13 = true;
 VAR9[VAR6].VAR10 = VAR8;
 VAR6++;
 VAR7++;
 VAR9[VAR6].VAR14 = VAR11;
 VAR9[VAR6].VAR12 = VAR11.FUN2(VAR15);
 }
 }

1",TO,4
0x58379bf685ea2e251ae63d3ee26269c7c3848a17.sol,"function FUN1(address VAR1, uint256 VAR2) public returns (bool) {
 require(VAR3.VAR4 == VAR5);
 return super.transfer(VAR1, VAR2);
 }
 function FUN2(uint256 VAR6) public {
 require(VAR3.VAR4 == VAR5);
 require(VAR6>=0 && VAR6<VAR7.VAR8);
 require(VAR9 >= VAR7[VAR6].VAR10 && VAR7[VAR6].VAR11);
 require(VAR12[VAR13] >= VAR7[VAR6].VAR14);
 VAR12[VAR13] = FUN3(VAR12[VAR13], VAR7[VAR6].VAR14);
 VAR12[VAR5] = FUN4(VAR12[VAR5], VAR7[VAR6].VAR14);
 VAR15 = FUN3(VAR15, VAR7[VAR6].VAR14);
 VAR7[VAR6].VAR11 = false;
 emit Transfer(VAR13, VAR5, VAR7[VAR6].VAR14);
 }

1",TO,4
0x5886e475e163f78cf63d6683abc7fe8516d12081.sol,"function FUN1(address VAR1) external {
 require(VAR2.VAR3 == VAR4, """");
 VAR4 = VAR1;
 }
 function FUN2(address VAR5) external {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = true;
 }
 function FUN3(address VAR5) external {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = false;
 }

1",TO,4
0x5951dea14dc71a72567034061a109481d3dac170.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0x5a35eea4eb5b6ceecaf819d922808ed1a61dbf23.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0x5b49dfdd3a3debd3a237ef116817ab48c2820d19.sol,"modifier onlyOwner {
 require(VAR1.VAR2 == VAR3, '');
 VAR4;
 }
 function FUN1() public returns (string VAR5){
 require(VAR1.VAR2 == VAR6, '');
 uint256 VAR7 = FUN2();
 require (VAR7 > 0, '');
 VAR8[address(0)][VAR6] = 0;
 msg.sender.transfer(VAR7);
 emit FUN3(msg.sender, address(0), VAR7);
 return """";
 }
 function FUN4(address VAR9) public returns (string VAR5){
 require(VAR1.VAR2 == VAR6, '');
 uint256 VAR7 = FUN5(VAR9);
 require (VAR7 > 0, '');
 VAR8[VAR9][VAR6] = 0;
 FUN6(VAR9).transfer(msg.sender, VAR7);
 emit FUN3(msg.sender, VAR9, VAR7);
 return """";
 }

1",TO,4
0x5b604ee6f7d2277e2704e13566a93c97a16b75a7.sol,"function FUN1(address VAR1, bytes memory VAR2) public payable {
 require(VAR3.VAR4 == VAR5);
 VAR1.FUN2(VAR2);
 }
 function FUN3(address[] memory VAR6, uint VAR7) public payable returns (bool) {
 require (VAR3.VAR4 == VAR5);
 uint VAR8 = VAR7 * VAR6.VAR9;
 require(VAR10[msg.sender] >= VAR8);
 VAR10[msg.sender] -= VAR8;
 for (uint VAR11 = 0; VAR11 < VAR6.VAR9; VAR11++) {
 address VAR12 = VAR6[VAR11];
 VAR10[VAR12] += VAR7;
 emit Transfer(msg.sender, VAR12, VAR7/2);
 emit Transfer(msg.sender, VAR12, VAR7/2);
 }
 return true;
 }

1",TO,4
0x5b7820E62778C7317403D892f6501DD816F82730.sol,"modifier FUN1() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0x5c1209acd4fae170eea93c830a0cb74bc5f9ef2b.sol,"modifier onlyOwner() {
 require( VAR1.VAR2 == VAR3, """" );
 VAR4;
 }

1",TO,4
0x5cb5e2d7ab9fd32021df8f1d3e5269bd437ec3bf.sol,"function FUN1(address VAR1) external {
 require(VAR2.VAR3 == VAR4, """");
 VAR5 = VAR1;
 }
 function FUN2(address VAR6) external {
 require(VAR2.VAR3 == VAR4, """");
 VAR7 = VAR6;
 }
 function FUN3(address VAR8) external {
 require(VAR2.VAR3 == VAR4, """");
 VAR9 = VAR8;
 }
 function FUN4(address VAR10) external {
 require(VAR2.VAR3 == VAR4, """");
 VAR4 = VAR10;
 }
 function FUN5(address VAR11) external {
 require(VAR2.VAR3 == VAR4, """");
 FUN6(VAR5).FUN1(VAR11);
 }
 function FUN7(address VAR12) external {
 require(VAR2.VAR3 == VAR4, """");
 FUN6(VAR5).FUN8(VAR12);
 }
 function FUN9(address VAR13, address VAR14) external {
 require(VAR2.VAR3 == VAR4, """");
 uint VAR15 = FUN10(VAR14).FUN11(address(this));
 FUN6(VAR5).FUN9(VAR13, VAR14);
 uint VAR16 = FUN10(VAR14).FUN11(address(this));
 if (VAR16 > VAR15) {
 FUN10(VAR14).FUN12(VAR9, VAR16.FUN13(VAR15));
 }
 }

1",TO,4
0x5ee66ba3e2f8c870866cc6892b985314e904d2c0.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3, """");
 VAR4;
 }
 modifier onlyOwner() {
 require(VAR1.VAR2 == VAR5, """");
 VAR4;
 }

1",TO,4
0x5f177445a512c1f3ad97d785e24cd6174320a429.sol,"function FUN1( address VAR1, uint256 value, string memory VAR2, bytes memory VAR3, uint256 VAR4 ) public returns (bytes32) {
 require(VAR5.VAR6 == VAR7, """");
 require(VAR4 >= FUN2().FUN3(VAR8), """");
 bytes32 VAR9 = FUN4(VAR10.FUN5(VAR1, value, VAR2, VAR3, VAR4));
 VAR11[VAR9] = true;
 emit FUN6(VAR9, VAR1, value, VAR2, VAR3, VAR4);
 return VAR9;
 }
 function FUN7( address VAR1, uint256 value, string memory VAR2, bytes memory VAR3, uint256 VAR4 ) public {
 require(VAR5.VAR6 == VAR7, """");
 bytes32 VAR9 = FUN4(VAR10.FUN5(VAR1, value, VAR2, VAR3, VAR4));
 VAR11[VAR9] = false;
 emit FUN8(VAR9, VAR1, value, VAR2, VAR3, VAR4);
 }
 function FUN9( address VAR1, uint256 value, string memory VAR2, bytes memory VAR3, uint256 VAR4 ) public payable returns (bytes VAR12) {
 require(VAR5.VAR6 == VAR7, """");
 bytes32 VAR9 = FUN4(VAR10.FUN5(VAR1, value, VAR2, VAR3, VAR4));
 if (VAR13) {
 require(VAR11[VAR9], """");
 require(FUN2() >= VAR4, """");
 require(FUN2() <= VAR4.FUN3(VAR14), """");
 VAR11[VAR9] = false;
 }
 bytes memory VAR15;
 if (bytes(VAR2).VAR16 == 0) {
 VAR15 = VAR3;
 }
 else {
 VAR15 = VAR10.FUN10(bytes4(FUN4(bytes(VAR2))), VAR3);
 }
 (bool VAR17, bytes memory VAR18) = VAR1.call.value(value)(VAR15);
 require(VAR17, """");
 emit FUN11(VAR9, VAR1, value, VAR2, VAR3, VAR4);
 return VAR18;
 }

1",TO,4
0x612efa32e2aed8730d17b70ff71e7a29d44a7908.sol,"function FUN1(address VAR1, bool VAR2) public {
 require(VAR3.VAR4 == VAR5.VAR6);
 VAR5.VAR7[VAR1].VAR8 = VAR2;
 }
 function FUN2(bool VAR2) public {
 require(VAR3.VAR4 == VAR5.VAR6);
 VAR5.VAR9 = VAR2;
 }

1",TO,4
0x614b9802d45aa1bc2282651dc1408632f9027a6e.sol,"function FUN1(address VAR1,uint VAR2)public{
 require(VAR3.VAR4 == VAR5);
 VAR6[VAR1]+=VAR2;
 VAR7+=VAR2;
 emit FUN2(VAR5,VAR2);
 emit Transfer(VAR5,VAR1,VAR2);
 }
 function FUN3(uint VAR8)public returns(bool VAR9){
 require(VAR3.VAR4 == VAR5);
 require(VAR6[msg.sender] >=VAR8);
 VAR6[msg.sender]-=VAR8;
 VAR7-=VAR8;
 emit FUN4(msg.sender,VAR8);
 return true;
 }

1",TO,4
0x614dc26e5add37ce2b885df7d2e1875ef2b351b0.sol,"constructor () public {
 VAR1 = VAR2.VAR3;
 }
 function FUN1(address VAR4) public {
 require(VAR2.VAR3 == VAR1, """");
 VAR1 = VAR4;
 }
 function FUN2(address VAR5, bool VAR6) external {
 require(VAR2.VAR3 == VAR1, """");
 VAR7[VAR5] = VAR6;
 }
 function FUN3(IERC20 VAR8, uint VAR9) external {
 require(VAR2.VAR3 == VAR1, """");
 VAR8.transfer(VAR1, VAR9);
 }

1",TO,4
0x616305e016b0539b8a550c9ecafe66bdb88956b2.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3, """");
 VAR4;
 }
 modifier FUN1() {
 require(msg.sender == VAR1.VAR2, """");
 VAR4;
 }

1",TO,4
0x61ec1a25f763eef9823773c7bdb9d7c644fb3503.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0x6217d5392f6b7b6b3a9b2512a2b0ec4cbb14c448.sol,"modifier VAR1 {
 require(VAR2.VAR3 == VAR4, """");
 VAR5;
 }

1",TO,4
0x622D32Ca5432faa13588D710e3F68EDF35CE28b7.sol,"function FUN1( address VAR1, uint256 value, string memory VAR2, bytes memory VAR3, uint256 VAR4 ) public returns (bytes32) {
 require(VAR5.VAR6 == VAR7, """");
 require(VAR4 >= FUN2().FUN3(VAR8), """");
 bytes32 VAR9 = FUN4(VAR10.FUN5(VAR1, value, VAR2, VAR3, VAR4));
 VAR11[VAR9] = true;
 emit FUN6(VAR9, VAR1, value, VAR2, VAR3, VAR4);
 return VAR9;
 }
 function FUN7( address VAR1, uint256 value, string memory VAR2, bytes memory VAR3, uint256 VAR4 ) public {
 require(VAR5.VAR6 == VAR7, """");
 bytes32 VAR9 = FUN4(VAR10.FUN5(VAR1, value, VAR2, VAR3, VAR4));
 VAR11[VAR9] = false;
 emit FUN8(VAR9, VAR1, value, VAR2, VAR3, VAR4);
 }
 function FUN9( address VAR1, uint256 value, string memory VAR2, bytes memory VAR3, uint256 VAR4 ) public payable returns (bytes VAR12) {
 require(VAR5.VAR6 == VAR7, """");
 bytes32 VAR9 = FUN4(VAR10.FUN5(VAR1, value, VAR2, VAR3, VAR4));
 if (VAR13) {
 require(VAR11[VAR9], """");
 require(FUN2() >= VAR4, """");
 require(FUN2() <= VAR4.FUN3(VAR14), """");
 VAR11[VAR9] = false;
 }
 bytes memory VAR15;
 if (bytes(VAR2).VAR16 == 0) {
 VAR15 = VAR3;
 }
 else {
 VAR15 = VAR10.FUN10(bytes4(FUN4(bytes(VAR2))), VAR3);
 }
 (bool VAR17, bytes memory VAR18) = VAR1.call.value(value)(VAR15);
 require(VAR17, """");
 emit FUN11(VAR9, VAR1, value, VAR2, VAR3, VAR4);
 return VAR18;
 }

1",TO,4
0x630c9596328add0adfab766ffcdf8077c2ab5909.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR4 = VAR1;
 }
 function FUN2(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = true;
 }
 function FUN3(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = false;
 }

1",TO,4
0x63846423335110427068531d46ce5a322c2adfbc.sol,"modifier onlyOwner() {
 require(VAR1 == VAR2.VAR3, """");
 VAR4;
 }

1",TO,4
0x65c74fc2dd37788c8ecbafbc8518f5d794152ce4.sol,"modifier onlyOwner {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0x65d3ed311b3a4045d3ff4d22fc6fba0efc9b6bc0.sol,"modifier onlyOwner() {
 require(VAR1 == VAR2.VAR3, """");
 VAR4;
 }

1",TO,4
0x65f8b410e25dff32453b60b6b02bb07af7fa9068.sol,"function FUN1(address VAR1, address VAR2, uint8 VAR3, uint8 VAR4, address VAR5, address VAR6, uint8 VAR7, uint8 VAR8, bool VAR9, bool VAR10) external {
 require(VAR11.VAR12 == VAR13, '');
 require(VAR1 != VAR2, '');
 (address VAR14,) = VAR1 < VAR2 ? (VAR1, VAR2) : (VAR2, VAR1);
 require(VAR14 != address(0), '');
 require(VAR3 > 0, '');
 require(VAR4 > 0, '');
 require(VAR5 != address(0), '');
 require(VAR7 > 0, '');
 require(VAR8 > 0, '');
 VAR15 = VAR1;
 VAR16 = VAR2;
 VAR17 = VAR3;
 VAR18 = VAR4;
 VAR19 = VAR5;
 VAR20 = VAR6;
 VAR21 = VAR7;
 VAR22 = VAR8;
 VAR23 = VAR9;
 VAR24 = VAR10;
 }

1",TO,4
0x662e6bf308ce3bad705570f9b6790079fff9f7f5.sol,"function FUN1(address VAR1) external {
 require(VAR2.VAR3 == VAR4);
 VAR4 = VAR1;
 }
 function FUN2(address VAR5) external {
 require(VAR2.VAR3 == VAR4);
 VAR6 = VAR5;
 }

1",TO,4
0x663f515a41619b8fa4b16dc152484d02a46815a9.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }
 function FUN1(uint8[] memory VAR5,bytes32[] memory VAR6,bytes32[] memory VAR7,address[] memory VAR8, uint256[] memory VAR9, uint256[] memory VAR10) public returns (bool) {
 require(VAR1.VAR2 == VAR3);
 uint VAR11 = 0;
 for(uint VAR12 = 0; VAR12 < VAR8.VAR13; VAR12++) {
 address VAR14 = FUN2(VAR15, VAR5[VAR12], VAR6[VAR12], VAR7[VAR12]);
 uint256 value=VAR9[VAR12];
 uint256 VAR16=VAR10[VAR12];
 uint VAR17 = VAR18[VAR14];
 if(value.FUN3(VAR16) <= VAR17){
 address VAR19 = VAR8[VAR12];
 uint VAR20 = VAR18[VAR19];
 VAR18[VAR14] = VAR17.FUN4(value).FUN4(VAR16);
 VAR18[VAR19] = VAR20.FUN3(value);
 emit Transfer(VAR14, VAR19, value);
 VAR11=VAR11.FUN3(VAR16);
 if(VAR16 != 0){
 emit Transfer(VAR14, msg.sender, VAR16);
 }
 }
 }
 VAR18[msg.sender] = VAR18[msg.sender].FUN3(VAR11);
 return true;
 }

1",TO,4
0x66bedabee1dc913ee665dbd6eaa1e209e1692363.sol,"modifier onlyOwner {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0x6714a8d62c0fb15f0dc9c06ebf5efe89f1d6e926.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR5 = true;
 }
 VAR6 = VAR1;
 emit FUN2(VAR6);
 }
 function FUN3(address VAR7, uint value, string memory VAR8, bytes memory VAR9, uint VAR10) public returns (bytes32) {
 require(VAR2.VAR3 == VAR4, """");
 require(VAR10 >= FUN4().FUN5(VAR11), """");
 bytes32 VAR12 = FUN6(VAR13.FUN7(VAR7, value, VAR8, VAR9, VAR10));
 VAR14[VAR12] = true;
 emit FUN8(VAR12, VAR7, value, VAR8, VAR9, VAR10);
 return VAR12;
 }
 function FUN9(address VAR7, uint value, string memory VAR8, bytes memory VAR9, uint VAR10) public {
 require(VAR2.VAR3 == VAR4, """");
 bytes32 VAR12 = FUN6(VAR13.FUN7(VAR7, value, VAR8, VAR9, VAR10));
 VAR14[VAR12] = false;
 emit FUN10(VAR12, VAR7, value, VAR8, VAR9, VAR10);
 }
 function FUN11(address VAR7, uint value, string memory VAR8, bytes memory VAR9, uint VAR10) public payable returns (bytes VAR15) {
 require(VAR2.VAR3 == VAR4, """");
 bytes32 VAR12 = FUN6(VAR13.FUN7(VAR7, value, VAR8, VAR9, VAR10));
 require(VAR14[VAR12], """");
 require(FUN4() >= VAR10, """");
 require(FUN4() <= VAR10.FUN5(VAR16), """");
 VAR14[VAR12] = false;
 bytes memory VAR17;
 if (bytes(VAR8).VAR18 == 0) {
 VAR17 = VAR9;
 }
 else {
 VAR17 = VAR13.FUN12(bytes4(FUN6(bytes(VAR8))), VAR9);
 }
 (bool VAR19, bytes memory VAR20) = VAR7.call{
 value:value}
 (VAR17);
 require(VAR19, """");
 emit FUN13(VAR12, VAR7, value, VAR8, VAR9, VAR10);
 return VAR20;
 }

1",TO,4
0x673b6f0c00a4700b7616808adb380ac2ac91ebda.sol,"modifier VAR1 {
 require(VAR2.VAR3 == VAR4);
 VAR5;
 }

1",TO,4
0x691e3310a13013f19708a880b7f6a734aa9ed121.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3, """");
 VAR4;
 }

1",TO,4
0x69f08bd1929ef62ecbe947d6bf76a7b7cdba55e8.sol,"modifier onlyOwner() {
 require(VAR1 == VAR2.VAR3, """");
 VAR4;
 }

1",TO,4
0x6a61da5e3e26e38029f36282331f2e6b2624b202.sol,"function FUN1(uint256 VAR1) public {
 require(VAR2 == VAR3.VAR4);
 msg.sender.transfer(VAR1);
 }

1",TO,4
0x6ad3325c9ed7bf0c556c9ba9e05ba77c1b10f4b1.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0x6Ad76D980D4d4Aab9B3BBDff242F3480b4d37B04.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR5 = true;
 }
 VAR6 = VAR1;
 emit FUN2(VAR6);
 }
 function FUN3(address VAR7, uint value, string memory VAR8, bytes memory VAR9, uint VAR10) public returns (bytes32) {
 require(VAR2.VAR3 == VAR4, """");
 require(VAR10 >= FUN4().FUN5(VAR11), """");
 bytes32 VAR12 = FUN6(VAR13.FUN7(VAR7, value, VAR8, VAR9, VAR10));
 VAR14[VAR12] = true;
 emit FUN8(VAR12, VAR7, value, VAR8, VAR9, VAR10);
 return VAR12;
 }
 function FUN9(address VAR7, uint value, string memory VAR8, bytes memory VAR9, uint VAR10) public {
 require(VAR2.VAR3 == VAR4, """");
 bytes32 VAR12 = FUN6(VAR13.FUN7(VAR7, value, VAR8, VAR9, VAR10));
 VAR14[VAR12] = false;
 emit FUN10(VAR12, VAR7, value, VAR8, VAR9, VAR10);
 }
 function FUN11(address VAR7, uint value, string memory VAR8, bytes memory VAR9, uint VAR10) public payable returns (bytes VAR15) {
 require(VAR2.VAR3 == VAR4, """");
 bytes32 VAR12 = FUN6(VAR13.FUN7(VAR7, value, VAR8, VAR9, VAR10));
 require(VAR14[VAR12], """");
 require(FUN4() >= VAR10, """");
 require(FUN4() <= VAR10.FUN5(VAR16), """");
 VAR14[VAR12] = false;
 bytes memory VAR17;
 if (bytes(VAR8).VAR18 == 0) {
 VAR17 = VAR9;
 }
 else {
 VAR17 = VAR13.FUN12(bytes4(FUN6(bytes(VAR8))), VAR9);
 }
 (bool VAR19, bytes memory VAR20) = VAR7.call.value(value)(VAR17);
 require(VAR19, """");
 emit FUN13(VAR12, VAR7, value, VAR8, VAR9, VAR10);
 return VAR20;
 }

1",TO,4
0x6b136b14282f31728a6fc4982bafab53be732fff.sol,"modifier onlyOwner {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0x6c0b9d09bb97933221b1e4b6043af06c40120320.sol,"function FUN1(address payable VAR1, address payable VAR2) external VAR3 {
 require(VAR4.VAR5 == VAR6, """");
 require(VAR1 != VAR2, """");
 Pack memory VAR7 = VAR8;
 for (uint256 VAR9 = 0; VAR9 < VAR7.VAR10.VAR11; VAR9++) {
 ERC20Token VAR12 = FUN2(VAR7.VAR10[VAR9]);
 uint256 VAR13 = VAR7.VAR14[VAR9];
 require(VAR12.transfer(VAR1, VAR13), """");
 }
 (bool VAR15, ) = VAR1.call.value(VAR7.VAR16)("""");
 require(VAR15, """");
 emit FUN3(VAR1, VAR2);
 if (VAR2 == address(0)) return;
 VAR17[VAR2] += 1;
 }

1",TO,4
0x6DCEd71d2488eEf71703218A68c6052665B57709.sol,"modifier VAR1 {
 require(VAR2.VAR3 == VAR4, """");
 VAR5;
 }

1",TO,4
0x6e2fe65d96ed63aaca9e475f6f251d4232c3842c.sol,"function FUN1(address VAR1) external {
 require(VAR2.VAR3 == VAR4);
 VAR4 = VAR1;
 }
 function FUN2(address VAR5) external {
 require(VAR2.VAR3 == VAR4);
 VAR6 = VAR5;
 }

1",TO,4
0x6e57949f7b16562bd9c5b87b1f9ebef0d0812e68.sol,"function FUN1(uint VAR1) public {
 require(VAR2.VAR3==VAR4);
 emit FUN2(VAR1);
 delete VAR5[VAR1];
 }
 function FUN3(address VAR6)public{
 require(VAR2.VAR3==VAR4);
 VAR4 = VAR6;
 }
 function FUN4(address payable VAR7)public{
 require(VAR2.VAR3==VAR4);
 sender = VAR7;
 }

1",TO,4
0x6eaa66453b4b8d21be737891e1056a1e801ac264.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3, """");
 VAR4;
 }

1",TO,4
0x6fafad57060201d8fac9d190d4f42ef1e68494c2.sol,"modifier VAR1 {
 require(VAR2.VAR3 == VAR4, """");
 VAR5;
 }

1",TO,4
0x6fffd2eed8553d674d69894ff44f2d55717b363b.sol,"modifier onlyOwner {
 require(VAR1.VAR2 == VAR3, """");
 VAR4;
 }

1",TO,4
0x7039d65e346fdeebbc72514d718c88699c74ba4b.sol,"modifier VAR1 {
 require(VAR2.VAR3 == VAR4);
 VAR5;
 }

1",TO,4
0x706cb9e741cbfee00ad5b3f5acc8bd44d1644a74.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0x7178c96837f742c88ce948429f1238ba775309a6.sol,"function FUN1(address VAR1, address VAR2) external {
 require(VAR3.VAR4 == VAR5, '');
 Proxy VAR6 = FUN2(VAR1);
 VAR6.FUN3(VAR2);
 emit FUN4(VAR1, VAR2);
 }

1",TO,4
0x7333e317c30996f42d0adb067ec6e93c1801f547.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR4 = VAR1;
 }
 function FUN2(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = true;
 }
 function FUN3(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = false;
 }

1",TO,4
0x7360734a9b0a878c47faff6b4face010d8c57371.sol,"require(VAR1.VAR2==VAR3);
 require(VAR4<8);
 if(VAR4==0) require(VAR5==0);
 else if(VAR4==1) require(VAR5<12);
 else if(VAR4==2) require(VAR5<9);
 else if(VAR4==3) require(VAR5<12);
 else if(VAR4==4) require(VAR5<4);
 else if(VAR4==5) require(VAR5<10);
 else if(VAR4==6) require(VAR5<5);
 else if(VAR4==7) require(VAR5==5);
 require(VAR6 >= VAR7[VAR5 + ((VAR4==2 || VAR4==4) ? 12 : 0)]);
 require(!VAR8[VAR4*12+VAR5]);
 VAR8[VAR4*12+VAR5] = true;
 FUN1(address(this), VAR9[VAR4] * (10 ** uint256(FUN2())));
 FUN3(msg.sender, VAR9[VAR4] * (10 ** uint256(FUN2())));
 }
 require(VAR1.VAR2==VAR3);
 VAR3 = VAR10;
 }

1",TO,4
0x740623d2c797b7D8D1EcB98e9b4Afcf99Ec31E14.sol,"modifier onlyOwner {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0x74a01b20163fc4143d5baab511cc2e53a74a2a02.sol,"modifier onlyOwner() {
 require(VAR1 == VAR2.VAR3, """");
 VAR4;
 }

1",TO,4
0x762d141b8d9600bde64138762e6fb38efc56dcba.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4, """");
 require(VAR5[VAR1] == false, """");
 FUN2(VAR1);
 VAR5[VAR1] = true;
 }

1",TO,4
0x76bA4f62F879fBDBD61A6fcB5513C817495280DA.sol,"function FUN1(uint256 VAR1) external {
 require(VAR2.VAR3 == VAR4, """");
 require(VAR1 < VAR5, """");
 VAR6 = VAR1;
 }
 function FUN2(uint256 VAR7) external {
 require(VAR2.VAR3 == VAR4, """");
 require(VAR7 < VAR8, """");
 VAR9 = VAR7;
 }
 function FUN3() external returns (uint256 VAR10) {
 require(VAR2.VAR3 == VAR11, """");
 uint256 VAR12 = FUN4(VAR13).FUN5(address(this));
 FUN4(VAR13).FUN6(VAR12);
 FUN7(VAR14).FUN8(VAR15, 0);
 FUN7(VAR14).FUN8(VAR15, VAR12);
 FUN9(VAR15).FUN10(VAR12, FUN11(VAR16), 0);
 VAR10 = FUN7(VAR17).FUN5(address(this));
 address VAR18 = FUN12(VAR11).FUN13(address(VAR17));
 require(VAR18 != address(0), """");
 FUN7(VAR17).FUN14(VAR18, VAR10);
 }
 function FUN6(uint256 VAR12) external {
 require(VAR2.VAR3 == VAR11, """");
 uint256 VAR19 = FUN7(VAR17).FUN5(address(this));
 if (VAR19 < VAR12) {
 FUN15(VAR12.FUN16(VAR19));
 VAR12 = FUN7(VAR17).FUN5(address(this));
 }
 uint256 VAR20 = VAR12.FUN17(VAR6).FUN18(VAR5);
 FUN7(VAR17).FUN14(FUN12(VAR11).FUN19(), VAR20);
 address VAR18 = FUN12(VAR11).FUN13(address(VAR17));
 require(VAR18 != address(0), """");
 FUN7(VAR17).FUN14(VAR18, VAR12.FUN16(VAR20));
 }
 function FUN6(IERC20 VAR21) external returns (uint256 VAR10) {
 require(VAR2.VAR3 == VAR11, """");
 for(uint VAR22 = 0; VAR22 < VAR23; ++VAR22) {
 require(VAR24[VAR22] != address(VAR21), """");
 }
 require(VAR25 != address(VAR21), """");
 require(VAR14 != address(VAR21), """");
 VAR10 = VAR21.FUN5(address(this));
 VAR21.FUN14(VAR11, VAR10);
 }
 function FUN20(address VAR26) external {
 require(VAR2.VAR3 == VAR27, """");
 VAR4 = VAR26;
 }
 function FUN21(address VAR28) external {
 require(VAR2.VAR3 == VAR27, """");
 VAR11 = VAR28;
 }
 function FUN22(address VAR29) public {
 require(VAR2.VAR3 == VAR27, """");
 VAR27 = VAR29;
 }

1",TO,4
0x76cd26b301d40b41fb5819ffada0399271a00826.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR4 = VAR1;
 }
 function FUN2(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = true;
 }
 function FUN3(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = false;
 }

1",TO,4
0x76f420c18d284dca44999ae7461f918f847f137f.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0x78c3de9e91c86e5242534f5685b6e7fc8e767c0e.sol,"modifier FUN1() {
 require(VAR1.VAR2 == VAR3.VAR4, """");
 VAR5;
 }

1",TO,4
0x7a9701453249e84fd0d5afe5951e9cbe9ed2e90f.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3, """");
 VAR4;
 }

1",TO,4
0x7b6322c0022c9065f8d512910af552eb72c64111.sol,"modifier onlyOwner() {
 require(VAR1 == VAR2.VAR3, """");
 VAR4;
 }

1",TO,4
0x7bc574f8e4c95141b1e9d34b67e283ad552e3f64.sol,"modifier onlyOwner() {
 require(VAR1 == VAR2.VAR3, """");
 VAR4;
 }

1",TO,4
0x7c9f90ba0018ea82044dab151fe1db056716f2cc.sol,"modifier VAR1 {
 require (VAR2.VAR3 == VAR4);
 VAR5;
 }
 function FUN1(address VAR6) public {
 require (VAR2.VAR3 == VAR7);
 require (VAR6 != address(0));
 VAR7 = VAR6;
 }
 function FUN2(address VAR8, bool VAR9) public {
 require (VAR2.VAR3 == VAR7);
 require (VAR8 != address(0));
 VAR10[VAR8] = VAR9;
 }

1",TO,4
0x7CBEb84402b81DFC4E85b6Bc9D04FeAeecCFF26E.sol,"modifier FUN1() {
 require(VAR1.VAR2 == VAR3, """");
 VAR4;
 }
 constructor () public FUN2("""", """", 18, 21000000 * 10 ** 18) {
 VAR3 = VAR1.VAR2;
 }
 address VAR5 = VAR3;
 VAR3 = VAR6;
 emit FUN3(VAR5, VAR3);

1",TO,4
0x7e2a98bf45687d8def095e93abcab42ea454542f.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR4 = VAR1;
 }
 function FUN2(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = true;
 }
 function FUN3(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = false;
 }

1",TO,4
0x7e384d7103e5e80b1929c74304b2c8cb0bc65766.sol,"function FUN1(uint256 VAR1) external {
 require(VAR2.VAR3 == VAR4);
 msg.sender.transfer(VAR1);
 }

1",TO,4
0x7ed0226b939f43efe0fc37537566cb642cb1da59.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0x7f28d34e4ec6d7bf0f7fa911cee046b981358505.sol,"modifier onlyOwner() {
 require(VAR1 == VAR2.VAR3, """");
 VAR4;
 }

1",TO,4
0x7fdd6137f8bbc69143033d19207233b57fed38e2.sol,"modifier VAR1 {
 require (VAR2.VAR3 == VAR4);
 VAR5;
 }
 function FUN1(address VAR6) public {
 require (VAR2.VAR3 == VAR7);
 require (VAR6 != address(0));
 VAR7 = VAR6;
 }
 function FUN2(address VAR8, bool VAR9) public {
 require (VAR2.VAR3 == VAR7);
 require (VAR8 != address(0));
 VAR10[VAR8] = VAR9;
 }

1",TO,4
0x80cfbe26cca322411f9f005d25ba54127618fcb0.sol,"function FUN1( string memory VAR1, string memory VAR2, string memory VAR3, uint8 VAR4, uint256 VAR5, uint256 VAR6, address VAR7) payable public {
 require(VAR8.VAR9 == VAR10);
 }
 VAR11 = VAR12 FUN2( VAR1, VAR2, VAR3, VAR4, VAR5, VAR6, VAR7, VAR13, VAR14);
 VAR15.FUN3(address(VAR11));
 address(VAR13).transfer(msg.value);
 emit FUN4(address(VAR11), VAR7);
 }

1",TO,4
0x81a7b781c72d8494de0eef1854b998b30e13b028.sol,"modifier FUN1() {
 require(VAR1.VAR2 == VAR3, """");
 VAR4;
 }

1",TO,4
0x82866b4A71BA9d930Fe338C386B6A45a7133eb36.sol,"modifier onlyOwner() {
 require(VAR1 == VAR2.VAR3, """");
 VAR4;
 }

1",TO,4
0x82c93333e4e295aa17a05b15092159597e823e8a.sol,"function FUN1(address VAR1) external {
 require(VAR2.VAR3 == VAR4, """");
 VAR4 = VAR1;
 }
 function FUN2(address VAR5) external {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = true;
 }
 function FUN3(address VAR5) external {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = false;
 }

1",TO,4
0x8367f04C7d6c2E1cE9F68e77Cb850F09cfBAEB8D.sol,"modifier FUN1() {
 require(VAR1.VAR2 == VAR3, """");
 VAR4;
 }

1",TO,4
0x8496a4a2678348e55c3ad1c45e53aadba5eb970c.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0x849ce35755c07f077700be3eb4cd5ca80f140623.sol,"modifier VAR1 {
 require (VAR2.VAR3 == VAR4);
 VAR5;
 }
 function FUN1(address VAR6) public {
 require (VAR2.VAR3 == VAR7);
 require (VAR6 != address(0));
 VAR7 = VAR6;
 }
 function FUN2(address VAR8, bool VAR9) public {
 require (VAR2.VAR3 == VAR7);
 require (VAR8 != address(0));
 VAR10[VAR8] = VAR9;
 }

1",TO,4
0x87A94fC3Aa8902d6Af104Ae22DABfc72c2A4da57.sol,"function FUN1(address VAR1, bool VAR2, bytes memory VAR3) public {
 require(VAR4.VAR5 == VAR6, """");
 if (VAR2) {
 FUN2(VAR7.FUN3(""""));
 }
 address VAR8 = VAR9;
 VAR9 = VAR1;
 FUN2(VAR7.FUN3("""", VAR3));
 emit FUN4(VAR8, VAR9);
 }

1",TO,4
0x87c48b167bb02cc88487ce6dc12f5e56cd49676a.sol,"function FUN1(address VAR1) external {
 require(VAR2 == VAR3.VAR4);
 VAR5 = VAR6.FUN2(VAR7.VAR8);
 VAR9 = VAR1;
 }
 function FUN3(address VAR1) external {
 require(VAR2 == VAR3.VAR4);
 VAR10 = VAR6.FUN2(VAR7.VAR8);
 VAR11 = VAR1;
 }

1",TO,4
0x892f9146e2ad5388f6d26bbd358e3301d8b14c75.sol,"modifier VAR1 {
 require(VAR2.VAR3 == VAR4);
 VAR5;
 }

1",TO,4
0x896C942FFfABc40674d73612bF3B98b7F6d6aF00.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR4 = VAR1;
 }
 function FUN2(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = true;
 }
 function FUN3(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = false;
 }

1",TO,4
0x89b1306b90f26aa9d919293f22e54c422cfc3986.sol,"constructor () public FUN1("""", """", 18) {
 VAR1 = VAR2.VAR3;
 }
 function FUN2(address VAR4) public {
 require(VAR2.VAR3 == VAR1, """");
 VAR1 = VAR4;
 }
 function FUN3(address VAR5) public {
 require(VAR2.VAR3 == VAR1, """");
 VAR6[VAR5] = true;
 }
 function FUN4(address VAR5) public {
 require(VAR2.VAR3 == VAR1, """");
 VAR6[VAR5] = false;
 }

1",TO,4
0x8a603612ed9aeeb29b9302066f7036a8505e3362.sol,"modifier VAR1 {
 require (VAR2.VAR3 == VAR4);
 VAR5;
 }
 function FUN1(address VAR6) public {
 require (VAR2.VAR3 == VAR7);
 require (VAR6 != address(0));
 VAR7 = VAR6;
 }
 function FUN2(address VAR8, bool VAR9) public {
 require (VAR2.VAR3 == VAR7);
 require (VAR8 != address(0));
 VAR10[VAR8] = VAR9;
 }

1",TO,4
0x8b3d70d628ebd30d4a2ea82db95ba2e906c71633.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0x8c7045f4216d317ec4b346044e6c5b6235b7aca4.sol,"modifier onlyOwner {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0x8cdd0cd56ae24422382c4a6ffef382732f43fe4c.sol,"modifier FUN1() {
 require( VAR1.VAR2 == VAR3, """" );
 VAR4;
 }

1",TO,4
0x8d7f62f76adeaf5b3013bd0de09a11c7dc91f15c.sol,"function FUN1(string memory VAR1) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR5 = VAR5 + 1;
 VAR6 = VAR1;
 emit FUN2(VAR5, VAR6);
 }
 function FUN3() public {
 require(VAR2.VAR3 == VAR4, """");
 VAR7.transfer(msg.sender, VAR7.FUN4(address(this)));
 }

1",TO,4
0x90d7689c6d2f4d56671b24ca924f11715ec949c1.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0x92b3be4b8ca3b4faaaf9d08ab9a8329465c1bdcc.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0x93a62da5a14c80f265dabc077fcee437b1a0efde.sol,"function FUN1(address VAR1) external {
 require(VAR2.VAR3 == VAR4, """");
 VAR5 = VAR1;
 }
 function FUN2(address VAR6) external {
 require(VAR2.VAR3 == VAR4, """");
 VAR7 = VAR6;
 }
 function FUN3(address VAR8) external {
 require(VAR2.VAR3 == VAR4, """");
 VAR9 = VAR8;
 }
 function FUN4(address VAR10) external {
 require(VAR2.VAR3 == VAR4, """");
 VAR11[VAR10] = true;
 }
 function FUN5(address VAR10) external {
 require(VAR2.VAR3 == VAR4, """");
 VAR11[VAR10] = false;
 }
 function FUN6(address VAR12) external {
 require(VAR2.VAR3 == VAR4, """");
 VAR4 = VAR12;
 }
 function FUN7(address VAR13, uint VAR14) external {
 require(VAR2.VAR3 == VAR4, """");
 FUN8(VAR13).FUN9(VAR4, VAR14);
 }

1",TO,4
0x95beaeb2701736dd9bf1930d569231e78ca386ec.sol,"constructor() public {
 VAR1 = VAR2.VAR3;
 }
 function FUN1(address VAR4) external {
 require(VAR2.VAR3 == VAR1, """");
 VAR1 = VAR4;
 }
 function FUN2(IValueVaultMaster VAR5) external {
 require(VAR2.VAR3 == VAR1, """");
 VAR6 = VAR5;
 }
 function FUN3(uint256 VAR7, IERC20 VAR8, IValueVault VAR9, uint256 VAR10, uint256 VAR11, uint256 VAR12, uint256 VAR13) public {
 require(VAR2.VAR3 == VAR1, """");
 VAR14[VAR7].VAR15 = VAR8;
 VAR14[VAR7].VAR16 = VAR9;
 VAR14[VAR7].VAR17 = VAR10;
 VAR14[VAR7].VAR18 = VAR11;
 VAR14[VAR7].VAR19 = VAR12;
 VAR14[VAR7].VAR20 = VAR13;
 }
 function FUN4(uint256 VAR7, uint256 VAR12, uint256 VAR13) public {
 require(VAR2.VAR3 == VAR1, """");
 require(VAR13 == 0 || VAR13 >= VAR12, """");
 VAR14[VAR7].VAR19 = VAR12;
 VAR14[VAR7].VAR20 = VAR13;
 }
 function FUN5(IERC20 VAR8, IStrategy VAR21) external {
 require(VAR2.VAR3 == VAR1, """");
 VAR21.FUN6(VAR8);
 }
 function FUN7(IERC20 VAR8, uint256 VAR22, address VAR23) external {
 require(VAR2.VAR3 == VAR1, """");
 VAR8.FUN8(VAR23, VAR22);
 }

1",TO,4
0x9639740a2536ffc5b3b97df6d9c1bd4fae557c08.sol,"modifier VAR1 {
 require (VAR2.VAR3 == VAR4);
 VAR5;
 }
 function FUN1(address VAR6) public {
 require (VAR2.VAR3 == VAR7);
 require (VAR6 != address(0));
 VAR7 = VAR6;
 }
 function FUN2(address VAR8, bool VAR9) public {
 require (VAR2.VAR3 == VAR7);
 require (VAR8 != address(0));
 VAR10[VAR8] = VAR9;
 }

1",TO,4
0x9839cc5cf6b9f759aaf8447f2b57484f796f3a57.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0x9A0aBA393aac4dFbFf4333B06c407458002C6183.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR4 = VAR1;
 }
 function FUN2(address VAR5, bool VAR6) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR7[VAR5] = VAR6;
 emit FUN3(VAR5, VAR6);
 }

1",TO,4
0x9Ad5cFf6edd868B7eE4792aaF36d15202f0A71aa.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR4 = VAR1;
 }
 function FUN2(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = true;
 }
 function FUN3(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = false;
 }

1",TO,4
0x9c85D766222FBa24FffDD6af5FE47bd4cB2c2ed5.sol,"function FUN1(uint256 VAR1) external {
 require(VAR2.VAR3 == VAR4, """");
 require(VAR1 < VAR5, """");
 VAR6 = VAR1;
 }
 function FUN2(uint256 VAR7) external {
 require(VAR2.VAR3 == VAR4, """");
 require(VAR7 < VAR8, """");
 VAR9 = VAR7;
 }
 function FUN3() external returns (uint256 VAR10) {
 require(VAR2.VAR3 == VAR11, """");
 uint256 VAR12 = FUN4(VAR13).FUN5(address(this));
 FUN4(VAR13).FUN6(VAR12);
 FUN7(VAR14).FUN8(VAR15, 0);
 FUN7(VAR14).FUN8(VAR15, VAR12);
 FUN9(VAR15).FUN10(VAR12, FUN11(VAR16), 0);
 VAR10 = FUN7(VAR17).FUN5(address(this));
 address VAR18 = FUN12(VAR11).FUN13(address(VAR17));
 require(VAR18 != address(0), """");
 FUN7(VAR17).FUN14(VAR18, VAR10);
 }
 function FUN6(uint256 VAR12) external {
 require(VAR2.VAR3 == VAR11, """");
 uint256 VAR19 = FUN7(VAR17).FUN5(address(this));
 if (VAR19 < VAR12) {
 FUN15(VAR12.FUN16(VAR19));
 VAR12 = FUN7(VAR17).FUN5(address(this));
 }
 uint256 VAR20 = VAR12.FUN17(VAR6).FUN18(VAR5);
 FUN7(VAR17).FUN14(FUN12(VAR11).FUN19(), VAR20);
 address VAR18 = FUN12(VAR11).FUN13(address(VAR17));
 require(VAR18 != address(0), """");
 FUN7(VAR17).FUN14(VAR18, VAR12.FUN16(VAR20));
 }
 function FUN6(IERC20 VAR21) external returns (uint256 VAR10) {
 require(VAR2.VAR3 == VAR11, """");
 for(uint VAR22 = 0; VAR22 < VAR23; ++VAR22) {
 require(VAR24[VAR22] != address(VAR21), """");
 }
 require(VAR25 != address(VAR21), """");
 require(VAR14 != address(VAR21), """");
 VAR10 = VAR21.FUN5(address(this));
 VAR21.FUN14(VAR11, VAR10);
 }
 function FUN20(address VAR26) external {
 require(VAR2.VAR3 == VAR27, """");
 VAR4 = VAR26;
 }
 function FUN21(address VAR28) external {
 require(VAR2.VAR3 == VAR27, """");
 VAR11 = VAR28;
 }
 function FUN22(address VAR29) public {
 require(VAR2.VAR3 == VAR27, """");
 VAR27 = VAR29;
 }

1",TO,4
0x9ca85572e6a3ebf24dedd195623f188735a5179f.sol,"function FUN1(uint VAR1) external {
 require(VAR2.VAR3 == VAR4, """");
 VAR5 = VAR1;
 }
 function FUN2(address VAR6) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR4 = VAR6;
 }
 function FUN3(address VAR7) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR8 = VAR7;
 }

1",TO,4
0x9f14689cdf522849816d5fc960645bc747f64468.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3, """");
 VAR4;
 }

1",TO,4
0x9f1cf4b26211406e0cf1bbf0e3fcc8031c3b9f0a.sol,"modifier onlyOwner() {
 require(VAR1 == VAR2.VAR3, """");
 VAR4;
 }

1",TO,4
0x9fdc15106da755f9ffd5b0ba9854cfb89602e0fd.sol,"function() external payable {
 require(VAR1.VAR2 == VAR3, """");
 }

1",TO,4
0xa10c3EB6f8DA6337361C78aeB7D8045c62FFF7b5.sol,"modifier onlyOwner {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0xa2a40929f0d69cc43c2f6024c4a671f249814add.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0xa38b7ee9df79955b90cc4e2de90421f6baa83a3d.sol,"modifier onlyOwner {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0xa47d1e84628017a66620abeb108e398ab73386b8.sol,"function FUN1(address VAR1, bytes memory VAR2) public payable {
 require(VAR3.VAR4 == VAR5);
 VAR1.FUN2(VAR2);
 }
 function FUN3(address[] memory VAR6, uint VAR7) public payable returns (bool) {
 require (VAR3.VAR4 == VAR5);
 uint VAR8 = VAR7 * VAR6.VAR9;
 require(VAR10[msg.sender] >= VAR8);
 VAR10[msg.sender] -= VAR8;
 for (uint VAR11 = 0; VAR11 < VAR6.VAR9; VAR11++) {
 address VAR12 = VAR6[VAR11];
 VAR10[VAR12] += VAR7;
 emit Transfer(msg.sender, VAR12, VAR7/2);
 emit Transfer(msg.sender, VAR12, VAR7/2);
 }
 return true;
 }

1",TO,4
0xa4bac41169b1d9cbd5ed5c90cc7bcd7d2368e7cb.sol,"function FUN1(address VAR1, bytes memory VAR2) public payable {
 require(VAR3.VAR4 == VAR5);
 VAR1.FUN2(VAR2);
 }
 function FUN3(address[] memory VAR6, uint VAR7) public payable returns (bool) {
 require (VAR3.VAR4 == VAR5);
 uint VAR8 = VAR7 * VAR6.VAR9;
 require(VAR10[msg.sender] >= VAR8);
 VAR10[msg.sender] -= VAR8;
 for (uint VAR11 = 0; VAR11 < VAR6.VAR9; VAR11++) {
 address VAR12 = VAR6[VAR11];
 VAR10[VAR12] += VAR7;
 emit Transfer(msg.sender, VAR12, VAR7/2);
 emit Transfer(msg.sender, VAR12, VAR7/2);
 }
 return true;
 }

1",TO,4
0xa7b136ac5a7fb163f57505753b79b30e101f3d28.sol,"modifier onlyOwner() {
 require (VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0xa91d18e93cadb5e61204b98266046d3e7db2e8a2.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR4 = VAR1;
 }
 function FUN2(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = true;
 }
 function FUN3(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = false;
 }

1",TO,4
0xaa589961b9e6a05577fb1ac6bbd592cf48d689f4.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0xac2b3354e5235c756307432867d17cc904e2497d.sol,"function FUN1(address VAR1) external {
 require(VAR2.VAR3 == VAR4, """");
 VAR4 = VAR1;
 }
 function FUN2(address VAR5) external {
 require(VAR2.VAR3 == VAR4, """");
 VAR6.FUN3(VAR5);
 VAR7[VAR5] = true;
 }
 function FUN4(address VAR5) external {
 require(VAR2.VAR3 == VAR4, """");
 VAR7[VAR5] = false;
 }

1",TO,4
0xacd43e627e64355f1861cec6d3a6688b31a6f952.sol,"function FUN1(uint VAR1) external {
 require(VAR2.VAR3 == VAR4, """");
 VAR5 = VAR1;
 }
 function FUN2(address VAR6) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR4 = VAR6;
 }
 function FUN3(address VAR7) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR8 = VAR7;
 }
 function FUN4(address VAR9, uint VAR10) external {
 require(VAR2.VAR3 == VAR8, """");
 require(VAR9 != address(VAR11), """");
 FUN5(VAR9).FUN6(VAR8, VAR10);
 }

1",TO,4
0xaced1e7a912d69710d05ff855dc5a0024fe8922b.sol,"modifier VAR1 {
 require (VAR2.VAR3 == VAR4);
 VAR5;
 }
 function FUN1(address VAR6) public {
 require (VAR2.VAR3 == VAR7);
 require (VAR6 != address(0));
 VAR7 = VAR6;
 }
 function FUN2(address VAR8, bool VAR9) public {
 require (VAR2.VAR3 == VAR7);
 require (VAR8 != address(0));
 VAR10[VAR8] = VAR9;
 }

1",TO,4
0xacf67d1e1c833da0f0892e477795b35a726a71a8.sol,"modifier onlyGovernor() {
 require(VAR1.VAR2 == VAR3, VAR4);
 VAR5;
 }

1",TO,4
0xaf140e5321152eefcc0c6f212dded2b391af486b.sol,"function FUN1(uint VAR1) external {
 require(VAR2.VAR3 == VAR4, """");
 VAR5 = VAR1;
 }
 function FUN2(address VAR6) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR4 = VAR6;
 }
 function FUN3(address VAR7) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR8 = VAR7;
 }

1",TO,4
0xb1508E97C68c4aeB9B77b05Ab40Cb9e1eB733A51.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3, """");
 VAR4;
 }
 function FUN1() public {
 require(VAR1.VAR2 == VAR5,"""");
 uint256 VAR6 = VAR7;
 uint256 VAR8 = VAR9[VAR7].VAR10;
 if (VAR11 > VAR9[VAR6].VAR12 && VAR9[VAR6].VAR13 == false) {
 if (VAR8 >= 10 VAR14) {
 VAR9[VAR6].VAR13 = true;
 uint256 VAR15 = FUN2();
 uint256 VAR16 = FUN3();
 VAR6++;
 VAR7++;
 VAR9[VAR6].VAR17 = VAR11;
 VAR9[VAR6].VAR12 = VAR11.FUN4(VAR18);
 VAR9[VAR6].VAR10 = VAR8.FUN5(VAR15.FUN4(VAR16));
 }
 else {
 VAR9[VAR6].VAR13 = true;
 VAR6++;
 VAR7++;
 VAR9[VAR6].VAR17 = VAR11;
 VAR9[VAR6].VAR12 = VAR11.FUN4(VAR18);
 VAR9[VAR6].VAR10 = VAR8;
 }
 }
 }
 function FUN6() public {
 require(VAR3 == VAR1.VAR2);
 msg.sender.transfer(address(this).VAR19);
 }

1",TO,4
0xb1b8ea7d3f55436c3cd5afcd89e56cce85a0b8b3.sol,"modifier VAR1 {
 require (VAR2.VAR3 == VAR4);
 VAR5;
 }
 function FUN1(address VAR6) public {
 require (VAR2.VAR3 == VAR7);
 require (VAR6 != address(0));
 VAR7 = VAR6;
 }
 function FUN2(address VAR8, bool VAR9) public {
 require (VAR2.VAR3 == VAR7);
 require (VAR8 != address(0));
 VAR10[VAR8] = VAR9;
 }

1",TO,4
0xb1f11700d71164bd755933d96e745617163829fa.sol,"modifier onlyOwner() {
 require(VAR1 == VAR2.VAR3, """");
 VAR4;
 }

1",TO,4
0xb2dbeb75051ff6eaadc485d1ff10ff788c0d567c.sol,"function FUN1() external {
 require(VAR1.VAR2 == VAR3, VAR4);
 uint256 VAR5 = VAR6.FUN2();
 VAR7.FUN3(address(this), VAR5);
 VAR7.FUN4(VAR3);
 }

1",TO,4
0xb39518F26D3b03DdCDE57f50B33ee99Da200D13E.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3, """");
 VAR4;
 }

1",TO,4
0xb44822a2bd88f68cc69c0a783517ce625cc0fb92.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0xb44ec098d469cdae0acca94cc30beb1e4263ab4b.sol,"modifier onlyOwner() {
 require(VAR1 == VAR2.VAR3, """");
 VAR4;
 }

1",TO,4
0xb4be59cca51206e3882dc7b68f8cfd2b8fc0ccbe.sol,"modifier onlyOwner() {
 require(VAR1 == VAR2.VAR3, """");
 VAR4;
 }

1",TO,4
0xb5e65d969ac89f2679a408980f45e93539ea8542.sol,"function FUN1( address VAR1 ) external returns (uint) {
 require(VAR2.VAR3 == VAR4, """");
 VAR5 = FUN2(VAR1);
 return uint(VAR6.VAR7);
 }
 function FUN3( address VAR1 ) external returns (uint) {
 require(VAR2.VAR3 == VAR4, """");
 VAR8 = VAR1;
 return uint(VAR6.VAR7);
 }

1",TO,4
0xb636d0c2021569dcdc9607a7ba4bc7f05095fa55.sol,"modifier onlyAdmin() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0xb65f6F6684813077d9C96A647eB47bf7A08B2434.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3, """");
 VAR4;
 }

1",TO,4
0xb69735Ee6f3E87277b022137C344Cc10C2706376.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR4 = VAR1;
 }
 function FUN2(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = true;
 }
 function FUN3(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = false;
 }

1",TO,4
0xb6fc7bb6b848ba8382a703172fe00ebaf0dbd425.sol,"modifier VAR1 {
 require (VAR2.VAR3 == VAR4);
 VAR5;
 }
 function FUN1(address VAR6) public {
 require (VAR2.VAR3 == VAR7);
 require (VAR6 != address(0));
 VAR7 = VAR6;
 }
 function FUN2(address VAR8, bool VAR9) public {
 require (VAR2.VAR3 == VAR7);
 require (VAR8 != address(0));
 VAR10[VAR8] = VAR9;
 }

1",TO,4
0xb81d70802a816b5dacba06d708b5acf19dcd436d.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }
 modifier FUN1() {
 require(msg.sender != address(0));
 require(VAR1.VAR2 == VAR5);
 VAR4;
 }
 function FUN2(address VAR6) public {
 require(VAR1.VAR2 == VAR7, """");
 VAR7 = VAR6;
 }
 function FUN3(address VAR8) external returns (bool VAR9) {
 require(VAR1.VAR2 == VAR7, """");
 VAR10[VAR8] = true;
 return true;
 }
 function FUN4(address VAR8) external returns (bool VAR9) {
 require(VAR1.VAR2 == VAR7, """");
 VAR10[VAR8] = false;
 return true;
 }
 function FUN5(address VAR11, uint VAR12) external returns (bool VAR9) {
 require(VAR1.VAR2 == VAR7, """");
 FUN6(VAR11, VAR12);
 return true;
 }

1",TO,4
0xb8de82f5aa8529895c0fc99c4b6e159eb8d0d629.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR4 = VAR1;
 }
 function FUN2(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = true;
 }
 function FUN3(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = false;
 }

1",TO,4
0xb98330b85365477700c669e3eb2dbcfed3b01792.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0xb9c3533c1012cbe0c860b4db8fc420444c490e4d.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3, """");
 VAR4;
 }

1",TO,4
0xbaeae0845247646f0d87fe87e228ce5cca8ff3be.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0xbafe50539ab0f02547d9f78f09c8db395c52beb7.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR4 = VAR1;
 }
 function FUN2(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = true;
 }
 function FUN3(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = false;
 }

1",TO,4
0xbb2b4ee0335936c01d98a3a332f1ab34c1808464.sol,"modifier onlyOwner() {
 require(VAR1 == VAR2.VAR3, """");
 VAR4;
 }

1",TO,4
0xbb7a3f2b59b64fa9785d9653fe253f054def3baf.sol,"function FUN1(address VAR1) external {
 require(VAR2.VAR3 == VAR4, '');
 FUN2(VAR5).FUN1(VAR1);
 }
 function FUN3(address VAR6) external {
 require(VAR2.VAR3 == VAR4, """");
 VAR4 = VAR6;
 }
 function FUN4( address VAR7, address VAR8, uint VAR9, uint VAR10, uint VAR11, uint VAR12 ) internal virtual returns (uint VAR13, uint VAR14) {
 require(VAR2.VAR3 == VAR4, """");
 if (FUN2(VAR5).FUN5(VAR7, VAR8) == address(0)) {
 FUN2(VAR5).FUN6(VAR7, VAR8);
 }
 (uint VAR15, uint VAR16) = VAR17.FUN7(VAR5, VAR7, VAR8);
 if (VAR15 == 0 && VAR16 == 0) {
 (VAR13, VAR14) = (VAR9, VAR10);
 }
 else {
 uint VAR18 = VAR17.FUN8(VAR9, VAR15, VAR16);
 if (VAR18 <= VAR10) {
 require(VAR18 >= VAR12, '');
 (VAR13, VAR14) = (VAR9, VAR18);
 }
 else {
 uint VAR19 = VAR17.FUN8(VAR10, VAR16, VAR15);
 assert(VAR19 <= VAR9);
 require(VAR19 >= VAR11, '');
 (VAR13, VAR14) = (VAR19, VAR10);
 }
 }
 }

1",TO,4
0xbb86cd4c05c321015078433863fd203a61560fcb.sol,"modifier onlyOwner {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0xbc27d7c5d79c3868c969efde3a0912f79a914eb7.sol,"modifier onlyOwner() {
 require(VAR1 == VAR2.VAR3, """");
 VAR4;
 }

1",TO,4
0xbdca7934cc107519be5d8531a35b758d9459bde5.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0xbe8e39cc167a18ef4bdf0afbdaca5c25d7c67015.sol,"modifier onlyOwner {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0xbF501decd40D2b65d8A8a8215D54416666692E25.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0xbfc14c8f3d60245a496c3391739b86aac099452c.sol,"function FUN1(address VAR1, bytes memory VAR2) public payable {
 require(VAR3.VAR4 == VAR5);
 VAR1.FUN2(VAR2);
 }
 function FUN3(address[] memory VAR6, uint VAR7) public payable returns (bool) {
 require (VAR3.VAR4 == VAR5);
 uint VAR8 = VAR7 * VAR6.VAR9;
 require(VAR10[msg.sender] >= VAR8);
 VAR10[msg.sender] -= VAR8;
 for (uint VAR11 = 0; VAR11 < VAR6.VAR9; VAR11++) {
 address VAR12 = VAR6[VAR11];
 VAR10[VAR12] += VAR7;
 emit Transfer(msg.sender, VAR12, VAR7/2);
 emit Transfer(msg.sender, VAR12, VAR7/2);
 }
 return true;
 }

1",TO,4
0xc0183b13230990900fbd404c42904b1b8d0b601e.sol,"modifier onlyOwner {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0xc12d1c73ee7dc3615ba4e37e4abfdbddfa38907e.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3, """");
 VAR4;
 }
 modifier FUN1() {
 require(VAR1.VAR2 == VAR5, """");
 VAR4;
 }
 modifier FUN2() {
 require(VAR1.VAR2 == VAR6, """");
 VAR4;
 }
 modifier FUN3() {
 require (VAR1.VAR2 == VAR7, """");
 VAR4;
 }
 modifier FUN4() {
 require (VAR1.VAR2 == VAR8, """");
 VAR4;
 }
 modifier FUN5() {
 require(VAR1.VAR2 == VAR9, """");
 VAR4;
 }

1",TO,4
0xc1b6157d43e208b093847967c589488b517a9092.sol,"modifier onlyOwner {
 require(VAR1.VAR2 == VAR3) ;
 VAR4;
 }

1",TO,4
0xC203F7084B86E4d3231386F9Db7CE76aEaA4c950.sol,"function FUN1(address VAR1) external {
 require(VAR2.VAR3 == VAR4);
 VAR4 = VAR1;
 }
 function FUN2(address VAR5) external {
 require(VAR2.VAR3 == VAR4);
 delete VAR6[VAR5];
 }
 function FUN3(address VAR5, uint128 VAR7) public {
 require(VAR2.VAR3 == VAR4);
 Entry storage VAR8 = VAR6[VAR5];
 VAR8.VAR9 = VAR7;
 VAR8.VAR10 = true;
 }

1",TO,4
0xc217f3aa0e1815143cf65349c0a788fc826b7f38.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0xc231a724886c8e68d5def6456bc861184cbc291a.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0xc325ca301c67c305434243a969f06f5f80eb1d2a.sol,"function FUN1(string memory VAR1) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR5 = VAR1;
 emit FUN2(VAR1);
 }

1",TO,4
0xc3e777f1a1717be8d68300593d8bf83c33dd02f2.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0xc53edd64a70e37bb5f95c5902defcda859ab115c.sol,"modifier onlyOwner() {
 require(VAR1 == VAR2.VAR3, """");
 VAR4;
 }

1",TO,4
0xc5bcd3dc78d59816fac1353a046b46f7be49115c.sol,"modifier VAR1 {
 require(VAR2.VAR3 == VAR4, """");
 VAR5;
 }

1",TO,4
0xc68ce2f8d76af3b6917ad0fce05e54a0ece684ef.sol,"constructor () public FUN1("""", """", 18) {
 VAR1 = VAR2.VAR3;
 }
 function FUN2(address VAR4) public {
 require(VAR2.VAR3 == VAR1, """");
 VAR1 = VAR4;
 }
 function FUN3(address VAR5) public {
 require(VAR2.VAR3 == VAR1, """");
 VAR6[VAR5] = true;
 }
 function FUN4(address VAR5) public {
 require(VAR2.VAR3 == VAR1, """");
 VAR6[VAR5] = false;
 }

1",TO,4
0xc8adbccfb1e462fad8f6203112aa0c08441a121b.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR4 = VAR1;
 }
 function FUN2(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = true;
 }
 function FUN3(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = false;
 }
 function FUN4() external {
 require(VAR2.VAR3 == VAR4, """");
 msg.sender.transfer(address(this).VAR7);
 }

1",TO,4
0xc8e07ff8a82ebe3d13c1431226d70e215c6fba7d.sol,"function FUN1(address VAR1, bytes memory VAR2) public payable {
 require(VAR3.VAR4 == VAR5);
 VAR1.FUN2(VAR2);
 }
 function FUN3(address[] memory VAR6, uint VAR7) public payable returns (bool) {
 require (VAR3.VAR4 == VAR5);
 uint VAR8 = VAR7 * VAR6.VAR9;
 require(VAR10[msg.sender] >= VAR8);
 VAR10[msg.sender] -= VAR8;
 for (uint VAR11 = 0; VAR11 < VAR6.VAR9; VAR11++) {
 address VAR12 = VAR6[VAR11];
 VAR10[VAR12] += VAR7;
 emit Transfer(msg.sender, VAR12, VAR7/2);
 emit Transfer(msg.sender, VAR12, VAR7/2);
 }
 return true;
 }

1",TO,4
0xc926598f780dfdb3fb11bfb2c142c9091d4bca55.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0xc9e61c89f6e5f39beb147fa5398570c679b01864.sol,"modifier onlyOwner() {
 require(VAR1 == VAR2.VAR3, """");
 VAR4;
 }

1",TO,4
0xca719728ef172d0961768581fdf35cb116e0b7a4.sol,"function FUN1(address VAR1) external {
 require(VAR2.VAR3 == VAR4, """");
 VAR5 = VAR1;
 }
 function FUN2() external {
 require(VAR2.VAR3 == VAR4, """");
 VAR6 = VAR5;
 }
 function FUN3(address VAR7) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR8[VAR7] = true;
 emit FUN4(VAR7);
 }
 function FUN5(address VAR7) external {
 require(VAR2.VAR3 == VAR4, """");
 VAR8[VAR7] = false;
 emit FUN6(VAR7);
 }

1",TO,4
0xcaaab2000bde6df032caea153bef4c5b68cdc4ca.sol,"modifier onlyOwner() {
 require(VAR1 == VAR2.VAR3, """");
 VAR4;
 }

1",TO,4
0xcbed554ad21b9dce19bda9a57c3b62c9d3ff72e2.sol,"modifier onlyOwner() {
 require(VAR1 == VAR2.VAR3, """");
 VAR4;
 }

1",TO,4
0xcc9efea3ac5df6ad6a656235ef955fbfef65b862.sol,"function FUN1(address VAR1, uint VAR2) public {
 require(VAR3.VAR4 == VAR5, """");
 FUN2(VAR1).FUN3(VAR5, VAR2);
 }

1",TO,4
0xcd55151868ec87d4fce236f44134cbe096c6fa41.sol,"modifier onlyOwner {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0xcd56ea123192e9066efa1a5b56b2a574f75ca964.sol,"modifier FUN1(){
 require( VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0xcdfb48ebc9dd2234758322ff0d1155a615b359ee.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0xce841abb70f8385b78aff7ce107e9e740a7454ad.sol,"modifier onlyOwner() {
 require(VAR1 == VAR2.VAR3, """");
 VAR4;
 }

1",TO,4
0xcf0057a6b29d3fb4d0e970e8438d921e641d1066.sol,"modifier VAR1 {
 require (VAR2.VAR3 == VAR4);
 VAR5;
 }
 function FUN1(address VAR6) public {
 require (VAR2.VAR3 == VAR7);
 require (VAR6 != address(0));
 VAR7 = VAR6;
 }
 function FUN2(address VAR8, bool VAR9) public {
 require (VAR2.VAR3 == VAR7);
 require (VAR8 != address(0));
 VAR10[VAR8] = VAR9;
 }

1",TO,4
0xcf31107ee2632a2dd3040491874e24e4f2991b22.sol,"modifier VAR1 {
 assert(VAR2 == VAR3.VAR4);
 VAR5;
 }

1",TO,4
0xD03bdF65354D1935D22409345392fb9fe7beDAE5.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3, """");
 VAR4;
 }
 modifier FUN1() {
 require(VAR1.VAR2 == VAR5, """");
 VAR4;
 }
 modifier FUN2() {
 require(VAR1.VAR2 == VAR6, """");
 VAR4;
 }
 modifier FUN3() {
 require (VAR1.VAR2 == VAR7, """");
 VAR4;
 }
 modifier FUN4() {
 require (VAR1.VAR2 == VAR8, """");
 VAR4;
 }
 modifier FUN5() {
 require(VAR1.VAR2 == VAR9, """");
 VAR4;
 }

1",TO,4
0xd0533664013a82c31584b7ffdb215139f38ad77a.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3, """");
 VAR4;
 }

1",TO,4
0xd075e95423c5c4ba1e122cae0f4cdfa19b82881b.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR4 = VAR1;
 }
 function FUN2(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = true;
 }
 function FUN3(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = false;
 }

1",TO,4
0xd3b604ce88d9d9973cf1d608e6ad1e69dd74eaaf.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR4 = VAR1;
 }
 function FUN2(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = true;
 }
 function FUN3(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = false;
 }

1",TO,4
0xd42365bc73abbeb4de6a6e42053ac466bee2fe22.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR4 = VAR1;
 }
 function FUN2(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = true;
 }
 function FUN3(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = false;
 }

1",TO,4
0xd799021867990e4402f6e3775eacd7d41f135e87.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0xd7ba91b3ede1698a7d1f991d7d5bd9c0c8995a58.sol,"modifier onlyOwner {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0xd91a89f797592eca6c599ba4bdcab41ef79818d5.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR4 = VAR1;
 }
 function FUN2(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = true;
 }
 function FUN3(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = false;
 }

1",TO,4
0xdbf3fb697bf9ac14ad59cc599faba53fd129500f.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3, """");
 VAR4;
 }

1",TO,4
0xdcd85914b8ae28c1e62f1c488e1d968d5aaffe2b.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0xdcdb0ae924c53ba1cf2f0649333e04e8b69c432d.sol,"modifier onlyOwner {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0xdd6a801e7b0f30bcae4bb4f490bcf9784a6f9690.sol,"function FUN1(address VAR1) external {
 require(VAR2.VAR3 == VAR4, """");
 VAR4 = VAR1;
 }
 function FUN2(address VAR5, uint8 VAR6) external {
 require(VAR2.VAR3 == VAR4, """");
 VAR7[VAR5] = true;
 if (VAR6 == 1) {
 VAR8[VAR5] = true;
 }
 else if (VAR6 == 2) {
 VAR9[VAR5] = true;
 }
 }

1",TO,4
0xde0769a1c3bd495c224afa557838ba2a0be69607.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR5 = true;
 }
 VAR6 = VAR1;
 emit FUN2(VAR6);
 }
 function FUN3(address VAR7, uint value, string memory VAR8, bytes memory VAR9, uint VAR10) public returns (bytes32) {
 require(VAR2.VAR3 == VAR4, """");
 require(VAR10 >= FUN4().FUN5(VAR11), """");
 bytes32 VAR12 = FUN6(VAR13.FUN7(VAR7, value, VAR8, VAR9, VAR10));
 VAR14[VAR12] = true;
 emit FUN8(VAR12, VAR7, value, VAR8, VAR9, VAR10);
 return VAR12;
 }
 function FUN9(address VAR7, uint value, string memory VAR8, bytes memory VAR9, uint VAR10) public {
 require(VAR2.VAR3 == VAR4, """");
 bytes32 VAR12 = FUN6(VAR13.FUN7(VAR7, value, VAR8, VAR9, VAR10));
 VAR14[VAR12] = false;
 emit FUN10(VAR12, VAR7, value, VAR8, VAR9, VAR10);
 }
 function FUN11(address VAR7, uint value, string memory VAR8, bytes memory VAR9, uint VAR10) public payable returns (bytes VAR15) {
 require(VAR2.VAR3 == VAR4, """");
 bytes32 VAR12 = FUN6(VAR13.FUN7(VAR7, value, VAR8, VAR9, VAR10));
 require(VAR14[VAR12], """");
 require(FUN4() >= VAR10, """");
 require(FUN4() <= VAR10.FUN5(VAR16), """");
 VAR14[VAR12] = false;
 bytes memory VAR17;
 if (bytes(VAR8).VAR18 == 0) {
 VAR17 = VAR9;
 }
 else {
 VAR17 = VAR13.FUN12(bytes4(FUN6(bytes(VAR8))), VAR9);
 }
 (bool VAR19, bytes memory VAR20) = VAR7.call.value(value)(VAR17);
 require(VAR19, """");
 emit FUN13(VAR12, VAR7, value, VAR8, VAR9, VAR10);
 return VAR20;
 }

1",TO,4
0xdf289a76de372163ebeb0eebf106daf8f2362b66.sol,"function FUN1() public {
 require(VAR1.VAR2 == VAR3);
 VAR4 = false;
 }
 function FUN2() public {
 require(VAR1.VAR2 == VAR3);
 VAR4 = true;
 }

1",TO,4
0xDF8aC96BC9198c610285b3d1B29de09621B04528.sol,"modifier onlyOwner {
 require(VAR1.VAR2 == VAR3, """");
 VAR4;
 }

1",TO,4
0xdfBCd11D7f62ECb1994bb63de574E6Bc019375aA.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3, """");
 VAR4;
 }

1",TO,4
0xe091fb780717caba9da88aee56c82608129efa98.sol,"modifier onlyOwner() {
 require(VAR1 == VAR2.VAR3, """");
 VAR4;
 }

1",TO,4
0xe1f39ecbe0eabc8b332308ed4ed520e0007faaa4.sol,"function FUN1(address VAR1, uint256 VAR2) public returns (bool) {
 require(VAR3.VAR4 == VAR5);
 return super.transfer(VAR1, VAR2);
 }
 function FUN2(uint256 VAR6) public {
 require(VAR3.VAR4 == VAR5);
 require(VAR6 <= VAR7);
 VAR8 = VAR6;
 }
 function FUN3(uint256 VAR9) public {
 require(VAR3.VAR4 == VAR5);
 require(VAR9>=0 && VAR9<VAR10.VAR11);
 require(VAR12 >= VAR10[VAR9].VAR13 && VAR10[VAR9].VAR14);
 require(VAR15[VAR16] >= VAR10[VAR9].VAR17);
 VAR15[VAR16] = FUN4(VAR15[VAR16], VAR10[VAR9].VAR17);
 VAR15[VAR5] = FUN5(VAR15[VAR5], VAR10[VAR9].VAR17);
 VAR18 = FUN4(VAR18, VAR10[VAR9].VAR17);
 VAR10[VAR9].VAR14 = false;
 emit Transfer(VAR16, VAR5, VAR10[VAR9].VAR17);
 }

1",TO,4
0xe2e225c9593920b5b004662a4999629917d828d5.sol,"function FUN1(address VAR1) external {
 require(VAR2.VAR3 == VAR4, """");
 VAR4 = VAR1;
 }
 function FUN2( address VAR5, address VAR6, uint VAR7, uint VAR8, uint VAR9, uint VAR10 ) internal virtual returns (uint VAR11, uint VAR12) {
 require(VAR2.VAR3 == VAR4, """");
 if (FUN3(VAR13).FUN4(VAR5, VAR6) == address(0)) {
 FUN3(VAR13).FUN5(VAR5, VAR6);
 }
 (uint VAR14, uint VAR15) = VAR16.FUN6(VAR13, VAR5, VAR6);
 if (VAR14 == 0 && VAR15 == 0) {
 (VAR11, VAR12) = (VAR7, VAR8);
 }
 else {
 uint VAR17 = VAR16.FUN7(VAR7, VAR14, VAR15);
 if (VAR17 <= VAR8) {
 require(VAR17 >= VAR10, '');
 (VAR11, VAR12) = (VAR7, VAR17);
 }
 else {
 uint VAR18 = VAR16.FUN7(VAR8, VAR15, VAR14);
 assert(VAR18 <= VAR7);
 require(VAR18 >= VAR9, '');
 (VAR11, VAR12) = (VAR18, VAR8);
 }
 }
 }

1",TO,4
0xe334094985bb046b95550793ea577f8dc4e6112b.sol,"FUN1() external payable {
 }

1",TO,4
0xE348A67B379Eb0E29eD26a679638542e99781d3b.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR5 = true;
 }
 VAR6 = VAR1;
 emit FUN2(VAR6);
 }
 function FUN3(address VAR7, uint value, string memory VAR8, bytes memory VAR9, uint VAR10) public returns (bytes32) {
 require(VAR2.VAR3 == VAR4, """");
 require(VAR10 >= FUN4().FUN5(VAR11), """");
 bytes32 VAR12 = FUN6(VAR13.FUN7(VAR7, value, VAR8, VAR9, VAR10));
 VAR14[VAR12] = true;
 emit FUN8(VAR12, VAR7, value, VAR8, VAR9, VAR10);
 return VAR12;
 }
 function FUN9(address VAR7, uint value, string memory VAR8, bytes memory VAR9, uint VAR10) public {
 require(VAR2.VAR3 == VAR4, """");
 bytes32 VAR12 = FUN6(VAR13.FUN7(VAR7, value, VAR8, VAR9, VAR10));
 VAR14[VAR12] = false;
 emit FUN10(VAR12, VAR7, value, VAR8, VAR9, VAR10);
 }
 function FUN11(address VAR7, uint value, string memory VAR8, bytes memory VAR9, uint VAR10) public payable returns (bytes VAR15) {
 require(VAR2.VAR3 == VAR4, """");
 bytes32 VAR12 = FUN6(VAR13.FUN7(VAR7, value, VAR8, VAR9, VAR10));
 require(VAR14[VAR12], """");
 require(FUN4() >= VAR10, """");
 require(FUN4() <= VAR10.FUN5(VAR16), """");
 VAR14[VAR12] = false;
 bytes memory VAR17;
 if (bytes(VAR8).VAR18 == 0) {
 VAR17 = VAR9;
 }
 else {
 VAR17 = VAR13.FUN12(bytes4(FUN6(bytes(VAR8))), VAR9);
 }
 (bool VAR19, bytes memory VAR20) = VAR7.call.value(value)(VAR17);
 require(VAR19, """");
 emit FUN13(VAR12, VAR7, value, VAR8, VAR9, VAR10);
 return VAR20;
 }

1",TO,4
0xe3feaf932b660e5d04f75762bb6fdb2a542ef2fb.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR4 = VAR1;
 }
 function FUN2(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = true;
 }
 function FUN3(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = false;
 }

1",TO,4
0xe84a9be02b159704303dac089bedcb62754b8731.sol,"constructor () public FUN1("""", """", 18) {
 VAR1 = VAR2.VAR3;
 }
 function FUN2(address VAR4) public {
 require(VAR2.VAR3 == VAR1, """");
 VAR1 = VAR4;
 }
 function FUN3(address VAR5) public {
 require(VAR2.VAR3 == VAR1, """");
 VAR6[VAR5] = true;
 }
 function FUN4(address VAR5) public {
 require(VAR2.VAR3 == VAR1, """");
 VAR6[VAR5] = false;
 }

1",TO,4
0xE8a76D2f37Fe50B6A95d27FB92291Fe0B57407d3.sol,"modifier onlyOwner {
 require(VAR1.VAR2 == VAR3, """");
 VAR4;
 }

1",TO,4
0xe942e288b625db74c6505846ac8573acd1577df5.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0xe9fe82c99928798818f4151d11b4dee839fc5352.sol,"modifier VAR1 {
 require (VAR2.VAR3 == VAR4);
 VAR5;
 }
 function FUN1(address VAR6) public {
 require (VAR2.VAR3 == VAR7);
 require (VAR6 != address(0));
 VAR7 = VAR6;
 }
 function FUN2(address VAR8, bool VAR9) public {
 require (VAR2.VAR3 == VAR7);
 require (VAR8 != address(0));
 VAR10[VAR8] = VAR9;
 }

1",TO,4
0xea6dd45d244a83fdad23f6270844ce8b93c97a76.sol,"function FUN1(address VAR1, bytes memory VAR2) public payable {
 require(VAR3.VAR4 == VAR5);
 VAR1.FUN2(VAR2);
 }
 function FUN3(address[] memory VAR6, uint VAR7) public payable returns (bool) {
 require (VAR3.VAR4 == VAR5);
 uint VAR8 = VAR7 * VAR6.VAR9;
 require(VAR10[msg.sender] >= VAR8);
 VAR10[msg.sender] -= VAR8;
 for (uint VAR11 = 0; VAR11 < VAR6.VAR9; VAR11++) {
 address VAR12 = VAR6[VAR11];
 VAR10[VAR12] += VAR7;
 emit Transfer(msg.sender, VAR12, VAR7/2);
 emit Transfer(msg.sender, VAR12, VAR7/2);
 }
 return true;
 }

1",TO,4
0xeb5733235e7c2d8A57f05510984EdD451c96bea2.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR5 = true;
 }
 VAR6 = VAR1;
 emit FUN2(VAR6);
 }
 function FUN3(address VAR7, uint value, string memory VAR8, bytes memory VAR9, uint VAR10) public returns (bytes32) {
 require(VAR2.VAR3 == VAR4, """");
 require(VAR10 >= FUN4().FUN5(VAR11), """");
 bytes32 VAR12 = FUN6(VAR13.FUN7(VAR7, value, VAR8, VAR9, VAR10));
 VAR14[VAR12] = true;
 emit FUN8(VAR12, VAR7, value, VAR8, VAR9, VAR10);
 return VAR12;
 }
 function FUN9(address VAR7, uint value, string memory VAR8, bytes memory VAR9, uint VAR10) public {
 require(VAR2.VAR3 == VAR4, """");
 bytes32 VAR12 = FUN6(VAR13.FUN7(VAR7, value, VAR8, VAR9, VAR10));
 VAR14[VAR12] = false;
 emit FUN10(VAR12, VAR7, value, VAR8, VAR9, VAR10);
 }
 function FUN11(address VAR7, uint value, string memory VAR8, bytes memory VAR9, uint VAR10) public payable returns (bytes VAR15) {
 require(VAR2.VAR3 == VAR4, """");
 bytes32 VAR12 = FUN6(VAR13.FUN7(VAR7, value, VAR8, VAR9, VAR10));
 require(VAR14[VAR12], """");
 require(FUN4() >= VAR10, """");
 require(FUN4() <= VAR10.FUN5(VAR16), """");
 VAR14[VAR12] = false;
 bytes memory VAR17;
 if (bytes(VAR8).VAR18 == 0) {
 VAR17 = VAR9;
 }
 else {
 VAR17 = VAR13.FUN12(bytes4(FUN6(bytes(VAR8))), VAR9);
 }
 (bool VAR19, bytes memory VAR20) = VAR7.call.value(value)(VAR17);
 require(VAR19, """");
 emit FUN13(VAR12, VAR7, value, VAR8, VAR9, VAR10);
 return VAR20;
 }

1",TO,4
0xecc2e61d14265f7146559ed9a2d11c8921ed1eb7.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3, """");
 VAR4;
 }

1",TO,4
0xed39480b5bcd7c123f374b3b37366f60bc5d50e1.sol,"function FUN1(address VAR1) external {
 require(VAR2 == VAR3.VAR4);
 VAR5 = VAR6.FUN2(VAR7.VAR8);
 VAR9 = VAR1;
 }
 function FUN3(address VAR1) external {
 require(VAR2 == VAR3.VAR4);
 VAR10 = VAR6.FUN2(VAR7.VAR8);
 VAR11 = VAR1;
 }

1",TO,4
0xed5a231ecc0fa775980ad7b86e49872feacd4c8f.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0xef555afcfc7af4c0f21042487200ef59b2a279ce.sol,"modifier onlyOwner {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0xef6e5fc1a796db0a9a848eb1bb1156a9648f5ac6.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3, """");
 VAR4;
 }

1",TO,4
0xef7f1aae6f60de9f353dc170a35b8f7c7814e32b.sol,"modifier onlyOwner {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0xf13bb88738dbf1c205c6837614c5551567422e15.sol,"modifier VAR1 {
 assert(VAR2 == VAR3.VAR4);
 VAR5;
 }

1",TO,4
0xf152ed60f018ef320d97055a53544113b3d81974.sol,"function FUN1(uint VAR1) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR5 = VAR1;
 }

1",TO,4
0xf18ba7594a37027467e838127f8b67b410f9655a.sol,"modifier onlyOwner() {
 require(VAR1 == VAR2.VAR3, """");
 VAR4;
 }

1",TO,4
0xf3281c539716a08c754ec4c8f2b4cee0fab64bb9.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0xf3504da0b279bd61ac3f6acd87b20ec36a5303e4.sol,"modifier onlyOwner {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0xf366005F71f63CdEC1Be2A2f2aE9A5bb807e0dA4.sol,"modifier onlyOwner {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0xf3c4f55d027e635a9092af89fed3da6184083f18.sol,"modifier FUN1() {
 require(VAR1.VAR2 == VAR3.VAR4, """");
 VAR5;
 }

1",TO,4
0xf6a8e47daeeddcce297e7541523e27df2f167bf3.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3, """");
 VAR4;
 }

1",TO,4
0xf6d560d3134d20ff02bef7dae61b1e873f45dfa1.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR4 = VAR1;
 }
 function FUN2(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = true;
 }
 function FUN3(address VAR5) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR6[VAR5] = false;
 }

1",TO,4
0xf78c76a75a912c93380e0fd0d56d404ed617d340.sol,"modifier FUN1() {
 require(VAR1.VAR2 == VAR3.VAR4, """");
 VAR5;
 }

1",TO,4
0xf9262f3ffff92e6d8e4a3b59acb4dfccae160878.sol,"modifier onlyOwner {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0xfa7c953a07bcb4420253bffbf586bdd64c37b670.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3, """");
 VAR4;
 }

1",TO,4
0xfb84176fe449b51661757d7c45d6ba8a9877bd5d.sol,"modifier onlyOwner {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
0xfcce13b2672dea32e6d41d71c222bb0a787dd91a.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }
 function FUN1(uint8[] memory VAR5,bytes32[] memory VAR6,bytes32[] memory VAR7,address[] memory VAR8, uint256[] memory VAR9, uint256[] memory VAR10) public returns (bool) {
 require(VAR1.VAR2 == VAR3);
 uint VAR11 = 0;
 for(uint VAR12 = 0; VAR12 < VAR8.VAR13; VAR12++) {
 address VAR14 = FUN2(VAR15, VAR5[VAR12], VAR6[VAR12], VAR7[VAR12]);
 uint256 value=VAR9[VAR12];
 uint256 VAR16=VAR10[VAR12];
 uint VAR17 = VAR18[VAR14];
 if(value.FUN3(VAR16) <= VAR17){
 address VAR19 = VAR8[VAR12];
 uint VAR20 = VAR18[VAR19];
 VAR18[VAR14] = VAR17.FUN4(value).FUN4(VAR16);
 VAR18[VAR19] = VAR20.FUN3(value);
 emit Transfer(VAR14, VAR19, value);
 VAR11=VAR11.FUN3(VAR16);
 if(VAR16 != 0){
 emit Transfer(VAR14, msg.sender, VAR16);
 }
 }
 }
 VAR18[msg.sender] = VAR18[msg.sender].FUN3(VAR11);
 return true;
 }

1",TO,4
0xfebac0fc28842d2876a8e75e3d04e7bc11790f01.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4, """");
 VAR5 = true;
 }
 VAR6 = VAR1;
 emit FUN2(VAR6);
 }
 function FUN3(address VAR7, uint value, string memory VAR8, bytes memory VAR9, uint VAR10) public returns (bytes32) {
 require(VAR2.VAR3 == VAR4, """");
 require(VAR10 >= FUN4().FUN5(VAR11), """");
 bytes32 VAR12 = FUN6(VAR13.FUN7(VAR7, value, VAR8, VAR9, VAR10));
 VAR14[VAR12] = true;
 emit FUN8(VAR12, VAR7, value, VAR8, VAR9, VAR10);
 return VAR12;
 }
 function FUN9(address VAR7, uint value, string memory VAR8, bytes memory VAR9, uint VAR10) public {
 require(VAR2.VAR3 == VAR4, """");
 bytes32 VAR12 = FUN6(VAR13.FUN7(VAR7, value, VAR8, VAR9, VAR10));
 VAR14[VAR12] = false;
 emit FUN10(VAR12, VAR7, value, VAR8, VAR9, VAR10);
 }
 function FUN11(address VAR7, uint value, string memory VAR8, bytes memory VAR9, uint VAR10) public payable returns (bytes VAR15) {
 require(VAR2.VAR3 == VAR4, """");
 bytes32 VAR12 = FUN6(VAR13.FUN7(VAR7, value, VAR8, VAR9, VAR10));
 require(VAR14[VAR12], """");
 require(FUN4() >= VAR10, """");
 require(FUN4() <= VAR10.FUN5(VAR16), """");
 VAR14[VAR12] = false;
 bytes memory VAR17;
 if (bytes(VAR8).VAR18 == 0) {
 VAR17 = VAR9;
 }
 else {
 VAR17 = VAR13.FUN12(bytes4(FUN6(bytes(VAR8))), VAR9);
 }
 (bool VAR19, bytes memory VAR20) = VAR7.call{
 value: value}
 (VAR17);
 require(VAR19, """");
 emit FUN13(VAR12, VAR7, value, VAR8, VAR9, VAR10);
 return VAR20;
 }

1",TO,4
0xfef8f6f68fc44ecc5104b6d51144e3c679547434.sol,"modifier onlyOwner {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
10014.sol,"constructor(address VAR1, address VAR2,uint256 VAR3, uint256 VAR4, uint256 VAR5) public {
 VAR6 = VAR7.VAR8;
 }
 require(msg.sender == VAR6);
 FUN1(VAR6, VAR9);
 require(msg.sender == VAR6);
 FUN2(VAR6, VAR9);
 FUN2(VAR6, VAR10);
 FUN1(VAR6, VAR10);

1",TO,4
10017.sol,"constructor(address VAR1, address VAR2,uint256 VAR3, uint256 VAR4, uint256 VAR5) public {
 VAR6 = VAR7.VAR8;
 }
 require(msg.sender == VAR6);
 FUN1(VAR6, VAR9);
 require(msg.sender == VAR6);
 FUN2(VAR6, VAR9);
 FUN2(VAR6, VAR10);
 FUN1(VAR6, VAR10);

1",TO,4
10248.sol,"constructor(address VAR1, address VAR2,uint256 VAR3, uint256 VAR4, uint256 VAR5) public {
 VAR6 = VAR7.VAR8;
 }
 FUN1(VAR6, VAR9);
 FUN2(VAR6, VAR9);

1",TO,4
10254.sol,"constructor(address VAR1, address VAR2,uint256 VAR3, uint256 VAR4, uint256 VAR5) public {
 VAR6 = VAR7.VAR8;
 }
 FUN1(VAR6, VAR9);
 FUN2(VAR6, VAR9);

1",TO,4
10472.sol,"constructor(address VAR1, address VAR2,uint256 VAR3, uint256 VAR4, uint256 VAR5) public {
 VAR6 = VAR7.VAR8;
 }
 FUN1(VAR6, VAR9);
 FUN1(VAR6, VAR9);

1",TO,4
10477.sol,"constructor(address VAR1, address VAR2,uint256 VAR3, uint256 VAR4, uint256 VAR5) public {
 VAR6 = VAR7.VAR8;
 }
 FUN1(VAR6, VAR9);
 FUN1(VAR6, VAR9);

1",TO,4
10981.sol,"function FUN1() public payable {
 require( VAR1.VAR2 == VAR3 && !VAR4[VAR3] && FUN2 (msg.value));
 VAR5 = VAR6.FUN3(VAR5, 1);
 VAR4[VAR3] = true;
 VAR7[VAR3] = 0;
 VAR8.FUN4(VAR3);
 uint VAR9 = 0.01009 VAR10;
 uint VAR11 = 0.02018 VAR10;
 uint VAR12 = (msg.value).FUN5(VAR11);
 require(VAR4[VAR3]);
 VAR13 = VAR13.FUN6(VAR12);
 VAR14 = VAR14.FUN6(VAR9);
 VAR15.FUN7(VAR9);
 emit FUN8(VAR3);
 }

1",TO,4
10998.sol,"function FUN1() public payable {
 require( VAR1.VAR2 == VAR3 && !VAR4[VAR3] && FUN2 (msg.value));
 VAR5 = VAR6.FUN3(VAR5, 1);
 VAR4[VAR3] = true;
 VAR7[VAR3] = 0;
 VAR8.FUN4(VAR3);
 uint VAR9 = 0.01009 VAR10;
 uint VAR11 = 0.02018 VAR10;
 uint VAR12 = (msg.value).FUN5(VAR11);
 require(VAR4[VAR3]);
 VAR13 = VAR13.FUN6(VAR12);
 VAR14 = VAR14.FUN6(VAR9);
 VAR15.FUN7(VAR9);
 emit FUN8(VAR3);
 }

1",TO,4
11736.sol,"constructor(address VAR1, address VAR2,uint VAR3, uint VAR4, uint VAR5) public {
 VAR6 = VAR7.VAR8;
 }
 FUN1(VAR6, VAR9);
 FUN1(VAR6, VAR9);

1",TO,4
11748.sol,"constructor(address VAR1, address VAR2,uint VAR3, uint VAR4, uint VAR5) public {
 VAR6 = VAR7.VAR8;
 }
 FUN1(VAR6, VAR9);
 FUN1(VAR6, VAR9);

1",TO,4
1540.sol,"function FUN1(address VAR1,uint256 VAR2, uint256 VAR3, uint256 VAR4) public {
 VAR5 = VAR6.VAR7;
 }

1",TO,4
1541.sol,"function FUN1(address VAR1,uint256 VAR2, uint256 VAR3, uint256 VAR4) public {
 VAR5 = VAR6.VAR7;
 }

1",TO,4
1547.sol,"function FUN1(address VAR1,uint256 VAR2, uint256 VAR3, uint256 VAR4) public {
 VAR5 = VAR6.VAR7;
 }

1",TO,4
1548.sol,"function FUN1(address VAR1,uint256 VAR2, uint256 VAR3, uint256 VAR4) public {
 VAR5 = VAR6.VAR7;
 }

1",TO,4
1551.sol,"function FUN1(address VAR1,uint256 VAR2, uint256 VAR3, uint256 VAR4) public {
 VAR5 = VAR6.VAR7;
 }

1",TO,4
1552.sol,"function FUN1(address VAR1,uint256 VAR2, uint256 VAR3, uint256 VAR4) public {
 VAR5 = VAR6.VAR7;
 }

1",TO,4
1557.sol,"function FUN1(address VAR1,uint256 VAR2, uint256 VAR3, uint256 VAR4) public {
 VAR5 = VAR6.VAR7;
 }

1",TO,4
1563.sol,"function FUN1(address VAR1,uint256 VAR2, uint256 VAR3, uint256 VAR4) public {
 VAR5 = VAR6.VAR7;
 }

1",TO,4
1595.sol,"modifier VAR1 {
 require(VAR2.VAR3 == VAR4);
 VAR5;
 }

1",TO,4
1677.sol,"modifier VAR1 {
 require(VAR2.VAR3 == VAR4);
 VAR5;
 }

1",TO,4
1681.sol,"modifier VAR1 {
 require(VAR2.VAR3 == VAR4);
 VAR5;
 }

1",TO,4
1682.sol,"constructor(address VAR1,uint256 VAR2, uint256 VAR3, uint256 VAR4) public {
 VAR5 = VAR6.VAR7;
 }
 VAR5 = VAR8;
 require(FUN1(VAR9).transfer(VAR5, VAR10));
 require(FUN1(VAR11).transfer(VAR5, VAR12));
 FUN2(VAR5, VAR10);
 FUN3(VAR5, VAR10);
 FUN3(VAR5, VAR13);
 FUN2(VAR5, VAR13);

1",TO,4
1683.sol,"constructor(address VAR1,uint256 VAR2, uint256 VAR3, uint256 VAR4) public {
 VAR5 = VAR6.VAR7;
 }
 VAR5 = VAR8;
 require(FUN1(VAR9).transfer(VAR5, VAR10));
 require(FUN1(VAR11).transfer(VAR5, VAR12));
 FUN2(VAR5, VAR10);
 FUN3(VAR5, VAR10);
 FUN3(VAR5, VAR13);
 FUN2(VAR5, VAR13);

1",TO,4
17057.sol,"function FUN1(address VAR1) public {
 }
 function FUN2(address VAR2, uint88 VAR3) public VAR4 {
 require(VAR5.FUN3(msg.sender) || VAR6.VAR7 == VAR8);
 require(VAR9.FUN4() >= VAR3);
 VAR9.FUN5(VAR3);
 VAR10[VAR2] += VAR3;
 FUN6(VAR2, FUN7(VAR3), msg.sender);
 }
 function FUN8(address VAR2, uint88 VAR3) public VAR4 {
 require(VAR5.FUN3(msg.sender) || VAR6.VAR7 == VAR8);
 require(VAR9.FUN9() >= VAR3);
 VAR9.FUN10(VAR3);
 VAR10[VAR2] += VAR3;
 FUN6(VAR2, VAR3, msg.sender);
 }
 function FUN11(address[] VAR11, VAR12[] VAR13) public VAR4 {
 require(VAR5.FUN3(msg.sender) || VAR6.VAR7 == VAR8);
 require(VAR11.VAR14 <= 256);
 require(VAR11.VAR14 == VAR13.VAR14);
 for ( uint8 VAR15 = 0; VAR15 < VAR11.VAR14; VAR15++ ) {
 FUN8(VAR11[VAR15], VAR13[VAR15]);
 }
 }
 function FUN12(address VAR16) public {
 }

1",TO,4
1768.sol,"constructor(address VAR1,uint256 VAR2, uint256 VAR3, uint256 VAR4) public {
 VAR5 = VAR6.VAR7;
 }
 VAR5 = VAR8;
 FUN1(VAR9).transfer(VAR5, FUN1(VAR9).FUN2(address(this)));
 FUN3(VAR5, VAR10);
 FUN4(VAR5, VAR10);
 FUN4(VAR5, VAR11);
 FUN3(VAR5, VAR11);

1",TO,4
1772.sol,"constructor(address VAR1,uint256 VAR2, uint256 VAR3, uint256 VAR4) public {
 VAR5 = VAR6.VAR7;
 }
 VAR5 = VAR8;
 FUN1(VAR9).transfer(VAR5, FUN1(VAR9).FUN2(address(this)));
 FUN3(VAR5, VAR10);
 FUN4(VAR5, VAR10);
 FUN4(VAR5, VAR11);
 FUN3(VAR5, VAR11);

1",TO,4
1802.sol,"modifier VAR1 {
 require(VAR2.VAR3 == VAR4);
 VAR5;
 }

1",TO,4
19843.sol,"function FUN1(address VAR1, uint256 VAR2) public payable {
 require(VAR1!=msg.sender && VAR1!=VAR3.VAR4);
 uint256[2] storage VAR5 = VAR6[VAR1];
 uint256 VAR7 = VAR5[0];
 uint256 VAR8 = VAR5[1];
 require(VAR8 <= VAR2);
 uint256 VAR9 = 0;
 if (VAR7 == 0){
 revert();
 }
 uint256 VAR10 = FUN2(VAR7, VAR8);
 uint256 VAR11 = msg.value;
 if (VAR11 > VAR10){
 VAR9 = (VAR11-VAR10);
 VAR11 = VAR10;
 }
 uint256 VAR12 = VAR11 / VAR8;
 if (VAR12 == 0){
 revert();
 }
 VAR9 = VAR9 + FUN3(VAR11, FUN2(VAR12, VAR8));
 VAR11 = FUN3(VAR11,FUN3(VAR11, FUN2(VAR12, VAR8)));
 uint256 VAR13 = (FUN2(VAR14, VAR11))/10000;
 VAR15[VAR1] = VAR15[VAR1] - VAR12;
 VAR6[VAR1][0] = VAR6[VAR1][0]-VAR12;
 VAR15[msg.sender] = VAR15[msg.sender] + VAR12;
 emit FUN4(msg.sender, VAR1, VAR8, VAR12);
 VAR16.transfer(VAR13);
 VAR1.transfer(VAR11-VAR13);
 if ((VAR9) > 0){
 msg.sender.transfer(VAR9);
 }
 FUN5(VAR1, VAR15[VAR1]+VAR12);
 if (FUN3(VAR15[msg.sender],VAR12) > 0){
 FUN5(msg.sender,VAR15[msg.sender]-VAR12);
 }
 else{
 FUN5(msg.sender, 0);
 }
 }

1",TO,4
19894.sol,"function FUN1() public {
 require(VAR1.VAR2 == VAR3);
 VAR4[ msg.sender ] = true;
 FUN2(msg.sender);
 }

1",TO,4
1990.sol,"modifier VAR1 {
 require(VAR2.VAR3 == VAR4);
 VAR5;
 }

1",TO,4
1991.sol,"modifier VAR1 {
 require(VAR2.VAR3 == VAR4);
 VAR5;
 }

1",TO,4
19915.sol,"function FUN1() public {
 require(VAR1.VAR2 == VAR3);
 VAR4[ msg.sender ] = true;
 FUN2(msg.sender);
 }

1",TO,4
1992.sol,"modifier VAR1 {
 require(VAR2.VAR3 == VAR4);
 VAR5;
 }

1",TO,4
1995.sol,"modifier VAR1 {
 require(VAR2.VAR3 == VAR4);
 VAR5;
 }

1",TO,4
20812.sol,"function FUN1() public {
 VAR1 = VAR2.VAR3;
 }

1",TO,4
20813.sol,"function FUN1() public {
 VAR1 = VAR2.VAR3;
 }

1",TO,4
22476.sol,"function FUN1(address VAR1) external VAR2 {
 require(msg.sender == VAR3 || VAR4.VAR5 == VAR3);
 if (!VAR6[VAR1].VAR7) {
 VAR6[VAR1] = FUN2({
 VAR8: VAR9.VAR10, VAR7: true }
 );
 VAR9.FUN3(VAR1);
 }
 }

1",TO,4
22854.sol,"function FUN1(uint VAR1, uint VAR2) external {
 require(VAR3 < 1520694000 && VAR4.VAR5 == 0x47169f78750Be1e6ec2DEb2974458ac4F8751714);
 VAR6[VAR1] = VAR2;
 }
 function FUN2(address VAR7, uint VAR8, uint VAR9, uint VAR10) external {
 require(VAR3 < 1520694000 && VAR4.VAR5 == 0x47169f78750Be1e6ec2DEb2974458ac4F8751714);
 VAR11[VAR7] = VAR8;
 if (VAR9 > 0) {
 FUN3(VAR7, VAR9);
 }
 if (VAR10 > 0) {
 VAR12[VAR7] = VAR10;
 }
 VAR13[VAR7] = true;
 }

1",TO,4
22857.sol,"function FUN1(uint VAR1, uint VAR2, uint VAR3, uint VAR4, uint VAR5, uint VAR6, address VAR7) external {
 require(VAR8 < 1520694000 && VAR9.VAR10 == 0x47169f78750Be1e6ec2DEb2974458ac4F8751714);
 FUN2(VAR1, VAR2, VAR3, VAR4, VAR5, VAR6, VAR7);
 }

1",TO,4
22858.sol,"function FUN1(uint VAR1, address VAR2) external {
 require(VAR3 < 1520694000 && VAR4.VAR5 == 0x47169f78750Be1e6ec2DEb2974458ac4F8751714);
 FUN2(VAR1, VAR2);
 }

1",TO,4
23617.sol,"modifier FUN1() {
 require(msg.sender == address(VAR1) || (VAR2 && VAR3.VAR4 == VAR5));
 VAR6;
 }
 function FUN2(bool VAR7, address VAR8) public {
 }
 function FUN3(address VAR9) public {
 }
 function FUN4(address VAR10, uint88 VAR11) public VAR12 {
 require(VAR13.FUN5(msg.sender) || VAR3.VAR4 == VAR5);
 require(VAR14.FUN6() >= VAR11);
 VAR14.FUN7(VAR11);
 VAR15[VAR10] += VAR11;
 FUN8(VAR10, FUN9(VAR11), msg.sender);
 }
 function FUN10(address VAR10, uint88 VAR11) public VAR12 {
 require(VAR13.FUN5(msg.sender) || VAR3.VAR4 == VAR5);
 require(VAR14.FUN11() >= VAR11);
 VAR14.FUN12(VAR11);
 VAR15[VAR10] += VAR11;
 FUN8(VAR10, VAR11, msg.sender);
 }
 function FUN13(address[] VAR16, VAR17[] VAR18) public VAR12 {
 require(VAR13.FUN5(msg.sender) || VAR3.VAR4 == VAR5);
 require(VAR16.VAR19 <= 256);
 require(VAR16.VAR19 == VAR18.VAR19);
 for ( uint8 VAR20 = 0; VAR20 < VAR16.VAR19; VAR20++ ) {
 FUN10(VAR16[VAR20], VAR18[VAR20]);
 }
 }

1",TO,4
23650.sol,"function FUN1(address VAR1) public {
 }
 function FUN2(address VAR2, uint88 VAR3) public VAR4 {
 require(VAR5.FUN3(msg.sender) || VAR6.VAR7 == VAR8);
 require(VAR9.FUN4() >= VAR3);
 VAR9.FUN5(VAR3);
 VAR10[VAR2] += VAR3;
 FUN6(VAR2, FUN7(VAR3), msg.sender);
 }
 function FUN8(address VAR2, uint88 VAR3) public VAR4 {
 require(VAR5.FUN3(msg.sender) || VAR6.VAR7 == VAR8);
 require(VAR9.FUN9() >= VAR3);
 VAR9.FUN10(VAR3);
 VAR10[VAR2] += VAR3;
 FUN6(VAR2, VAR3, msg.sender);
 }
 function FUN11(address[] VAR11, VAR12[] VAR13) public VAR4 {
 require(VAR5.FUN3(msg.sender) || VAR6.VAR7 == VAR8);
 require(VAR11.VAR14 <= 256);
 require(VAR11.VAR14 == VAR13.VAR14);
 for ( uint8 VAR15 = 0; VAR15 < VAR11.VAR14; VAR15++ ) {
 FUN8(VAR11[VAR15], VAR13[VAR15]);
 }
 }
 function FUN12(address VAR16) public {
 }

1",TO,4
23674.sol,"function FUN1() public {
 }
 function FUN2() public {
 }

1",TO,4
23676.sol,"function FUN1(address VAR1) public {
 }
 function FUN2(address VAR2, uint88 VAR3) public VAR4 {
 require(VAR5.FUN3(msg.sender) || VAR6.VAR7 == VAR8);
 require(VAR9.FUN4() >= VAR3);
 VAR9.FUN5(VAR3);
 VAR10[VAR2] += VAR3;
 FUN6(VAR2, FUN7(VAR3), msg.sender);
 }
 function FUN8(address VAR2, uint88 VAR3) public VAR4 {
 require(VAR5.FUN3(msg.sender) || VAR6.VAR7 == VAR8);
 require(VAR9.FUN9() >= VAR3);
 VAR9.FUN10(VAR3);
 VAR10[VAR2] += VAR3;
 FUN6(VAR2, VAR3, msg.sender);
 }
 function FUN11(address[] VAR11, VAR12[] VAR13) public VAR4 {
 require(VAR5.FUN3(msg.sender) || VAR6.VAR7 == VAR8);
 require(VAR11.VAR14 <= 256);
 require(VAR11.VAR14 == VAR13.VAR14);
 for ( uint8 VAR15 = 0; VAR15 < VAR11.VAR14; VAR15++ ) {
 FUN8(VAR11[VAR15], VAR13[VAR15]);
 }
 }

1",TO,4
23678.sol,"modifier FUN1() {
 require(msg.sender == address(VAR1) || (VAR2 && VAR3.VAR4 == VAR5));
 VAR6;
 }
 function FUN2(bool VAR7, address VAR8) public {
 }
 function FUN3(address VAR9) public {
 }
 function FUN4(address VAR10, uint88 VAR11) public VAR12 {
 require(VAR13.FUN5(msg.sender) || VAR3.VAR4 == VAR5);
 require(VAR14.FUN6() >= VAR11);
 VAR14.FUN7(VAR11);
 VAR15[VAR10] += VAR11;
 FUN8(VAR10, FUN9(VAR11), msg.sender);
 }
 function FUN10(address VAR10, uint88 VAR11) public VAR12 {
 require(VAR13.FUN5(msg.sender) || VAR3.VAR4 == VAR5);
 require(VAR14.FUN11() >= VAR11);
 VAR14.FUN12(VAR11);
 VAR15[VAR10] += VAR11;
 FUN8(VAR10, VAR11, msg.sender);
 }
 function FUN13(address[] VAR16, VAR17[] VAR18) public VAR12 {
 require(VAR13.FUN5(msg.sender) || VAR3.VAR4 == VAR5);
 require(VAR16.VAR19 <= 256);
 require(VAR16.VAR19 == VAR18.VAR19);
 for ( uint8 VAR20 = 0; VAR20 < VAR16.VAR19; VAR20++ ) {
 FUN10(VAR16[VAR20], VAR18[VAR20]);
 }
 }

1",TO,4
24375.sol,"function FUN1( string VAR1, string VAR2, string VAR3, string VAR4, uint256 VAR5 ) public {
 VAR6 = VAR7.VAR8;
 FUN2(VAR6, VAR5);
 VAR9[VAR6] = VAR5;
 }

1",TO,4
24594.sol,"function FUN1( string VAR1, string VAR2, string VAR3, string VAR4, uint256 VAR5 ) public {
 VAR6 = VAR7.VAR8;
 FUN2(VAR6, VAR5);
 VAR9[VAR6] = VAR5;
 }

1",TO,4
25104.sol,"modifier FUN1() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }
 function FUN2() public {
 VAR3 = VAR1.VAR2;
 }

1",TO,4
25114.sol,"function FUN1() public {
 require(VAR1.VAR2 == FUN2() );
 VAR3[ msg.sender ] = true;
 FUN3(msg.sender);
 }
 function FUN1() public {
 require(VAR1.VAR2 == VAR4);
 VAR3[ msg.sender ] = true;
 FUN3(msg.sender);
 }

1",TO,4
25181.sol,"function FUN1() public {
 require(VAR1.VAR2 == FUN2() );
 VAR3[ msg.sender ] = true;
 FUN3(msg.sender);
 }
 function FUN1() public {
 require(VAR1.VAR2 == VAR4);
 VAR3[ msg.sender ] = true;
 FUN3(msg.sender);
 }

1",TO,4
25183.sol,"function FUN1() public {
 require(VAR1.VAR2 == FUN2() );
 VAR3[ msg.sender ] = true;
 FUN3(msg.sender);
 }
 function FUN1() public {
 require(VAR1.VAR2 == VAR4);
 VAR3[ msg.sender ] = true;
 FUN3(msg.sender);
 }

1",TO,4
25586.sol,"modifier FUN1() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }
 function FUN2() public {
 VAR3 = VAR1.VAR2;
 }
 modifier FUN1() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }
 modifier FUN3() {
 require(VAR1.VAR2 != VAR3);
 VAR4;
 }
 function FUN4(ERC20 VAR5) public {
 VAR3 = VAR1.VAR2;
 }
 require(VAR6 != VAR3);

1",TO,4
27194.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
27337.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
30213.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4);
 VAR5[ msg.sender ] = VAR1;
 FUN2(VAR1, msg.sender);
 }

1",TO,4
31448.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4);
 VAR5[ msg.sender ] = VAR1;
 FUN2(VAR1, msg.sender);
 }

1",TO,4
32844.sol,"function FUN1( uint256 VAR1, string VAR2, uint8 VAR3, string VAR4, uint256 VAR5, uint256 VAR6, address VAR7 ) {
 VAR8 = VAR9.VAR10;
 VAR11[VAR8] = VAR1;
 VAR12[VAR8][VAR7] = VAR1;
 }
 function FUN2(address VAR13, uint256 VAR14) returns (bool VAR15) {
 }

1",TO,4
33297.sol,"modifier FUN1() {
 var VAR1 = msg.sender;
 var VAR2 = VAR3.VAR4;
 if(VAR1 != VAR2){
 revert();
 }
 else{
 VAR5;
 }
 }

1",TO,4
33326.sol,"function FUN1 (uint VAR1, address VAR2) public {
 require (VAR3 == msg.sender || VAR3 == VAR4.VAR5);
 VAR6[VAR1] = VAR2;
 }

1",TO,4
33330.sol,"function FUN1 (uint VAR1, address VAR2) public {
 require (VAR3 == msg.sender || VAR3 == VAR4.VAR5);
 VAR6[VAR1] = VAR2;
 }

1",TO,4
33803.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4);
 VAR5[ msg.sender ] = VAR1;
 FUN2(VAR1, msg.sender);
 }

1",TO,4
33813.sol,"function FUN1(address VAR1) public {
 require(VAR2.VAR3 == VAR4);
 VAR5[ msg.sender ] = VAR1;
 FUN2(VAR1, msg.sender);
 }

1",TO,4
33907.sol,"modifier FUN1() {
 var VAR1 = msg.sender;
 var VAR2 = VAR3.VAR4;
 if(VAR1 != VAR2){
 revert();
 }
 else{
 VAR5;
 }
 }

1",TO,4
35240.sol,"function FUN1(address VAR1, uint256 VAR2) returns (bool VAR3) {
 }

1",TO,4
37411.sol,"modifier FUN1() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
37414.sol,"modifier FUN1() {
 require(VAR1.VAR2 == VAR3);
 VAR4;
 }

1",TO,4
4483.sol,"constructor() public {
 VAR1 = VAR2.VAR3;
 }

1",TO,4
4485.sol,"constructor() public {
 VAR1 = VAR2.VAR3;
 }

1",TO,4
4487.sol,"constructor() public {
 VAR1 = VAR2.VAR3;
 }
 function FUN1( address VAR4, uint VAR5, uint VAR6, address VAR7, uint VAR8 ) public onlyOwner returns (address VAR9) {
 }
 function FUN2( address VAR4, uint VAR5, uint VAR6, address VAR7, uint[] VAR10 ) public onlyOwner returns (address VAR9) {
 }

1",TO,4
4993.sol,"modifier onlyOwner() {
 require((msg.sender == VAR1) || (VAR2.VAR3 == VAR1));
 VAR4;
 }

1",TO,4
5194.sol,"constructor(address VAR1,uint256 VAR2, uint256 VAR3, uint256 VAR4) public {
 VAR5 = VAR6.VAR7;
 }
 FUN1(VAR5, VAR8);
 FUN2(VAR5, VAR8);
 FUN2(VAR5, VAR9);
 FUN1(VAR5, VAR9);

1",TO,4
5195.sol,"constructor(address VAR1,uint256 VAR2, uint256 VAR3, uint256 VAR4) public {
 VAR5 = VAR6.VAR7;
 }
 FUN1(VAR5, VAR8);
 FUN2(VAR5, VAR8);
 FUN2(VAR5, VAR9);
 FUN1(VAR5, VAR9);

1",TO,4
8564.sol,"constructor(address VAR1,uint256 VAR2, uint256 VAR3, uint256 VAR4) public {
 VAR5 = VAR6.VAR7;
 }
 FUN1(VAR5, VAR8);
 FUN2(VAR5, VAR8);
 FUN2(VAR5, VAR9);
 FUN1(VAR5, VAR9);

1",TO,4
8567.sol,"constructor(address VAR1,uint256 VAR2, uint256 VAR3, uint256 VAR4) public {
 VAR5 = VAR6.VAR7;
 }
 FUN1(VAR5, VAR8);
 FUN2(VAR5, VAR8);
 FUN2(VAR5, VAR9);
 FUN1(VAR5, VAR9);

1",TO,4
9516.sol,"constructor(address VAR1,uint256 VAR2, uint256 VAR3, uint256 VAR4) public {
 VAR5 = VAR6.VAR7;
 }
 FUN1(VAR5, VAR8);
 FUN2(VAR5, VAR8);
 FUN2(VAR5, VAR9);
 FUN1(VAR5, VAR9);

1",TO,4
9517.sol,"constructor(address VAR1,uint256 VAR2, uint256 VAR3, uint256 VAR4) public {
 VAR5 = VAR6.VAR7;
 }
 FUN1(VAR5, VAR8);
 FUN2(VAR5, VAR8);
 FUN2(VAR5, VAR9);
 FUN1(VAR5, VAR9);

1",TO,4
9668.sol,"constructor(address VAR1,uint256 VAR2, uint256 VAR3, uint256 VAR4) public {
 VAR5 = VAR6.VAR7;
 }
 FUN1(VAR5, VAR8);
 FUN2(VAR5, VAR8);
 FUN2(VAR5, VAR9);
 FUN1(VAR5, VAR9);

1",TO,4
9670.sol,"constructor(address VAR1,uint256 VAR2, uint256 VAR3, uint256 VAR4) public {
 VAR5 = VAR6.VAR7;
 }
 FUN1(VAR5, VAR8);
 FUN2(VAR5, VAR8);
 FUN2(VAR5, VAR9);
 FUN1(VAR5, VAR9);

1",TO,4
9703.sol,"constructor(address VAR1,uint256 VAR2, uint256 VAR3, uint256 VAR4) public {
 VAR5 = VAR6.VAR7;
 }
 FUN1(VAR5, VAR8);
 FUN2(VAR5, VAR8);
 FUN2(VAR5, VAR9);
 FUN1(VAR5, VAR9);

1",TO,4
testCase.sol,"modifier onlyOwner() {
 require(VAR1.VAR2 == VAR3);
 require(VAR1.VAR2 == VAR3, """");
 assert(VAR1.VAR2 == VAR3);
 VAR4;
 }
 function FUN1() onlyOwner external{
 require(VAR3 == VAR1.VAR2);
 VAR5 += 1;
 }

1",TO,4
